
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
var app = (function () {
    'use strict';

    function _mergeNamespaces(n, m) {
        m.forEach(function (e) {
            e && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {
                if (k !== 'default' && !(k in n)) {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () { return e[k]; }
                    });
                }
            });
        });
        return Object.freeze(n);
    }

    function noop$4() { }
    const identity$a = x => x;
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function is_promise(value) {
        return value && typeof value === 'object' && typeof value.then === 'function';
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    let src_url_equal_anchor;
    function src_url_equal(element_src, url) {
        if (!src_url_equal_anchor) {
            src_url_equal_anchor = document.createElement('a');
        }
        src_url_equal_anchor.href = url;
        return element_src === src_url_equal_anchor.href;
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop$4;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
                return lets;
            }
            if (typeof lets === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
        if (slot_changes) {
            const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
            slot.p(slot_context, slot_changes);
        }
    }
    function get_all_dirty_from_scope($$scope) {
        if ($$scope.ctx.length > 32) {
            const dirty = [];
            const length = $$scope.ctx.length / 32;
            for (let i = 0; i < length; i++) {
                dirty[i] = -1;
            }
            return dirty;
        }
        return -1;
    }
    function exclude_internal_props(props) {
        const result = {};
        for (const k in props)
            if (k[0] !== '$')
                result[k] = props[k];
        return result;
    }
    function compute_rest_props(props, keys) {
        const rest = {};
        keys = new Set(keys);
        for (const k in props)
            if (!keys.has(k) && k[0] !== '$')
                rest[k] = props[k];
        return rest;
    }
    function compute_slots(slots) {
        const result = {};
        for (const key in slots) {
            result[key] = true;
        }
        return result;
    }
    function action_destroyer(action_result) {
        return action_result && is_function(action_result.destroy) ? action_result.destroy : noop$4;
    }

    const is_client = typeof window !== 'undefined';
    let now$1 = is_client
        ? () => window.performance.now()
        : () => Date.now();
    let raf = is_client ? cb => requestAnimationFrame(cb) : noop$4;

    const tasks = new Set();
    function run_tasks(now) {
        tasks.forEach(task => {
            if (!task.c(now)) {
                tasks.delete(task);
                task.f();
            }
        });
        if (tasks.size !== 0)
            raf(run_tasks);
    }
    /**
     * Creates a new task that runs on each raf frame
     * until it returns a falsy value or is aborted
     */
    function loop(callback) {
        let task;
        if (tasks.size === 0)
            raf(run_tasks);
        return {
            promise: new Promise(fulfill => {
                tasks.add(task = { c: callback, f: fulfill });
            }),
            abort() {
                tasks.delete(task);
            }
        };
    }
    function append(target, node) {
        target.appendChild(node);
    }
    function get_root_for_style(node) {
        if (!node)
            return document;
        const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
        if (root && root.host) {
            return root;
        }
        return node.ownerDocument;
    }
    function append_empty_stylesheet(node) {
        const style_element = element$1('style');
        append_stylesheet(get_root_for_style(node), style_element);
        return style_element.sheet;
    }
    function append_stylesheet(node, style) {
        append(node.head || node, style);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element$1(name) {
        return document.createElement(name);
    }
    function text$1(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text$1(' ');
    }
    function empty$2() {
        return text$1('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function set_attributes(node, attributes) {
        // @ts-ignore
        const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
        for (const key in attributes) {
            if (attributes[key] == null) {
                node.removeAttribute(key);
            }
            else if (key === 'style') {
                node.style.cssText = attributes[key];
            }
            else if (key === '__value') {
                node.value = node[key] = attributes[key];
            }
            else if (descriptors[key] && descriptors[key].set) {
                node[key] = attributes[key];
            }
            else {
                attr(node, key, attributes[key]);
            }
        }
    }
    function to_number(value) {
        return value === '' ? null : +value;
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function custom_event(type, detail, bubbles = false) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, bubbles, false, detail);
        return e;
    }

    // we need to store the information for multiple documents because a Svelte application could also contain iframes
    // https://github.com/sveltejs/svelte/issues/3624
    const managed_styles = new Map();
    let active$1 = 0;
    // https://github.com/darkskyapp/string-hash/blob/master/index.js
    function hash$2(str) {
        let hash = 5381;
        let i = str.length;
        while (i--)
            hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
        return hash >>> 0;
    }
    function create_style_information(doc, node) {
        const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
        managed_styles.set(doc, info);
        return info;
    }
    function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
        const step = 16.666 / duration;
        let keyframes = '{\n';
        for (let p = 0; p <= 1; p += step) {
            const t = a + (b - a) * ease(p);
            keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
        }
        const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
        const name = `__svelte_${hash$2(rule)}_${uid}`;
        const doc = get_root_for_style(node);
        const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
        if (!rules[name]) {
            rules[name] = true;
            stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
        }
        const animation = node.style.animation || '';
        node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
        active$1 += 1;
        return name;
    }
    function delete_rule(node, name) {
        const previous = (node.style.animation || '').split(', ');
        const next = previous.filter(name
            ? anim => anim.indexOf(name) < 0 // remove specific animation
            : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
        );
        const deleted = previous.length - next.length;
        if (deleted) {
            node.style.animation = next.join(', ');
            active$1 -= deleted;
            if (!active$1)
                clear_rules();
        }
    }
    function clear_rules() {
        raf(() => {
            if (active$1)
                return;
            managed_styles.forEach(info => {
                const { stylesheet } = info;
                let i = stylesheet.cssRules.length;
                while (i--)
                    stylesheet.deleteRule(i);
                info.rules = {};
            });
            managed_styles.clear();
        });
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function afterUpdate(fn) {
        get_current_component().$$.after_update.push(fn);
    }
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail);
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
            }
        };
    }
    function setContext(key, context) {
        get_current_component().$$.context.set(key, context);
    }
    function getContext(key) {
        return get_current_component().$$.context.get(key);
    }
    // TODO figure out if we still want to support
    // shorthand events, or if we want to implement
    // a real bubbling mechanism
    function bubble(component, event) {
        const callbacks = component.$$.callbacks[event.type];
        if (callbacks) {
            // @ts-ignore
            callbacks.slice().forEach(fn => fn.call(this, event));
        }
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function tick() {
        schedule_update();
        return resolved_promise;
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    // flush() calls callbacks in this order:
    // 1. All beforeUpdate callbacks, in order: parents before children
    // 2. All bind:this callbacks, in reverse order: children before parents.
    // 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
    //    for afterUpdates called during the initial onMount, which are called in
    //    reverse order: children before parents.
    // Since callbacks might update component values, which could trigger another
    // call to flush(), the following steps guard against this:
    // 1. During beforeUpdate, any updated components will be added to the
    //    dirty_components array and will cause a reentrant call to flush(). Because
    //    the flush index is kept outside the function, the reentrant call will pick
    //    up where the earlier call left off and go through all dirty components. The
    //    current_component value is saved and restored so that the reentrant call will
    //    not interfere with the "parent" flush() call.
    // 2. bind:this callbacks cannot trigger new flush() calls.
    // 3. During afterUpdate, any updated components will NOT have their afterUpdate
    //    callback called a second time; the seen_callbacks set, outside the flush()
    //    function, guarantees this behavior.
    const seen_callbacks = new Set();
    let flushidx = 0; // Do *not* move this inside the flush() function
    function flush() {
        const saved_component = current_component;
        do {
            // first, call beforeUpdate functions
            // and update components
            while (flushidx < dirty_components.length) {
                const component = dirty_components[flushidx];
                flushidx++;
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            flushidx = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        seen_callbacks.clear();
        set_current_component(saved_component);
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }

    let promise;
    function wait() {
        if (!promise) {
            promise = Promise.resolve();
            promise.then(() => {
                promise = null;
            });
        }
        return promise;
    }
    function dispatch$1(node, direction, kind) {
        node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }
    const null_transition = { duration: 0 };
    function create_bidirectional_transition(node, fn, params, intro) {
        let config = fn(node, params);
        let t = intro ? 0 : 1;
        let running_program = null;
        let pending_program = null;
        let animation_name = null;
        function clear_animation() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function init(program, duration) {
            const d = (program.b - t);
            duration *= Math.abs(d);
            return {
                a: t,
                b: program.b,
                d,
                duration,
                start: program.start,
                end: program.start + duration,
                group: program.group
            };
        }
        function go(b) {
            const { delay = 0, duration = 300, easing = identity$a, tick = noop$4, css } = config || null_transition;
            const program = {
                start: now$1() + delay,
                b
            };
            if (!b) {
                // @ts-ignore todo: improve typings
                program.group = outros;
                outros.r += 1;
            }
            if (running_program || pending_program) {
                pending_program = program;
            }
            else {
                // if this is an intro, and there's a delay, we need to do
                // an initial tick and/or apply CSS animation immediately
                if (css) {
                    clear_animation();
                    animation_name = create_rule(node, t, b, duration, delay, easing, css);
                }
                if (b)
                    tick(0, 1);
                running_program = init(program, duration);
                add_render_callback(() => dispatch$1(node, b, 'start'));
                loop(now => {
                    if (pending_program && now > pending_program.start) {
                        running_program = init(pending_program, duration);
                        pending_program = null;
                        dispatch$1(node, running_program.b, 'start');
                        if (css) {
                            clear_animation();
                            animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
                        }
                    }
                    if (running_program) {
                        if (now >= running_program.end) {
                            tick(t = running_program.b, 1 - t);
                            dispatch$1(node, running_program.b, 'end');
                            if (!pending_program) {
                                // we're done
                                if (running_program.b) {
                                    // intro — we can tidy up immediately
                                    clear_animation();
                                }
                                else {
                                    // outro — needs to be coordinated
                                    if (!--running_program.group.r)
                                        run_all(running_program.group.c);
                                }
                            }
                            running_program = null;
                        }
                        else if (now >= running_program.start) {
                            const p = now - running_program.start;
                            t = running_program.a + running_program.d * easing(p / running_program.duration);
                            tick(t, 1 - t);
                        }
                    }
                    return !!(running_program || pending_program);
                });
            }
        }
        return {
            run(b) {
                if (is_function(config)) {
                    wait().then(() => {
                        // @ts-ignore
                        config = config();
                        go(b);
                    });
                }
                else {
                    go(b);
                }
            },
            end() {
                clear_animation();
                running_program = pending_program = null;
            }
        };
    }

    function handle_promise(promise, info) {
        const token = info.token = {};
        function update(type, index, key, value) {
            if (info.token !== token)
                return;
            info.resolved = value;
            let child_ctx = info.ctx;
            if (key !== undefined) {
                child_ctx = child_ctx.slice();
                child_ctx[key] = value;
            }
            const block = type && (info.current = type)(child_ctx);
            let needs_flush = false;
            if (info.block) {
                if (info.blocks) {
                    info.blocks.forEach((block, i) => {
                        if (i !== index && block) {
                            group_outros();
                            transition_out(block, 1, 1, () => {
                                if (info.blocks[i] === block) {
                                    info.blocks[i] = null;
                                }
                            });
                            check_outros();
                        }
                    });
                }
                else {
                    info.block.d(1);
                }
                block.c();
                transition_in(block, 1);
                block.m(info.mount(), info.anchor);
                needs_flush = true;
            }
            info.block = block;
            if (info.blocks)
                info.blocks[index] = block;
            if (needs_flush) {
                flush();
            }
        }
        if (is_promise(promise)) {
            const current_component = get_current_component();
            promise.then(value => {
                set_current_component(current_component);
                update(info.then, 1, info.value, value);
                set_current_component(null);
            }, error => {
                set_current_component(current_component);
                update(info.catch, 2, info.error, error);
                set_current_component(null);
                if (!info.hasCatch) {
                    throw error;
                }
            });
            // if we previously had a then/catch block, destroy it
            if (info.current !== info.pending) {
                update(info.pending, 0);
                return true;
            }
        }
        else {
            if (info.current !== info.then) {
                update(info.then, 1, info.value, promise);
                return true;
            }
            info.resolved = promise;
        }
    }
    function update_await_block_branch(info, ctx, dirty) {
        const child_ctx = ctx.slice();
        const { resolved } = info;
        if (info.current === info.then) {
            child_ctx[info.value] = resolved;
        }
        if (info.current === info.catch) {
            child_ctx[info.error] = resolved;
        }
        info.block.p(child_ctx, dirty);
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }
    function get_spread_object(spread_props) {
        return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = on_mount.map(run).filter(is_function);
                if (on_destroy) {
                    on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init$1(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop$4,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false,
            root: options.target || parent_component.$$.root
        };
        append_styles && append_styles($$.root);
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop$4;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.47.0' }, detail), true));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    /**
     * @typedef {Object} WrappedComponent Object returned by the `wrap` method
     * @property {SvelteComponent} component - Component to load (this is always asynchronous)
     * @property {RoutePrecondition[]} [conditions] - Route pre-conditions to validate
     * @property {Object} [props] - Optional dictionary of static props
     * @property {Object} [userData] - Optional user data dictionary
     * @property {bool} _sveltesparouter - Internal flag; always set to true
     */

    /**
     * @callback AsyncSvelteComponent
     * @returns {Promise<SvelteComponent>} Returns a Promise that resolves with a Svelte component
     */

    /**
     * @callback RoutePrecondition
     * @param {RouteDetail} detail - Route detail object
     * @returns {boolean|Promise<boolean>} If the callback returns a false-y value, it's interpreted as the precondition failed, so it aborts loading the component (and won't process other pre-condition callbacks)
     */

    /**
     * @typedef {Object} WrapOptions Options object for the call to `wrap`
     * @property {SvelteComponent} [component] - Svelte component to load (this is incompatible with `asyncComponent`)
     * @property {AsyncSvelteComponent} [asyncComponent] - Function that returns a Promise that fulfills with a Svelte component (e.g. `{asyncComponent: () => import('Foo.svelte')}`)
     * @property {SvelteComponent} [loadingComponent] - Svelte component to be displayed while the async route is loading (as a placeholder); when unset or false-y, no component is shown while component
     * @property {object} [loadingParams] - Optional dictionary passed to the `loadingComponent` component as params (for an exported prop called `params`)
     * @property {object} [userData] - Optional object that will be passed to events such as `routeLoading`, `routeLoaded`, `conditionsFailed`
     * @property {object} [props] - Optional key-value dictionary of static props that will be passed to the component. The props are expanded with {...props}, so the key in the dictionary becomes the name of the prop.
     * @property {RoutePrecondition[]|RoutePrecondition} [conditions] - Route pre-conditions to add, which will be executed in order
     */

    /**
     * Wraps a component to enable multiple capabilities:
     * 1. Using dynamically-imported component, with (e.g. `{asyncComponent: () => import('Foo.svelte')}`), which also allows bundlers to do code-splitting.
     * 2. Adding route pre-conditions (e.g. `{conditions: [...]}`)
     * 3. Adding static props that are passed to the component
     * 4. Adding custom userData, which is passed to route events (e.g. route loaded events) or to route pre-conditions (e.g. `{userData: {foo: 'bar}}`)
     * 
     * @param {WrapOptions} args - Arguments object
     * @returns {WrappedComponent} Wrapped component
     */
    function wrap$1(args) {
        if (!args) {
            throw Error('Parameter args is required')
        }

        // We need to have one and only one of component and asyncComponent
        // This does a "XNOR"
        if (!args.component == !args.asyncComponent) {
            throw Error('One and only one of component and asyncComponent is required')
        }

        // If the component is not async, wrap it into a function returning a Promise
        if (args.component) {
            args.asyncComponent = () => Promise.resolve(args.component);
        }

        // Parameter asyncComponent and each item of conditions must be functions
        if (typeof args.asyncComponent != 'function') {
            throw Error('Parameter asyncComponent must be a function')
        }
        if (args.conditions) {
            // Ensure it's an array
            if (!Array.isArray(args.conditions)) {
                args.conditions = [args.conditions];
            }
            for (let i = 0; i < args.conditions.length; i++) {
                if (!args.conditions[i] || typeof args.conditions[i] != 'function') {
                    throw Error('Invalid parameter conditions[' + i + ']')
                }
            }
        }

        // Check if we have a placeholder component
        if (args.loadingComponent) {
            args.asyncComponent.loading = args.loadingComponent;
            args.asyncComponent.loadingParams = args.loadingParams || undefined;
        }

        // Returns an object that contains all the functions to execute too
        // The _sveltesparouter flag is to confirm the object was created by this router
        const obj = {
            component: args.asyncComponent,
            userData: args.userData,
            conditions: (args.conditions && args.conditions.length) ? args.conditions : undefined,
            props: (args.props && Object.keys(args.props).length) ? args.props : {},
            _sveltesparouter: true
        };

        return obj
    }

    const subscriber_queue = [];
    /**
     * Creates a `Readable` store that allows reading by subscription.
     * @param value initial value
     * @param {StartStopNotifier}start start and stop notifications for subscriptions
     */
    function readable(value, start) {
        return {
            subscribe: writable(value, start).subscribe
        };
    }
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop$4) {
        let stop;
        const subscribers = new Set();
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (const subscriber of subscribers) {
                        subscriber[1]();
                        subscriber_queue.push(subscriber, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop$4) {
            const subscriber = [run, invalidate];
            subscribers.add(subscriber);
            if (subscribers.size === 1) {
                stop = start(set) || noop$4;
            }
            run(value);
            return () => {
                subscribers.delete(subscriber);
                if (subscribers.size === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }
    function derived(stores, fn, initial_value) {
        const single = !Array.isArray(stores);
        const stores_array = single
            ? [stores]
            : stores;
        const auto = fn.length < 2;
        return readable(initial_value, (set) => {
            let inited = false;
            const values = [];
            let pending = 0;
            let cleanup = noop$4;
            const sync = () => {
                if (pending) {
                    return;
                }
                cleanup();
                const result = fn(single ? values[0] : values, set);
                if (auto) {
                    set(result);
                }
                else {
                    cleanup = is_function(result) ? result : noop$4;
                }
            };
            const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
                values[i] = value;
                pending &= ~(1 << i);
                if (inited) {
                    sync();
                }
            }, () => {
                pending |= (1 << i);
            }));
            inited = true;
            sync();
            return function stop() {
                run_all(unsubscribers);
                cleanup();
            };
        });
    }

    function parse(str, loose) {
    	if (str instanceof RegExp) return { keys:false, pattern:str };
    	var c, o, tmp, ext, keys=[], pattern='', arr = str.split('/');
    	arr[0] || arr.shift();

    	while (tmp = arr.shift()) {
    		c = tmp[0];
    		if (c === '*') {
    			keys.push('wild');
    			pattern += '/(.*)';
    		} else if (c === ':') {
    			o = tmp.indexOf('?', 1);
    			ext = tmp.indexOf('.', 1);
    			keys.push( tmp.substring(1, !!~o ? o : !!~ext ? ext : tmp.length) );
    			pattern += !!~o && !~ext ? '(?:/([^/]+?))?' : '/([^/]+?)';
    			if (!!~ext) pattern += (!!~o ? '?' : '') + '\\' + tmp.substring(ext);
    		} else {
    			pattern += '/' + tmp;
    		}
    	}

    	return {
    		keys: keys,
    		pattern: new RegExp('^' + pattern + (loose ? '(?=$|\/)' : '\/?$'), 'i')
    	};
    }

    /* node_modules\svelte-spa-router\Router.svelte generated by Svelte v3.47.0 */

    const { Error: Error_1$1, Object: Object_1, console: console_1$s } = globals;

    // (251:0) {:else}
    function create_else_block$8(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [/*props*/ ctx[2]];
    	var switch_value = /*component*/ ctx[0];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    		switch_instance.$on("routeEvent", /*routeEvent_handler_1*/ ctx[7]);
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*props*/ 4)
    			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*props*/ ctx[2])])
    			: {};

    			if (switch_value !== (switch_value = /*component*/ ctx[0])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					switch_instance.$on("routeEvent", /*routeEvent_handler_1*/ ctx[7]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$8.name,
    		type: "else",
    		source: "(251:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (244:0) {#if componentParams}
    function create_if_block$h(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [{ params: /*componentParams*/ ctx[1] }, /*props*/ ctx[2]];
    	var switch_value = /*component*/ ctx[0];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    		switch_instance.$on("routeEvent", /*routeEvent_handler*/ ctx[6]);
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*componentParams, props*/ 6)
    			? get_spread_update(switch_instance_spread_levels, [
    					dirty & /*componentParams*/ 2 && { params: /*componentParams*/ ctx[1] },
    					dirty & /*props*/ 4 && get_spread_object(/*props*/ ctx[2])
    				])
    			: {};

    			if (switch_value !== (switch_value = /*component*/ ctx[0])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					switch_instance.$on("routeEvent", /*routeEvent_handler*/ ctx[6]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$h.name,
    		type: "if",
    		source: "(244:0) {#if componentParams}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$O(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$h, create_else_block$8];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*componentParams*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$2();
    		},
    		l: function claim(nodes) {
    			throw new Error_1$1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$O.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function wrap(component, userData, ...conditions) {
    	// Use the new wrap method and show a deprecation warning
    	// eslint-disable-next-line no-console
    	console.warn('Method `wrap` from `svelte-spa-router` is deprecated and will be removed in a future version. Please use `svelte-spa-router/wrap` instead. See http://bit.ly/svelte-spa-router-upgrading');

    	return wrap$1({ component, userData, conditions });
    }

    /**
     * @typedef {Object} Location
     * @property {string} location - Location (page/view), for example `/book`
     * @property {string} [querystring] - Querystring from the hash, as a string not parsed
     */
    /**
     * Returns the current location from the hash.
     *
     * @returns {Location} Location object
     * @private
     */
    function getLocation() {
    	const hashPosition = window.location.href.indexOf('#/');

    	let location = hashPosition > -1
    	? window.location.href.substr(hashPosition + 1)
    	: '/';

    	// Check if there's a querystring
    	const qsPosition = location.indexOf('?');

    	let querystring = '';

    	if (qsPosition > -1) {
    		querystring = location.substr(qsPosition + 1);
    		location = location.substr(0, qsPosition);
    	}

    	return { location, querystring };
    }

    const loc = readable(null, // eslint-disable-next-line prefer-arrow-callback
    function start(set) {
    	set(getLocation());

    	const update = () => {
    		set(getLocation());
    	};

    	window.addEventListener('hashchange', update, false);

    	return function stop() {
    		window.removeEventListener('hashchange', update, false);
    	};
    });

    const location$1 = derived(loc, $loc => $loc.location);
    const querystring = derived(loc, $loc => $loc.querystring);
    const params = writable(undefined);

    async function push(location) {
    	if (!location || location.length < 1 || location.charAt(0) != '/' && location.indexOf('#/') !== 0) {
    		throw Error('Invalid parameter location');
    	}

    	// Execute this code when the current call stack is complete
    	await tick();

    	// Note: this will include scroll state in history even when restoreScrollState is false
    	history.replaceState(
    		{
    			...history.state,
    			__svelte_spa_router_scrollX: window.scrollX,
    			__svelte_spa_router_scrollY: window.scrollY
    		},
    		undefined,
    		undefined
    	);

    	window.location.hash = (location.charAt(0) == '#' ? '' : '#') + location;
    }

    async function pop() {
    	// Execute this code when the current call stack is complete
    	await tick();

    	window.history.back();
    }

    async function replace(location) {
    	if (!location || location.length < 1 || location.charAt(0) != '/' && location.indexOf('#/') !== 0) {
    		throw Error('Invalid parameter location');
    	}

    	// Execute this code when the current call stack is complete
    	await tick();

    	const dest = (location.charAt(0) == '#' ? '' : '#') + location;

    	try {
    		const newState = { ...history.state };
    		delete newState['__svelte_spa_router_scrollX'];
    		delete newState['__svelte_spa_router_scrollY'];
    		window.history.replaceState(newState, undefined, dest);
    	} catch(e) {
    		// eslint-disable-next-line no-console
    		console.warn('Caught exception while replacing the current page. If you\'re running this in the Svelte REPL, please note that the `replace` method might not work in this environment.');
    	}

    	// The method above doesn't trigger the hashchange event, so let's do that manually
    	window.dispatchEvent(new Event('hashchange'));
    }

    function link$3(node, opts) {
    	opts = linkOpts(opts);

    	// Only apply to <a> tags
    	if (!node || !node.tagName || node.tagName.toLowerCase() != 'a') {
    		throw Error('Action "link" can only be used with <a> tags');
    	}

    	updateLink(node, opts);

    	return {
    		update(updated) {
    			updated = linkOpts(updated);
    			updateLink(node, updated);
    		}
    	};
    }

    // Internal function used by the link function
    function updateLink(node, opts) {
    	let href = opts.href || node.getAttribute('href');

    	// Destination must start with '/' or '#/'
    	if (href && href.charAt(0) == '/') {
    		// Add # to the href attribute
    		href = '#' + href;
    	} else if (!href || href.length < 2 || href.slice(0, 2) != '#/') {
    		throw Error('Invalid value for "href" attribute: ' + href);
    	}

    	node.setAttribute('href', href);

    	node.addEventListener('click', event => {
    		// Prevent default anchor onclick behaviour
    		event.preventDefault();

    		if (!opts.disabled) {
    			scrollstateHistoryHandler(event.currentTarget.getAttribute('href'));
    		}
    	});
    }

    // Internal function that ensures the argument of the link action is always an object
    function linkOpts(val) {
    	if (val && typeof val == 'string') {
    		return { href: val };
    	} else {
    		return val || {};
    	}
    }

    /**
     * The handler attached to an anchor tag responsible for updating the
     * current history state with the current scroll state
     *
     * @param {string} href - Destination
     */
    function scrollstateHistoryHandler(href) {
    	// Setting the url (3rd arg) to href will break clicking for reasons, so don't try to do that
    	history.replaceState(
    		{
    			...history.state,
    			__svelte_spa_router_scrollX: window.scrollX,
    			__svelte_spa_router_scrollY: window.scrollY
    		},
    		undefined,
    		undefined
    	);

    	// This will force an update as desired, but this time our scroll state will be attached
    	window.location.hash = href;
    }

    function instance$O($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Router', slots, []);
    	let { routes = {} } = $$props;
    	let { prefix = '' } = $$props;
    	let { restoreScrollState = false } = $$props;

    	/**
     * Container for a route: path, component
     */
    	class RouteItem {
    		/**
     * Initializes the object and creates a regular expression from the path, using regexparam.
     *
     * @param {string} path - Path to the route (must start with '/' or '*')
     * @param {SvelteComponent|WrappedComponent} component - Svelte component for the route, optionally wrapped
     */
    		constructor(path, component) {
    			if (!component || typeof component != 'function' && (typeof component != 'object' || component._sveltesparouter !== true)) {
    				throw Error('Invalid component object');
    			}

    			// Path must be a regular or expression, or a string starting with '/' or '*'
    			if (!path || typeof path == 'string' && (path.length < 1 || path.charAt(0) != '/' && path.charAt(0) != '*') || typeof path == 'object' && !(path instanceof RegExp)) {
    				throw Error('Invalid value for "path" argument - strings must start with / or *');
    			}

    			const { pattern, keys } = parse(path);
    			this.path = path;

    			// Check if the component is wrapped and we have conditions
    			if (typeof component == 'object' && component._sveltesparouter === true) {
    				this.component = component.component;
    				this.conditions = component.conditions || [];
    				this.userData = component.userData;
    				this.props = component.props || {};
    			} else {
    				// Convert the component to a function that returns a Promise, to normalize it
    				this.component = () => Promise.resolve(component);

    				this.conditions = [];
    				this.props = {};
    			}

    			this._pattern = pattern;
    			this._keys = keys;
    		}

    		/**
     * Checks if `path` matches the current route.
     * If there's a match, will return the list of parameters from the URL (if any).
     * In case of no match, the method will return `null`.
     *
     * @param {string} path - Path to test
     * @returns {null|Object.<string, string>} List of paramters from the URL if there's a match, or `null` otherwise.
     */
    		match(path) {
    			// If there's a prefix, check if it matches the start of the path.
    			// If not, bail early, else remove it before we run the matching.
    			if (prefix) {
    				if (typeof prefix == 'string') {
    					if (path.startsWith(prefix)) {
    						path = path.substr(prefix.length) || '/';
    					} else {
    						return null;
    					}
    				} else if (prefix instanceof RegExp) {
    					const match = path.match(prefix);

    					if (match && match[0]) {
    						path = path.substr(match[0].length) || '/';
    					} else {
    						return null;
    					}
    				}
    			}

    			// Check if the pattern matches
    			const matches = this._pattern.exec(path);

    			if (matches === null) {
    				return null;
    			}

    			// If the input was a regular expression, this._keys would be false, so return matches as is
    			if (this._keys === false) {
    				return matches;
    			}

    			const out = {};
    			let i = 0;

    			while (i < this._keys.length) {
    				// In the match parameters, URL-decode all values
    				try {
    					out[this._keys[i]] = decodeURIComponent(matches[i + 1] || '') || null;
    				} catch(e) {
    					out[this._keys[i]] = null;
    				}

    				i++;
    			}

    			return out;
    		}

    		/**
     * Dictionary with route details passed to the pre-conditions functions, as well as the `routeLoading`, `routeLoaded` and `conditionsFailed` events
     * @typedef {Object} RouteDetail
     * @property {string|RegExp} route - Route matched as defined in the route definition (could be a string or a reguar expression object)
     * @property {string} location - Location path
     * @property {string} querystring - Querystring from the hash
     * @property {object} [userData] - Custom data passed by the user
     * @property {SvelteComponent} [component] - Svelte component (only in `routeLoaded` events)
     * @property {string} [name] - Name of the Svelte component (only in `routeLoaded` events)
     */
    		/**
     * Executes all conditions (if any) to control whether the route can be shown. Conditions are executed in the order they are defined, and if a condition fails, the following ones aren't executed.
     * 
     * @param {RouteDetail} detail - Route detail
     * @returns {boolean} Returns true if all the conditions succeeded
     */
    		async checkConditions(detail) {
    			for (let i = 0; i < this.conditions.length; i++) {
    				if (!await this.conditions[i](detail)) {
    					return false;
    				}
    			}

    			return true;
    		}
    	}

    	// Set up all routes
    	const routesList = [];

    	if (routes instanceof Map) {
    		// If it's a map, iterate on it right away
    		routes.forEach((route, path) => {
    			routesList.push(new RouteItem(path, route));
    		});
    	} else {
    		// We have an object, so iterate on its own properties
    		Object.keys(routes).forEach(path => {
    			routesList.push(new RouteItem(path, routes[path]));
    		});
    	}

    	// Props for the component to render
    	let component = null;

    	let componentParams = null;
    	let props = {};

    	// Event dispatcher from Svelte
    	const dispatch = createEventDispatcher();

    	// Just like dispatch, but executes on the next iteration of the event loop
    	async function dispatchNextTick(name, detail) {
    		// Execute this code when the current call stack is complete
    		await tick();

    		dispatch(name, detail);
    	}

    	// If this is set, then that means we have popped into this var the state of our last scroll position
    	let previousScrollState = null;

    	let popStateChanged = null;

    	if (restoreScrollState) {
    		popStateChanged = event => {
    			// If this event was from our history.replaceState, event.state will contain
    			// our scroll history. Otherwise, event.state will be null (like on forward
    			// navigation)
    			if (event.state && event.state.__svelte_spa_router_scrollY) {
    				previousScrollState = event.state;
    			} else {
    				previousScrollState = null;
    			}
    		};

    		// This is removed in the destroy() invocation below
    		window.addEventListener('popstate', popStateChanged);

    		afterUpdate(() => {
    			// If this exists, then this is a back navigation: restore the scroll position
    			if (previousScrollState) {
    				window.scrollTo(previousScrollState.__svelte_spa_router_scrollX, previousScrollState.__svelte_spa_router_scrollY);
    			} else {
    				// Otherwise this is a forward navigation: scroll to top
    				window.scrollTo(0, 0);
    			}
    		});
    	}

    	// Always have the latest value of loc
    	let lastLoc = null;

    	// Current object of the component loaded
    	let componentObj = null;

    	// Handle hash change events
    	// Listen to changes in the $loc store and update the page
    	// Do not use the $: syntax because it gets triggered by too many things
    	const unsubscribeLoc = loc.subscribe(async newLoc => {
    		lastLoc = newLoc;

    		// Find a route matching the location
    		let i = 0;

    		while (i < routesList.length) {
    			const match = routesList[i].match(newLoc.location);

    			if (!match) {
    				i++;
    				continue;
    			}

    			const detail = {
    				route: routesList[i].path,
    				location: newLoc.location,
    				querystring: newLoc.querystring,
    				userData: routesList[i].userData,
    				params: match && typeof match == 'object' && Object.keys(match).length
    				? match
    				: null
    			};

    			// Check if the route can be loaded - if all conditions succeed
    			if (!await routesList[i].checkConditions(detail)) {
    				// Don't display anything
    				$$invalidate(0, component = null);

    				componentObj = null;

    				// Trigger an event to notify the user, then exit
    				dispatchNextTick('conditionsFailed', detail);

    				return;
    			}

    			// Trigger an event to alert that we're loading the route
    			// We need to clone the object on every event invocation so we don't risk the object to be modified in the next tick
    			dispatchNextTick('routeLoading', Object.assign({}, detail));

    			// If there's a component to show while we're loading the route, display it
    			const obj = routesList[i].component;

    			// Do not replace the component if we're loading the same one as before, to avoid the route being unmounted and re-mounted
    			if (componentObj != obj) {
    				if (obj.loading) {
    					$$invalidate(0, component = obj.loading);
    					componentObj = obj;
    					$$invalidate(1, componentParams = obj.loadingParams);
    					$$invalidate(2, props = {});

    					// Trigger the routeLoaded event for the loading component
    					// Create a copy of detail so we don't modify the object for the dynamic route (and the dynamic route doesn't modify our object too)
    					dispatchNextTick('routeLoaded', Object.assign({}, detail, {
    						component,
    						name: component.name,
    						params: componentParams
    					}));
    				} else {
    					$$invalidate(0, component = null);
    					componentObj = null;
    				}

    				// Invoke the Promise
    				const loaded = await obj();

    				// Now that we're here, after the promise resolved, check if we still want this component, as the user might have navigated to another page in the meanwhile
    				if (newLoc != lastLoc) {
    					// Don't update the component, just exit
    					return;
    				}

    				// If there is a "default" property, which is used by async routes, then pick that
    				$$invalidate(0, component = loaded && loaded.default || loaded);

    				componentObj = obj;
    			}

    			// Set componentParams only if we have a match, to avoid a warning similar to `<Component> was created with unknown prop 'params'`
    			// Of course, this assumes that developers always add a "params" prop when they are expecting parameters
    			if (match && typeof match == 'object' && Object.keys(match).length) {
    				$$invalidate(1, componentParams = match);
    			} else {
    				$$invalidate(1, componentParams = null);
    			}

    			// Set static props, if any
    			$$invalidate(2, props = routesList[i].props);

    			// Dispatch the routeLoaded event then exit
    			// We need to clone the object on every event invocation so we don't risk the object to be modified in the next tick
    			dispatchNextTick('routeLoaded', Object.assign({}, detail, {
    				component,
    				name: component.name,
    				params: componentParams
    			})).then(() => {
    				params.set(componentParams);
    			});

    			return;
    		}

    		// If we're still here, there was no match, so show the empty component
    		$$invalidate(0, component = null);

    		componentObj = null;
    		params.set(undefined);
    	});

    	onDestroy(() => {
    		unsubscribeLoc();
    		popStateChanged && window.removeEventListener('popstate', popStateChanged);
    	});

    	const writable_props = ['routes', 'prefix', 'restoreScrollState'];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$s.warn(`<Router> was created with unknown prop '${key}'`);
    	});

    	function routeEvent_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function routeEvent_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ('routes' in $$props) $$invalidate(3, routes = $$props.routes);
    		if ('prefix' in $$props) $$invalidate(4, prefix = $$props.prefix);
    		if ('restoreScrollState' in $$props) $$invalidate(5, restoreScrollState = $$props.restoreScrollState);
    	};

    	$$self.$capture_state = () => ({
    		readable,
    		writable,
    		derived,
    		tick,
    		_wrap: wrap$1,
    		wrap,
    		getLocation,
    		loc,
    		location: location$1,
    		querystring,
    		params,
    		push,
    		pop,
    		replace,
    		link: link$3,
    		updateLink,
    		linkOpts,
    		scrollstateHistoryHandler,
    		onDestroy,
    		createEventDispatcher,
    		afterUpdate,
    		parse,
    		routes,
    		prefix,
    		restoreScrollState,
    		RouteItem,
    		routesList,
    		component,
    		componentParams,
    		props,
    		dispatch,
    		dispatchNextTick,
    		previousScrollState,
    		popStateChanged,
    		lastLoc,
    		componentObj,
    		unsubscribeLoc
    	});

    	$$self.$inject_state = $$props => {
    		if ('routes' in $$props) $$invalidate(3, routes = $$props.routes);
    		if ('prefix' in $$props) $$invalidate(4, prefix = $$props.prefix);
    		if ('restoreScrollState' in $$props) $$invalidate(5, restoreScrollState = $$props.restoreScrollState);
    		if ('component' in $$props) $$invalidate(0, component = $$props.component);
    		if ('componentParams' in $$props) $$invalidate(1, componentParams = $$props.componentParams);
    		if ('props' in $$props) $$invalidate(2, props = $$props.props);
    		if ('previousScrollState' in $$props) previousScrollState = $$props.previousScrollState;
    		if ('popStateChanged' in $$props) popStateChanged = $$props.popStateChanged;
    		if ('lastLoc' in $$props) lastLoc = $$props.lastLoc;
    		if ('componentObj' in $$props) componentObj = $$props.componentObj;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*restoreScrollState*/ 32) {
    			// Update history.scrollRestoration depending on restoreScrollState
    			history.scrollRestoration = restoreScrollState ? 'manual' : 'auto';
    		}
    	};

    	return [
    		component,
    		componentParams,
    		props,
    		routes,
    		prefix,
    		restoreScrollState,
    		routeEvent_handler,
    		routeEvent_handler_1
    	];
    }

    class Router extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$O, create_fragment$O, safe_not_equal, {
    			routes: 3,
    			prefix: 4,
    			restoreScrollState: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Router",
    			options,
    			id: create_fragment$O.name
    		});
    	}

    	get routes() {
    		throw new Error_1$1("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set routes(value) {
    		throw new Error_1$1("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get prefix() {
    		throw new Error_1$1("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set prefix(value) {
    		throw new Error_1$1("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get restoreScrollState() {
    		throw new Error_1$1("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set restoreScrollState(value) {
    		throw new Error_1$1("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function toClassName(value) {
      let result = '';

      if (typeof value === 'string' || typeof value === 'number') {
        result += value;
      } else if (typeof value === 'object') {
        if (Array.isArray(value)) {
          result = value.map(toClassName).filter(Boolean).join(' ');
        } else {
          for (let key in value) {
            if (value[key]) {
              result && (result += ' ');
              result += key;
            }
          }
        }
      }

      return result;
    }

    function classnames(...args) {
      return args.map(toClassName).filter(Boolean).join(' ');
    }

    function fade(node, { delay = 0, duration = 400, easing = identity$a } = {}) {
        const o = +getComputedStyle(node).opacity;
        return {
            delay,
            duration,
            easing,
            css: t => `opacity: ${t * o}`
        };
    }

    /* node_modules\sveltestrap\src\Alert.svelte generated by Svelte v3.47.0 */
    const file$N = "node_modules\\sveltestrap\\src\\Alert.svelte";
    const get_heading_slot_changes = dirty => ({});
    const get_heading_slot_context = ctx => ({});

    // (26:0) {#if isOpen}
    function create_if_block$g(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let current_block_type_index;
    	let if_block2;
    	let div_transition;
    	let current;
    	let if_block0 = (/*heading*/ ctx[3] || /*$$slots*/ ctx[10].heading) && create_if_block_3(ctx);
    	let if_block1 = /*showClose*/ ctx[5] && create_if_block_2$3(ctx);
    	const if_block_creators = [create_if_block_1$5, create_else_block$7];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*children*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let div_levels = [/*$$restProps*/ ctx[9], { class: /*classes*/ ctx[7] }, { role: "alert" }];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element$1("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if_block2.c();
    			set_attributes(div, div_data);
    			add_location(div, file$N, 26, 2, 834);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t1);
    			if_blocks[current_block_type_index].m(div, null);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (/*heading*/ ctx[3] || /*$$slots*/ ctx[10].heading) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*heading, $$slots*/ 1032) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_3(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*showClose*/ ctx[5]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_2$3(ctx);
    					if_block1.c();
    					if_block1.m(div, t1);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block2 = if_blocks[current_block_type_index];

    				if (!if_block2) {
    					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block2.c();
    				} else {
    					if_block2.p(ctx, dirty);
    				}

    				transition_in(if_block2, 1);
    				if_block2.m(div, null);
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				dirty & /*$$restProps*/ 512 && /*$$restProps*/ ctx[9],
    				(!current || dirty & /*classes*/ 128) && { class: /*classes*/ ctx[7] },
    				{ role: "alert" }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block2);

    			add_render_callback(() => {
    				if (!div_transition) div_transition = create_bidirectional_transition(div, fade, /*transition*/ ctx[4], true);
    				div_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block2);
    			if (!div_transition) div_transition = create_bidirectional_transition(div, fade, /*transition*/ ctx[4], false);
    			div_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if_blocks[current_block_type_index].d();
    			if (detaching && div_transition) div_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$g.name,
    		type: "if",
    		source: "(26:0) {#if isOpen}",
    		ctx
    	});

    	return block;
    }

    // (33:4) {#if heading || $$slots.heading}
    function create_if_block_3(ctx) {
    	let h4;
    	let t;
    	let current;
    	const heading_slot_template = /*#slots*/ ctx[18].heading;
    	const heading_slot = create_slot(heading_slot_template, ctx, /*$$scope*/ ctx[17], get_heading_slot_context);

    	const block = {
    		c: function create() {
    			h4 = element$1("h4");
    			t = text$1(/*heading*/ ctx[3]);
    			if (heading_slot) heading_slot.c();
    			attr_dev(h4, "class", "alert-heading");
    			add_location(h4, file$N, 33, 6, 994);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h4, anchor);
    			append_dev(h4, t);

    			if (heading_slot) {
    				heading_slot.m(h4, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*heading*/ 8) set_data_dev(t, /*heading*/ ctx[3]);

    			if (heading_slot) {
    				if (heading_slot.p && (!current || dirty & /*$$scope*/ 131072)) {
    					update_slot_base(
    						heading_slot,
    						heading_slot_template,
    						ctx,
    						/*$$scope*/ ctx[17],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[17])
    						: get_slot_changes(heading_slot_template, /*$$scope*/ ctx[17], dirty, get_heading_slot_changes),
    						get_heading_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(heading_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(heading_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h4);
    			if (heading_slot) heading_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(33:4) {#if heading || $$slots.heading}",
    		ctx
    	});

    	return block;
    }

    // (38:4) {#if showClose}
    function create_if_block_2$3(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element$1("button");
    			attr_dev(button, "type", "button");
    			attr_dev(button, "class", /*closeClassNames*/ ctx[6]);
    			attr_dev(button, "aria-label", /*closeAriaLabel*/ ctx[2]);
    			add_location(button, file$N, 38, 6, 1115);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(
    					button,
    					"click",
    					function () {
    						if (is_function(/*handleToggle*/ ctx[8])) /*handleToggle*/ ctx[8].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				);

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*closeClassNames*/ 64) {
    				attr_dev(button, "class", /*closeClassNames*/ ctx[6]);
    			}

    			if (dirty & /*closeAriaLabel*/ 4) {
    				attr_dev(button, "aria-label", /*closeAriaLabel*/ ctx[2]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$3.name,
    		type: "if",
    		source: "(38:4) {#if showClose}",
    		ctx
    	});

    	return block;
    }

    // (48:4) {:else}
    function create_else_block$7(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[18].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[17], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 131072)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[17],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[17])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[17], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$7.name,
    		type: "else",
    		source: "(48:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (46:4) {#if children}
    function create_if_block_1$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1(/*children*/ ctx[1]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*children*/ 2) set_data_dev(t, /*children*/ ctx[1]);
    		},
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$5.name,
    		type: "if",
    		source: "(46:4) {#if children}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$N(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*isOpen*/ ctx[0] && create_if_block$g(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$2();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*isOpen*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*isOpen*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$g(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$N.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$N($$self, $$props, $$invalidate) {
    	let showClose;
    	let handleToggle;
    	let classes;
    	let closeClassNames;

    	const omit_props_names = [
    		"class","children","color","closeClassName","closeAriaLabel","dismissible","heading","isOpen","toggle","fade","transition"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Alert', slots, ['heading','default']);
    	const $$slots = compute_slots(slots);
    	let { class: className = '' } = $$props;
    	let { children = undefined } = $$props;
    	let { color = 'success' } = $$props;
    	let { closeClassName = '' } = $$props;
    	let { closeAriaLabel = 'Close' } = $$props;
    	let { dismissible = false } = $$props;
    	let { heading = undefined } = $$props;
    	let { isOpen = true } = $$props;
    	let { toggle = undefined } = $$props;
    	let { fade: fade$1 = true } = $$props;
    	let { transition = { duration: fade$1 ? 400 : 0 } } = $$props;

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(11, className = $$new_props.class);
    		if ('children' in $$new_props) $$invalidate(1, children = $$new_props.children);
    		if ('color' in $$new_props) $$invalidate(12, color = $$new_props.color);
    		if ('closeClassName' in $$new_props) $$invalidate(13, closeClassName = $$new_props.closeClassName);
    		if ('closeAriaLabel' in $$new_props) $$invalidate(2, closeAriaLabel = $$new_props.closeAriaLabel);
    		if ('dismissible' in $$new_props) $$invalidate(14, dismissible = $$new_props.dismissible);
    		if ('heading' in $$new_props) $$invalidate(3, heading = $$new_props.heading);
    		if ('isOpen' in $$new_props) $$invalidate(0, isOpen = $$new_props.isOpen);
    		if ('toggle' in $$new_props) $$invalidate(15, toggle = $$new_props.toggle);
    		if ('fade' in $$new_props) $$invalidate(16, fade$1 = $$new_props.fade);
    		if ('transition' in $$new_props) $$invalidate(4, transition = $$new_props.transition);
    		if ('$$scope' in $$new_props) $$invalidate(17, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		fadeTransition: fade,
    		classnames,
    		className,
    		children,
    		color,
    		closeClassName,
    		closeAriaLabel,
    		dismissible,
    		heading,
    		isOpen,
    		toggle,
    		fade: fade$1,
    		transition,
    		closeClassNames,
    		showClose,
    		classes,
    		handleToggle
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('className' in $$props) $$invalidate(11, className = $$new_props.className);
    		if ('children' in $$props) $$invalidate(1, children = $$new_props.children);
    		if ('color' in $$props) $$invalidate(12, color = $$new_props.color);
    		if ('closeClassName' in $$props) $$invalidate(13, closeClassName = $$new_props.closeClassName);
    		if ('closeAriaLabel' in $$props) $$invalidate(2, closeAriaLabel = $$new_props.closeAriaLabel);
    		if ('dismissible' in $$props) $$invalidate(14, dismissible = $$new_props.dismissible);
    		if ('heading' in $$props) $$invalidate(3, heading = $$new_props.heading);
    		if ('isOpen' in $$props) $$invalidate(0, isOpen = $$new_props.isOpen);
    		if ('toggle' in $$props) $$invalidate(15, toggle = $$new_props.toggle);
    		if ('fade' in $$props) $$invalidate(16, fade$1 = $$new_props.fade);
    		if ('transition' in $$props) $$invalidate(4, transition = $$new_props.transition);
    		if ('closeClassNames' in $$props) $$invalidate(6, closeClassNames = $$new_props.closeClassNames);
    		if ('showClose' in $$props) $$invalidate(5, showClose = $$new_props.showClose);
    		if ('classes' in $$props) $$invalidate(7, classes = $$new_props.classes);
    		if ('handleToggle' in $$props) $$invalidate(8, handleToggle = $$new_props.handleToggle);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*dismissible, toggle*/ 49152) {
    			$$invalidate(5, showClose = dismissible || toggle);
    		}

    		if ($$self.$$.dirty & /*toggle*/ 32768) {
    			$$invalidate(8, handleToggle = toggle || (() => $$invalidate(0, isOpen = false)));
    		}

    		if ($$self.$$.dirty & /*className, color, showClose*/ 6176) {
    			$$invalidate(7, classes = classnames(className, 'alert', `alert-${color}`, { 'alert-dismissible': showClose }));
    		}

    		if ($$self.$$.dirty & /*closeClassName*/ 8192) {
    			$$invalidate(6, closeClassNames = classnames('btn-close', closeClassName));
    		}
    	};

    	return [
    		isOpen,
    		children,
    		closeAriaLabel,
    		heading,
    		transition,
    		showClose,
    		closeClassNames,
    		classes,
    		handleToggle,
    		$$restProps,
    		$$slots,
    		className,
    		color,
    		closeClassName,
    		dismissible,
    		toggle,
    		fade$1,
    		$$scope,
    		slots
    	];
    }

    class Alert extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$N, create_fragment$N, safe_not_equal, {
    			class: 11,
    			children: 1,
    			color: 12,
    			closeClassName: 13,
    			closeAriaLabel: 2,
    			dismissible: 14,
    			heading: 3,
    			isOpen: 0,
    			toggle: 15,
    			fade: 16,
    			transition: 4
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Alert",
    			options,
    			id: create_fragment$N.name
    		});
    	}

    	get class() {
    		throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get children() {
    		throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set children(value) {
    		throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get closeClassName() {
    		throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set closeClassName(value) {
    		throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get closeAriaLabel() {
    		throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set closeAriaLabel(value) {
    		throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dismissible() {
    		throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dismissible(value) {
    		throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get heading() {
    		throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set heading(value) {
    		throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isOpen() {
    		throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isOpen(value) {
    		throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get toggle() {
    		throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set toggle(value) {
    		throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fade() {
    		throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fade(value) {
    		throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transition() {
    		throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transition(value) {
    		throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\sveltestrap\src\Button.svelte generated by Svelte v3.47.0 */
    const file$M = "node_modules\\sveltestrap\\src\\Button.svelte";

    // (54:0) {:else}
    function create_else_block_1(ctx) {
    	let button;
    	let button_aria_label_value;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[19].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[18], null);
    	const default_slot_or_fallback = default_slot || fallback_block$1(ctx);

    	let button_levels = [
    		/*$$restProps*/ ctx[9],
    		{ class: /*classes*/ ctx[7] },
    		{ disabled: /*disabled*/ ctx[2] },
    		{ value: /*value*/ ctx[5] },
    		{
    			"aria-label": button_aria_label_value = /*ariaLabel*/ ctx[8] || /*defaultAriaLabel*/ ctx[6]
    		},
    		{ style: /*style*/ ctx[4] }
    	];

    	let button_data = {};

    	for (let i = 0; i < button_levels.length; i += 1) {
    		button_data = assign(button_data, button_levels[i]);
    	}

    	const block_1 = {
    		c: function create() {
    			button = element$1("button");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			set_attributes(button, button_data);
    			add_location(button, file$M, 54, 2, 1178);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(button, null);
    			}

    			if (button.autofocus) button.focus();
    			/*button_binding*/ ctx[23](button);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler_1*/ ctx[21], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 262144)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[18],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[18])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[18], dirty, null),
    						null
    					);
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*children, $$scope*/ 262146)) {
    					default_slot_or_fallback.p(ctx, !current ? -1 : dirty);
    				}
    			}

    			set_attributes(button, button_data = get_spread_update(button_levels, [
    				dirty & /*$$restProps*/ 512 && /*$$restProps*/ ctx[9],
    				(!current || dirty & /*classes*/ 128) && { class: /*classes*/ ctx[7] },
    				(!current || dirty & /*disabled*/ 4) && { disabled: /*disabled*/ ctx[2] },
    				(!current || dirty & /*value*/ 32) && { value: /*value*/ ctx[5] },
    				(!current || dirty & /*ariaLabel, defaultAriaLabel*/ 320 && button_aria_label_value !== (button_aria_label_value = /*ariaLabel*/ ctx[8] || /*defaultAriaLabel*/ ctx[6])) && { "aria-label": button_aria_label_value },
    				(!current || dirty & /*style*/ 16) && { style: /*style*/ ctx[4] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			/*button_binding*/ ctx[23](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_else_block_1.name,
    		type: "else",
    		source: "(54:0) {:else}",
    		ctx
    	});

    	return block_1;
    }

    // (37:0) {#if href}
    function create_if_block$f(ctx) {
    	let a;
    	let current_block_type_index;
    	let if_block;
    	let a_aria_label_value;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block_1$4, create_else_block$6];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*children*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	let a_levels = [
    		/*$$restProps*/ ctx[9],
    		{ class: /*classes*/ ctx[7] },
    		{ disabled: /*disabled*/ ctx[2] },
    		{ href: /*href*/ ctx[3] },
    		{
    			"aria-label": a_aria_label_value = /*ariaLabel*/ ctx[8] || /*defaultAriaLabel*/ ctx[6]
    		},
    		{ style: /*style*/ ctx[4] }
    	];

    	let a_data = {};

    	for (let i = 0; i < a_levels.length; i += 1) {
    		a_data = assign(a_data, a_levels[i]);
    	}

    	const block_1 = {
    		c: function create() {
    			a = element$1("a");
    			if_block.c();
    			set_attributes(a, a_data);
    			add_location(a, file$M, 37, 2, 903);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			if_blocks[current_block_type_index].m(a, null);
    			/*a_binding*/ ctx[22](a);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(a, "click", /*click_handler*/ ctx[20], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(a, null);
    			}

    			set_attributes(a, a_data = get_spread_update(a_levels, [
    				dirty & /*$$restProps*/ 512 && /*$$restProps*/ ctx[9],
    				(!current || dirty & /*classes*/ 128) && { class: /*classes*/ ctx[7] },
    				(!current || dirty & /*disabled*/ 4) && { disabled: /*disabled*/ ctx[2] },
    				(!current || dirty & /*href*/ 8) && { href: /*href*/ ctx[3] },
    				(!current || dirty & /*ariaLabel, defaultAriaLabel*/ 320 && a_aria_label_value !== (a_aria_label_value = /*ariaLabel*/ ctx[8] || /*defaultAriaLabel*/ ctx[6])) && { "aria-label": a_aria_label_value },
    				(!current || dirty & /*style*/ 16) && { style: /*style*/ ctx[4] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if_blocks[current_block_type_index].d();
    			/*a_binding*/ ctx[22](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_if_block$f.name,
    		type: "if",
    		source: "(37:0) {#if href}",
    		ctx
    	});

    	return block_1;
    }

    // (68:6) {:else}
    function create_else_block_2(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[19].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[18], null);

    	const block_1 = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 262144)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[18],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[18])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[18], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_else_block_2.name,
    		type: "else",
    		source: "(68:6) {:else}",
    		ctx
    	});

    	return block_1;
    }

    // (66:6) {#if children}
    function create_if_block_2$2(ctx) {
    	let t;

    	const block_1 = {
    		c: function create() {
    			t = text$1(/*children*/ ctx[1]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*children*/ 2) set_data_dev(t, /*children*/ ctx[1]);
    		},
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(66:6) {#if children}",
    		ctx
    	});

    	return block_1;
    }

    // (65:10)         
    function fallback_block$1(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_2$2, create_else_block_2];
    	const if_blocks = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*children*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_2(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block_1 = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_2(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: fallback_block$1.name,
    		type: "fallback",
    		source: "(65:10)         ",
    		ctx
    	});

    	return block_1;
    }

    // (50:4) {:else}
    function create_else_block$6(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[19].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[18], null);

    	const block_1 = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 262144)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[18],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[18])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[18], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_else_block$6.name,
    		type: "else",
    		source: "(50:4) {:else}",
    		ctx
    	});

    	return block_1;
    }

    // (48:4) {#if children}
    function create_if_block_1$4(ctx) {
    	let t;

    	const block_1 = {
    		c: function create() {
    			t = text$1(/*children*/ ctx[1]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*children*/ 2) set_data_dev(t, /*children*/ ctx[1]);
    		},
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_if_block_1$4.name,
    		type: "if",
    		source: "(48:4) {#if children}",
    		ctx
    	});

    	return block_1;
    }

    function create_fragment$M(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$f, create_else_block_1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*href*/ ctx[3]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block_1 = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$2();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_fragment$M.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block_1;
    }

    function instance$M($$self, $$props, $$invalidate) {
    	let ariaLabel;
    	let classes;
    	let defaultAriaLabel;

    	const omit_props_names = [
    		"class","active","block","children","close","color","disabled","href","inner","outline","size","style","value","white"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Button', slots, ['default']);
    	let { class: className = '' } = $$props;
    	let { active = false } = $$props;
    	let { block = false } = $$props;
    	let { children = undefined } = $$props;
    	let { close = false } = $$props;
    	let { color = 'secondary' } = $$props;
    	let { disabled = false } = $$props;
    	let { href = '' } = $$props;
    	let { inner = undefined } = $$props;
    	let { outline = false } = $$props;
    	let { size = null } = $$props;
    	let { style = '' } = $$props;
    	let { value = '' } = $$props;
    	let { white = false } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function click_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function a_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inner = $$value;
    			$$invalidate(0, inner);
    		});
    	}

    	function button_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inner = $$value;
    			$$invalidate(0, inner);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(24, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(10, className = $$new_props.class);
    		if ('active' in $$new_props) $$invalidate(11, active = $$new_props.active);
    		if ('block' in $$new_props) $$invalidate(12, block = $$new_props.block);
    		if ('children' in $$new_props) $$invalidate(1, children = $$new_props.children);
    		if ('close' in $$new_props) $$invalidate(13, close = $$new_props.close);
    		if ('color' in $$new_props) $$invalidate(14, color = $$new_props.color);
    		if ('disabled' in $$new_props) $$invalidate(2, disabled = $$new_props.disabled);
    		if ('href' in $$new_props) $$invalidate(3, href = $$new_props.href);
    		if ('inner' in $$new_props) $$invalidate(0, inner = $$new_props.inner);
    		if ('outline' in $$new_props) $$invalidate(15, outline = $$new_props.outline);
    		if ('size' in $$new_props) $$invalidate(16, size = $$new_props.size);
    		if ('style' in $$new_props) $$invalidate(4, style = $$new_props.style);
    		if ('value' in $$new_props) $$invalidate(5, value = $$new_props.value);
    		if ('white' in $$new_props) $$invalidate(17, white = $$new_props.white);
    		if ('$$scope' in $$new_props) $$invalidate(18, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		classnames,
    		className,
    		active,
    		block,
    		children,
    		close,
    		color,
    		disabled,
    		href,
    		inner,
    		outline,
    		size,
    		style,
    		value,
    		white,
    		defaultAriaLabel,
    		classes,
    		ariaLabel
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(24, $$props = assign(assign({}, $$props), $$new_props));
    		if ('className' in $$props) $$invalidate(10, className = $$new_props.className);
    		if ('active' in $$props) $$invalidate(11, active = $$new_props.active);
    		if ('block' in $$props) $$invalidate(12, block = $$new_props.block);
    		if ('children' in $$props) $$invalidate(1, children = $$new_props.children);
    		if ('close' in $$props) $$invalidate(13, close = $$new_props.close);
    		if ('color' in $$props) $$invalidate(14, color = $$new_props.color);
    		if ('disabled' in $$props) $$invalidate(2, disabled = $$new_props.disabled);
    		if ('href' in $$props) $$invalidate(3, href = $$new_props.href);
    		if ('inner' in $$props) $$invalidate(0, inner = $$new_props.inner);
    		if ('outline' in $$props) $$invalidate(15, outline = $$new_props.outline);
    		if ('size' in $$props) $$invalidate(16, size = $$new_props.size);
    		if ('style' in $$props) $$invalidate(4, style = $$new_props.style);
    		if ('value' in $$props) $$invalidate(5, value = $$new_props.value);
    		if ('white' in $$props) $$invalidate(17, white = $$new_props.white);
    		if ('defaultAriaLabel' in $$props) $$invalidate(6, defaultAriaLabel = $$new_props.defaultAriaLabel);
    		if ('classes' in $$props) $$invalidate(7, classes = $$new_props.classes);
    		if ('ariaLabel' in $$props) $$invalidate(8, ariaLabel = $$new_props.ariaLabel);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(8, ariaLabel = $$props['aria-label']);

    		if ($$self.$$.dirty & /*className, close, outline, color, size, block, active, white*/ 261120) {
    			$$invalidate(7, classes = classnames(className, close ? 'btn-close' : 'btn', close || `btn${outline ? '-outline' : ''}-${color}`, size ? `btn-${size}` : false, block ? 'd-block w-100' : false, {
    				active,
    				'btn-close-white': close && white
    			}));
    		}

    		if ($$self.$$.dirty & /*close*/ 8192) {
    			$$invalidate(6, defaultAriaLabel = close ? 'Close' : null);
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		inner,
    		children,
    		disabled,
    		href,
    		style,
    		value,
    		defaultAriaLabel,
    		classes,
    		ariaLabel,
    		$$restProps,
    		className,
    		active,
    		block,
    		close,
    		color,
    		outline,
    		size,
    		white,
    		$$scope,
    		slots,
    		click_handler,
    		click_handler_1,
    		a_binding,
    		button_binding
    	];
    }

    class Button extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$M, create_fragment$M, safe_not_equal, {
    			class: 10,
    			active: 11,
    			block: 12,
    			children: 1,
    			close: 13,
    			color: 14,
    			disabled: 2,
    			href: 3,
    			inner: 0,
    			outline: 15,
    			size: 16,
    			style: 4,
    			value: 5,
    			white: 17
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Button",
    			options,
    			id: create_fragment$M.name
    		});
    	}

    	get class() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get active() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get block() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set block(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get children() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set children(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get close() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set close(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get href() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inner() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inner(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get outline() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set outline(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get white() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set white(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function getWindow(node) {
      if (node == null) {
        return window;
      }

      if (node.toString() !== '[object Window]') {
        var ownerDocument = node.ownerDocument;
        return ownerDocument ? ownerDocument.defaultView || window : window;
      }

      return node;
    }

    function isElement(node) {
      var OwnElement = getWindow(node).Element;
      return node instanceof OwnElement || node instanceof Element;
    }

    function isHTMLElement(node) {
      var OwnElement = getWindow(node).HTMLElement;
      return node instanceof OwnElement || node instanceof HTMLElement;
    }

    function isShadowRoot(node) {
      // IE 11 has no ShadowRoot
      if (typeof ShadowRoot === 'undefined') {
        return false;
      }

      var OwnElement = getWindow(node).ShadowRoot;
      return node instanceof OwnElement || node instanceof ShadowRoot;
    }

    var max$3 = Math.max;
    var min$2 = Math.min;
    var round = Math.round;

    function getBoundingClientRect(element, includeScale) {
      if (includeScale === void 0) {
        includeScale = false;
      }

      var rect = element.getBoundingClientRect();
      var scaleX = 1;
      var scaleY = 1;

      if (isHTMLElement(element) && includeScale) {
        var offsetHeight = element.offsetHeight;
        var offsetWidth = element.offsetWidth; // Do not attempt to divide by 0, otherwise we get `Infinity` as scale
        // Fallback to 1 in case both values are `0`

        if (offsetWidth > 0) {
          scaleX = round(rect.width) / offsetWidth || 1;
        }

        if (offsetHeight > 0) {
          scaleY = round(rect.height) / offsetHeight || 1;
        }
      }

      return {
        width: rect.width / scaleX,
        height: rect.height / scaleY,
        top: rect.top / scaleY,
        right: rect.right / scaleX,
        bottom: rect.bottom / scaleY,
        left: rect.left / scaleX,
        x: rect.left / scaleX,
        y: rect.top / scaleY
      };
    }

    function getWindowScroll(node) {
      var win = getWindow(node);
      var scrollLeft = win.pageXOffset;
      var scrollTop = win.pageYOffset;
      return {
        scrollLeft: scrollLeft,
        scrollTop: scrollTop
      };
    }

    function getHTMLElementScroll(element) {
      return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
      };
    }

    function getNodeScroll(node) {
      if (node === getWindow(node) || !isHTMLElement(node)) {
        return getWindowScroll(node);
      } else {
        return getHTMLElementScroll(node);
      }
    }

    function getNodeName(element) {
      return element ? (element.nodeName || '').toLowerCase() : null;
    }

    function getDocumentElement(element) {
      // $FlowFixMe[incompatible-return]: assume body is always available
      return ((isElement(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]
      element.document) || window.document).documentElement;
    }

    function getWindowScrollBarX(element) {
      // If <html> has a CSS width greater than the viewport, then this will be
      // incorrect for RTL.
      // Popper 1 is broken in this case and never had a bug report so let's assume
      // it's not an issue. I don't think anyone ever specifies width on <html>
      // anyway.
      // Browsers where the left scrollbar doesn't cause an issue report `0` for
      // this (e.g. Edge 2019, IE11, Safari)
      return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
    }

    function getComputedStyle$1(element) {
      return getWindow(element).getComputedStyle(element);
    }

    function isScrollParent(element) {
      // Firefox wants us to check `-x` and `-y` variations as well
      var _getComputedStyle = getComputedStyle$1(element),
          overflow = _getComputedStyle.overflow,
          overflowX = _getComputedStyle.overflowX,
          overflowY = _getComputedStyle.overflowY;

      return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
    }

    function isElementScaled(element) {
      var rect = element.getBoundingClientRect();
      var scaleX = round(rect.width) / element.offsetWidth || 1;
      var scaleY = round(rect.height) / element.offsetHeight || 1;
      return scaleX !== 1 || scaleY !== 1;
    } // Returns the composite rect of an element relative to its offsetParent.
    // Composite means it takes into account transforms as well as layout.


    function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
      if (isFixed === void 0) {
        isFixed = false;
      }

      var isOffsetParentAnElement = isHTMLElement(offsetParent);
      var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
      var documentElement = getDocumentElement(offsetParent);
      var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled);
      var scroll = {
        scrollLeft: 0,
        scrollTop: 0
      };
      var offsets = {
        x: 0,
        y: 0
      };

      if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
        isScrollParent(documentElement)) {
          scroll = getNodeScroll(offsetParent);
        }

        if (isHTMLElement(offsetParent)) {
          offsets = getBoundingClientRect(offsetParent, true);
          offsets.x += offsetParent.clientLeft;
          offsets.y += offsetParent.clientTop;
        } else if (documentElement) {
          offsets.x = getWindowScrollBarX(documentElement);
        }
      }

      return {
        x: rect.left + scroll.scrollLeft - offsets.x,
        y: rect.top + scroll.scrollTop - offsets.y,
        width: rect.width,
        height: rect.height
      };
    }

    // means it doesn't take into account transforms.

    function getLayoutRect(element) {
      var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.
      // Fixes https://github.com/popperjs/popper-core/issues/1223

      var width = element.offsetWidth;
      var height = element.offsetHeight;

      if (Math.abs(clientRect.width - width) <= 1) {
        width = clientRect.width;
      }

      if (Math.abs(clientRect.height - height) <= 1) {
        height = clientRect.height;
      }

      return {
        x: element.offsetLeft,
        y: element.offsetTop,
        width: width,
        height: height
      };
    }

    function getParentNode(element) {
      if (getNodeName(element) === 'html') {
        return element;
      }

      return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
        // $FlowFixMe[incompatible-return]
        // $FlowFixMe[prop-missing]
        element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
        element.parentNode || ( // DOM Element detected
        isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
        // $FlowFixMe[incompatible-call]: HTMLElement is a Node
        getDocumentElement(element) // fallback

      );
    }

    function getScrollParent(node) {
      if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {
        // $FlowFixMe[incompatible-return]: assume body is always available
        return node.ownerDocument.body;
      }

      if (isHTMLElement(node) && isScrollParent(node)) {
        return node;
      }

      return getScrollParent(getParentNode(node));
    }

    /*
    given a DOM element, return the list of all scroll parents, up the list of ancesors
    until we get to the top window object. This list is what we attach scroll listeners
    to, because if any of these parent elements scroll, we'll need to re-calculate the
    reference element's position.
    */

    function listScrollParents(element, list) {
      var _element$ownerDocumen;

      if (list === void 0) {
        list = [];
      }

      var scrollParent = getScrollParent(element);
      var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
      var win = getWindow(scrollParent);
      var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
      var updatedList = list.concat(target);
      return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
      updatedList.concat(listScrollParents(getParentNode(target)));
    }

    function isTableElement(element) {
      return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;
    }

    function getTrueOffsetParent(element) {
      if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
      getComputedStyle$1(element).position === 'fixed') {
        return null;
      }

      return element.offsetParent;
    } // `.offsetParent` reports `null` for fixed elements, while absolute elements
    // return the containing block


    function getContainingBlock(element) {
      var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') !== -1;
      var isIE = navigator.userAgent.indexOf('Trident') !== -1;

      if (isIE && isHTMLElement(element)) {
        // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
        var elementCss = getComputedStyle$1(element);

        if (elementCss.position === 'fixed') {
          return null;
        }
      }

      var currentNode = getParentNode(element);

      if (isShadowRoot(currentNode)) {
        currentNode = currentNode.host;
      }

      while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {
        var css = getComputedStyle$1(currentNode); // This is non-exhaustive but covers the most common CSS properties that
        // create a containing block.
        // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

        if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
          return currentNode;
        } else {
          currentNode = currentNode.parentNode;
        }
      }

      return null;
    } // Gets the closest ancestor positioned element. Handles some edge cases,
    // such as table ancestors and cross browser bugs.


    function getOffsetParent(element) {
      var window = getWindow(element);
      var offsetParent = getTrueOffsetParent(element);

      while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {
        offsetParent = getTrueOffsetParent(offsetParent);
      }

      if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static')) {
        return window;
      }

      return offsetParent || getContainingBlock(element) || window;
    }

    var top$1 = 'top';
    var bottom$1 = 'bottom';
    var right$1 = 'right';
    var left$1 = 'left';
    var auto = 'auto';
    var basePlacements = [top$1, bottom$1, right$1, left$1];
    var start$1 = 'start';
    var end = 'end';
    var clippingParents = 'clippingParents';
    var viewport = 'viewport';
    var popper = 'popper';
    var reference = 'reference';
    var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
      return acc.concat([placement + "-" + start$1, placement + "-" + end]);
    }, []);
    var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
      return acc.concat([placement, placement + "-" + start$1, placement + "-" + end]);
    }, []); // modifiers that need to read the DOM

    var beforeRead = 'beforeRead';
    var read = 'read';
    var afterRead = 'afterRead'; // pure-logic modifiers

    var beforeMain = 'beforeMain';
    var main = 'main';
    var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

    var beforeWrite = 'beforeWrite';
    var write = 'write';
    var afterWrite = 'afterWrite';
    var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

    function order(modifiers) {
      var map = new Map();
      var visited = new Set();
      var result = [];
      modifiers.forEach(function (modifier) {
        map.set(modifier.name, modifier);
      }); // On visiting object, check for its dependencies and visit them recursively

      function sort(modifier) {
        visited.add(modifier.name);
        var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
        requires.forEach(function (dep) {
          if (!visited.has(dep)) {
            var depModifier = map.get(dep);

            if (depModifier) {
              sort(depModifier);
            }
          }
        });
        result.push(modifier);
      }

      modifiers.forEach(function (modifier) {
        if (!visited.has(modifier.name)) {
          // check for visited object
          sort(modifier);
        }
      });
      return result;
    }

    function orderModifiers(modifiers) {
      // order based on dependencies
      var orderedModifiers = order(modifiers); // order based on phase

      return modifierPhases.reduce(function (acc, phase) {
        return acc.concat(orderedModifiers.filter(function (modifier) {
          return modifier.phase === phase;
        }));
      }, []);
    }

    function debounce(fn) {
      var pending;
      return function () {
        if (!pending) {
          pending = new Promise(function (resolve) {
            Promise.resolve().then(function () {
              pending = undefined;
              resolve(fn());
            });
          });
        }

        return pending;
      };
    }

    function getBasePlacement(placement) {
      return placement.split('-')[0];
    }

    function mergeByName(modifiers) {
      var merged = modifiers.reduce(function (merged, current) {
        var existing = merged[current.name];
        merged[current.name] = existing ? Object.assign({}, existing, current, {
          options: Object.assign({}, existing.options, current.options),
          data: Object.assign({}, existing.data, current.data)
        }) : current;
        return merged;
      }, {}); // IE11 does not support Object.values

      return Object.keys(merged).map(function (key) {
        return merged[key];
      });
    }

    function getViewportRect(element) {
      var win = getWindow(element);
      var html = getDocumentElement(element);
      var visualViewport = win.visualViewport;
      var width = html.clientWidth;
      var height = html.clientHeight;
      var x = 0;
      var y = 0; // NB: This isn't supported on iOS <= 12. If the keyboard is open, the popper
      // can be obscured underneath it.
      // Also, `html.clientHeight` adds the bottom bar height in Safari iOS, even
      // if it isn't open, so if this isn't available, the popper will be detected
      // to overflow the bottom of the screen too early.

      if (visualViewport) {
        width = visualViewport.width;
        height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)
        // In Chrome, it returns a value very close to 0 (+/-) but contains rounding
        // errors due to floating point numbers, so we need to check precision.
        // Safari returns a number <= 0, usually < -1 when pinch-zoomed
        // Feature detection fails in mobile emulation mode in Chrome.
        // Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) <
        // 0.001
        // Fallback here: "Not Safari" userAgent

        if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
          x = visualViewport.offsetLeft;
          y = visualViewport.offsetTop;
        }
      }

      return {
        width: width,
        height: height,
        x: x + getWindowScrollBarX(element),
        y: y
      };
    }

    // of the `<html>` and `<body>` rect bounds if horizontally scrollable

    function getDocumentRect(element) {
      var _element$ownerDocumen;

      var html = getDocumentElement(element);
      var winScroll = getWindowScroll(element);
      var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
      var width = max$3(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
      var height = max$3(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
      var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
      var y = -winScroll.scrollTop;

      if (getComputedStyle$1(body || html).direction === 'rtl') {
        x += max$3(html.clientWidth, body ? body.clientWidth : 0) - width;
      }

      return {
        width: width,
        height: height,
        x: x,
        y: y
      };
    }

    function contains$3(parent, child) {
      var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

      if (parent.contains(child)) {
        return true;
      } // then fallback to custom implementation with Shadow DOM support
      else if (rootNode && isShadowRoot(rootNode)) {
          var next = child;

          do {
            if (next && parent.isSameNode(next)) {
              return true;
            } // $FlowFixMe[prop-missing]: need a better way to handle this...


            next = next.parentNode || next.host;
          } while (next);
        } // Give up, the result is false


      return false;
    }

    function rectToClientRect(rect) {
      return Object.assign({}, rect, {
        left: rect.x,
        top: rect.y,
        right: rect.x + rect.width,
        bottom: rect.y + rect.height
      });
    }

    function getInnerBoundingClientRect(element) {
      var rect = getBoundingClientRect(element);
      rect.top = rect.top + element.clientTop;
      rect.left = rect.left + element.clientLeft;
      rect.bottom = rect.top + element.clientHeight;
      rect.right = rect.left + element.clientWidth;
      rect.width = element.clientWidth;
      rect.height = element.clientHeight;
      rect.x = rect.left;
      rect.y = rect.top;
      return rect;
    }

    function getClientRectFromMixedType(element, clippingParent) {
      return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
    } // A "clipping parent" is an overflowable container with the characteristic of
    // clipping (or hiding) overflowing elements with a position different from
    // `initial`


    function getClippingParents(element) {
      var clippingParents = listScrollParents(getParentNode(element));
      var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle$1(element).position) >= 0;
      var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;

      if (!isElement(clipperElement)) {
        return [];
      } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414


      return clippingParents.filter(function (clippingParent) {
        return isElement(clippingParent) && contains$3(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';
      });
    } // Gets the maximum area that the element is visible in due to any number of
    // clipping parents


    function getClippingRect(element, boundary, rootBoundary) {
      var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
      var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
      var firstClippingParent = clippingParents[0];
      var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
        var rect = getClientRectFromMixedType(element, clippingParent);
        accRect.top = max$3(rect.top, accRect.top);
        accRect.right = min$2(rect.right, accRect.right);
        accRect.bottom = min$2(rect.bottom, accRect.bottom);
        accRect.left = max$3(rect.left, accRect.left);
        return accRect;
      }, getClientRectFromMixedType(element, firstClippingParent));
      clippingRect.width = clippingRect.right - clippingRect.left;
      clippingRect.height = clippingRect.bottom - clippingRect.top;
      clippingRect.x = clippingRect.left;
      clippingRect.y = clippingRect.top;
      return clippingRect;
    }

    function getVariation(placement) {
      return placement.split('-')[1];
    }

    function getMainAxisFromPlacement(placement) {
      return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
    }

    function computeOffsets(_ref) {
      var reference = _ref.reference,
          element = _ref.element,
          placement = _ref.placement;
      var basePlacement = placement ? getBasePlacement(placement) : null;
      var variation = placement ? getVariation(placement) : null;
      var commonX = reference.x + reference.width / 2 - element.width / 2;
      var commonY = reference.y + reference.height / 2 - element.height / 2;
      var offsets;

      switch (basePlacement) {
        case top$1:
          offsets = {
            x: commonX,
            y: reference.y - element.height
          };
          break;

        case bottom$1:
          offsets = {
            x: commonX,
            y: reference.y + reference.height
          };
          break;

        case right$1:
          offsets = {
            x: reference.x + reference.width,
            y: commonY
          };
          break;

        case left$1:
          offsets = {
            x: reference.x - element.width,
            y: commonY
          };
          break;

        default:
          offsets = {
            x: reference.x,
            y: reference.y
          };
      }

      var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;

      if (mainAxis != null) {
        var len = mainAxis === 'y' ? 'height' : 'width';

        switch (variation) {
          case start$1:
            offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
            break;

          case end:
            offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
            break;
        }
      }

      return offsets;
    }

    function getFreshSideObject() {
      return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };
    }

    function mergePaddingObject(paddingObject) {
      return Object.assign({}, getFreshSideObject(), paddingObject);
    }

    function expandToHashMap(value, keys) {
      return keys.reduce(function (hashMap, key) {
        hashMap[key] = value;
        return hashMap;
      }, {});
    }

    function detectOverflow(state, options) {
      if (options === void 0) {
        options = {};
      }

      var _options = options,
          _options$placement = _options.placement,
          placement = _options$placement === void 0 ? state.placement : _options$placement,
          _options$boundary = _options.boundary,
          boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
          _options$rootBoundary = _options.rootBoundary,
          rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
          _options$elementConte = _options.elementContext,
          elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
          _options$altBoundary = _options.altBoundary,
          altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
          _options$padding = _options.padding,
          padding = _options$padding === void 0 ? 0 : _options$padding;
      var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
      var altContext = elementContext === popper ? reference : popper;
      var popperRect = state.rects.popper;
      var element = state.elements[altBoundary ? altContext : elementContext];
      var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
      var referenceClientRect = getBoundingClientRect(state.elements.reference);
      var popperOffsets = computeOffsets({
        reference: referenceClientRect,
        element: popperRect,
        strategy: 'absolute',
        placement: placement
      });
      var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
      var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
      // 0 or negative = within the clipping rect

      var overflowOffsets = {
        top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
        bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
        left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
        right: elementClientRect.right - clippingClientRect.right + paddingObject.right
      };
      var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

      if (elementContext === popper && offsetData) {
        var offset = offsetData[placement];
        Object.keys(overflowOffsets).forEach(function (key) {
          var multiply = [right$1, bottom$1].indexOf(key) >= 0 ? 1 : -1;
          var axis = [top$1, bottom$1].indexOf(key) >= 0 ? 'y' : 'x';
          overflowOffsets[key] += offset[axis] * multiply;
        });
      }

      return overflowOffsets;
    }

    var DEFAULT_OPTIONS = {
      placement: 'bottom',
      modifiers: [],
      strategy: 'absolute'
    };

    function areValidElements() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return !args.some(function (element) {
        return !(element && typeof element.getBoundingClientRect === 'function');
      });
    }

    function popperGenerator(generatorOptions) {
      if (generatorOptions === void 0) {
        generatorOptions = {};
      }

      var _generatorOptions = generatorOptions,
          _generatorOptions$def = _generatorOptions.defaultModifiers,
          defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
          _generatorOptions$def2 = _generatorOptions.defaultOptions,
          defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
      return function createPopper(reference, popper, options) {
        if (options === void 0) {
          options = defaultOptions;
        }

        var state = {
          placement: 'bottom',
          orderedModifiers: [],
          options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
          modifiersData: {},
          elements: {
            reference: reference,
            popper: popper
          },
          attributes: {},
          styles: {}
        };
        var effectCleanupFns = [];
        var isDestroyed = false;
        var instance = {
          state: state,
          setOptions: function setOptions(setOptionsAction) {
            var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
            cleanupModifierEffects();
            state.options = Object.assign({}, defaultOptions, state.options, options);
            state.scrollParents = {
              reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
              popper: listScrollParents(popper)
            }; // Orders the modifiers based on their dependencies and `phase`
            // properties

            var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

            state.orderedModifiers = orderedModifiers.filter(function (m) {
              return m.enabled;
            }); // Validate the provided modifiers so that the consumer will get warned

            runModifierEffects();
            return instance.update();
          },
          // Sync update – it will always be executed, even if not necessary. This
          // is useful for low frequency updates where sync behavior simplifies the
          // logic.
          // For high frequency updates (e.g. `resize` and `scroll` events), always
          // prefer the async Popper#update method
          forceUpdate: function forceUpdate() {
            if (isDestroyed) {
              return;
            }

            var _state$elements = state.elements,
                reference = _state$elements.reference,
                popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
            // anymore

            if (!areValidElements(reference, popper)) {

              return;
            } // Store the reference and popper rects to be read by modifiers


            state.rects = {
              reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
              popper: getLayoutRect(popper)
            }; // Modifiers have the ability to reset the current update cycle. The
            // most common use case for this is the `flip` modifier changing the
            // placement, which then needs to re-run all the modifiers, because the
            // logic was previously ran for the previous placement and is therefore
            // stale/incorrect

            state.reset = false;
            state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
            // is filled with the initial data specified by the modifier. This means
            // it doesn't persist and is fresh on each update.
            // To ensure persistent data, use `${name}#persistent`

            state.orderedModifiers.forEach(function (modifier) {
              return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
            });

            for (var index = 0; index < state.orderedModifiers.length; index++) {

              if (state.reset === true) {
                state.reset = false;
                index = -1;
                continue;
              }

              var _state$orderedModifie = state.orderedModifiers[index],
                  fn = _state$orderedModifie.fn,
                  _state$orderedModifie2 = _state$orderedModifie.options,
                  _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
                  name = _state$orderedModifie.name;

              if (typeof fn === 'function') {
                state = fn({
                  state: state,
                  options: _options,
                  name: name,
                  instance: instance
                }) || state;
              }
            }
          },
          // Async and optimistically optimized update – it will not be executed if
          // not necessary (debounced to run at most once-per-tick)
          update: debounce(function () {
            return new Promise(function (resolve) {
              instance.forceUpdate();
              resolve(state);
            });
          }),
          destroy: function destroy() {
            cleanupModifierEffects();
            isDestroyed = true;
          }
        };

        if (!areValidElements(reference, popper)) {

          return instance;
        }

        instance.setOptions(options).then(function (state) {
          if (!isDestroyed && options.onFirstUpdate) {
            options.onFirstUpdate(state);
          }
        }); // Modifiers have the ability to execute arbitrary code before the first
        // update cycle runs. They will be executed in the same order as the update
        // cycle. This is useful when a modifier adds some persistent data that
        // other modifiers need to use, but the modifier is run after the dependent
        // one.

        function runModifierEffects() {
          state.orderedModifiers.forEach(function (_ref3) {
            var name = _ref3.name,
                _ref3$options = _ref3.options,
                options = _ref3$options === void 0 ? {} : _ref3$options,
                effect = _ref3.effect;

            if (typeof effect === 'function') {
              var cleanupFn = effect({
                state: state,
                name: name,
                instance: instance,
                options: options
              });

              var noopFn = function noopFn() {};

              effectCleanupFns.push(cleanupFn || noopFn);
            }
          });
        }

        function cleanupModifierEffects() {
          effectCleanupFns.forEach(function (fn) {
            return fn();
          });
          effectCleanupFns = [];
        }

        return instance;
      };
    }

    var passive = {
      passive: true
    };

    function effect$2(_ref) {
      var state = _ref.state,
          instance = _ref.instance,
          options = _ref.options;
      var _options$scroll = options.scroll,
          scroll = _options$scroll === void 0 ? true : _options$scroll,
          _options$resize = options.resize,
          resize = _options$resize === void 0 ? true : _options$resize;
      var window = getWindow(state.elements.popper);
      var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

      if (scroll) {
        scrollParents.forEach(function (scrollParent) {
          scrollParent.addEventListener('scroll', instance.update, passive);
        });
      }

      if (resize) {
        window.addEventListener('resize', instance.update, passive);
      }

      return function () {
        if (scroll) {
          scrollParents.forEach(function (scrollParent) {
            scrollParent.removeEventListener('scroll', instance.update, passive);
          });
        }

        if (resize) {
          window.removeEventListener('resize', instance.update, passive);
        }
      };
    } // eslint-disable-next-line import/no-unused-modules


    var eventListeners = {
      name: 'eventListeners',
      enabled: true,
      phase: 'write',
      fn: function fn() {},
      effect: effect$2,
      data: {}
    };

    function popperOffsets(_ref) {
      var state = _ref.state,
          name = _ref.name;
      // Offsets are the actual position the popper needs to have to be
      // properly positioned near its reference element
      // This is the most basic placement, and will be adjusted by
      // the modifiers in the next step
      state.modifiersData[name] = computeOffsets({
        reference: state.rects.reference,
        element: state.rects.popper,
        strategy: 'absolute',
        placement: state.placement
      });
    } // eslint-disable-next-line import/no-unused-modules


    var popperOffsets$1 = {
      name: 'popperOffsets',
      enabled: true,
      phase: 'read',
      fn: popperOffsets,
      data: {}
    };

    var unsetSides = {
      top: 'auto',
      right: 'auto',
      bottom: 'auto',
      left: 'auto'
    }; // Round the offsets to the nearest suitable subpixel based on the DPR.
    // Zooming can change the DPR, but it seems to report a value that will
    // cleanly divide the values into the appropriate subpixels.

    function roundOffsetsByDPR(_ref) {
      var x = _ref.x,
          y = _ref.y;
      var win = window;
      var dpr = win.devicePixelRatio || 1;
      return {
        x: round(x * dpr) / dpr || 0,
        y: round(y * dpr) / dpr || 0
      };
    }

    function mapToStyles(_ref2) {
      var _Object$assign2;

      var popper = _ref2.popper,
          popperRect = _ref2.popperRect,
          placement = _ref2.placement,
          variation = _ref2.variation,
          offsets = _ref2.offsets,
          position = _ref2.position,
          gpuAcceleration = _ref2.gpuAcceleration,
          adaptive = _ref2.adaptive,
          roundOffsets = _ref2.roundOffsets,
          isFixed = _ref2.isFixed;
      var _offsets$x = offsets.x,
          x = _offsets$x === void 0 ? 0 : _offsets$x,
          _offsets$y = offsets.y,
          y = _offsets$y === void 0 ? 0 : _offsets$y;

      var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({
        x: x,
        y: y
      }) : {
        x: x,
        y: y
      };

      x = _ref3.x;
      y = _ref3.y;
      var hasX = offsets.hasOwnProperty('x');
      var hasY = offsets.hasOwnProperty('y');
      var sideX = left$1;
      var sideY = top$1;
      var win = window;

      if (adaptive) {
        var offsetParent = getOffsetParent(popper);
        var heightProp = 'clientHeight';
        var widthProp = 'clientWidth';

        if (offsetParent === getWindow(popper)) {
          offsetParent = getDocumentElement(popper);

          if (getComputedStyle$1(offsetParent).position !== 'static' && position === 'absolute') {
            heightProp = 'scrollHeight';
            widthProp = 'scrollWidth';
          }
        } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it


        offsetParent = offsetParent;

        if (placement === top$1 || (placement === left$1 || placement === right$1) && variation === end) {
          sideY = bottom$1;
          var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : // $FlowFixMe[prop-missing]
          offsetParent[heightProp];
          y -= offsetY - popperRect.height;
          y *= gpuAcceleration ? 1 : -1;
        }

        if (placement === left$1 || (placement === top$1 || placement === bottom$1) && variation === end) {
          sideX = right$1;
          var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : // $FlowFixMe[prop-missing]
          offsetParent[widthProp];
          x -= offsetX - popperRect.width;
          x *= gpuAcceleration ? 1 : -1;
        }
      }

      var commonStyles = Object.assign({
        position: position
      }, adaptive && unsetSides);

      var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
        x: x,
        y: y
      }) : {
        x: x,
        y: y
      };

      x = _ref4.x;
      y = _ref4.y;

      if (gpuAcceleration) {
        var _Object$assign;

        return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
      }

      return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
    }

    function computeStyles(_ref5) {
      var state = _ref5.state,
          options = _ref5.options;
      var _options$gpuAccelerat = options.gpuAcceleration,
          gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
          _options$adaptive = options.adaptive,
          adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
          _options$roundOffsets = options.roundOffsets,
          roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;

      var commonStyles = {
        placement: getBasePlacement(state.placement),
        variation: getVariation(state.placement),
        popper: state.elements.popper,
        popperRect: state.rects.popper,
        gpuAcceleration: gpuAcceleration,
        isFixed: state.options.strategy === 'fixed'
      };

      if (state.modifiersData.popperOffsets != null) {
        state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
          offsets: state.modifiersData.popperOffsets,
          position: state.options.strategy,
          adaptive: adaptive,
          roundOffsets: roundOffsets
        })));
      }

      if (state.modifiersData.arrow != null) {
        state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
          offsets: state.modifiersData.arrow,
          position: 'absolute',
          adaptive: false,
          roundOffsets: roundOffsets
        })));
      }

      state.attributes.popper = Object.assign({}, state.attributes.popper, {
        'data-popper-placement': state.placement
      });
    } // eslint-disable-next-line import/no-unused-modules


    var computeStyles$1 = {
      name: 'computeStyles',
      enabled: true,
      phase: 'beforeWrite',
      fn: computeStyles,
      data: {}
    };

    // and applies them to the HTMLElements such as popper and arrow

    function applyStyles(_ref) {
      var state = _ref.state;
      Object.keys(state.elements).forEach(function (name) {
        var style = state.styles[name] || {};
        var attributes = state.attributes[name] || {};
        var element = state.elements[name]; // arrow is optional + virtual elements

        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        } // Flow doesn't support to extend this property, but it's the most
        // effective way to apply styles to an HTMLElement
        // $FlowFixMe[cannot-write]


        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function (name) {
          var value = attributes[name];

          if (value === false) {
            element.removeAttribute(name);
          } else {
            element.setAttribute(name, value === true ? '' : value);
          }
        });
      });
    }

    function effect$1(_ref2) {
      var state = _ref2.state;
      var initialStyles = {
        popper: {
          position: state.options.strategy,
          left: '0',
          top: '0',
          margin: '0'
        },
        arrow: {
          position: 'absolute'
        },
        reference: {}
      };
      Object.assign(state.elements.popper.style, initialStyles.popper);
      state.styles = initialStyles;

      if (state.elements.arrow) {
        Object.assign(state.elements.arrow.style, initialStyles.arrow);
      }

      return function () {
        Object.keys(state.elements).forEach(function (name) {
          var element = state.elements[name];
          var attributes = state.attributes[name] || {};
          var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

          var style = styleProperties.reduce(function (style, property) {
            style[property] = '';
            return style;
          }, {}); // arrow is optional + virtual elements

          if (!isHTMLElement(element) || !getNodeName(element)) {
            return;
          }

          Object.assign(element.style, style);
          Object.keys(attributes).forEach(function (attribute) {
            element.removeAttribute(attribute);
          });
        });
      };
    } // eslint-disable-next-line import/no-unused-modules


    var applyStyles$1 = {
      name: 'applyStyles',
      enabled: true,
      phase: 'write',
      fn: applyStyles,
      effect: effect$1,
      requires: ['computeStyles']
    };

    function distanceAndSkiddingToXY(placement, rects, offset) {
      var basePlacement = getBasePlacement(placement);
      var invertDistance = [left$1, top$1].indexOf(basePlacement) >= 0 ? -1 : 1;

      var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
        placement: placement
      })) : offset,
          skidding = _ref[0],
          distance = _ref[1];

      skidding = skidding || 0;
      distance = (distance || 0) * invertDistance;
      return [left$1, right$1].indexOf(basePlacement) >= 0 ? {
        x: distance,
        y: skidding
      } : {
        x: skidding,
        y: distance
      };
    }

    function offset(_ref2) {
      var state = _ref2.state,
          options = _ref2.options,
          name = _ref2.name;
      var _options$offset = options.offset,
          offset = _options$offset === void 0 ? [0, 0] : _options$offset;
      var data = placements.reduce(function (acc, placement) {
        acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
        return acc;
      }, {});
      var _data$state$placement = data[state.placement],
          x = _data$state$placement.x,
          y = _data$state$placement.y;

      if (state.modifiersData.popperOffsets != null) {
        state.modifiersData.popperOffsets.x += x;
        state.modifiersData.popperOffsets.y += y;
      }

      state.modifiersData[name] = data;
    } // eslint-disable-next-line import/no-unused-modules


    var offset$1 = {
      name: 'offset',
      enabled: true,
      phase: 'main',
      requires: ['popperOffsets'],
      fn: offset
    };

    var hash$1 = {
      left: 'right',
      right: 'left',
      bottom: 'top',
      top: 'bottom'
    };
    function getOppositePlacement(placement) {
      return placement.replace(/left|right|bottom|top/g, function (matched) {
        return hash$1[matched];
      });
    }

    var hash = {
      start: 'end',
      end: 'start'
    };
    function getOppositeVariationPlacement(placement) {
      return placement.replace(/start|end/g, function (matched) {
        return hash[matched];
      });
    }

    function computeAutoPlacement(state, options) {
      if (options === void 0) {
        options = {};
      }

      var _options = options,
          placement = _options.placement,
          boundary = _options.boundary,
          rootBoundary = _options.rootBoundary,
          padding = _options.padding,
          flipVariations = _options.flipVariations,
          _options$allowedAutoP = _options.allowedAutoPlacements,
          allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
      var variation = getVariation(placement);
      var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
        return getVariation(placement) === variation;
      }) : basePlacements;
      var allowedPlacements = placements$1.filter(function (placement) {
        return allowedAutoPlacements.indexOf(placement) >= 0;
      });

      if (allowedPlacements.length === 0) {
        allowedPlacements = placements$1;
      } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...


      var overflows = allowedPlacements.reduce(function (acc, placement) {
        acc[placement] = detectOverflow(state, {
          placement: placement,
          boundary: boundary,
          rootBoundary: rootBoundary,
          padding: padding
        })[getBasePlacement(placement)];
        return acc;
      }, {});
      return Object.keys(overflows).sort(function (a, b) {
        return overflows[a] - overflows[b];
      });
    }

    function getExpandedFallbackPlacements(placement) {
      if (getBasePlacement(placement) === auto) {
        return [];
      }

      var oppositePlacement = getOppositePlacement(placement);
      return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
    }

    function flip(_ref) {
      var state = _ref.state,
          options = _ref.options,
          name = _ref.name;

      if (state.modifiersData[name]._skip) {
        return;
      }

      var _options$mainAxis = options.mainAxis,
          checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
          _options$altAxis = options.altAxis,
          checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
          specifiedFallbackPlacements = options.fallbackPlacements,
          padding = options.padding,
          boundary = options.boundary,
          rootBoundary = options.rootBoundary,
          altBoundary = options.altBoundary,
          _options$flipVariatio = options.flipVariations,
          flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
          allowedAutoPlacements = options.allowedAutoPlacements;
      var preferredPlacement = state.options.placement;
      var basePlacement = getBasePlacement(preferredPlacement);
      var isBasePlacement = basePlacement === preferredPlacement;
      var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
      var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
        return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
          placement: placement,
          boundary: boundary,
          rootBoundary: rootBoundary,
          padding: padding,
          flipVariations: flipVariations,
          allowedAutoPlacements: allowedAutoPlacements
        }) : placement);
      }, []);
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var checksMap = new Map();
      var makeFallbackChecks = true;
      var firstFittingPlacement = placements[0];

      for (var i = 0; i < placements.length; i++) {
        var placement = placements[i];

        var _basePlacement = getBasePlacement(placement);

        var isStartVariation = getVariation(placement) === start$1;
        var isVertical = [top$1, bottom$1].indexOf(_basePlacement) >= 0;
        var len = isVertical ? 'width' : 'height';
        var overflow = detectOverflow(state, {
          placement: placement,
          boundary: boundary,
          rootBoundary: rootBoundary,
          altBoundary: altBoundary,
          padding: padding
        });
        var mainVariationSide = isVertical ? isStartVariation ? right$1 : left$1 : isStartVariation ? bottom$1 : top$1;

        if (referenceRect[len] > popperRect[len]) {
          mainVariationSide = getOppositePlacement(mainVariationSide);
        }

        var altVariationSide = getOppositePlacement(mainVariationSide);
        var checks = [];

        if (checkMainAxis) {
          checks.push(overflow[_basePlacement] <= 0);
        }

        if (checkAltAxis) {
          checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
        }

        if (checks.every(function (check) {
          return check;
        })) {
          firstFittingPlacement = placement;
          makeFallbackChecks = false;
          break;
        }

        checksMap.set(placement, checks);
      }

      if (makeFallbackChecks) {
        // `2` may be desired in some cases – research later
        var numberOfChecks = flipVariations ? 3 : 1;

        var _loop = function _loop(_i) {
          var fittingPlacement = placements.find(function (placement) {
            var checks = checksMap.get(placement);

            if (checks) {
              return checks.slice(0, _i).every(function (check) {
                return check;
              });
            }
          });

          if (fittingPlacement) {
            firstFittingPlacement = fittingPlacement;
            return "break";
          }
        };

        for (var _i = numberOfChecks; _i > 0; _i--) {
          var _ret = _loop(_i);

          if (_ret === "break") break;
        }
      }

      if (state.placement !== firstFittingPlacement) {
        state.modifiersData[name]._skip = true;
        state.placement = firstFittingPlacement;
        state.reset = true;
      }
    } // eslint-disable-next-line import/no-unused-modules


    var flip$1 = {
      name: 'flip',
      enabled: true,
      phase: 'main',
      fn: flip,
      requiresIfExists: ['offset'],
      data: {
        _skip: false
      }
    };

    function getAltAxis(axis) {
      return axis === 'x' ? 'y' : 'x';
    }

    function within$1(min, value, max) {
      return max$3(min, min$2(value, max));
    }
    function withinMaxClamp(min, value, max) {
      var v = within$1(min, value, max);
      return v > max ? max : v;
    }

    function preventOverflow(_ref) {
      var state = _ref.state,
          options = _ref.options,
          name = _ref.name;
      var _options$mainAxis = options.mainAxis,
          checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
          _options$altAxis = options.altAxis,
          checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
          boundary = options.boundary,
          rootBoundary = options.rootBoundary,
          altBoundary = options.altBoundary,
          padding = options.padding,
          _options$tether = options.tether,
          tether = _options$tether === void 0 ? true : _options$tether,
          _options$tetherOffset = options.tetherOffset,
          tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
      var overflow = detectOverflow(state, {
        boundary: boundary,
        rootBoundary: rootBoundary,
        padding: padding,
        altBoundary: altBoundary
      });
      var basePlacement = getBasePlacement(state.placement);
      var variation = getVariation(state.placement);
      var isBasePlacement = !variation;
      var mainAxis = getMainAxisFromPlacement(basePlacement);
      var altAxis = getAltAxis(mainAxis);
      var popperOffsets = state.modifiersData.popperOffsets;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
        placement: state.placement
      })) : tetherOffset;
      var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {
        mainAxis: tetherOffsetValue,
        altAxis: tetherOffsetValue
      } : Object.assign({
        mainAxis: 0,
        altAxis: 0
      }, tetherOffsetValue);
      var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
      var data = {
        x: 0,
        y: 0
      };

      if (!popperOffsets) {
        return;
      }

      if (checkMainAxis) {
        var _offsetModifierState$;

        var mainSide = mainAxis === 'y' ? top$1 : left$1;
        var altSide = mainAxis === 'y' ? bottom$1 : right$1;
        var len = mainAxis === 'y' ? 'height' : 'width';
        var offset = popperOffsets[mainAxis];
        var min = offset + overflow[mainSide];
        var max = offset - overflow[altSide];
        var additive = tether ? -popperRect[len] / 2 : 0;
        var minLen = variation === start$1 ? referenceRect[len] : popperRect[len];
        var maxLen = variation === start$1 ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
        // outside the reference bounds

        var arrowElement = state.elements.arrow;
        var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
          width: 0,
          height: 0
        };
        var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
        var arrowPaddingMin = arrowPaddingObject[mainSide];
        var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
        // to include its full size in the calculation. If the reference is small
        // and near the edge of a boundary, the popper can overflow even if the
        // reference is not overflowing as well (e.g. virtual elements with no
        // width or height)

        var arrowLen = within$1(0, referenceRect[len], arrowRect[len]);
        var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
        var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
        var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
        var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
        var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
        var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
        var tetherMax = offset + maxOffset - offsetModifierValue;
        var preventedOffset = within$1(tether ? min$2(min, tetherMin) : min, offset, tether ? max$3(max, tetherMax) : max);
        popperOffsets[mainAxis] = preventedOffset;
        data[mainAxis] = preventedOffset - offset;
      }

      if (checkAltAxis) {
        var _offsetModifierState$2;

        var _mainSide = mainAxis === 'x' ? top$1 : left$1;

        var _altSide = mainAxis === 'x' ? bottom$1 : right$1;

        var _offset = popperOffsets[altAxis];

        var _len = altAxis === 'y' ? 'height' : 'width';

        var _min = _offset + overflow[_mainSide];

        var _max = _offset - overflow[_altSide];

        var isOriginSide = [top$1, left$1].indexOf(basePlacement) !== -1;

        var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;

        var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;

        var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;

        var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within$1(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);

        popperOffsets[altAxis] = _preventedOffset;
        data[altAxis] = _preventedOffset - _offset;
      }

      state.modifiersData[name] = data;
    } // eslint-disable-next-line import/no-unused-modules


    var preventOverflow$1 = {
      name: 'preventOverflow',
      enabled: true,
      phase: 'main',
      fn: preventOverflow,
      requiresIfExists: ['offset']
    };

    var toPaddingObject = function toPaddingObject(padding, state) {
      padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
        placement: state.placement
      })) : padding;
      return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
    };

    function arrow(_ref) {
      var _state$modifiersData$;

      var state = _ref.state,
          name = _ref.name,
          options = _ref.options;
      var arrowElement = state.elements.arrow;
      var popperOffsets = state.modifiersData.popperOffsets;
      var basePlacement = getBasePlacement(state.placement);
      var axis = getMainAxisFromPlacement(basePlacement);
      var isVertical = [left$1, right$1].indexOf(basePlacement) >= 0;
      var len = isVertical ? 'height' : 'width';

      if (!arrowElement || !popperOffsets) {
        return;
      }

      var paddingObject = toPaddingObject(options.padding, state);
      var arrowRect = getLayoutRect(arrowElement);
      var minProp = axis === 'y' ? top$1 : left$1;
      var maxProp = axis === 'y' ? bottom$1 : right$1;
      var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
      var startDiff = popperOffsets[axis] - state.rects.reference[axis];
      var arrowOffsetParent = getOffsetParent(arrowElement);
      var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
      var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
      // outside of the popper bounds

      var min = paddingObject[minProp];
      var max = clientSize - arrowRect[len] - paddingObject[maxProp];
      var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
      var offset = within$1(min, center, max); // Prevents breaking syntax highlighting...

      var axisProp = axis;
      state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
    }

    function effect(_ref2) {
      var state = _ref2.state,
          options = _ref2.options;
      var _options$element = options.element,
          arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;

      if (arrowElement == null) {
        return;
      } // CSS selector


      if (typeof arrowElement === 'string') {
        arrowElement = state.elements.popper.querySelector(arrowElement);

        if (!arrowElement) {
          return;
        }
      }

      if (!contains$3(state.elements.popper, arrowElement)) {

        return;
      }

      state.elements.arrow = arrowElement;
    } // eslint-disable-next-line import/no-unused-modules


    var arrow$1 = {
      name: 'arrow',
      enabled: true,
      phase: 'main',
      fn: arrow,
      effect: effect,
      requires: ['popperOffsets'],
      requiresIfExists: ['preventOverflow']
    };

    function getSideOffsets(overflow, rect, preventedOffsets) {
      if (preventedOffsets === void 0) {
        preventedOffsets = {
          x: 0,
          y: 0
        };
      }

      return {
        top: overflow.top - rect.height - preventedOffsets.y,
        right: overflow.right - rect.width + preventedOffsets.x,
        bottom: overflow.bottom - rect.height + preventedOffsets.y,
        left: overflow.left - rect.width - preventedOffsets.x
      };
    }

    function isAnySideFullyClipped(overflow) {
      return [top$1, right$1, bottom$1, left$1].some(function (side) {
        return overflow[side] >= 0;
      });
    }

    function hide(_ref) {
      var state = _ref.state,
          name = _ref.name;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var preventedOffsets = state.modifiersData.preventOverflow;
      var referenceOverflow = detectOverflow(state, {
        elementContext: 'reference'
      });
      var popperAltOverflow = detectOverflow(state, {
        altBoundary: true
      });
      var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
      var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
      var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
      var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
      state.modifiersData[name] = {
        referenceClippingOffsets: referenceClippingOffsets,
        popperEscapeOffsets: popperEscapeOffsets,
        isReferenceHidden: isReferenceHidden,
        hasPopperEscaped: hasPopperEscaped
      };
      state.attributes.popper = Object.assign({}, state.attributes.popper, {
        'data-popper-reference-hidden': isReferenceHidden,
        'data-popper-escaped': hasPopperEscaped
      });
    } // eslint-disable-next-line import/no-unused-modules


    var hide$1 = {
      name: 'hide',
      enabled: true,
      phase: 'main',
      requiresIfExists: ['preventOverflow'],
      fn: hide
    };

    var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
    var createPopper = /*#__PURE__*/popperGenerator({
      defaultModifiers: defaultModifiers
    }); // eslint-disable-next-line import/no-unused-modules

    // Code derived from https://github.com/bryanmylee/svelte-popperjs/blob/master/src/index.ts
    function createPopperActions(initOptions) {
      let contentNode;
      let options = initOptions;
      let popperInstance = null;
      let referenceNode;

      const initPopper = () => {
        if (referenceNode && contentNode) {
          popperInstance = createPopper(referenceNode, contentNode, options);
        }
      };

      const deinitPopper = () => {
        if (popperInstance) {
          popperInstance.destroy();
          popperInstance = null;
        }
      };

      const referenceAction = (node) => {
        referenceNode = node;
        initPopper();
        return {
          destroy() {
            deinitPopper();
          }
        };
      };

      const contentAction = (node, contentOptions) => {
        contentNode = node;
        options = Object.assign(Object.assign({}, initOptions), contentOptions);
        initPopper();

        return {
          update(newContentOptions) {
            options = Object.assign(
              Object.assign({}, initOptions),
              newContentOptions
            );
            if (popperInstance && options) {
              popperInstance.setOptions(options);
            }
          },
          destroy() {
            deinitPopper();
          }
        };
      };

      return [referenceAction, contentAction, () => popperInstance];
    }

    const createContext = () => writable({});

    /* node_modules\sveltestrap\src\Dropdown.svelte generated by Svelte v3.47.0 */

    const { Error: Error_1 } = globals;
    const file$L = "node_modules\\sveltestrap\\src\\Dropdown.svelte";

    // (123:0) {:else}
    function create_else_block$5(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[18].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[17], null);
    	let div_levels = [/*$$restProps*/ ctx[3], { class: /*classes*/ ctx[2] }];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element$1("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$L, 123, 2, 3332);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			/*div_binding*/ ctx[20](div);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 131072)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[17],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[17])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[17], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3],
    				(!current || dirty & /*classes*/ 4) && { class: /*classes*/ ctx[2] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			/*div_binding*/ ctx[20](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$5.name,
    		type: "else",
    		source: "(123:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (119:0) {#if nav}
    function create_if_block$e(ctx) {
    	let li;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[18].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[17], null);
    	let li_levels = [/*$$restProps*/ ctx[3], { class: /*classes*/ ctx[2] }];
    	let li_data = {};

    	for (let i = 0; i < li_levels.length; i += 1) {
    		li_data = assign(li_data, li_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			li = element$1("li");
    			if (default_slot) default_slot.c();
    			set_attributes(li, li_data);
    			add_location(li, file$L, 119, 2, 3237);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);

    			if (default_slot) {
    				default_slot.m(li, null);
    			}

    			/*li_binding*/ ctx[19](li);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 131072)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[17],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[17])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[17], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(li, li_data = get_spread_update(li_levels, [
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3],
    				(!current || dirty & /*classes*/ 4) && { class: /*classes*/ ctx[2] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			if (default_slot) default_slot.d(detaching);
    			/*li_binding*/ ctx[19](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$e.name,
    		type: "if",
    		source: "(119:0) {#if nav}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$L(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$e, create_else_block$5];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*nav*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$2();
    		},
    		l: function claim(nodes) {
    			throw new Error_1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$L.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$L($$self, $$props, $$invalidate) {
    	let subItemIsActive;
    	let classes;
    	let handleToggle;

    	const omit_props_names = [
    		"class","active","direction","dropup","group","inNavbar","isOpen","nav","setActiveFromChild","size","toggle"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Dropdown', slots, ['default']);
    	const noop = () => undefined;
    	let context = createContext();
    	setContext('dropdownContext', context);
    	const navbarContext = getContext('navbar');
    	let { class: className = '' } = $$props;
    	let { active = false } = $$props;
    	let { direction = 'down' } = $$props;
    	let { dropup = false } = $$props;
    	let { group = false } = $$props;
    	let { inNavbar = navbarContext ? navbarContext.inNavbar : false } = $$props;
    	let { isOpen = false } = $$props;
    	let { nav = false } = $$props;
    	let { setActiveFromChild = false } = $$props;
    	let { size = '' } = $$props;
    	let { toggle = undefined } = $$props;
    	const [popperRef, popperContent] = createPopperActions();
    	const validDirections = ['up', 'down', 'left', 'right', 'start', 'end'];

    	if (validDirections.indexOf(direction) === -1) {
    		throw new Error(`Invalid direction sent: '${direction}' is not one of 'up', 'down', 'left', 'right', 'start', 'end'`);
    	}

    	let component;
    	let dropdownDirection;

    	function handleDocumentClick(e) {
    		if (e && (e.which === 3 || e.type === 'keyup' && e.which !== 9)) return;

    		if (component.contains(e.target) && component !== e.target && (e.type !== 'keyup' || e.which === 9)) {
    			return;
    		}

    		handleToggle(e);
    	}

    	onDestroy(() => {
    		if (typeof document !== 'undefined') {
    			['click', 'touchstart', 'keyup'].forEach(event => document.removeEventListener(event, handleDocumentClick, true));
    		}
    	});

    	function li_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			component = $$value;
    			$$invalidate(1, component);
    		});
    	}

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			component = $$value;
    			$$invalidate(1, component);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(5, className = $$new_props.class);
    		if ('active' in $$new_props) $$invalidate(6, active = $$new_props.active);
    		if ('direction' in $$new_props) $$invalidate(7, direction = $$new_props.direction);
    		if ('dropup' in $$new_props) $$invalidate(8, dropup = $$new_props.dropup);
    		if ('group' in $$new_props) $$invalidate(9, group = $$new_props.group);
    		if ('inNavbar' in $$new_props) $$invalidate(10, inNavbar = $$new_props.inNavbar);
    		if ('isOpen' in $$new_props) $$invalidate(4, isOpen = $$new_props.isOpen);
    		if ('nav' in $$new_props) $$invalidate(0, nav = $$new_props.nav);
    		if ('setActiveFromChild' in $$new_props) $$invalidate(11, setActiveFromChild = $$new_props.setActiveFromChild);
    		if ('size' in $$new_props) $$invalidate(12, size = $$new_props.size);
    		if ('toggle' in $$new_props) $$invalidate(13, toggle = $$new_props.toggle);
    		if ('$$scope' in $$new_props) $$invalidate(17, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		setContext,
    		onDestroy,
    		createPopperActions,
    		classnames,
    		createContext,
    		noop,
    		context,
    		navbarContext,
    		className,
    		active,
    		direction,
    		dropup,
    		group,
    		inNavbar,
    		isOpen,
    		nav,
    		setActiveFromChild,
    		size,
    		toggle,
    		popperRef,
    		popperContent,
    		validDirections,
    		component,
    		dropdownDirection,
    		handleDocumentClick,
    		handleToggle,
    		subItemIsActive,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('context' in $$props) $$invalidate(22, context = $$new_props.context);
    		if ('className' in $$props) $$invalidate(5, className = $$new_props.className);
    		if ('active' in $$props) $$invalidate(6, active = $$new_props.active);
    		if ('direction' in $$props) $$invalidate(7, direction = $$new_props.direction);
    		if ('dropup' in $$props) $$invalidate(8, dropup = $$new_props.dropup);
    		if ('group' in $$props) $$invalidate(9, group = $$new_props.group);
    		if ('inNavbar' in $$props) $$invalidate(10, inNavbar = $$new_props.inNavbar);
    		if ('isOpen' in $$props) $$invalidate(4, isOpen = $$new_props.isOpen);
    		if ('nav' in $$props) $$invalidate(0, nav = $$new_props.nav);
    		if ('setActiveFromChild' in $$props) $$invalidate(11, setActiveFromChild = $$new_props.setActiveFromChild);
    		if ('size' in $$props) $$invalidate(12, size = $$new_props.size);
    		if ('toggle' in $$props) $$invalidate(13, toggle = $$new_props.toggle);
    		if ('component' in $$props) $$invalidate(1, component = $$new_props.component);
    		if ('dropdownDirection' in $$props) $$invalidate(14, dropdownDirection = $$new_props.dropdownDirection);
    		if ('handleToggle' in $$props) $$invalidate(15, handleToggle = $$new_props.handleToggle);
    		if ('subItemIsActive' in $$props) $$invalidate(16, subItemIsActive = $$new_props.subItemIsActive);
    		if ('classes' in $$props) $$invalidate(2, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*setActiveFromChild, component*/ 2050) {
    			$$invalidate(16, subItemIsActive = !!(setActiveFromChild && component && typeof component.querySelector === 'function' && component.querySelector('.active')));
    		}

    		if ($$self.$$.dirty & /*direction*/ 128) {
    			{
    				if (direction === 'left') $$invalidate(14, dropdownDirection = 'start'); else if (direction === 'right') $$invalidate(14, dropdownDirection = 'end'); else $$invalidate(14, dropdownDirection = direction);
    			}
    		}

    		if ($$self.$$.dirty & /*toggle, isOpen*/ 8208) {
    			$$invalidate(15, handleToggle = toggle || (() => $$invalidate(4, isOpen = !isOpen)));
    		}

    		if ($$self.$$.dirty & /*className, direction, dropdownDirection, nav, active, setActiveFromChild, subItemIsActive, group, size, isOpen*/ 88817) {
    			$$invalidate(2, classes = classnames(className, direction !== 'down' && `drop${dropdownDirection}`, nav && active ? 'active' : false, setActiveFromChild && subItemIsActive ? 'active' : false, {
    				'btn-group': group,
    				[`btn-group-${size}`]: !!size,
    				dropdown: !group,
    				show: isOpen,
    				'nav-item': nav
    			}));
    		}

    		if ($$self.$$.dirty & /*isOpen*/ 16) {
    			{
    				if (typeof document !== 'undefined') {
    					if (isOpen) {
    						['click', 'touchstart', 'keyup'].forEach(event => document.addEventListener(event, handleDocumentClick, true));
    					} else {
    						['click', 'touchstart', 'keyup'].forEach(event => document.removeEventListener(event, handleDocumentClick, true));
    					}
    				}
    			}
    		}

    		if ($$self.$$.dirty & /*handleToggle, isOpen, direction, dropup, nav, inNavbar*/ 34193) {
    			{
    				context.update(() => {
    					return {
    						toggle: handleToggle,
    						isOpen,
    						direction: direction === 'down' && dropup ? 'up' : direction,
    						inNavbar: nav || inNavbar,
    						popperRef: nav ? noop : popperRef,
    						popperContent: nav ? noop : popperContent
    					};
    				});
    			}
    		}
    	};

    	return [
    		nav,
    		component,
    		classes,
    		$$restProps,
    		isOpen,
    		className,
    		active,
    		direction,
    		dropup,
    		group,
    		inNavbar,
    		setActiveFromChild,
    		size,
    		toggle,
    		dropdownDirection,
    		handleToggle,
    		subItemIsActive,
    		$$scope,
    		slots,
    		li_binding,
    		div_binding
    	];
    }

    class Dropdown extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$L, create_fragment$L, safe_not_equal, {
    			class: 5,
    			active: 6,
    			direction: 7,
    			dropup: 8,
    			group: 9,
    			inNavbar: 10,
    			isOpen: 4,
    			nav: 0,
    			setActiveFromChild: 11,
    			size: 12,
    			toggle: 13
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Dropdown",
    			options,
    			id: create_fragment$L.name
    		});
    	}

    	get class() {
    		throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get active() {
    		throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get direction() {
    		throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set direction(value) {
    		throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dropup() {
    		throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dropup(value) {
    		throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get group() {
    		throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set group(value) {
    		throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inNavbar() {
    		throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inNavbar(value) {
    		throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isOpen() {
    		throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isOpen(value) {
    		throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get nav() {
    		throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set nav(value) {
    		throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setActiveFromChild() {
    		throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set setActiveFromChild(value) {
    		throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get toggle() {
    		throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set toggle(value) {
    		throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\sveltestrap\src\Container.svelte generated by Svelte v3.47.0 */
    const file$K = "node_modules\\sveltestrap\\src\\Container.svelte";

    function create_fragment$K(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[10].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);
    	let div_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element$1("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$K, 23, 0, 565);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 512)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[9],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[9], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
    				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$K.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$K($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class","sm","md","lg","xl","xxl","fluid"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Container', slots, ['default']);
    	let { class: className = '' } = $$props;
    	let { sm = undefined } = $$props;
    	let { md = undefined } = $$props;
    	let { lg = undefined } = $$props;
    	let { xl = undefined } = $$props;
    	let { xxl = undefined } = $$props;
    	let { fluid = false } = $$props;

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ('sm' in $$new_props) $$invalidate(3, sm = $$new_props.sm);
    		if ('md' in $$new_props) $$invalidate(4, md = $$new_props.md);
    		if ('lg' in $$new_props) $$invalidate(5, lg = $$new_props.lg);
    		if ('xl' in $$new_props) $$invalidate(6, xl = $$new_props.xl);
    		if ('xxl' in $$new_props) $$invalidate(7, xxl = $$new_props.xxl);
    		if ('fluid' in $$new_props) $$invalidate(8, fluid = $$new_props.fluid);
    		if ('$$scope' in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		classnames,
    		className,
    		sm,
    		md,
    		lg,
    		xl,
    		xxl,
    		fluid,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('className' in $$props) $$invalidate(2, className = $$new_props.className);
    		if ('sm' in $$props) $$invalidate(3, sm = $$new_props.sm);
    		if ('md' in $$props) $$invalidate(4, md = $$new_props.md);
    		if ('lg' in $$props) $$invalidate(5, lg = $$new_props.lg);
    		if ('xl' in $$props) $$invalidate(6, xl = $$new_props.xl);
    		if ('xxl' in $$props) $$invalidate(7, xxl = $$new_props.xxl);
    		if ('fluid' in $$props) $$invalidate(8, fluid = $$new_props.fluid);
    		if ('classes' in $$props) $$invalidate(0, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, sm, md, lg, xl, xxl, fluid*/ 508) {
    			$$invalidate(0, classes = classnames(className, {
    				'container-sm': sm,
    				'container-md': md,
    				'container-lg': lg,
    				'container-xl': xl,
    				'container-xxl': xxl,
    				'container-fluid': fluid,
    				container: !sm && !md && !lg && !xl && !xxl && !fluid
    			}));
    		}
    	};

    	return [classes, $$restProps, className, sm, md, lg, xl, xxl, fluid, $$scope, slots];
    }

    class Container extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$K, create_fragment$K, safe_not_equal, {
    			class: 2,
    			sm: 3,
    			md: 4,
    			lg: 5,
    			xl: 6,
    			xxl: 7,
    			fluid: 8
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Container",
    			options,
    			id: create_fragment$K.name
    		});
    	}

    	get class() {
    		throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sm() {
    		throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sm(value) {
    		throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get md() {
    		throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set md(value) {
    		throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get lg() {
    		throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set lg(value) {
    		throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get xl() {
    		throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set xl(value) {
    		throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get xxl() {
    		throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set xxl(value) {
    		throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fluid() {
    		throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fluid(value) {
    		throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\sveltestrap\src\DropdownItem.svelte generated by Svelte v3.47.0 */
    const file$J = "node_modules\\sveltestrap\\src\\DropdownItem.svelte";

    // (49:0) {:else}
    function create_else_block$4(ctx) {
    	let button;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[12].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);
    	let button_levels = [{ type: "button" }, /*$$restProps*/ ctx[6], { class: /*classes*/ ctx[3] }];
    	let button_data = {};

    	for (let i = 0; i < button_levels.length; i += 1) {
    		button_data = assign(button_data, button_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			button = element$1("button");
    			if (default_slot) default_slot.c();
    			set_attributes(button, button_data);
    			add_location(button, file$J, 49, 2, 1135);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (default_slot) {
    				default_slot.m(button, null);
    			}

    			if (button.autofocus) button.focus();
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button, "click", /*click_handler_2*/ ctx[15], false, false, false),
    					listen_dev(button, "click", /*handleItemClick*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[11],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[11])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(button, button_data = get_spread_update(button_levels, [
    				{ type: "button" },
    				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
    				(!current || dirty & /*classes*/ 8) && { class: /*classes*/ ctx[3] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$4.name,
    		type: "else",
    		source: "(49:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (45:15) 
    function create_if_block_2$1(ctx) {
    	let a;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[12].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

    	let a_levels = [
    		/*$$restProps*/ ctx[6],
    		{ click: "" },
    		{ href: /*href*/ ctx[2] },
    		{ class: /*classes*/ ctx[3] }
    	];

    	let a_data = {};

    	for (let i = 0; i < a_levels.length; i += 1) {
    		a_data = assign(a_data, a_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			a = element$1("a");
    			if (default_slot) default_slot.c();
    			set_attributes(a, a_data);
    			add_location(a, file$J, 45, 2, 1024);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (default_slot) {
    				default_slot.m(a, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(a, "click", /*handleItemClick*/ ctx[5], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[11],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[11])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(a, a_data = get_spread_update(a_levels, [
    				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
    				{ click: "" },
    				(!current || dirty & /*href*/ 4) && { href: /*href*/ ctx[2] },
    				(!current || dirty & /*classes*/ 8) && { class: /*classes*/ ctx[3] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(45:15) ",
    		ctx
    	});

    	return block;
    }

    // (41:18) 
    function create_if_block_1$3(ctx) {
    	let div;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[12].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);
    	let div_levels = [/*$$restProps*/ ctx[6], { class: /*classes*/ ctx[3] }];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element$1("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$J, 41, 2, 905);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div, "click", /*click_handler_1*/ ctx[14], false, false, false),
    					listen_dev(div, "click", /*handleItemClick*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[11],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[11])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
    				(!current || dirty & /*classes*/ 8) && { class: /*classes*/ ctx[3] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(41:18) ",
    		ctx
    	});

    	return block;
    }

    // (37:0) {#if header}
    function create_if_block$d(ctx) {
    	let h6;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[12].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);
    	let h6_levels = [/*$$restProps*/ ctx[6], { class: /*classes*/ ctx[3] }];
    	let h6_data = {};

    	for (let i = 0; i < h6_levels.length; i += 1) {
    		h6_data = assign(h6_data, h6_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			h6 = element$1("h6");
    			if (default_slot) default_slot.c();
    			set_attributes(h6, h6_data);
    			add_location(h6, file$J, 37, 2, 785);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);

    			if (default_slot) {
    				default_slot.m(h6, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(h6, "click", /*click_handler*/ ctx[13], false, false, false),
    					listen_dev(h6, "click", /*handleItemClick*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[11],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[11])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(h6, h6_data = get_spread_update(h6_levels, [
    				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
    				(!current || dirty & /*classes*/ 8) && { class: /*classes*/ ctx[3] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$d.name,
    		type: "if",
    		source: "(37:0) {#if header}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$J(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$d, create_if_block_1$3, create_if_block_2$1, create_else_block$4];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*header*/ ctx[1]) return 0;
    		if (/*divider*/ ctx[0]) return 1;
    		if (/*href*/ ctx[2]) return 2;
    		return 3;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$2();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$J.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$J($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class","active","disabled","divider","header","toggle","href"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let $context;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('DropdownItem', slots, ['default']);
    	const context = getContext('dropdownContext');
    	validate_store(context, 'context');
    	component_subscribe($$self, context, value => $$invalidate(16, $context = value));
    	let { class: className = '' } = $$props;
    	let { active = false } = $$props;
    	let { disabled = false } = $$props;
    	let { divider = false } = $$props;
    	let { header = false } = $$props;
    	let { toggle = true } = $$props;
    	let { href = '' } = $$props;

    	function handleItemClick(e) {
    		if (disabled || header || divider) {
    			e.preventDefault();
    			return;
    		}

    		if (toggle) {
    			$context.toggle(e);
    		}
    	}

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function click_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function click_handler_2(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(7, className = $$new_props.class);
    		if ('active' in $$new_props) $$invalidate(8, active = $$new_props.active);
    		if ('disabled' in $$new_props) $$invalidate(9, disabled = $$new_props.disabled);
    		if ('divider' in $$new_props) $$invalidate(0, divider = $$new_props.divider);
    		if ('header' in $$new_props) $$invalidate(1, header = $$new_props.header);
    		if ('toggle' in $$new_props) $$invalidate(10, toggle = $$new_props.toggle);
    		if ('href' in $$new_props) $$invalidate(2, href = $$new_props.href);
    		if ('$$scope' in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		classnames,
    		context,
    		className,
    		active,
    		disabled,
    		divider,
    		header,
    		toggle,
    		href,
    		handleItemClick,
    		classes,
    		$context
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('className' in $$props) $$invalidate(7, className = $$new_props.className);
    		if ('active' in $$props) $$invalidate(8, active = $$new_props.active);
    		if ('disabled' in $$props) $$invalidate(9, disabled = $$new_props.disabled);
    		if ('divider' in $$props) $$invalidate(0, divider = $$new_props.divider);
    		if ('header' in $$props) $$invalidate(1, header = $$new_props.header);
    		if ('toggle' in $$props) $$invalidate(10, toggle = $$new_props.toggle);
    		if ('href' in $$props) $$invalidate(2, href = $$new_props.href);
    		if ('classes' in $$props) $$invalidate(3, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, disabled, divider, header, active*/ 899) {
    			$$invalidate(3, classes = classnames(className, {
    				disabled,
    				'dropdown-item': !divider && !header,
    				active,
    				'dropdown-header': header,
    				'dropdown-divider': divider
    			}));
    		}
    	};

    	return [
    		divider,
    		header,
    		href,
    		classes,
    		context,
    		handleItemClick,
    		$$restProps,
    		className,
    		active,
    		disabled,
    		toggle,
    		$$scope,
    		slots,
    		click_handler,
    		click_handler_1,
    		click_handler_2
    	];
    }

    class DropdownItem extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$J, create_fragment$J, safe_not_equal, {
    			class: 7,
    			active: 8,
    			disabled: 9,
    			divider: 0,
    			header: 1,
    			toggle: 10,
    			href: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DropdownItem",
    			options,
    			id: create_fragment$J.name
    		});
    	}

    	get class() {
    		throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get active() {
    		throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get divider() {
    		throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set divider(value) {
    		throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get header() {
    		throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set header(value) {
    		throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get toggle() {
    		throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set toggle(value) {
    		throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get href() {
    		throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\sveltestrap\src\DropdownMenu.svelte generated by Svelte v3.47.0 */
    const file$I = "node_modules\\sveltestrap\\src\\DropdownMenu.svelte";

    function create_fragment$I(ctx) {
    	let div;
    	let div_data_bs_popper_value;
    	let $context_popperContent_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[10].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

    	let div_levels = [
    		/*$$restProps*/ ctx[4],
    		{ class: /*classes*/ ctx[1] },
    		{
    			"data-bs-popper": div_data_bs_popper_value = /*$context*/ ctx[0].inNavbar ? 'static' : undefined
    		}
    	];

    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element$1("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$I, 41, 0, 974);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = action_destroyer($context_popperContent_action = /*$context*/ ctx[0].popperContent(div, /*popperOptions*/ ctx[2]));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 512)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[9],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[9], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				dirty & /*$$restProps*/ 16 && /*$$restProps*/ ctx[4],
    				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
    				(!current || dirty & /*$context*/ 1 && div_data_bs_popper_value !== (div_data_bs_popper_value = /*$context*/ ctx[0].inNavbar ? 'static' : undefined)) && {
    					"data-bs-popper": div_data_bs_popper_value
    				}
    			]));

    			if ($context_popperContent_action && is_function($context_popperContent_action.update) && dirty & /*popperOptions*/ 4) $context_popperContent_action.update.call(null, /*popperOptions*/ ctx[2]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$I.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$I($$self, $$props, $$invalidate) {
    	let popperOptions;
    	let classes;
    	const omit_props_names = ["class","dark","end","right"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let $context;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('DropdownMenu', slots, ['default']);
    	const context = getContext('dropdownContext');
    	validate_store(context, 'context');
    	component_subscribe($$self, context, value => $$invalidate(0, $context = value));
    	let { class: className = '' } = $$props;
    	let { dark = false } = $$props;
    	let { end = false } = $$props;
    	let { right = false } = $$props;

    	const popperPlacement = (direction, end) => {
    		let prefix = direction;
    		if (direction === 'up') prefix = 'top'; else if (direction === 'down') prefix = 'bottom';
    		let suffix = end ? 'end' : 'start';
    		return `${prefix}-${suffix}`;
    	};

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(5, className = $$new_props.class);
    		if ('dark' in $$new_props) $$invalidate(6, dark = $$new_props.dark);
    		if ('end' in $$new_props) $$invalidate(7, end = $$new_props.end);
    		if ('right' in $$new_props) $$invalidate(8, right = $$new_props.right);
    		if ('$$scope' in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		classnames,
    		context,
    		className,
    		dark,
    		end,
    		right,
    		popperPlacement,
    		classes,
    		popperOptions,
    		$context
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('className' in $$props) $$invalidate(5, className = $$new_props.className);
    		if ('dark' in $$props) $$invalidate(6, dark = $$new_props.dark);
    		if ('end' in $$props) $$invalidate(7, end = $$new_props.end);
    		if ('right' in $$props) $$invalidate(8, right = $$new_props.right);
    		if ('classes' in $$props) $$invalidate(1, classes = $$new_props.classes);
    		if ('popperOptions' in $$props) $$invalidate(2, popperOptions = $$new_props.popperOptions);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$context, end, right*/ 385) {
    			$$invalidate(2, popperOptions = {
    				modifiers: [
    					{ name: 'flip' },
    					{
    						name: 'offset',
    						options: { offset: [0, 2] }
    					}
    				],
    				placement: popperPlacement($context.direction, end || right)
    			});
    		}

    		if ($$self.$$.dirty & /*className, dark, end, right, $context*/ 481) {
    			$$invalidate(1, classes = classnames(className, 'dropdown-menu', {
    				'dropdown-menu-dark': dark,
    				'dropdown-menu-end': end || right,
    				show: $context.isOpen
    			}));
    		}
    	};

    	return [
    		$context,
    		classes,
    		popperOptions,
    		context,
    		$$restProps,
    		className,
    		dark,
    		end,
    		right,
    		$$scope,
    		slots
    	];
    }

    class DropdownMenu extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$I, create_fragment$I, safe_not_equal, { class: 5, dark: 6, end: 7, right: 8 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DropdownMenu",
    			options,
    			id: create_fragment$I.name
    		});
    	}

    	get class() {
    		throw new Error("<DropdownMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<DropdownMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dark() {
    		throw new Error("<DropdownMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dark(value) {
    		throw new Error("<DropdownMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get end() {
    		throw new Error("<DropdownMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set end(value) {
    		throw new Error("<DropdownMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get right() {
    		throw new Error("<DropdownMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set right(value) {
    		throw new Error("<DropdownMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\sveltestrap\src\DropdownToggle.svelte generated by Svelte v3.47.0 */
    const file$H = "node_modules\\sveltestrap\\src\\DropdownToggle.svelte";

    // (94:0) {:else}
    function create_else_block$3(ctx) {
    	let button;
    	let button_aria_expanded_value;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[20].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[19], null);
    	const default_slot_or_fallback = default_slot || fallback_block_3(ctx);

    	let button_levels = [
    		/*$$restProps*/ ctx[9],
    		{ type: "button" },
    		{
    			"aria-expanded": button_aria_expanded_value = /*$context*/ ctx[6].isOpen
    		},
    		{ class: /*btnClasses*/ ctx[5] }
    	];

    	let button_data = {};

    	for (let i = 0; i < button_levels.length; i += 1) {
    		button_data = assign(button_data, button_levels[i]);
    	}

    	const block_1 = {
    		c: function create() {
    			button = element$1("button");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			set_attributes(button, button_data);
    			add_location(button, file$H, 94, 2, 2042);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(button, null);
    			}

    			if (button.autofocus) button.focus();
    			/*button_binding*/ ctx[28](button);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(/*$context*/ ctx[6].popperRef(button)),
    					listen_dev(button, "click", /*click_handler_3*/ ctx[24], false, false, false),
    					listen_dev(button, "click", /*toggleButton*/ ctx[8], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 524288)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[19],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[19])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[19], dirty, null),
    						null
    					);
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*ariaLabel*/ 2)) {
    					default_slot_or_fallback.p(ctx, !current ? -1 : dirty);
    				}
    			}

    			set_attributes(button, button_data = get_spread_update(button_levels, [
    				dirty & /*$$restProps*/ 512 && /*$$restProps*/ ctx[9],
    				{ type: "button" },
    				(!current || dirty & /*$context*/ 64 && button_aria_expanded_value !== (button_aria_expanded_value = /*$context*/ ctx[6].isOpen)) && {
    					"aria-expanded": button_aria_expanded_value
    				},
    				(!current || dirty & /*btnClasses*/ 32) && { class: /*btnClasses*/ ctx[5] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			/*button_binding*/ ctx[28](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_else_block$3.name,
    		type: "else",
    		source: "(94:0) {:else}",
    		ctx
    	});

    	return block_1;
    }

    // (80:25) 
    function create_if_block_2(ctx) {
    	let span;
    	let span_aria_expanded_value;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[20].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[19], null);
    	const default_slot_or_fallback = default_slot || fallback_block_2(ctx);

    	let span_levels = [
    		/*$$restProps*/ ctx[9],
    		{
    			"aria-expanded": span_aria_expanded_value = /*$context*/ ctx[6].isOpen
    		},
    		{ class: /*classes*/ ctx[4] }
    	];

    	let span_data = {};

    	for (let i = 0; i < span_levels.length; i += 1) {
    		span_data = assign(span_data, span_levels[i]);
    	}

    	const block_1 = {
    		c: function create() {
    			span = element$1("span");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			set_attributes(span, span_data);
    			add_location(span, file$H, 80, 2, 1753);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(span, null);
    			}

    			/*span_binding*/ ctx[27](span);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(/*$context*/ ctx[6].popperRef(span)),
    					listen_dev(span, "click", /*click_handler_2*/ ctx[23], false, false, false),
    					listen_dev(span, "click", /*toggleButton*/ ctx[8], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 524288)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[19],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[19])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[19], dirty, null),
    						null
    					);
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*ariaLabel*/ 2)) {
    					default_slot_or_fallback.p(ctx, !current ? -1 : dirty);
    				}
    			}

    			set_attributes(span, span_data = get_spread_update(span_levels, [
    				dirty & /*$$restProps*/ 512 && /*$$restProps*/ ctx[9],
    				(!current || dirty & /*$context*/ 64 && span_aria_expanded_value !== (span_aria_expanded_value = /*$context*/ ctx[6].isOpen)) && {
    					"aria-expanded": span_aria_expanded_value
    				},
    				(!current || dirty & /*classes*/ 16) && { class: /*classes*/ ctx[4] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			/*span_binding*/ ctx[27](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(80:25) ",
    		ctx
    	});

    	return block_1;
    }

    // (66:24) 
    function create_if_block_1$2(ctx) {
    	let div;
    	let div_aria_expanded_value;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[20].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[19], null);
    	const default_slot_or_fallback = default_slot || fallback_block_1(ctx);

    	let div_levels = [
    		/*$$restProps*/ ctx[9],
    		{
    			"aria-expanded": div_aria_expanded_value = /*$context*/ ctx[6].isOpen
    		},
    		{ class: /*classes*/ ctx[4] }
    	];

    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block_1 = {
    		c: function create() {
    			div = element$1("div");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			set_attributes(div, div_data);
    			add_location(div, file$H, 66, 2, 1448);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(div, null);
    			}

    			/*div_binding*/ ctx[26](div);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(/*$context*/ ctx[6].popperRef(div)),
    					listen_dev(div, "click", /*click_handler_1*/ ctx[22], false, false, false),
    					listen_dev(div, "click", /*toggleButton*/ ctx[8], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 524288)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[19],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[19])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[19], dirty, null),
    						null
    					);
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*ariaLabel*/ 2)) {
    					default_slot_or_fallback.p(ctx, !current ? -1 : dirty);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				dirty & /*$$restProps*/ 512 && /*$$restProps*/ ctx[9],
    				(!current || dirty & /*$context*/ 64 && div_aria_expanded_value !== (div_aria_expanded_value = /*$context*/ ctx[6].isOpen)) && { "aria-expanded": div_aria_expanded_value },
    				(!current || dirty & /*classes*/ 16) && { class: /*classes*/ ctx[4] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			/*div_binding*/ ctx[26](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(66:24) ",
    		ctx
    	});

    	return block_1;
    }

    // (51:0) {#if nav}
    function create_if_block$c(ctx) {
    	let a;
    	let a_aria_expanded_value;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[20].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[19], null);
    	const default_slot_or_fallback = default_slot || fallback_block(ctx);

    	let a_levels = [
    		/*$$restProps*/ ctx[9],
    		{ href: "#nav" },
    		{
    			"aria-expanded": a_aria_expanded_value = /*$context*/ ctx[6].isOpen
    		},
    		{ class: /*classes*/ ctx[4] }
    	];

    	let a_data = {};

    	for (let i = 0; i < a_levels.length; i += 1) {
    		a_data = assign(a_data, a_levels[i]);
    	}

    	const block_1 = {
    		c: function create() {
    			a = element$1("a");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			set_attributes(a, a_data);
    			add_location(a, file$H, 51, 2, 1131);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(a, null);
    			}

    			/*a_binding*/ ctx[25](a);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(/*$context*/ ctx[6].popperRef(a)),
    					listen_dev(a, "click", /*click_handler*/ ctx[21], false, false, false),
    					listen_dev(a, "click", /*toggleButton*/ ctx[8], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 524288)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[19],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[19])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[19], dirty, null),
    						null
    					);
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*ariaLabel*/ 2)) {
    					default_slot_or_fallback.p(ctx, !current ? -1 : dirty);
    				}
    			}

    			set_attributes(a, a_data = get_spread_update(a_levels, [
    				dirty & /*$$restProps*/ 512 && /*$$restProps*/ ctx[9],
    				{ href: "#nav" },
    				(!current || dirty & /*$context*/ 64 && a_aria_expanded_value !== (a_aria_expanded_value = /*$context*/ ctx[6].isOpen)) && { "aria-expanded": a_aria_expanded_value },
    				(!current || dirty & /*classes*/ 16) && { class: /*classes*/ ctx[4] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			/*a_binding*/ ctx[25](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_if_block$c.name,
    		type: "if",
    		source: "(51:0) {#if nav}",
    		ctx
    	});

    	return block_1;
    }

    // (105:10)         
    function fallback_block_3(ctx) {
    	let span;
    	let t;

    	const block_1 = {
    		c: function create() {
    			span = element$1("span");
    			t = text$1(/*ariaLabel*/ ctx[1]);
    			attr_dev(span, "class", "visually-hidden");
    			add_location(span, file$H, 105, 6, 2270);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*ariaLabel*/ 2) set_data_dev(t, /*ariaLabel*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: fallback_block_3.name,
    		type: "fallback",
    		source: "(105:10)         ",
    		ctx
    	});

    	return block_1;
    }

    // (90:10)         
    function fallback_block_2(ctx) {
    	let span;
    	let t;

    	const block_1 = {
    		c: function create() {
    			span = element$1("span");
    			t = text$1(/*ariaLabel*/ ctx[1]);
    			attr_dev(span, "class", "visually-hidden");
    			add_location(span, file$H, 90, 6, 1957);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*ariaLabel*/ 2) set_data_dev(t, /*ariaLabel*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: fallback_block_2.name,
    		type: "fallback",
    		source: "(90:10)         ",
    		ctx
    	});

    	return block_1;
    }

    // (76:10)         
    function fallback_block_1(ctx) {
    	let span;
    	let t;

    	const block_1 = {
    		c: function create() {
    			span = element$1("span");
    			t = text$1(/*ariaLabel*/ ctx[1]);
    			attr_dev(span, "class", "visually-hidden");
    			add_location(span, file$H, 76, 6, 1651);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*ariaLabel*/ 2) set_data_dev(t, /*ariaLabel*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: fallback_block_1.name,
    		type: "fallback",
    		source: "(76:10)         ",
    		ctx
    	});

    	return block_1;
    }

    // (62:10)         
    function fallback_block(ctx) {
    	let span;
    	let t;

    	const block_1 = {
    		c: function create() {
    			span = element$1("span");
    			t = text$1(/*ariaLabel*/ ctx[1]);
    			attr_dev(span, "class", "visually-hidden");
    			add_location(span, file$H, 62, 6, 1349);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*ariaLabel*/ 2) set_data_dev(t, /*ariaLabel*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: fallback_block.name,
    		type: "fallback",
    		source: "(62:10)         ",
    		ctx
    	});

    	return block_1;
    }

    function create_fragment$H(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$c, create_if_block_1$2, create_if_block_2, create_else_block$3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*nav*/ ctx[2]) return 0;
    		if (/*tag*/ ctx[3] === 'div') return 1;
    		if (/*tag*/ ctx[3] === 'span') return 2;
    		return 3;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block_1 = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$2();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_fragment$H.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block_1;
    }

    function instance$H($$self, $$props, $$invalidate) {
    	let classes;
    	let btnClasses;

    	const omit_props_names = [
    		"class","ariaLabel","active","block","caret","color","disabled","inner","nav","outline","size","split","tag"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let $context;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('DropdownToggle', slots, ['default']);
    	const context = getContext('dropdownContext');
    	validate_store(context, 'context');
    	component_subscribe($$self, context, value => $$invalidate(6, $context = value));
    	let { class: className = '' } = $$props;
    	let { ariaLabel = 'Toggle Dropdown' } = $$props;
    	let { active = false } = $$props;
    	let { block = false } = $$props;
    	let { caret = false } = $$props;
    	let { color = 'secondary' } = $$props;
    	let { disabled = false } = $$props;
    	let { inner = undefined } = $$props;
    	let { nav = false } = $$props;
    	let { outline = false } = $$props;
    	let { size = '' } = $$props;
    	let { split = false } = $$props;
    	let { tag = null } = $$props;

    	function toggleButton(e) {
    		if (disabled) {
    			e.preventDefault();
    			return;
    		}

    		if (nav) {
    			e.preventDefault();
    		}

    		$context.toggle(e);
    	}

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function click_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function click_handler_2(event) {
    		bubble.call(this, $$self, event);
    	}

    	function click_handler_3(event) {
    		bubble.call(this, $$self, event);
    	}

    	function a_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inner = $$value;
    			$$invalidate(0, inner);
    		});
    	}

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inner = $$value;
    			$$invalidate(0, inner);
    		});
    	}

    	function span_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inner = $$value;
    			$$invalidate(0, inner);
    		});
    	}

    	function button_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inner = $$value;
    			$$invalidate(0, inner);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(10, className = $$new_props.class);
    		if ('ariaLabel' in $$new_props) $$invalidate(1, ariaLabel = $$new_props.ariaLabel);
    		if ('active' in $$new_props) $$invalidate(11, active = $$new_props.active);
    		if ('block' in $$new_props) $$invalidate(12, block = $$new_props.block);
    		if ('caret' in $$new_props) $$invalidate(13, caret = $$new_props.caret);
    		if ('color' in $$new_props) $$invalidate(14, color = $$new_props.color);
    		if ('disabled' in $$new_props) $$invalidate(15, disabled = $$new_props.disabled);
    		if ('inner' in $$new_props) $$invalidate(0, inner = $$new_props.inner);
    		if ('nav' in $$new_props) $$invalidate(2, nav = $$new_props.nav);
    		if ('outline' in $$new_props) $$invalidate(16, outline = $$new_props.outline);
    		if ('size' in $$new_props) $$invalidate(17, size = $$new_props.size);
    		if ('split' in $$new_props) $$invalidate(18, split = $$new_props.split);
    		if ('tag' in $$new_props) $$invalidate(3, tag = $$new_props.tag);
    		if ('$$scope' in $$new_props) $$invalidate(19, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		classnames,
    		context,
    		className,
    		ariaLabel,
    		active,
    		block,
    		caret,
    		color,
    		disabled,
    		inner,
    		nav,
    		outline,
    		size,
    		split,
    		tag,
    		toggleButton,
    		classes,
    		btnClasses,
    		$context
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('className' in $$props) $$invalidate(10, className = $$new_props.className);
    		if ('ariaLabel' in $$props) $$invalidate(1, ariaLabel = $$new_props.ariaLabel);
    		if ('active' in $$props) $$invalidate(11, active = $$new_props.active);
    		if ('block' in $$props) $$invalidate(12, block = $$new_props.block);
    		if ('caret' in $$props) $$invalidate(13, caret = $$new_props.caret);
    		if ('color' in $$props) $$invalidate(14, color = $$new_props.color);
    		if ('disabled' in $$props) $$invalidate(15, disabled = $$new_props.disabled);
    		if ('inner' in $$props) $$invalidate(0, inner = $$new_props.inner);
    		if ('nav' in $$props) $$invalidate(2, nav = $$new_props.nav);
    		if ('outline' in $$props) $$invalidate(16, outline = $$new_props.outline);
    		if ('size' in $$props) $$invalidate(17, size = $$new_props.size);
    		if ('split' in $$props) $$invalidate(18, split = $$new_props.split);
    		if ('tag' in $$props) $$invalidate(3, tag = $$new_props.tag);
    		if ('classes' in $$props) $$invalidate(4, classes = $$new_props.classes);
    		if ('btnClasses' in $$props) $$invalidate(5, btnClasses = $$new_props.btnClasses);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, caret, split, nav*/ 271364) {
    			$$invalidate(4, classes = classnames(className, {
    				'dropdown-toggle': caret || split,
    				'dropdown-toggle-split': split,
    				'nav-link': nav
    			}));
    		}

    		if ($$self.$$.dirty & /*classes, outline, color, size, block, active*/ 219152) {
    			$$invalidate(5, btnClasses = classnames(classes, 'btn', `btn${outline ? '-outline' : ''}-${color}`, size ? `btn-${size}` : false, block ? 'd-block w-100' : false, { active }));
    		}
    	};

    	return [
    		inner,
    		ariaLabel,
    		nav,
    		tag,
    		classes,
    		btnClasses,
    		$context,
    		context,
    		toggleButton,
    		$$restProps,
    		className,
    		active,
    		block,
    		caret,
    		color,
    		disabled,
    		outline,
    		size,
    		split,
    		$$scope,
    		slots,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		a_binding,
    		div_binding,
    		span_binding,
    		button_binding
    	];
    }

    class DropdownToggle extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$H, create_fragment$H, safe_not_equal, {
    			class: 10,
    			ariaLabel: 1,
    			active: 11,
    			block: 12,
    			caret: 13,
    			color: 14,
    			disabled: 15,
    			inner: 0,
    			nav: 2,
    			outline: 16,
    			size: 17,
    			split: 18,
    			tag: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DropdownToggle",
    			options,
    			id: create_fragment$H.name
    		});
    	}

    	get class() {
    		throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ariaLabel() {
    		throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ariaLabel(value) {
    		throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get active() {
    		throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get block() {
    		throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set block(value) {
    		throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get caret() {
    		throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set caret(value) {
    		throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inner() {
    		throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inner(value) {
    		throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get nav() {
    		throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set nav(value) {
    		throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get outline() {
    		throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set outline(value) {
    		throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get split() {
    		throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set split(value) {
    		throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tag() {
    		throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tag(value) {
    		throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\sveltestrap\src\Nav.svelte generated by Svelte v3.47.0 */
    const file$G = "node_modules\\sveltestrap\\src\\Nav.svelte";

    function create_fragment$G(ctx) {
    	let ul;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[12].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);
    	let ul_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
    	let ul_data = {};

    	for (let i = 0; i < ul_levels.length; i += 1) {
    		ul_data = assign(ul_data, ul_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			ul = element$1("ul");
    			if (default_slot) default_slot.c();
    			set_attributes(ul, ul_data);
    			add_location(ul, file$G, 39, 0, 980);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);

    			if (default_slot) {
    				default_slot.m(ul, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[11],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[11])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(ul, ul_data = get_spread_update(ul_levels, [
    				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
    				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$G.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function getVerticalClass(vertical) {
    	if (vertical === false) {
    		return false;
    	} else if (vertical === true || vertical === 'xs') {
    		return 'flex-column';
    	}

    	return `flex-${vertical}-column`;
    }

    function instance$G($$self, $$props, $$invalidate) {
    	let classes;

    	const omit_props_names = [
    		"class","tabs","pills","vertical","horizontal","justified","fill","navbar","card"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Nav', slots, ['default']);
    	let { class: className = '' } = $$props;
    	let { tabs = false } = $$props;
    	let { pills = false } = $$props;
    	let { vertical = false } = $$props;
    	let { horizontal = '' } = $$props;
    	let { justified = false } = $$props;
    	let { fill = false } = $$props;
    	let { navbar = false } = $$props;
    	let { card = false } = $$props;

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ('tabs' in $$new_props) $$invalidate(3, tabs = $$new_props.tabs);
    		if ('pills' in $$new_props) $$invalidate(4, pills = $$new_props.pills);
    		if ('vertical' in $$new_props) $$invalidate(5, vertical = $$new_props.vertical);
    		if ('horizontal' in $$new_props) $$invalidate(6, horizontal = $$new_props.horizontal);
    		if ('justified' in $$new_props) $$invalidate(7, justified = $$new_props.justified);
    		if ('fill' in $$new_props) $$invalidate(8, fill = $$new_props.fill);
    		if ('navbar' in $$new_props) $$invalidate(9, navbar = $$new_props.navbar);
    		if ('card' in $$new_props) $$invalidate(10, card = $$new_props.card);
    		if ('$$scope' in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		classnames,
    		className,
    		tabs,
    		pills,
    		vertical,
    		horizontal,
    		justified,
    		fill,
    		navbar,
    		card,
    		getVerticalClass,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('className' in $$props) $$invalidate(2, className = $$new_props.className);
    		if ('tabs' in $$props) $$invalidate(3, tabs = $$new_props.tabs);
    		if ('pills' in $$props) $$invalidate(4, pills = $$new_props.pills);
    		if ('vertical' in $$props) $$invalidate(5, vertical = $$new_props.vertical);
    		if ('horizontal' in $$props) $$invalidate(6, horizontal = $$new_props.horizontal);
    		if ('justified' in $$props) $$invalidate(7, justified = $$new_props.justified);
    		if ('fill' in $$props) $$invalidate(8, fill = $$new_props.fill);
    		if ('navbar' in $$props) $$invalidate(9, navbar = $$new_props.navbar);
    		if ('card' in $$props) $$invalidate(10, card = $$new_props.card);
    		if ('classes' in $$props) $$invalidate(0, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, navbar, horizontal, vertical, tabs, card, pills, justified, fill*/ 2044) {
    			$$invalidate(0, classes = classnames(className, navbar ? 'navbar-nav' : 'nav', horizontal ? `justify-content-${horizontal}` : false, getVerticalClass(vertical), {
    				'nav-tabs': tabs,
    				'card-header-tabs': card && tabs,
    				'nav-pills': pills,
    				'card-header-pills': card && pills,
    				'nav-justified': justified,
    				'nav-fill': fill
    			}));
    		}
    	};

    	return [
    		classes,
    		$$restProps,
    		className,
    		tabs,
    		pills,
    		vertical,
    		horizontal,
    		justified,
    		fill,
    		navbar,
    		card,
    		$$scope,
    		slots
    	];
    }

    class Nav extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$G, create_fragment$G, safe_not_equal, {
    			class: 2,
    			tabs: 3,
    			pills: 4,
    			vertical: 5,
    			horizontal: 6,
    			justified: 7,
    			fill: 8,
    			navbar: 9,
    			card: 10
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Nav",
    			options,
    			id: create_fragment$G.name
    		});
    	}

    	get class() {
    		throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabs() {
    		throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabs(value) {
    		throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pills() {
    		throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pills(value) {
    		throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get vertical() {
    		throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set vertical(value) {
    		throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get horizontal() {
    		throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set horizontal(value) {
    		throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get justified() {
    		throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set justified(value) {
    		throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fill() {
    		throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fill(value) {
    		throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get navbar() {
    		throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set navbar(value) {
    		throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\sveltestrap\src\Navbar.svelte generated by Svelte v3.47.0 */
    const file$F = "node_modules\\sveltestrap\\src\\Navbar.svelte";

    // (44:2) {:else}
    function create_else_block$2(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[10].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[11],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[11])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(44:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (40:2) {#if container}
    function create_if_block$b(ctx) {
    	let container_1;
    	let current;

    	container_1 = new Container({
    			props: {
    				fluid: /*container*/ ctx[0] === 'fluid',
    				$$slots: { default: [create_default_slot$u] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(container_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(container_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const container_1_changes = {};
    			if (dirty & /*container*/ 1) container_1_changes.fluid = /*container*/ ctx[0] === 'fluid';

    			if (dirty & /*$$scope*/ 2048) {
    				container_1_changes.$$scope = { dirty, ctx };
    			}

    			container_1.$set(container_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(container_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(container_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(container_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$b.name,
    		type: "if",
    		source: "(40:2) {#if container}",
    		ctx
    	});

    	return block;
    }

    // (41:4) <Container fluid={container === 'fluid'}>
    function create_default_slot$u(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[10].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[11],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[11])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$u.name,
    		type: "slot",
    		source: "(41:4) <Container fluid={container === 'fluid'}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$F(ctx) {
    	let nav;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$b, create_else_block$2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*container*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let nav_levels = [/*$$restProps*/ ctx[2], { class: /*classes*/ ctx[1] }];
    	let nav_data = {};

    	for (let i = 0; i < nav_levels.length; i += 1) {
    		nav_data = assign(nav_data, nav_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			nav = element$1("nav");
    			if_block.c();
    			set_attributes(nav, nav_data);
    			add_location(nav, file$F, 38, 0, 927);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, nav, anchor);
    			if_blocks[current_block_type_index].m(nav, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(nav, null);
    			}

    			set_attributes(nav, nav_data = get_spread_update(nav_levels, [
    				dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2],
    				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(nav);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$F.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function getExpandClass(expand) {
    	if (expand === false) {
    		return false;
    	} else if (expand === true || expand === 'xs') {
    		return 'navbar-expand';
    	}

    	return `navbar-expand-${expand}`;
    }

    function instance$F($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class","container","color","dark","expand","fixed","light","sticky"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Navbar', slots, ['default']);
    	setContext('navbar', { inNavbar: true });
    	let { class: className = '' } = $$props;
    	let { container = 'fluid' } = $$props;
    	let { color = '' } = $$props;
    	let { dark = false } = $$props;
    	let { expand = '' } = $$props;
    	let { fixed = '' } = $$props;
    	let { light = false } = $$props;
    	let { sticky = '' } = $$props;

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
    		if ('container' in $$new_props) $$invalidate(0, container = $$new_props.container);
    		if ('color' in $$new_props) $$invalidate(4, color = $$new_props.color);
    		if ('dark' in $$new_props) $$invalidate(5, dark = $$new_props.dark);
    		if ('expand' in $$new_props) $$invalidate(6, expand = $$new_props.expand);
    		if ('fixed' in $$new_props) $$invalidate(7, fixed = $$new_props.fixed);
    		if ('light' in $$new_props) $$invalidate(8, light = $$new_props.light);
    		if ('sticky' in $$new_props) $$invalidate(9, sticky = $$new_props.sticky);
    		if ('$$scope' in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		classnames,
    		Container,
    		setContext,
    		className,
    		container,
    		color,
    		dark,
    		expand,
    		fixed,
    		light,
    		sticky,
    		getExpandClass,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('className' in $$props) $$invalidate(3, className = $$new_props.className);
    		if ('container' in $$props) $$invalidate(0, container = $$new_props.container);
    		if ('color' in $$props) $$invalidate(4, color = $$new_props.color);
    		if ('dark' in $$props) $$invalidate(5, dark = $$new_props.dark);
    		if ('expand' in $$props) $$invalidate(6, expand = $$new_props.expand);
    		if ('fixed' in $$props) $$invalidate(7, fixed = $$new_props.fixed);
    		if ('light' in $$props) $$invalidate(8, light = $$new_props.light);
    		if ('sticky' in $$props) $$invalidate(9, sticky = $$new_props.sticky);
    		if ('classes' in $$props) $$invalidate(1, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, expand, light, dark, color, fixed, sticky*/ 1016) {
    			$$invalidate(1, classes = classnames(className, 'navbar', getExpandClass(expand), {
    				'navbar-light': light,
    				'navbar-dark': dark,
    				[`bg-${color}`]: color,
    				[`fixed-${fixed}`]: fixed,
    				[`sticky-${sticky}`]: sticky
    			}));
    		}
    	};

    	return [
    		container,
    		classes,
    		$$restProps,
    		className,
    		color,
    		dark,
    		expand,
    		fixed,
    		light,
    		sticky,
    		slots,
    		$$scope
    	];
    }

    class Navbar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$F, create_fragment$F, safe_not_equal, {
    			class: 3,
    			container: 0,
    			color: 4,
    			dark: 5,
    			expand: 6,
    			fixed: 7,
    			light: 8,
    			sticky: 9
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Navbar",
    			options,
    			id: create_fragment$F.name
    		});
    	}

    	get class() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get container() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set container(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dark() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dark(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get expand() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set expand(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fixed() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fixed(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get light() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set light(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sticky() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sticky(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\sveltestrap\src\NavItem.svelte generated by Svelte v3.47.0 */
    const file$E = "node_modules\\sveltestrap\\src\\NavItem.svelte";

    function create_fragment$E(ctx) {
    	let li;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
    	let li_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
    	let li_data = {};

    	for (let i = 0; i < li_levels.length; i += 1) {
    		li_data = assign(li_data, li_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			li = element$1("li");
    			if (default_slot) default_slot.c();
    			set_attributes(li, li_data);
    			add_location(li, file$E, 10, 0, 229);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);

    			if (default_slot) {
    				default_slot.m(li, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[4],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(li, li_data = get_spread_update(li_levels, [
    				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
    				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$E.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$E($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class","active"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('NavItem', slots, ['default']);
    	let { class: className = '' } = $$props;
    	let { active = false } = $$props;

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ('active' in $$new_props) $$invalidate(3, active = $$new_props.active);
    		if ('$$scope' in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({ classnames, className, active, classes });

    	$$self.$inject_state = $$new_props => {
    		if ('className' in $$props) $$invalidate(2, className = $$new_props.className);
    		if ('active' in $$props) $$invalidate(3, active = $$new_props.active);
    		if ('classes' in $$props) $$invalidate(0, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, active*/ 12) {
    			$$invalidate(0, classes = classnames(className, 'nav-item', active ? 'active' : false));
    		}
    	};

    	return [classes, $$restProps, className, active, $$scope, slots];
    }

    class NavItem extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$E, create_fragment$E, safe_not_equal, { class: 2, active: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NavItem",
    			options,
    			id: create_fragment$E.name
    		});
    	}

    	get class() {
    		throw new Error("<NavItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<NavItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get active() {
    		throw new Error("<NavItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<NavItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\sveltestrap\src\NavLink.svelte generated by Svelte v3.47.0 */
    const file$D = "node_modules\\sveltestrap\\src\\NavLink.svelte";

    function create_fragment$D(ctx) {
    	let a;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

    	let a_levels = [
    		/*$$restProps*/ ctx[3],
    		{ href: /*href*/ ctx[0] },
    		{ class: /*classes*/ ctx[1] }
    	];

    	let a_data = {};

    	for (let i = 0; i < a_levels.length; i += 1) {
    		a_data = assign(a_data, a_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			a = element$1("a");
    			if (default_slot) default_slot.c();
    			set_attributes(a, a_data);
    			add_location(a, file$D, 27, 0, 499);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (default_slot) {
    				default_slot.m(a, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(a, "click", /*click_handler*/ ctx[9], false, false, false),
    					listen_dev(a, "click", /*handleClick*/ ctx[2], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 128)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[7],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(a, a_data = get_spread_update(a_levels, [
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3],
    				(!current || dirty & /*href*/ 1) && { href: /*href*/ ctx[0] },
    				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$D.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$D($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class","disabled","active","href"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('NavLink', slots, ['default']);
    	let { class: className = '' } = $$props;
    	let { disabled = false } = $$props;
    	let { active = false } = $$props;
    	let { href = '#' } = $$props;

    	function handleClick(e) {
    		if (disabled) {
    			e.preventDefault();
    			e.stopImmediatePropagation();
    			return;
    		}

    		if (href === '#') {
    			e.preventDefault();
    		}
    	}

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(4, className = $$new_props.class);
    		if ('disabled' in $$new_props) $$invalidate(5, disabled = $$new_props.disabled);
    		if ('active' in $$new_props) $$invalidate(6, active = $$new_props.active);
    		if ('href' in $$new_props) $$invalidate(0, href = $$new_props.href);
    		if ('$$scope' in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		classnames,
    		className,
    		disabled,
    		active,
    		href,
    		handleClick,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('className' in $$props) $$invalidate(4, className = $$new_props.className);
    		if ('disabled' in $$props) $$invalidate(5, disabled = $$new_props.disabled);
    		if ('active' in $$props) $$invalidate(6, active = $$new_props.active);
    		if ('href' in $$props) $$invalidate(0, href = $$new_props.href);
    		if ('classes' in $$props) $$invalidate(1, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, disabled, active*/ 112) {
    			$$invalidate(1, classes = classnames(className, 'nav-link', { disabled, active }));
    		}
    	};

    	return [
    		href,
    		classes,
    		handleClick,
    		$$restProps,
    		className,
    		disabled,
    		active,
    		$$scope,
    		slots,
    		click_handler
    	];
    }

    class NavLink extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$D, create_fragment$D, safe_not_equal, {
    			class: 4,
    			disabled: 5,
    			active: 6,
    			href: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NavLink",
    			options,
    			id: create_fragment$D.name
    		});
    	}

    	get class() {
    		throw new Error("<NavLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<NavLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<NavLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<NavLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get active() {
    		throw new Error("<NavLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<NavLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get href() {
    		throw new Error("<NavLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<NavLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\sveltestrap\src\NavbarBrand.svelte generated by Svelte v3.47.0 */
    const file$C = "node_modules\\sveltestrap\\src\\NavbarBrand.svelte";

    function create_fragment$C(ctx) {
    	let a;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

    	let a_levels = [
    		/*$$restProps*/ ctx[2],
    		{ class: /*classes*/ ctx[1] },
    		{ href: /*href*/ ctx[0] }
    	];

    	let a_data = {};

    	for (let i = 0; i < a_levels.length; i += 1) {
    		a_data = assign(a_data, a_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			a = element$1("a");
    			if (default_slot) default_slot.c();
    			set_attributes(a, a_data);
    			add_location(a, file$C, 10, 0, 202);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (default_slot) {
    				default_slot.m(a, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(a, "click", /*click_handler*/ ctx[6], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[4],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(a, a_data = get_spread_update(a_levels, [
    				dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2],
    				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
    				(!current || dirty & /*href*/ 1) && { href: /*href*/ ctx[0] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$C.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$C($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class","href"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('NavbarBrand', slots, ['default']);
    	let { class: className = '' } = $$props;
    	let { href = '/' } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
    		if ('href' in $$new_props) $$invalidate(0, href = $$new_props.href);
    		if ('$$scope' in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({ classnames, className, href, classes });

    	$$self.$inject_state = $$new_props => {
    		if ('className' in $$props) $$invalidate(3, className = $$new_props.className);
    		if ('href' in $$props) $$invalidate(0, href = $$new_props.href);
    		if ('classes' in $$props) $$invalidate(1, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className*/ 8) {
    			$$invalidate(1, classes = classnames(className, 'navbar-brand'));
    		}
    	};

    	return [href, classes, $$restProps, className, $$scope, slots, click_handler];
    }

    class NavbarBrand extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$C, create_fragment$C, safe_not_equal, { class: 3, href: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NavbarBrand",
    			options,
    			id: create_fragment$C.name
    		});
    	}

    	get class() {
    		throw new Error("<NavbarBrand>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<NavbarBrand>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get href() {
    		throw new Error("<NavbarBrand>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<NavbarBrand>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\sveltestrap\src\Colgroup.svelte generated by Svelte v3.47.0 */
    const file$B = "node_modules\\sveltestrap\\src\\Colgroup.svelte";

    function create_fragment$B(ctx) {
    	let colgroup;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

    	const block = {
    		c: function create() {
    			colgroup = element$1("colgroup");
    			if (default_slot) default_slot.c();
    			add_location(colgroup, file$B, 6, 0, 98);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, colgroup, anchor);

    			if (default_slot) {
    				default_slot.m(colgroup, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 1)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[0],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[0], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(colgroup);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$B.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$B($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Colgroup', slots, ['default']);
    	setContext('colgroup', true);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Colgroup> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('$$scope' in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ setContext });
    	return [$$scope, slots];
    }

    class Colgroup extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$B, create_fragment$B, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Colgroup",
    			options,
    			id: create_fragment$B.name
    		});
    	}
    }

    /* node_modules\sveltestrap\src\ResponsiveContainer.svelte generated by Svelte v3.47.0 */
    const file$A = "node_modules\\sveltestrap\\src\\ResponsiveContainer.svelte";

    // (15:0) {:else}
    function create_else_block$1(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(15:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (13:0) {#if responsive}
    function create_if_block$a(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

    	const block = {
    		c: function create() {
    			div = element$1("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", /*responsiveClassName*/ ctx[1]);
    			add_location(div, file$A, 13, 2, 318);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*responsiveClassName*/ 2) {
    				attr_dev(div, "class", /*responsiveClassName*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$a.name,
    		type: "if",
    		source: "(13:0) {#if responsive}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$A(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$a, create_else_block$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*responsive*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$2();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$A.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$A($$self, $$props, $$invalidate) {
    	let responsiveClassName;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ResponsiveContainer', slots, ['default']);
    	let className = '';
    	let { responsive = false } = $$props;
    	const writable_props = ['responsive'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ResponsiveContainer> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('responsive' in $$props) $$invalidate(0, responsive = $$props.responsive);
    		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		classnames,
    		className,
    		responsive,
    		responsiveClassName
    	});

    	$$self.$inject_state = $$props => {
    		if ('className' in $$props) $$invalidate(4, className = $$props.className);
    		if ('responsive' in $$props) $$invalidate(0, responsive = $$props.responsive);
    		if ('responsiveClassName' in $$props) $$invalidate(1, responsiveClassName = $$props.responsiveClassName);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*responsive*/ 1) {
    			$$invalidate(1, responsiveClassName = classnames(className, {
    				'table-responsive': responsive === true,
    				[`table-responsive-${responsive}`]: typeof responsive === 'string'
    			}));
    		}
    	};

    	return [responsive, responsiveClassName, $$scope, slots];
    }

    class ResponsiveContainer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$A, create_fragment$A, safe_not_equal, { responsive: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ResponsiveContainer",
    			options,
    			id: create_fragment$A.name
    		});
    	}

    	get responsive() {
    		throw new Error("<ResponsiveContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set responsive(value) {
    		throw new Error("<ResponsiveContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\sveltestrap\src\TableFooter.svelte generated by Svelte v3.47.0 */
    const file$z = "node_modules\\sveltestrap\\src\\TableFooter.svelte";

    function create_fragment$z(ctx) {
    	let tfoot;
    	let tr;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[2].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);
    	let tfoot_levels = [/*$$restProps*/ ctx[0]];
    	let tfoot_data = {};

    	for (let i = 0; i < tfoot_levels.length; i += 1) {
    		tfoot_data = assign(tfoot_data, tfoot_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			tfoot = element$1("tfoot");
    			tr = element$1("tr");
    			if (default_slot) default_slot.c();
    			add_location(tr, file$z, 7, 2, 124);
    			set_attributes(tfoot, tfoot_data);
    			add_location(tfoot, file$z, 6, 0, 96);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tfoot, anchor);
    			append_dev(tfoot, tr);

    			if (default_slot) {
    				default_slot.m(tr, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 2)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[1],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[1])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[1], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(tfoot, tfoot_data = get_spread_update(tfoot_levels, [dirty & /*$$restProps*/ 1 && /*$$restProps*/ ctx[0]]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tfoot);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$z($$self, $$props, $$invalidate) {
    	const omit_props_names = [];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TableFooter', slots, ['default']);
    	setContext('footer', true);

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('$$scope' in $$new_props) $$invalidate(1, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({ setContext });
    	return [$$restProps, $$scope, slots];
    }

    class TableFooter extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$z, create_fragment$z, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TableFooter",
    			options,
    			id: create_fragment$z.name
    		});
    	}
    }

    /* node_modules\sveltestrap\src\TableHeader.svelte generated by Svelte v3.47.0 */
    const file$y = "node_modules\\sveltestrap\\src\\TableHeader.svelte";

    function create_fragment$y(ctx) {
    	let thead;
    	let tr;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[2].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);
    	let thead_levels = [/*$$restProps*/ ctx[0]];
    	let thead_data = {};

    	for (let i = 0; i < thead_levels.length; i += 1) {
    		thead_data = assign(thead_data, thead_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			thead = element$1("thead");
    			tr = element$1("tr");
    			if (default_slot) default_slot.c();
    			add_location(tr, file$y, 7, 2, 124);
    			set_attributes(thead, thead_data);
    			add_location(thead, file$y, 6, 0, 96);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, thead, anchor);
    			append_dev(thead, tr);

    			if (default_slot) {
    				default_slot.m(tr, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 2)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[1],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[1])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[1], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(thead, thead_data = get_spread_update(thead_levels, [dirty & /*$$restProps*/ 1 && /*$$restProps*/ ctx[0]]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(thead);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$y($$self, $$props, $$invalidate) {
    	const omit_props_names = [];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TableHeader', slots, ['default']);
    	setContext('header', true);

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('$$scope' in $$new_props) $$invalidate(1, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({ setContext });
    	return [$$restProps, $$scope, slots];
    }

    class TableHeader extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$y, create_fragment$y, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TableHeader",
    			options,
    			id: create_fragment$y.name
    		});
    	}
    }

    /* node_modules\sveltestrap\src\Table.svelte generated by Svelte v3.47.0 */
    const file$x = "node_modules\\sveltestrap\\src\\Table.svelte";

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[13] = list[i];
    	return child_ctx;
    }

    const get_default_slot_changes_1 = dirty => ({ row: dirty & /*rows*/ 2 });
    const get_default_slot_context_1 = ctx => ({ row: /*row*/ ctx[13] });
    const get_default_slot_changes = dirty => ({ row: dirty & /*rows*/ 2 });
    const get_default_slot_context = ctx => ({ row: /*row*/ ctx[13] });

    // (50:4) {:else}
    function create_else_block(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[11].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4096)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[12],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[12])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[12], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(50:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (33:4) {#if rows}
    function create_if_block$9(ctx) {
    	let colgroup;
    	let t0;
    	let tableheader;
    	let t1;
    	let tbody;
    	let t2;
    	let tablefooter;
    	let current;

    	colgroup = new Colgroup({
    			props: {
    				$$slots: { default: [create_default_slot_3$s] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tableheader = new TableHeader({
    			props: {
    				$$slots: { default: [create_default_slot_2$s] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let each_value = /*rows*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	tablefooter = new TableFooter({
    			props: {
    				$$slots: { default: [create_default_slot_1$t] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(colgroup.$$.fragment);
    			t0 = space();
    			create_component(tableheader.$$.fragment);
    			t1 = space();
    			tbody = element$1("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t2 = space();
    			create_component(tablefooter.$$.fragment);
    			add_location(tbody, file$x, 39, 6, 1096);
    		},
    		m: function mount(target, anchor) {
    			mount_component(colgroup, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(tableheader, target, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, tbody, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}

    			insert_dev(target, t2, anchor);
    			mount_component(tablefooter, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const colgroup_changes = {};

    			if (dirty & /*$$scope*/ 4096) {
    				colgroup_changes.$$scope = { dirty, ctx };
    			}

    			colgroup.$set(colgroup_changes);
    			const tableheader_changes = {};

    			if (dirty & /*$$scope, rows*/ 4098) {
    				tableheader_changes.$$scope = { dirty, ctx };
    			}

    			tableheader.$set(tableheader_changes);

    			if (dirty & /*$$scope, rows*/ 4098) {
    				each_value = /*rows*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$3(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$3(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			const tablefooter_changes = {};

    			if (dirty & /*$$scope*/ 4096) {
    				tablefooter_changes.$$scope = { dirty, ctx };
    			}

    			tablefooter.$set(tablefooter_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(colgroup.$$.fragment, local);
    			transition_in(tableheader.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(tablefooter.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(colgroup.$$.fragment, local);
    			transition_out(tableheader.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(tablefooter.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(colgroup, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(tableheader, detaching);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(tbody);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(tablefooter, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$9.name,
    		type: "if",
    		source: "(33:4) {#if rows}",
    		ctx
    	});

    	return block;
    }

    // (34:6) <Colgroup>
    function create_default_slot_3$s(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[11].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4096)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[12],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[12])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[12], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$s.name,
    		type: "slot",
    		source: "(34:6) <Colgroup>",
    		ctx
    	});

    	return block;
    }

    // (37:6) <TableHeader>
    function create_default_slot_2$s(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[11].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], get_default_slot_context);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope, rows*/ 4098)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[12],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[12])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[12], dirty, get_default_slot_changes),
    						get_default_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$s.name,
    		type: "slot",
    		source: "(37:6) <TableHeader>",
    		ctx
    	});

    	return block;
    }

    // (41:8) {#each rows as row}
    function create_each_block$3(ctx) {
    	let tr;
    	let t;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[11].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], get_default_slot_context_1);

    	const block = {
    		c: function create() {
    			tr = element$1("tr");
    			if (default_slot) default_slot.c();
    			t = space();
    			add_location(tr, file$x, 41, 10, 1144);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);

    			if (default_slot) {
    				default_slot.m(tr, null);
    			}

    			append_dev(tr, t);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope, rows*/ 4098)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[12],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[12])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[12], dirty, get_default_slot_changes_1),
    						get_default_slot_context_1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(41:8) {#each rows as row}",
    		ctx
    	});

    	return block;
    }

    // (47:6) <TableFooter>
    function create_default_slot_1$t(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[11].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4096)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[12],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[12])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[12], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$t.name,
    		type: "slot",
    		source: "(47:6) <TableFooter>",
    		ctx
    	});

    	return block;
    }

    // (31:0) <ResponsiveContainer {responsive}>
    function create_default_slot$t(ctx) {
    	let table;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$9, create_else_block];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*rows*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let table_levels = [/*$$restProps*/ ctx[3], { class: /*classes*/ ctx[2] }];
    	let table_data = {};

    	for (let i = 0; i < table_levels.length; i += 1) {
    		table_data = assign(table_data, table_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			table = element$1("table");
    			if_block.c();
    			set_attributes(table, table_data);
    			add_location(table, file$x, 31, 2, 916);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, table, anchor);
    			if_blocks[current_block_type_index].m(table, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(table, null);
    			}

    			set_attributes(table, table_data = get_spread_update(table_levels, [
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3],
    				(!current || dirty & /*classes*/ 4) && { class: /*classes*/ ctx[2] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(table);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$t.name,
    		type: "slot",
    		source: "(31:0) <ResponsiveContainer {responsive}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$x(ctx) {
    	let responsivecontainer;
    	let current;

    	responsivecontainer = new ResponsiveContainer({
    			props: {
    				responsive: /*responsive*/ ctx[0],
    				$$slots: { default: [create_default_slot$t] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(responsivecontainer.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(responsivecontainer, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const responsivecontainer_changes = {};
    			if (dirty & /*responsive*/ 1) responsivecontainer_changes.responsive = /*responsive*/ ctx[0];

    			if (dirty & /*$$scope, $$restProps, classes, rows*/ 4110) {
    				responsivecontainer_changes.$$scope = { dirty, ctx };
    			}

    			responsivecontainer.$set(responsivecontainer_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(responsivecontainer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(responsivecontainer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(responsivecontainer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$x($$self, $$props, $$invalidate) {
    	let classes;

    	const omit_props_names = [
    		"class","size","bordered","borderless","striped","dark","hover","responsive","rows"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Table', slots, ['default']);
    	let { class: className = '' } = $$props;
    	let { size = '' } = $$props;
    	let { bordered = false } = $$props;
    	let { borderless = false } = $$props;
    	let { striped = false } = $$props;
    	let { dark = false } = $$props;
    	let { hover = false } = $$props;
    	let { responsive = false } = $$props;
    	let { rows = undefined } = $$props;

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(4, className = $$new_props.class);
    		if ('size' in $$new_props) $$invalidate(5, size = $$new_props.size);
    		if ('bordered' in $$new_props) $$invalidate(6, bordered = $$new_props.bordered);
    		if ('borderless' in $$new_props) $$invalidate(7, borderless = $$new_props.borderless);
    		if ('striped' in $$new_props) $$invalidate(8, striped = $$new_props.striped);
    		if ('dark' in $$new_props) $$invalidate(9, dark = $$new_props.dark);
    		if ('hover' in $$new_props) $$invalidate(10, hover = $$new_props.hover);
    		if ('responsive' in $$new_props) $$invalidate(0, responsive = $$new_props.responsive);
    		if ('rows' in $$new_props) $$invalidate(1, rows = $$new_props.rows);
    		if ('$$scope' in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		classnames,
    		Colgroup,
    		ResponsiveContainer,
    		TableFooter,
    		TableHeader,
    		className,
    		size,
    		bordered,
    		borderless,
    		striped,
    		dark,
    		hover,
    		responsive,
    		rows,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('className' in $$props) $$invalidate(4, className = $$new_props.className);
    		if ('size' in $$props) $$invalidate(5, size = $$new_props.size);
    		if ('bordered' in $$props) $$invalidate(6, bordered = $$new_props.bordered);
    		if ('borderless' in $$props) $$invalidate(7, borderless = $$new_props.borderless);
    		if ('striped' in $$props) $$invalidate(8, striped = $$new_props.striped);
    		if ('dark' in $$props) $$invalidate(9, dark = $$new_props.dark);
    		if ('hover' in $$props) $$invalidate(10, hover = $$new_props.hover);
    		if ('responsive' in $$props) $$invalidate(0, responsive = $$new_props.responsive);
    		if ('rows' in $$props) $$invalidate(1, rows = $$new_props.rows);
    		if ('classes' in $$props) $$invalidate(2, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, size, bordered, borderless, striped, dark, hover*/ 2032) {
    			$$invalidate(2, classes = classnames(className, 'table', size ? 'table-' + size : false, bordered ? 'table-bordered' : false, borderless ? 'table-borderless' : false, striped ? 'table-striped' : false, dark ? 'table-dark' : false, hover ? 'table-hover' : false));
    		}
    	};

    	return [
    		responsive,
    		rows,
    		classes,
    		$$restProps,
    		className,
    		size,
    		bordered,
    		borderless,
    		striped,
    		dark,
    		hover,
    		slots,
    		$$scope
    	];
    }

    class Table extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$x, create_fragment$x, safe_not_equal, {
    			class: 4,
    			size: 5,
    			bordered: 6,
    			borderless: 7,
    			striped: 8,
    			dark: 9,
    			hover: 10,
    			responsive: 0,
    			rows: 1
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Table",
    			options,
    			id: create_fragment$x.name
    		});
    	}

    	get class() {
    		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get bordered() {
    		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set bordered(value) {
    		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get borderless() {
    		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set borderless(value) {
    		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get striped() {
    		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set striped(value) {
    		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dark() {
    		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dark(value) {
    		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hover() {
    		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hover(value) {
    		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get responsive() {
    		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set responsive(value) {
    		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rows() {
    		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rows(value) {
    		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\front\Home.svelte generated by Svelte v3.47.0 */

    const file$w = "src\\front\\Home.svelte";

    // (8:4) <NavbarBrand style=color:black; href="#/info">
    function create_default_slot_1$s(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Cargar APIs");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$s.name,
    		type: "slot",
    		source: "(8:4) <NavbarBrand style=color:black; href=\\\"#/info\\\">",
    		ctx
    	});

    	return block;
    }

    // (7:3) <Navbar style="background-color: lightgreen; color:white;" light expand="lg">
    function create_default_slot$s(ctx) {
    	let navbarbrand;
    	let t;
    	let nav;
    	let current;

    	navbarbrand = new NavbarBrand({
    			props: {
    				style: "color:black;",
    				href: "#/info",
    				$$slots: { default: [create_default_slot_1$s] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	nav = new Nav({ props: { navbar: true }, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(navbarbrand.$$.fragment);
    			t = space();
    			create_component(nav.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbarbrand, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(nav, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navbarbrand_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				navbarbrand_changes.$$scope = { dirty, ctx };
    			}

    			navbarbrand.$set(navbarbrand_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbarbrand.$$.fragment, local);
    			transition_in(nav.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbarbrand.$$.fragment, local);
    			transition_out(nav.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbarbrand, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(nav, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$s.name,
    		type: "slot",
    		source: "(7:3) <Navbar style=\\\"background-color: lightgreen; color:white;\\\" light expand=\\\"lg\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$w(ctx) {
    	let body;
    	let navbar;
    	let current;

    	navbar = new Navbar({
    			props: {
    				style: "background-color: lightgreen; color:white;",
    				light: true,
    				expand: "lg",
    				$$slots: { default: [create_default_slot$s] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			body = element$1("body");
    			create_component(navbar.$$.fragment);
    			add_location(body, file$w, 5, 0, 162);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, body, anchor);
    			mount_component(navbar, body, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const navbar_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				navbar_changes.$$scope = { dirty, ctx };
    			}

    			navbar.$set(navbar_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(body);
    			destroy_component(navbar);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$w($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Home', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Home> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Navbar,
    		Nav,
    		NavItem,
    		NavLink,
    		NavbarBrand,
    		Dropdown,
    		DropdownToggle,
    		DropdownMenu,
    		DropdownItem,
    		Button
    	});

    	return [];
    }

    class Home extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$w, create_fragment$w, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Home",
    			options,
    			id: create_fragment$w.name
    		});
    	}
    }

    /* src\front\Info.svelte generated by Svelte v3.47.0 */

    const file$v = "src\\front\\Info.svelte";

    // (8:2) <NavbarBrand href="#/info">
    function create_default_slot_21$q(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("INICIO");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_21$q.name,
    		type: "slot",
    		source: "(8:2) <NavbarBrand href=\\\"#/info\\\">",
    		ctx
    	});

    	return block;
    }

    // (11:4) <DropdownToggle nav caret>
    function create_default_slot_20$q(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("API");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_20$q.name,
    		type: "slot",
    		source: "(11:4) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (13:6) <DropdownItem href="./api/v2/economies">
    function create_default_slot_19$q(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_19$q.name,
    		type: "slot",
    		source: "(13:6) <DropdownItem href=\\\"./api/v2/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (15:6) <DropdownItem href="./api/v1/esco-stats">
    function create_default_slot_18$q(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_18$q.name,
    		type: "slot",
    		source: "(15:6) <DropdownItem href=\\\"./api/v1/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (17:6) <DropdownItem href="./api/v1/expo">
    function create_default_slot_17$q(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17$q.name,
    		type: "slot",
    		source: "(17:6) <DropdownItem href=\\\"./api/v1/expo\\\">",
    		ctx
    	});

    	return block;
    }

    // (12:4) <DropdownMenu end>
    function create_default_slot_16$q(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./api/v2/economies",
    				$$slots: { default: [create_default_slot_19$q] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "./api/v1/esco-stats",
    				$$slots: { default: [create_default_slot_18$q] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "./api/v1/expo",
    				$$slots: { default: [create_default_slot_17$q] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16$q.name,
    		type: "slot",
    		source: "(12:4) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (10:3) <Dropdown >
    function create_default_slot_15$q(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_20$q] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_16$q] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15$q.name,
    		type: "slot",
    		source: "(10:3) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (22:4) <DropdownToggle nav caret>
    function create_default_slot_14$q(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14$q.name,
    		type: "slot",
    		source: "(22:4) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (24:6) <DropdownItem href="./#/economies">
    function create_default_slot_13$q(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13$q.name,
    		type: "slot",
    		source: "(24:6) <DropdownItem href=\\\"./#/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (26:6) <DropdownItem href="./#/esco-stats">
    function create_default_slot_12$q(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12$q.name,
    		type: "slot",
    		source: "(26:6) <DropdownItem href=\\\"./#/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (28:6) <DropdownItem href="#/expo">
    function create_default_slot_11$q(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Expo FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$q.name,
    		type: "slot",
    		source: "(28:6) <DropdownItem href=\\\"#/expo\\\">",
    		ctx
    	});

    	return block;
    }

    // (23:4) <DropdownMenu end>
    function create_default_slot_10$q(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies",
    				$$slots: { default: [create_default_slot_13$q] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "./#/esco-stats",
    				$$slots: { default: [create_default_slot_12$q] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/expo",
    				$$slots: { default: [create_default_slot_11$q] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$q.name,
    		type: "slot",
    		source: "(23:4) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (21:12) <Dropdown>
    function create_default_slot_9$q(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_14$q] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_10$q] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$q.name,
    		type: "slot",
    		source: "(21:12) <Dropdown>",
    		ctx
    	});

    	return block;
    }

    // (33:3) <DropdownToggle nav caret>
    function create_default_slot_8$q(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Gráficas");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$q.name,
    		type: "slot",
    		source: "(33:3) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (35:5) <DropdownItem href="./#/economies-graph">
    function create_default_slot_7$q(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$q.name,
    		type: "slot",
    		source: "(35:5) <DropdownItem href=\\\"./#/economies-graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (37:5) <DropdownItem href="./#/graphesco">
    function create_default_slot_6$q(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$q.name,
    		type: "slot",
    		source: "(37:5) <DropdownItem href=\\\"./#/graphesco\\\">",
    		ctx
    	});

    	return block;
    }

    // (39:5) <DropdownItem href="#/graphexpo">
    function create_default_slot_5$q(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$q.name,
    		type: "slot",
    		source: "(39:5) <DropdownItem href=\\\"#/graphexpo\\\">",
    		ctx
    	});

    	return block;
    }

    // (41:13) <DropdownItem href="./#/graph">
    function create_default_slot_4$r(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Grafica comun");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$r.name,
    		type: "slot",
    		source: "(41:13) <DropdownItem href=\\\"./#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (34:3) <DropdownMenu end>
    function create_default_slot_3$r(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let t4;
    	let dropdownitem5;
    	let t5;
    	let dropdownitem6;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies-graph",
    				$$slots: { default: [create_default_slot_7$q] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "./#/graphesco",
    				$$slots: { default: [create_default_slot_6$q] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/graphexpo",
    				$$slots: { default: [create_default_slot_5$q] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem5 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem6 = new DropdownItem({
    			props: {
    				href: "./#/graph",
    				$$slots: { default: [create_default_slot_4$r] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    			t4 = space();
    			create_component(dropdownitem5.$$.fragment);
    			t5 = space();
    			create_component(dropdownitem6.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(dropdownitem5, target, anchor);
    			insert_dev(target, t5, anchor);
    			mount_component(dropdownitem6, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    			const dropdownitem6_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdownitem6_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem6.$set(dropdownitem6_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			transition_in(dropdownitem5.$$.fragment, local);
    			transition_in(dropdownitem6.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			transition_out(dropdownitem5.$$.fragment, local);
    			transition_out(dropdownitem6.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(dropdownitem5, detaching);
    			if (detaching) detach_dev(t5);
    			destroy_component(dropdownitem6, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$r.name,
    		type: "slot",
    		source: "(34:3) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (32:4) <Dropdown >
    function create_default_slot_2$r(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_8$q] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_3$r] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$r.name,
    		type: "slot",
    		source: "(32:4) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (9:2) <Nav navbar>
    function create_default_slot_1$r(ctx) {
    	let dropdown0;
    	let t0;
    	let dropdown1;
    	let t1;
    	let dropdown2;
    	let current;

    	dropdown0 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_15$q] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown1 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_9$q] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown2 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_2$r] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdown0.$$.fragment);
    			t0 = space();
    			create_component(dropdown1.$$.fragment);
    			t1 = space();
    			create_component(dropdown2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdown0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdown1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdown2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdown0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdown0_changes.$$scope = { dirty, ctx };
    			}

    			dropdown0.$set(dropdown0_changes);
    			const dropdown1_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdown1_changes.$$scope = { dirty, ctx };
    			}

    			dropdown1.$set(dropdown1_changes);
    			const dropdown2_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdown2_changes.$$scope = { dirty, ctx };
    			}

    			dropdown2.$set(dropdown2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdown0.$$.fragment, local);
    			transition_in(dropdown1.$$.fragment, local);
    			transition_in(dropdown2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdown0.$$.fragment, local);
    			transition_out(dropdown1.$$.fragment, local);
    			transition_out(dropdown2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdown0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdown1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdown2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$r.name,
    		type: "slot",
    		source: "(9:2) <Nav navbar>",
    		ctx
    	});

    	return block;
    }

    // (7:4) <Navbar style="background-color: lightgreen; color:white;" light expand="lg" >
    function create_default_slot$r(ctx) {
    	let navbarbrand;
    	let t;
    	let nav;
    	let current;

    	navbarbrand = new NavbarBrand({
    			props: {
    				href: "#/info",
    				$$slots: { default: [create_default_slot_21$q] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	nav = new Nav({
    			props: {
    				navbar: true,
    				$$slots: { default: [create_default_slot_1$r] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navbarbrand.$$.fragment);
    			t = space();
    			create_component(nav.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbarbrand, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(nav, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navbarbrand_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				navbarbrand_changes.$$scope = { dirty, ctx };
    			}

    			navbarbrand.$set(navbarbrand_changes);
    			const nav_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				nav_changes.$$scope = { dirty, ctx };
    			}

    			nav.$set(nav_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbarbrand.$$.fragment, local);
    			transition_in(nav.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbarbrand.$$.fragment, local);
    			transition_out(nav.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbarbrand, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(nav, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$r.name,
    		type: "slot",
    		source: "(7:4) <Navbar style=\\\"background-color: lightgreen; color:white;\\\" light expand=\\\"lg\\\" >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$v(ctx) {
    	let body;
    	let navbar;
    	let t0;
    	let main;
    	let h1;
    	let t2;
    	let h30;
    	let t4;
    	let p0;
    	let t5;
    	let a0;
    	let t7;
    	let p1;
    	let t8;
    	let a1;
    	let t10;
    	let p2;
    	let t11;
    	let a2;
    	let t13;
    	let br0;
    	let t14;
    	let h31;
    	let t16;
    	let br1;
    	let br2;
    	let t17;
    	let h32;
    	let a3;
    	let t20;
    	let br3;
    	let br4;
    	let t21;
    	let h33;
    	let a4;
    	let t24;
    	let br5;
    	let br6;
    	let t25;
    	let h34;
    	let t27;
    	let p3;
    	let t28;
    	let a5;
    	let t30;
    	let a6;
    	let t32;
    	let t33;
    	let p4;
    	let t34;
    	let a7;
    	let t36;
    	let a8;
    	let t38;
    	let t39;
    	let p5;
    	let t40;
    	let a9;
    	let t42;
    	let a10;
    	let t44;
    	let t45;
    	let br7;
    	let t46;
    	let h35;
    	let t48;
    	let p6;
    	let t49;
    	let a11;
    	let t51;
    	let a12;
    	let t53;
    	let t54;
    	let p7;
    	let t55;
    	let a13;
    	let t57;
    	let a14;
    	let t59;
    	let t60;
    	let p8;
    	let t61;
    	let a15;
    	let t63;
    	let a16;
    	let t65;
    	let t66;
    	let br8;
    	let t67;
    	let h36;
    	let t69;
    	let p9;
    	let t70;
    	let a17;
    	let t72;
    	let a18;
    	let t74;
    	let t75;
    	let p10;
    	let t76;
    	let a19;
    	let t78;
    	let a20;
    	let t80;
    	let t81;
    	let p11;
    	let t82;
    	let a21;
    	let t84;
    	let a22;
    	let t86;
    	let t87;
    	let br9;
    	let t88;
    	let h37;
    	let t90;
    	let p12;
    	let t91;
    	let a23;
    	let t93;
    	let a24;
    	let t95;
    	let t96;
    	let p13;
    	let t97;
    	let a25;
    	let t99;
    	let a26;
    	let t101;
    	let t102;
    	let p14;
    	let t103;
    	let a27;
    	let t105;
    	let a28;
    	let t107;
    	let t108;
    	let br10;
    	let t109;
    	let h38;
    	let t111;
    	let p15;
    	let t112;
    	let a29;
    	let t114;
    	let br11;
    	let t115;
    	let h39;
    	let a30;
    	let t117;
    	let br12;
    	let t118;
    	let h310;
    	let a31;
    	let current;

    	navbar = new Navbar({
    			props: {
    				style: "background-color: lightgreen; color:white;",
    				light: true,
    				expand: "lg",
    				$$slots: { default: [create_default_slot$r] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			body = element$1("body");
    			create_component(navbar.$$.fragment);
    			t0 = space();
    			main = element$1("main");
    			h1 = element$1("h1");
    			h1.textContent = "SOS2122-25";
    			t2 = space();
    			h30 = element$1("h3");
    			h30.textContent = "Team";
    			t4 = space();
    			p0 = element$1("p");
    			t5 = text$1("- ");
    			a0 = element$1("a");
    			a0.textContent = "Damian Gonzalez Carrasco";
    			t7 = space();
    			p1 = element$1("p");
    			t8 = text$1("- ");
    			a1 = element$1("a");
    			a1.textContent = "Angel Simon Mesa";
    			t10 = space();
    			p2 = element$1("p");
    			t11 = text$1("- ");
    			a2 = element$1("a");
    			a2.textContent = "Adrián Pérez Gómez";
    			t13 = space();
    			br0 = element$1("br");
    			t14 = space();
    			h31 = element$1("h3");
    			h31.textContent = "Project description:";
    			t16 = text$1(" Nuestras fuentes de información esta orientadas a analizar la relación que existe entre las exportaciones. \r\n    ");
    			br1 = element$1("br");
    			br2 = element$1("br");
    			t17 = space();
    			h32 = element$1("h3");
    			h32.textContent = "Repository:";
    			a3 = element$1("a");
    			a3.textContent = "gti-sos/SOS2122-25";
    			t20 = space();
    			br3 = element$1("br");
    			br4 = element$1("br");
    			t21 = space();
    			h33 = element$1("h3");
    			h33.textContent = "URL:";
    			a4 = element$1("a");
    			a4.textContent = "http://SOS2122-25.herokuapp.com";
    			t24 = space();
    			br5 = element$1("br");
    			br6 = element$1("br");
    			t25 = space();
    			h34 = element$1("h3");
    			h34.textContent = "Documentos POSTMAN:";
    			t27 = space();
    			p3 = element$1("p");
    			t28 = text$1("- ");
    			a5 = element$1("a");
    			a5.textContent = "https://SOS2122-25.herokuapp.com/api/v2/economies/docs ";
    			t30 = text$1("(developed by ");
    			a6 = element$1("a");
    			a6.textContent = "Damian Gonzalez Carrasco";
    			t32 = text$1(")");
    			t33 = space();
    			p4 = element$1("p");
    			t34 = text$1("- ");
    			a7 = element$1("a");
    			a7.textContent = "https://SOS2122-25.herokuapp.com/api/v1/esco-stats/docs ";
    			t36 = text$1("(developed by ");
    			a8 = element$1("a");
    			a8.textContent = "Angel Simon Mesa";
    			t38 = text$1(")");
    			t39 = space();
    			p5 = element$1("p");
    			t40 = text$1("- ");
    			a9 = element$1("a");
    			a9.textContent = "https://SOS2122-25.herokuapp.com/api/v1/expo/docs ";
    			t42 = text$1("(developed by ");
    			a10 = element$1("a");
    			a10.textContent = "Adrián Pérez Gómez";
    			t44 = text$1(")");
    			t45 = space();
    			br7 = element$1("br");
    			t46 = space();
    			h35 = element$1("h3");
    			h35.textContent = "APIS:";
    			t48 = space();
    			p6 = element$1("p");
    			t49 = text$1("- ");
    			a11 = element$1("a");
    			a11.textContent = "https://SOS2122-25.herokuapp.com/api/v2/economies ";
    			t51 = text$1("(developed by ");
    			a12 = element$1("a");
    			a12.textContent = "Damiangc99";
    			t53 = text$1(")");
    			t54 = space();
    			p7 = element$1("p");
    			t55 = text$1("- ");
    			a13 = element$1("a");
    			a13.textContent = "https://SOS2122-25.herokuapp.com/api/v1/esco-stats ";
    			t57 = text$1("(developed by ");
    			a14 = element$1("a");
    			a14.textContent = "Angel Simon Mesa";
    			t59 = text$1(")");
    			t60 = space();
    			p8 = element$1("p");
    			t61 = text$1("- ");
    			a15 = element$1("a");
    			a15.textContent = "https://SOS2122-25.herokuapp.com/api/v1/expo ";
    			t63 = text$1("(developed by ");
    			a16 = element$1("a");
    			a16.textContent = "Adrián Pérez Gómez";
    			t65 = text$1(")");
    			t66 = space();
    			br8 = element$1("br");
    			t67 = space();
    			h36 = element$1("h3");
    			h36.textContent = "FRONT-END:";
    			t69 = space();
    			p9 = element$1("p");
    			t70 = text$1("- ");
    			a17 = element$1("a");
    			a17.textContent = "https://SOS2122-25.herokuapp.com/#/economies ";
    			t72 = text$1("(developed by ");
    			a18 = element$1("a");
    			a18.textContent = "Damiangc99";
    			t74 = text$1(")");
    			t75 = space();
    			p10 = element$1("p");
    			t76 = text$1("- ");
    			a19 = element$1("a");
    			a19.textContent = "https://SOS2122-25.herokuapp.com/#/esco-stats ";
    			t78 = text$1("(developed by ");
    			a20 = element$1("a");
    			a20.textContent = "Angel Simon Mesa";
    			t80 = text$1(")");
    			t81 = space();
    			p11 = element$1("p");
    			t82 = text$1("- ");
    			a21 = element$1("a");
    			a21.textContent = "https://SOS2122-25.herokuapp.com/#/expo ";
    			t84 = text$1("(developed by ");
    			a22 = element$1("a");
    			a22.textContent = "Adrián Pérez Gómez";
    			t86 = text$1(")");
    			t87 = space();
    			br9 = element$1("br");
    			t88 = space();
    			h37 = element$1("h3");
    			h37.textContent = "GRÁFICAS:";
    			t90 = space();
    			p12 = element$1("p");
    			t91 = text$1("- ");
    			a23 = element$1("a");
    			a23.textContent = "https://SOS2122-25.herokuapp.com/#/economies-graph ";
    			t93 = text$1("(developed by ");
    			a24 = element$1("a");
    			a24.textContent = "Damiangc99";
    			t95 = text$1(")");
    			t96 = space();
    			p13 = element$1("p");
    			t97 = text$1("- ");
    			a25 = element$1("a");
    			a25.textContent = "https://SOS2122-25.herokuapp.com/#/graphesco ";
    			t99 = text$1("(developed by ");
    			a26 = element$1("a");
    			a26.textContent = "Angel Simon Mesa";
    			t101 = text$1(")");
    			t102 = space();
    			p14 = element$1("p");
    			t103 = text$1("- ");
    			a27 = element$1("a");
    			a27.textContent = "https://SOS2122-25.herokuapp.com/#/graphexpo ";
    			t105 = text$1("(developed by ");
    			a28 = element$1("a");
    			a28.textContent = "Adrián Pérez Gómez";
    			t107 = text$1(")");
    			t108 = space();
    			br10 = element$1("br");
    			t109 = space();
    			h38 = element$1("h3");
    			h38.textContent = "GRÁFICA COMÚN:";
    			t111 = space();
    			p15 = element$1("p");
    			t112 = text$1("- ");
    			a29 = element$1("a");
    			a29.textContent = "https://SOS2122-25.herokuapp.com/#/graph";
    			t114 = space();
    			br11 = element$1("br");
    			t115 = space();
    			h39 = element$1("h3");
    			a30 = element$1("a");
    			a30.textContent = "INTEGRACIONES";
    			t117 = space();
    			br12 = element$1("br");
    			t118 = space();
    			h310 = element$1("h3");
    			a31 = element$1("a");
    			a31.textContent = "VIDEOS";
    			add_location(body, file$v, 5, 0, 162);
    			attr_dev(h1, "class", "svelte-14b11ol");
    			add_location(h1, file$v, 50, 4, 1864);
    			add_location(h30, file$v, 52, 4, 1891);
    			attr_dev(a0, "href", "https://github.com/damiangc99");
    			add_location(a0, file$v, 53, 9, 1915);
    			add_location(p0, file$v, 53, 4, 1910);
    			attr_dev(a1, "href", "https://github.com/AngelSM11");
    			add_location(a1, file$v, 54, 9, 1998);
    			add_location(p1, file$v, 54, 4, 1993);
    			attr_dev(a2, "href", "https://github.com/adriperez01");
    			add_location(a2, file$v, 55, 9, 2074);
    			add_location(p2, file$v, 55, 4, 2069);
    			add_location(br0, file$v, 56, 4, 2147);
    			add_location(h31, file$v, 57, 4, 2157);
    			add_location(br1, file$v, 58, 4, 2300);
    			add_location(br2, file$v, 58, 8, 2304);
    			add_location(h32, file$v, 59, 4, 2314);
    			attr_dev(a3, "href", "https://github.com/gti-sos/SOS2122-25.git");
    			add_location(a3, file$v, 59, 24, 2334);
    			add_location(br3, file$v, 60, 4, 2414);
    			add_location(br4, file$v, 60, 8, 2418);
    			add_location(h33, file$v, 61, 4, 2428);
    			attr_dev(a4, "href", "http://SOS2122-25.herokuapp.com");
    			add_location(a4, file$v, 61, 17, 2441);
    			add_location(br5, file$v, 62, 4, 2524);
    			add_location(br6, file$v, 62, 8, 2528);
    			add_location(h34, file$v, 63, 4, 2538);
    			attr_dev(a5, "href", "https://SOS2122-25.herokuapp.com/api/v2/economies/docs");
    			add_location(a5, file$v, 64, 9, 2577);
    			attr_dev(a6, "href", "https://github.com/damiangc99");
    			add_location(a6, file$v, 64, 147, 2715);
    			add_location(p3, file$v, 64, 4, 2572);
    			attr_dev(a7, "href", "https://documenter.getpostman.com/view/19481634/UyxjFko9");
    			add_location(a7, file$v, 65, 9, 2799);
    			attr_dev(a8, "href", "https://github.com/AngelSM11");
    			add_location(a8, file$v, 65, 150, 2940);
    			add_location(p4, file$v, 65, 4, 2794);
    			attr_dev(a9, "href", "https://SOS2122-25.herokuapp.com/api/v1/expo/docs");
    			add_location(a9, file$v, 66, 9, 3015);
    			attr_dev(a10, "href", "https://github.com/adriperez01");
    			add_location(a10, file$v, 66, 137, 3143);
    			add_location(p5, file$v, 66, 4, 3010);
    			add_location(br7, file$v, 67, 4, 3217);
    			add_location(h35, file$v, 68, 1, 3224);
    			attr_dev(a11, "href", "https://SOS2122-25.herokuapp.com/api/v2/economies");
    			add_location(a11, file$v, 69, 6, 3246);
    			attr_dev(a12, "href", "https://github.com/Damiangc99");
    			add_location(a12, file$v, 69, 134, 3374);
    			add_location(p6, file$v, 69, 1, 3241);
    			attr_dev(a13, "href", "https://SOS2122-25.herokuapp.com/api/v1/esco-stats");
    			add_location(a13, file$v, 70, 6, 3441);
    			attr_dev(a14, "href", "https://github.com/AngelSM11");
    			add_location(a14, file$v, 70, 136, 3571);
    			add_location(p7, file$v, 70, 1, 3436);
    			attr_dev(a15, "href", "https://SOS2122-25.herokuapp.com/api/v1/expo");
    			add_location(a15, file$v, 71, 6, 3643);
    			attr_dev(a16, "href", "https://github.com/adriperez01");
    			add_location(a16, file$v, 71, 124, 3761);
    			add_location(p8, file$v, 71, 1, 3638);
    			add_location(br8, file$v, 72, 4, 3835);
    			add_location(h36, file$v, 73, 4, 3845);
    			attr_dev(a17, "href", "#/economies");
    			add_location(a17, file$v, 74, 6, 3872);
    			attr_dev(a18, "href", "https://github.com/Damiangc99");
    			add_location(a18, file$v, 74, 91, 3957);
    			add_location(p9, file$v, 74, 1, 3867);
    			attr_dev(a19, "href", "#/esco-stats");
    			add_location(a19, file$v, 75, 6, 4024);
    			attr_dev(a20, "href", "https://github.com/AngelSM11");
    			add_location(a20, file$v, 75, 93, 4111);
    			add_location(p10, file$v, 75, 1, 4019);
    			attr_dev(a21, "href", "#/expo");
    			add_location(a21, file$v, 76, 6, 4183);
    			attr_dev(a22, "href", "https://github.com/adriperez01");
    			add_location(a22, file$v, 76, 81, 4258);
    			add_location(p11, file$v, 76, 1, 4178);
    			add_location(br9, file$v, 77, 4, 4332);
    			add_location(h37, file$v, 78, 4, 4342);
    			attr_dev(a23, "href", "./#/economies-graph");
    			add_location(a23, file$v, 79, 9, 4371);
    			attr_dev(a24, "href", "https://github.com/Damiangc99");
    			add_location(a24, file$v, 79, 108, 4470);
    			add_location(p12, file$v, 79, 4, 4366);
    			attr_dev(a25, "href", "./#/graphesco");
    			add_location(a25, file$v, 80, 9, 4540);
    			attr_dev(a26, "href", "https://github.com/AngelSM11");
    			add_location(a26, file$v, 80, 96, 4627);
    			add_location(p13, file$v, 80, 4, 4535);
    			attr_dev(a27, "href", "#/graphexpo");
    			add_location(a27, file$v, 81, 9, 4702);
    			attr_dev(a28, "href", "https://github.com/adriperez01");
    			add_location(a28, file$v, 81, 94, 4787);
    			add_location(p14, file$v, 81, 4, 4697);
    			add_location(br10, file$v, 82, 1, 4858);
    			add_location(h38, file$v, 83, 1, 4865);
    			attr_dev(a29, "href", "./#/graph");
    			add_location(a29, file$v, 84, 6, 4896);
    			add_location(p15, file$v, 84, 1, 4891);
    			add_location(br11, file$v, 85, 1, 4968);
    			attr_dev(a30, "href", "https://SOS2122-25.herokuapp.com/#/integration");
    			add_location(a30, file$v, 86, 5, 4979);
    			add_location(h39, file$v, 86, 1, 4975);
    			add_location(br12, file$v, 87, 1, 5061);
    			attr_dev(a31, "href", "https://SOS2122-25.herokuapp.com/#/about");
    			add_location(a31, file$v, 88, 5, 5072);
    			add_location(h310, file$v, 88, 1, 5068);
    			attr_dev(main, "class", "svelte-14b11ol");
    			add_location(main, file$v, 49, 0, 1852);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, body, anchor);
    			mount_component(navbar, body, null);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			append_dev(main, h1);
    			append_dev(main, t2);
    			append_dev(main, h30);
    			append_dev(main, t4);
    			append_dev(main, p0);
    			append_dev(p0, t5);
    			append_dev(p0, a0);
    			append_dev(main, t7);
    			append_dev(main, p1);
    			append_dev(p1, t8);
    			append_dev(p1, a1);
    			append_dev(main, t10);
    			append_dev(main, p2);
    			append_dev(p2, t11);
    			append_dev(p2, a2);
    			append_dev(main, t13);
    			append_dev(main, br0);
    			append_dev(main, t14);
    			append_dev(main, h31);
    			append_dev(main, t16);
    			append_dev(main, br1);
    			append_dev(main, br2);
    			append_dev(main, t17);
    			append_dev(main, h32);
    			append_dev(main, a3);
    			append_dev(main, t20);
    			append_dev(main, br3);
    			append_dev(main, br4);
    			append_dev(main, t21);
    			append_dev(main, h33);
    			append_dev(main, a4);
    			append_dev(main, t24);
    			append_dev(main, br5);
    			append_dev(main, br6);
    			append_dev(main, t25);
    			append_dev(main, h34);
    			append_dev(main, t27);
    			append_dev(main, p3);
    			append_dev(p3, t28);
    			append_dev(p3, a5);
    			append_dev(p3, t30);
    			append_dev(p3, a6);
    			append_dev(p3, t32);
    			append_dev(main, t33);
    			append_dev(main, p4);
    			append_dev(p4, t34);
    			append_dev(p4, a7);
    			append_dev(p4, t36);
    			append_dev(p4, a8);
    			append_dev(p4, t38);
    			append_dev(main, t39);
    			append_dev(main, p5);
    			append_dev(p5, t40);
    			append_dev(p5, a9);
    			append_dev(p5, t42);
    			append_dev(p5, a10);
    			append_dev(p5, t44);
    			append_dev(main, t45);
    			append_dev(main, br7);
    			append_dev(main, t46);
    			append_dev(main, h35);
    			append_dev(main, t48);
    			append_dev(main, p6);
    			append_dev(p6, t49);
    			append_dev(p6, a11);
    			append_dev(p6, t51);
    			append_dev(p6, a12);
    			append_dev(p6, t53);
    			append_dev(main, t54);
    			append_dev(main, p7);
    			append_dev(p7, t55);
    			append_dev(p7, a13);
    			append_dev(p7, t57);
    			append_dev(p7, a14);
    			append_dev(p7, t59);
    			append_dev(main, t60);
    			append_dev(main, p8);
    			append_dev(p8, t61);
    			append_dev(p8, a15);
    			append_dev(p8, t63);
    			append_dev(p8, a16);
    			append_dev(p8, t65);
    			append_dev(main, t66);
    			append_dev(main, br8);
    			append_dev(main, t67);
    			append_dev(main, h36);
    			append_dev(main, t69);
    			append_dev(main, p9);
    			append_dev(p9, t70);
    			append_dev(p9, a17);
    			append_dev(p9, t72);
    			append_dev(p9, a18);
    			append_dev(p9, t74);
    			append_dev(main, t75);
    			append_dev(main, p10);
    			append_dev(p10, t76);
    			append_dev(p10, a19);
    			append_dev(p10, t78);
    			append_dev(p10, a20);
    			append_dev(p10, t80);
    			append_dev(main, t81);
    			append_dev(main, p11);
    			append_dev(p11, t82);
    			append_dev(p11, a21);
    			append_dev(p11, t84);
    			append_dev(p11, a22);
    			append_dev(p11, t86);
    			append_dev(main, t87);
    			append_dev(main, br9);
    			append_dev(main, t88);
    			append_dev(main, h37);
    			append_dev(main, t90);
    			append_dev(main, p12);
    			append_dev(p12, t91);
    			append_dev(p12, a23);
    			append_dev(p12, t93);
    			append_dev(p12, a24);
    			append_dev(p12, t95);
    			append_dev(main, t96);
    			append_dev(main, p13);
    			append_dev(p13, t97);
    			append_dev(p13, a25);
    			append_dev(p13, t99);
    			append_dev(p13, a26);
    			append_dev(p13, t101);
    			append_dev(main, t102);
    			append_dev(main, p14);
    			append_dev(p14, t103);
    			append_dev(p14, a27);
    			append_dev(p14, t105);
    			append_dev(p14, a28);
    			append_dev(p14, t107);
    			append_dev(main, t108);
    			append_dev(main, br10);
    			append_dev(main, t109);
    			append_dev(main, h38);
    			append_dev(main, t111);
    			append_dev(main, p15);
    			append_dev(p15, t112);
    			append_dev(p15, a29);
    			append_dev(main, t114);
    			append_dev(main, br11);
    			append_dev(main, t115);
    			append_dev(main, h39);
    			append_dev(h39, a30);
    			append_dev(main, t117);
    			append_dev(main, br12);
    			append_dev(main, t118);
    			append_dev(main, h310);
    			append_dev(h310, a31);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const navbar_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				navbar_changes.$$scope = { dirty, ctx };
    			}

    			navbar.$set(navbar_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(body);
    			destroy_component(navbar);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$v($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Info', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Info> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Navbar,
    		Nav,
    		NavItem,
    		NavLink,
    		NavbarBrand,
    		Dropdown,
    		DropdownToggle,
    		DropdownMenu,
    		DropdownItem,
    		Button
    	});

    	return [];
    }

    class Info extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$v, create_fragment$v, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Info",
    			options,
    			id: create_fragment$v.name
    		});
    	}
    }

    /* src\front\esco-stats\esco.svelte generated by Svelte v3.47.0 */

    const { console: console_1$r } = globals;

    const file$u = "src\\front\\esco-stats\\esco.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[29] = list[i];
    	return child_ctx;
    }

    // (190:2) <NavbarBrand href="#/info">
    function create_default_slot_34$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("INICIO");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_34$2.name,
    		type: "slot",
    		source: "(190:2) <NavbarBrand href=\\\"#/info\\\">",
    		ctx
    	});

    	return block;
    }

    // (193:4) <DropdownToggle nav caret>
    function create_default_slot_33$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("API");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_33$2.name,
    		type: "slot",
    		source: "(193:4) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (195:6) <DropdownItem href="./api/v2/economies">
    function create_default_slot_32$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Econmies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_32$2.name,
    		type: "slot",
    		source: "(195:6) <DropdownItem href=\\\"./api/v2/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (197:6) <DropdownItem href="./api/v1/esco-stats">
    function create_default_slot_31$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_31$2.name,
    		type: "slot",
    		source: "(197:6) <DropdownItem href=\\\"./api/v1/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (199:6) <DropdownItem href="./api/v1/expo">
    function create_default_slot_30$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_30$2.name,
    		type: "slot",
    		source: "(199:6) <DropdownItem href=\\\"./api/v1/expo\\\">",
    		ctx
    	});

    	return block;
    }

    // (194:4) <DropdownMenu end>
    function create_default_slot_29$2(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./api/v2/economies",
    				$$slots: { default: [create_default_slot_32$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "./api/v1/esco-stats",
    				$$slots: { default: [create_default_slot_31$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "./api/v1/expo",
    				$$slots: { default: [create_default_slot_30$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem2_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_29$2.name,
    		type: "slot",
    		source: "(194:4) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (192:3) <Dropdown >
    function create_default_slot_28$2(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_33$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_29$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_28$2.name,
    		type: "slot",
    		source: "(192:3) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (204:4) <DropdownToggle nav caret>
    function create_default_slot_27$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_27$3.name,
    		type: "slot",
    		source: "(204:4) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (206:6) <DropdownItem href="./#/economies">
    function create_default_slot_26$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_26$3.name,
    		type: "slot",
    		source: "(206:6) <DropdownItem href=\\\"./#/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (208:6) <DropdownItem href="./#/esco-stats">
    function create_default_slot_25$6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco FRONT_END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_25$6.name,
    		type: "slot",
    		source: "(208:6) <DropdownItem href=\\\"./#/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (210:6) <DropdownItem href="#/expo">
    function create_default_slot_24$7(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_24$7.name,
    		type: "slot",
    		source: "(210:6) <DropdownItem href=\\\"#/expo\\\">",
    		ctx
    	});

    	return block;
    }

    // (205:4) <DropdownMenu end>
    function create_default_slot_23$d(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies",
    				$$slots: { default: [create_default_slot_26$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "./#/esco-stats",
    				$$slots: { default: [create_default_slot_25$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/expo",
    				$$slots: { default: [create_default_slot_24$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem2_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_23$d.name,
    		type: "slot",
    		source: "(205:4) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (203:12) <Dropdown>
    function create_default_slot_22$l(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_27$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_23$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_22$l.name,
    		type: "slot",
    		source: "(203:12) <Dropdown>",
    		ctx
    	});

    	return block;
    }

    // (215:4) <DropdownToggle nav caret>
    function create_default_slot_21$p(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Gráficas");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_21$p.name,
    		type: "slot",
    		source: "(215:4) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (217:6) <DropdownItem href="./#/economies-graph">
    function create_default_slot_20$p(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("econmies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_20$p.name,
    		type: "slot",
    		source: "(217:6) <DropdownItem href=\\\"./#/economies-graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (219:6) <DropdownItem href="./#/graphesco">
    function create_default_slot_19$p(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_19$p.name,
    		type: "slot",
    		source: "(219:6) <DropdownItem href=\\\"./#/graphesco\\\">",
    		ctx
    	});

    	return block;
    }

    // (221:6) <DropdownItem href="#/graphexpo">
    function create_default_slot_18$p(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_18$p.name,
    		type: "slot",
    		source: "(221:6) <DropdownItem href=\\\"#/graphexpo\\\">",
    		ctx
    	});

    	return block;
    }

    // (223:6) <DropdownItem href="./#/graph">
    function create_default_slot_17$p(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Grafica comun");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17$p.name,
    		type: "slot",
    		source: "(223:6) <DropdownItem href=\\\"./#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (216:4) <DropdownMenu end>
    function create_default_slot_16$p(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let t4;
    	let dropdownitem5;
    	let t5;
    	let dropdownitem6;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies-graph",
    				$$slots: { default: [create_default_slot_20$p] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "./#/graphesco",
    				$$slots: { default: [create_default_slot_19$p] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/graphexpo",
    				$$slots: { default: [create_default_slot_18$p] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem5 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem6 = new DropdownItem({
    			props: {
    				href: "./#/graph",
    				$$slots: { default: [create_default_slot_17$p] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    			t4 = space();
    			create_component(dropdownitem5.$$.fragment);
    			t5 = space();
    			create_component(dropdownitem6.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(dropdownitem5, target, anchor);
    			insert_dev(target, t5, anchor);
    			mount_component(dropdownitem6, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem2_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    			const dropdownitem6_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				dropdownitem6_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem6.$set(dropdownitem6_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			transition_in(dropdownitem5.$$.fragment, local);
    			transition_in(dropdownitem6.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			transition_out(dropdownitem5.$$.fragment, local);
    			transition_out(dropdownitem6.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(dropdownitem5, detaching);
    			if (detaching) detach_dev(t5);
    			destroy_component(dropdownitem6, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16$p.name,
    		type: "slot",
    		source: "(216:4) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (214:5) <Dropdown >
    function create_default_slot_15$p(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_21$p] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_16$p] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15$p.name,
    		type: "slot",
    		source: "(214:5) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (191:2) <Nav navbar>
    function create_default_slot_14$p(ctx) {
    	let dropdown0;
    	let t0;
    	let dropdown1;
    	let t1;
    	let dropdown2;
    	let current;

    	dropdown0 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_28$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown1 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_22$l] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown2 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_15$p] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdown0.$$.fragment);
    			t0 = space();
    			create_component(dropdown1.$$.fragment);
    			t1 = space();
    			create_component(dropdown2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdown0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdown1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdown2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdown0_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				dropdown0_changes.$$scope = { dirty, ctx };
    			}

    			dropdown0.$set(dropdown0_changes);
    			const dropdown1_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				dropdown1_changes.$$scope = { dirty, ctx };
    			}

    			dropdown1.$set(dropdown1_changes);
    			const dropdown2_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				dropdown2_changes.$$scope = { dirty, ctx };
    			}

    			dropdown2.$set(dropdown2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdown0.$$.fragment, local);
    			transition_in(dropdown1.$$.fragment, local);
    			transition_in(dropdown2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdown0.$$.fragment, local);
    			transition_out(dropdown1.$$.fragment, local);
    			transition_out(dropdown2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdown0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdown1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdown2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14$p.name,
    		type: "slot",
    		source: "(191:2) <Nav navbar>",
    		ctx
    	});

    	return block;
    }

    // (189:1) <Navbar style="background-color: lightgreen; color:white;" light expand="lg" >
    function create_default_slot_13$p(ctx) {
    	let navbarbrand;
    	let t;
    	let nav;
    	let current;

    	navbarbrand = new NavbarBrand({
    			props: {
    				href: "#/info",
    				$$slots: { default: [create_default_slot_34$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	nav = new Nav({
    			props: {
    				navbar: true,
    				$$slots: { default: [create_default_slot_14$p] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navbarbrand.$$.fragment);
    			t = space();
    			create_component(nav.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbarbrand, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(nav, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navbarbrand_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				navbarbrand_changes.$$scope = { dirty, ctx };
    			}

    			navbarbrand.$set(navbarbrand_changes);
    			const nav_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				nav_changes.$$scope = { dirty, ctx };
    			}

    			nav.$set(nav_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbarbrand.$$.fragment, local);
    			transition_in(nav.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbarbrand.$$.fragment, local);
    			transition_out(nav.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbarbrand, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(nav, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13$p.name,
    		type: "slot",
    		source: "(189:1) <Navbar style=\\\"background-color: lightgreen; color:white;\\\" light expand=\\\"lg\\\" >",
    		ctx
    	});

    	return block;
    }

    // (232:1) <Button on:click="{getPgAnt}">
    function create_default_slot_12$p(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Página Anterior");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12$p.name,
    		type: "slot",
    		source: "(232:1) <Button on:click=\\\"{getPgAnt}\\\">",
    		ctx
    	});

    	return block;
    }

    // (235:1) <Button on:click="{getPgSig}">
    function create_default_slot_11$p(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Página Siguiente");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$p.name,
    		type: "slot",
    		source: "(235:1) <Button on:click=\\\"{getPgSig}\\\">",
    		ctx
    	});

    	return block;
    }

    // (1:0) <script>      import {onMount}
    function create_catch_block$5(ctx) {
    	const block = {
    		c: noop$4,
    		m: noop$4,
    		p: noop$4,
    		i: noop$4,
    		o: noop$4,
    		d: noop$4
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block$5.name,
    		type: "catch",
    		source: "(1:0) <script>      import {onMount}",
    		ctx
    	});

    	return block;
    }

    // (240:1) {:then esco}
    function create_then_block$5(ctx) {
    	let alert;
    	let t0;
    	let table0;
    	let t1;
    	let table1;
    	let current;

    	alert = new Alert({
    			props: {
    				color: /*color*/ ctx[4],
    				isOpen: /*visible*/ ctx[3],
    				toggle: /*func*/ ctx[14],
    				$$slots: { default: [create_default_slot_10$p] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	table0 = new Table({
    			props: {
    				bordered: true,
    				$$slots: { default: [create_default_slot_7$p] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	table1 = new Table({
    			props: {
    				bordered: true,
    				$$slots: { default: [create_default_slot$q] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(alert.$$.fragment);
    			t0 = space();
    			create_component(table0.$$.fragment);
    			t1 = space();
    			create_component(table1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(alert, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(table0, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(table1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const alert_changes = {};
    			if (dirty[0] & /*color*/ 16) alert_changes.color = /*color*/ ctx[4];
    			if (dirty[0] & /*visible*/ 8) alert_changes.isOpen = /*visible*/ ctx[3];
    			if (dirty[0] & /*visible*/ 8) alert_changes.toggle = /*func*/ ctx[14];

    			if (dirty[0] & /*checkMSG*/ 4 | dirty[1] & /*$$scope*/ 2) {
    				alert_changes.$$scope = { dirty, ctx };
    			}

    			alert.$set(alert_changes);
    			const table0_changes = {};

    			if (dirty[0] & /*from, to, color, checkMSG, visible*/ 31 | dirty[1] & /*$$scope*/ 2) {
    				table0_changes.$$scope = { dirty, ctx };
    			}

    			table0.$set(table0_changes);
    			const table1_changes = {};

    			if (dirty[0] & /*esco, newesco*/ 96 | dirty[1] & /*$$scope*/ 2) {
    				table1_changes.$$scope = { dirty, ctx };
    			}

    			table1.$set(table1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(alert.$$.fragment, local);
    			transition_in(table0.$$.fragment, local);
    			transition_in(table1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(alert.$$.fragment, local);
    			transition_out(table0.$$.fragment, local);
    			transition_out(table1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(alert, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(table0, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(table1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block$5.name,
    		type: "then",
    		source: "(240:1) {:then esco}",
    		ctx
    	});

    	return block;
    }

    // (243:2) {#if checkMSG}
    function create_if_block$8(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1(/*checkMSG*/ ctx[2]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*checkMSG*/ 4) set_data_dev(t, /*checkMSG*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$8.name,
    		type: "if",
    		source: "(243:2) {#if checkMSG}",
    		ctx
    	});

    	return block;
    }

    // (242:1) <Alert color={color} isOpen={visible} toggle={() => (visible = false)}>
    function create_default_slot_10$p(ctx) {
    	let if_block_anchor;
    	let if_block = /*checkMSG*/ ctx[2] && create_if_block$8(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*checkMSG*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$8(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$p.name,
    		type: "slot",
    		source: "(242:1) <Alert color={color} isOpen={visible} toggle={() => (visible = false)}>",
    		ctx
    	});

    	return block;
    }

    // (261:22) <Button outline color="dark" on:click="{()=>{      if (from == null || to == null) {       color="success";       checkMSG="Los campos fecha inicio y fecha fin no pueden estar vacíos";       visible="true";       //window.alert('Los campos fecha inicio y fecha fin no pueden estar vacíos')      }else{       getesco();      }     }}">
    function create_default_slot_9$p(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Buscar");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$p.name,
    		type: "slot",
    		source: "(261:22) <Button outline color=\\\"dark\\\" on:click=\\\"{()=>{      if (from == null || to == null) {       color=\\\"success\\\";       checkMSG=\\\"Los campos fecha inicio y fecha fin no pueden estar vacíos\\\";       visible=\\\"true\\\";       //window.alert('Los campos fecha inicio y fecha fin no pueden estar vacíos')      }else{       getesco();      }     }}\\\">",
    		ctx
    	});

    	return block;
    }

    // (274:22) <Button outline color="info" on:click="{()=>{      from = null;      to = null;      getesco();           }}">
    function create_default_slot_8$p(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Limpiar Búsqueda");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$p.name,
    		type: "slot",
    		source: "(274:22) <Button outline color=\\\"info\\\" on:click=\\\"{()=>{      from = null;      to = null;      getesco();           }}\\\">",
    		ctx
    	});

    	return block;
    }

    // (248:1) <Table bordered>
    function create_default_slot_7$p(ctx) {
    	let thead;
    	let tr0;
    	let th0;
    	let t1;
    	let th1;
    	let t3;
    	let tbody;
    	let tr1;
    	let td0;
    	let input0;
    	let t4;
    	let td1;
    	let input1;
    	let t5;
    	let td2;
    	let button0;
    	let t6;
    	let td3;
    	let button1;
    	let current;
    	let mounted;
    	let dispose;

    	button0 = new Button({
    			props: {
    				outline: true,
    				color: "dark",
    				$$slots: { default: [create_default_slot_9$p] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button0.$on("click", /*click_handler*/ ctx[17]);

    	button1 = new Button({
    			props: {
    				outline: true,
    				color: "info",
    				$$slots: { default: [create_default_slot_8$p] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1.$on("click", /*click_handler_1*/ ctx[18]);

    	const block = {
    		c: function create() {
    			thead = element$1("thead");
    			tr0 = element$1("tr");
    			th0 = element$1("th");
    			th0.textContent = "Fecha de inicio";
    			t1 = space();
    			th1 = element$1("th");
    			th1.textContent = "Fecha fin";
    			t3 = space();
    			tbody = element$1("tbody");
    			tr1 = element$1("tr");
    			td0 = element$1("td");
    			input0 = element$1("input");
    			t4 = space();
    			td1 = element$1("td");
    			input1 = element$1("input");
    			t5 = space();
    			td2 = element$1("td");
    			create_component(button0.$$.fragment);
    			t6 = space();
    			td3 = element$1("td");
    			create_component(button1.$$.fragment);
    			add_location(th0, file$u, 250, 4, 7339);
    			add_location(th1, file$u, 251, 4, 7369);
    			add_location(tr0, file$u, 249, 3, 7329);
    			add_location(thead, file$u, 248, 2, 7317);
    			attr_dev(input0, "type", "number");
    			attr_dev(input0, "min", "0");
    			add_location(input0, file$u, 258, 7, 7443);
    			add_location(td0, file$u, 258, 3, 7439);
    			attr_dev(input1, "type", "number");
    			attr_dev(input1, "min", "0");
    			add_location(input1, file$u, 259, 7, 7506);
    			add_location(td1, file$u, 259, 3, 7502);
    			attr_dev(td2, "align", "center");
    			add_location(td2, file$u, 260, 3, 7563);
    			attr_dev(td3, "align", "center");
    			add_location(td3, file$u, 273, 3, 7958);
    			add_location(tr1, file$u, 257, 2, 7430);
    			add_location(tbody, file$u, 254, 2, 7413);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, thead, anchor);
    			append_dev(thead, tr0);
    			append_dev(tr0, th0);
    			append_dev(tr0, t1);
    			append_dev(tr0, th1);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, tbody, anchor);
    			append_dev(tbody, tr1);
    			append_dev(tr1, td0);
    			append_dev(td0, input0);
    			set_input_value(input0, /*from*/ ctx[0]);
    			append_dev(tr1, t4);
    			append_dev(tr1, td1);
    			append_dev(td1, input1);
    			set_input_value(input1, /*to*/ ctx[1]);
    			append_dev(tr1, t5);
    			append_dev(tr1, td2);
    			mount_component(button0, td2, null);
    			append_dev(tr1, t6);
    			append_dev(tr1, td3);
    			mount_component(button1, td3, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[15]),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[16])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*from*/ 1 && to_number(input0.value) !== /*from*/ ctx[0]) {
    				set_input_value(input0, /*from*/ ctx[0]);
    			}

    			if (dirty[0] & /*to*/ 2 && to_number(input1.value) !== /*to*/ ctx[1]) {
    				set_input_value(input1, /*to*/ ctx[1]);
    			}

    			const button0_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(thead);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(tbody);
    			destroy_component(button0);
    			destroy_component(button1);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$p.name,
    		type: "slot",
    		source: "(248:1) <Table bordered>",
    		ctx
    	});

    	return block;
    }

    // (306:8) <Button outline color="primary" on:click="{insertesco}">
    function create_default_slot_6$p(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Añadir");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$p.name,
    		type: "slot",
    		source: "(306:8) <Button outline color=\\\"primary\\\" on:click=\\\"{insertesco}\\\">",
    		ctx
    	});

    	return block;
    }

    // (310:23) <Button outline color="primary" on:click="{()=>{       newesco.country = null;       newesco.year = null;       newesco.tot_wom = null;       newesco.tot_man = null;       newesco.tot_esco = null;      }}">
    function create_default_slot_5$p(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Limpiar");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$p.name,
    		type: "slot",
    		source: "(310:23) <Button outline color=\\\"primary\\\" on:click=\\\"{()=>{       newesco.country = null;       newesco.year = null;       newesco.tot_wom = null;       newesco.tot_man = null;       newesco.tot_esco = null;      }}\\\">",
    		ctx
    	});

    	return block;
    }

    // (329:8) <Button outline color="warning" on:click={function (){       window.location.href = `/#/esco/${escoa.country}/${escoa.year}`      }}>
    function create_default_slot_4$q(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Editar");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$q.name,
    		type: "slot",
    		source: "(329:8) <Button outline color=\\\"warning\\\" on:click={function (){       window.location.href = `/#/esco/${escoa.country}/${escoa.year}`      }}>",
    		ctx
    	});

    	return block;
    }

    // (334:8) <Button outline color="danger" on:click={Borraresco(escoa.country,escoa.year)}>
    function create_default_slot_3$q(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Borrar");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$q.name,
    		type: "slot",
    		source: "(334:8) <Button outline color=\\\"danger\\\" on:click={Borraresco(escoa.country,escoa.year)}>",
    		ctx
    	});

    	return block;
    }

    // (321:3) {#each esco as escoa}
    function create_each_block$2(ctx) {
    	let tr;
    	let td0;
    	let t0_value = /*escoa*/ ctx[29].country + "";
    	let t0;
    	let t1;
    	let td1;
    	let t2_value = /*escoa*/ ctx[29].year + "";
    	let t2;
    	let t3;
    	let td2;
    	let t4_value = /*escoa*/ ctx[29].tot_wom + "";
    	let t4;
    	let t5;
    	let td3;
    	let t6_value = /*escoa*/ ctx[29].tot_man + "";
    	let t6;
    	let t7;
    	let td4;
    	let t8_value = /*escoa*/ ctx[29].tot_esco + "";
    	let t8;
    	let t9;
    	let td5;
    	let button0;
    	let t10;
    	let td6;
    	let button1;
    	let current;

    	function click_handler_3() {
    		return /*click_handler_3*/ ctx[25](/*escoa*/ ctx[29]);
    	}

    	button0 = new Button({
    			props: {
    				outline: true,
    				color: "warning",
    				$$slots: { default: [create_default_slot_4$q] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button0.$on("click", click_handler_3);

    	button1 = new Button({
    			props: {
    				outline: true,
    				color: "danger",
    				$$slots: { default: [create_default_slot_3$q] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1.$on("click", function () {
    		if (is_function(/*Borraresco*/ ctx[11](/*escoa*/ ctx[29].country, /*escoa*/ ctx[29].year))) /*Borraresco*/ ctx[11](/*escoa*/ ctx[29].country, /*escoa*/ ctx[29].year).apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			tr = element$1("tr");
    			td0 = element$1("td");
    			t0 = text$1(t0_value);
    			t1 = space();
    			td1 = element$1("td");
    			t2 = text$1(t2_value);
    			t3 = space();
    			td2 = element$1("td");
    			t4 = text$1(t4_value);
    			t5 = space();
    			td3 = element$1("td");
    			t6 = text$1(t6_value);
    			t7 = space();
    			td4 = element$1("td");
    			t8 = text$1(t8_value);
    			t9 = space();
    			td5 = element$1("td");
    			create_component(button0.$$.fragment);
    			t10 = space();
    			td6 = element$1("td");
    			create_component(button1.$$.fragment);
    			add_location(td0, file$u, 322, 4, 9183);
    			add_location(td1, file$u, 323, 4, 9213);
    			add_location(td2, file$u, 324, 16, 9252);
    			add_location(td3, file$u, 325, 16, 9294);
    			add_location(td4, file$u, 326, 16, 9336);
    			add_location(td5, file$u, 328, 4, 9369);
    			add_location(td6, file$u, 333, 4, 9540);
    			add_location(tr, file$u, 321, 3, 9173);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, t0);
    			append_dev(tr, t1);
    			append_dev(tr, td1);
    			append_dev(td1, t2);
    			append_dev(tr, t3);
    			append_dev(tr, td2);
    			append_dev(td2, t4);
    			append_dev(tr, t5);
    			append_dev(tr, td3);
    			append_dev(td3, t6);
    			append_dev(tr, t7);
    			append_dev(tr, td4);
    			append_dev(td4, t8);
    			append_dev(tr, t9);
    			append_dev(tr, td5);
    			mount_component(button0, td5, null);
    			append_dev(td5, t10);
    			append_dev(tr, td6);
    			mount_component(button1, td6, null);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if ((!current || dirty[0] & /*esco*/ 64) && t0_value !== (t0_value = /*escoa*/ ctx[29].country + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty[0] & /*esco*/ 64) && t2_value !== (t2_value = /*escoa*/ ctx[29].year + "")) set_data_dev(t2, t2_value);
    			if ((!current || dirty[0] & /*esco*/ 64) && t4_value !== (t4_value = /*escoa*/ ctx[29].tot_wom + "")) set_data_dev(t4, t4_value);
    			if ((!current || dirty[0] & /*esco*/ 64) && t6_value !== (t6_value = /*escoa*/ ctx[29].tot_man + "")) set_data_dev(t6, t6_value);
    			if ((!current || dirty[0] & /*esco*/ 64) && t8_value !== (t8_value = /*escoa*/ ctx[29].tot_esco + "")) set_data_dev(t8, t8_value);
    			const button0_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			destroy_component(button0);
    			destroy_component(button1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(321:3) {#each esco as escoa}",
    		ctx
    	});

    	return block;
    }

    // (342:8) <Button outline color="success" on:click={Loadesco}>
    function create_default_slot_2$q(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Cargar datos");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$q.name,
    		type: "slot",
    		source: "(342:8) <Button outline color=\\\"success\\\" on:click={Loadesco}>",
    		ctx
    	});

    	return block;
    }

    // (345:8) <Button outline color="danger" on:click={BorrarescosAll}>
    function create_default_slot_1$q(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Borrar todo");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$q.name,
    		type: "slot",
    		source: "(345:8) <Button outline color=\\\"danger\\\" on:click={BorrarescosAll}>",
    		ctx
    	});

    	return block;
    }

    // (288:1) <Table bordered>
    function create_default_slot$q(ctx) {
    	let thead;
    	let tr0;
    	let th0;
    	let t1;
    	let th1;
    	let t3;
    	let th2;
    	let t5;
    	let th3;
    	let t7;
    	let th4;
    	let t9;
    	let tbody;
    	let tr1;
    	let td0;
    	let input0;
    	let t10;
    	let td1;
    	let input1;
    	let t11;
    	let td2;
    	let input2;
    	let t12;
    	let td3;
    	let input3;
    	let t13;
    	let td4;
    	let input4;
    	let t14;
    	let td5;
    	let button0;
    	let t15;
    	let td6;
    	let button1;
    	let t16;
    	let t17;
    	let tr2;
    	let td7;
    	let button2;
    	let t18;
    	let td8;
    	let button3;
    	let current;
    	let mounted;
    	let dispose;

    	button0 = new Button({
    			props: {
    				outline: true,
    				color: "primary",
    				$$slots: { default: [create_default_slot_6$p] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button0.$on("click", /*insertesco*/ ctx[10]);

    	button1 = new Button({
    			props: {
    				outline: true,
    				color: "primary",
    				$$slots: { default: [create_default_slot_5$p] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1.$on("click", /*click_handler_2*/ ctx[24]);
    	let each_value = /*esco*/ ctx[6];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	button2 = new Button({
    			props: {
    				outline: true,
    				color: "success",
    				$$slots: { default: [create_default_slot_2$q] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button2.$on("click", /*Loadesco*/ ctx[13]);

    	button3 = new Button({
    			props: {
    				outline: true,
    				color: "danger",
    				$$slots: { default: [create_default_slot_1$q] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button3.$on("click", /*BorrarescosAll*/ ctx[12]);

    	const block = {
    		c: function create() {
    			thead = element$1("thead");
    			tr0 = element$1("tr");
    			th0 = element$1("th");
    			th0.textContent = "País";
    			t1 = space();
    			th1 = element$1("th");
    			th1.textContent = "Año";
    			t3 = space();
    			th2 = element$1("th");
    			th2.textContent = "Escolarizacion total";
    			t5 = space();
    			th3 = element$1("th");
    			th3.textContent = "Escolarizacion hombres";
    			t7 = space();
    			th4 = element$1("th");
    			th4.textContent = "Escolarizacion mujeres";
    			t9 = space();
    			tbody = element$1("tbody");
    			tr1 = element$1("tr");
    			td0 = element$1("td");
    			input0 = element$1("input");
    			t10 = space();
    			td1 = element$1("td");
    			input1 = element$1("input");
    			t11 = space();
    			td2 = element$1("td");
    			input2 = element$1("input");
    			t12 = space();
    			td3 = element$1("td");
    			input3 = element$1("input");
    			t13 = space();
    			td4 = element$1("td");
    			input4 = element$1("input");
    			t14 = space();
    			td5 = element$1("td");
    			create_component(button0.$$.fragment);
    			t15 = space();
    			td6 = element$1("td");
    			create_component(button1.$$.fragment);
    			t16 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t17 = space();
    			tr2 = element$1("tr");
    			td7 = element$1("td");
    			create_component(button2.$$.fragment);
    			t18 = space();
    			td8 = element$1("td");
    			create_component(button3.$$.fragment);
    			add_location(th0, file$u, 290, 4, 8215);
    			add_location(th1, file$u, 291, 4, 8234);
    			add_location(th2, file$u, 292, 16, 8264);
    			add_location(th3, file$u, 293, 16, 8311);
    			add_location(th4, file$u, 294, 16, 8360);
    			add_location(tr0, file$u, 289, 3, 8205);
    			add_location(thead, file$u, 288, 2, 8193);
    			add_location(input0, file$u, 299, 8, 8443);
    			add_location(td0, file$u, 299, 4, 8439);
    			attr_dev(input1, "type", "number");
    			add_location(input1, file$u, 300, 8, 8496);
    			add_location(td1, file$u, 300, 4, 8492);
    			attr_dev(input2, "type", "number");
    			add_location(input2, file$u, 301, 8, 8560);
    			add_location(td2, file$u, 301, 4, 8556);
    			attr_dev(input3, "type", "number");
    			add_location(input3, file$u, 302, 8, 8627);
    			add_location(td3, file$u, 302, 4, 8623);
    			attr_dev(input4, "type", "number");
    			add_location(input4, file$u, 303, 8, 8694);
    			add_location(td4, file$u, 303, 4, 8690);
    			add_location(td5, file$u, 305, 4, 8760);
    			attr_dev(td6, "align", "center");
    			add_location(td6, file$u, 309, 4, 8866);
    			add_location(tr1, file$u, 298, 3, 8429);
    			add_location(td7, file$u, 341, 4, 9705);
    			add_location(td8, file$u, 344, 4, 9806);
    			add_location(tr2, file$u, 340, 3, 9695);
    			add_location(tbody, file$u, 297, 2, 8417);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, thead, anchor);
    			append_dev(thead, tr0);
    			append_dev(tr0, th0);
    			append_dev(tr0, t1);
    			append_dev(tr0, th1);
    			append_dev(tr0, t3);
    			append_dev(tr0, th2);
    			append_dev(tr0, t5);
    			append_dev(tr0, th3);
    			append_dev(tr0, t7);
    			append_dev(tr0, th4);
    			insert_dev(target, t9, anchor);
    			insert_dev(target, tbody, anchor);
    			append_dev(tbody, tr1);
    			append_dev(tr1, td0);
    			append_dev(td0, input0);
    			set_input_value(input0, /*newesco*/ ctx[5].country);
    			append_dev(tr1, t10);
    			append_dev(tr1, td1);
    			append_dev(td1, input1);
    			set_input_value(input1, /*newesco*/ ctx[5].year);
    			append_dev(tr1, t11);
    			append_dev(tr1, td2);
    			append_dev(td2, input2);
    			set_input_value(input2, /*newesco*/ ctx[5].tot_wom);
    			append_dev(tr1, t12);
    			append_dev(tr1, td3);
    			append_dev(td3, input3);
    			set_input_value(input3, /*newesco*/ ctx[5].tot_man);
    			append_dev(tr1, t13);
    			append_dev(tr1, td4);
    			append_dev(td4, input4);
    			set_input_value(input4, /*newesco*/ ctx[5].tot_esco);
    			append_dev(tr1, t14);
    			append_dev(tr1, td5);
    			mount_component(button0, td5, null);
    			append_dev(tr1, t15);
    			append_dev(tr1, td6);
    			mount_component(button1, td6, null);
    			append_dev(tbody, t16);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}

    			append_dev(tbody, t17);
    			append_dev(tbody, tr2);
    			append_dev(tr2, td7);
    			mount_component(button2, td7, null);
    			append_dev(tr2, t18);
    			append_dev(tr2, td8);
    			mount_component(button3, td8, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "input", /*input0_input_handler_1*/ ctx[19]),
    					listen_dev(input1, "input", /*input1_input_handler_1*/ ctx[20]),
    					listen_dev(input2, "input", /*input2_input_handler*/ ctx[21]),
    					listen_dev(input3, "input", /*input3_input_handler*/ ctx[22]),
    					listen_dev(input4, "input", /*input4_input_handler*/ ctx[23])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*newesco*/ 32 && input0.value !== /*newesco*/ ctx[5].country) {
    				set_input_value(input0, /*newesco*/ ctx[5].country);
    			}

    			if (dirty[0] & /*newesco*/ 32 && to_number(input1.value) !== /*newesco*/ ctx[5].year) {
    				set_input_value(input1, /*newesco*/ ctx[5].year);
    			}

    			if (dirty[0] & /*newesco*/ 32 && to_number(input2.value) !== /*newesco*/ ctx[5].tot_wom) {
    				set_input_value(input2, /*newesco*/ ctx[5].tot_wom);
    			}

    			if (dirty[0] & /*newesco*/ 32 && to_number(input3.value) !== /*newesco*/ ctx[5].tot_man) {
    				set_input_value(input3, /*newesco*/ ctx[5].tot_man);
    			}

    			if (dirty[0] & /*newesco*/ 32 && to_number(input4.value) !== /*newesco*/ ctx[5].tot_esco) {
    				set_input_value(input4, /*newesco*/ ctx[5].tot_esco);
    			}

    			const button0_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);

    			if (dirty[0] & /*Borraresco, esco*/ 2112) {
    				each_value = /*esco*/ ctx[6];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(tbody, t17);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			const button2_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				button2_changes.$$scope = { dirty, ctx };
    			}

    			button2.$set(button2_changes);
    			const button3_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				button3_changes.$$scope = { dirty, ctx };
    			}

    			button3.$set(button3_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(button2.$$.fragment, local);
    			transition_in(button3.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(button2.$$.fragment, local);
    			transition_out(button3.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(thead);
    			if (detaching) detach_dev(t9);
    			if (detaching) detach_dev(tbody);
    			destroy_component(button0);
    			destroy_component(button1);
    			destroy_each(each_blocks, detaching);
    			destroy_component(button2);
    			destroy_component(button3);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$q.name,
    		type: "slot",
    		source: "(288:1) <Table bordered>",
    		ctx
    	});

    	return block;
    }

    // (238:17)   loading   {:then esco}
    function create_pending_block$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("loading");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop$4,
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block$5.name,
    		type: "pending",
    		source: "(238:17)   loading   {:then esco}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$u(ctx) {
    	let main;
    	let navbar;
    	let t0;
    	let h1;
    	let t2;
    	let button0;
    	let t3;
    	let button1;
    	let t4;
    	let promise;
    	let current;

    	navbar = new Navbar({
    			props: {
    				style: "background-color: lightgreen; color:white;",
    				light: true,
    				expand: "lg",
    				$$slots: { default: [create_default_slot_13$p] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button0 = new Button({
    			props: {
    				$$slots: { default: [create_default_slot_12$p] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button0.$on("click", /*getPgAnt*/ ctx[8]);

    	button1 = new Button({
    			props: {
    				$$slots: { default: [create_default_slot_11$p] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1.$on("click", /*getPgSig*/ ctx[9]);

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: false,
    		pending: create_pending_block$5,
    		then: create_then_block$5,
    		catch: create_catch_block$5,
    		value: 6,
    		blocks: [,,,]
    	};

    	handle_promise(promise = /*esco*/ ctx[6], info);

    	const block = {
    		c: function create() {
    			main = element$1("main");
    			create_component(navbar.$$.fragment);
    			t0 = space();
    			h1 = element$1("h1");
    			h1.textContent = "Tasa de escolarizacion";
    			t2 = space();
    			create_component(button0.$$.fragment);
    			t3 = space();
    			create_component(button1.$$.fragment);
    			t4 = space();
    			info.block.c();
    			add_location(h1, file$u, 230, 4, 6959);
    			add_location(main, file$u, 187, 0, 5277);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			mount_component(navbar, main, null);
    			append_dev(main, t0);
    			append_dev(main, h1);
    			append_dev(main, t2);
    			mount_component(button0, main, null);
    			append_dev(main, t3);
    			mount_component(button1, main, null);
    			append_dev(main, t4);
    			info.block.m(main, info.anchor = null);
    			info.mount = () => main;
    			info.anchor = null;
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const navbar_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				navbar_changes.$$scope = { dirty, ctx };
    			}

    			navbar.$set(navbar_changes);
    			const button0_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    			info.ctx = ctx;

    			if (dirty[0] & /*esco*/ 64 && promise !== (promise = /*esco*/ ctx[6]) && handle_promise(promise, info)) ; else {
    				update_await_block_branch(info, ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			transition_in(info.block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);

    			for (let i = 0; i < 3; i += 1) {
    				const block = info.blocks[i];
    				transition_out(block);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(navbar);
    			destroy_component(button0);
    			destroy_component(button1);
    			info.block.d();
    			info.token = null;
    			info = null;
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$u($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Esco', slots, []);
    	let esco = [];
    	let from = null;
    	let to = null;
    	let offset = 0;
    	let limit = 10;
    	let checkMSG = "";
    	let visible = false;
    	let color = "danger";
    	let numEntries;

    	let newesco = {
    		country: "",
    		year: "",
    		tot_wom: "",
    		tot_man: "",
    		tot_esco: ""
    	};

    	onMount(getesco);

    	async function getesco() {
    		console.log("fetching esco ....");
    		let cadena = `/api/v1/esco-stats?offset=+${offset}+&limit=+${limit}`;

    		if (from != null) {
    			cadena = cadena + `&from=${from}&`;
    		}

    		if (to != null) {
    			cadena = cadena + `to=${to}`;
    		}

    		const res = await fetch(cadena);

    		if (res.ok) {
    			const data = await res.json();
    			$$invalidate(6, esco = data);
    			numEntries = esco.length;
    			console.log("Received esco: " + esco.length);
    		} else {
    			$$invalidate(4, color = "danger");
    			$$invalidate(2, checkMSG = "No hay entradas para esas fechas");
    			$$invalidate(3, visible = "true");
    		} //window.alert("No hay entradas para esas fechas");
    	}

    	async function getPgAnt() {
    		if (offset >= 10) {
    			offset = offset - 10;
    		}

    		//limit=limit+10;
    		console.log("fetching esco ....");

    		let cadena = `/api/v1/esco-stats?offset=+${offset}+&limit=+${limit}`;

    		if (from != null) {
    			cadena = cadena + `&from=${from}&`;
    		}

    		if (to != null) {
    			cadena = cadena + `to=${to}`;
    		}

    		const res = await fetch(cadena);

    		if (res.ok) {
    			const data = await res.json();
    			$$invalidate(6, esco = data);
    			console.log("Received esco: " + esco.length);
    		}
    	}

    	async function getPgSig() {
    		if (esco.length >= 10) {
    			offset = offset + 10;
    		}

    		//limit=limit+10;
    		console.log("fetching esco ....");

    		let cadena = `/api/v1/esco-stats?offset=+${offset}+&limit=+${limit}`;

    		if (from != null) {
    			cadena = cadena + `&from=${from}&`;
    		}

    		if (to != null) {
    			cadena = cadena + `to=${to}`;
    		}

    		const res = await fetch(cadena);

    		if (res.ok) {
    			const data = await res.json();
    			$$invalidate(6, esco = data);
    			console.log("Received esco: " + esco.length);
    		}
    	}

    	async function insertesco() {
    		if (newesco.country == "" || newesco.country == null || newesco.year == "" || newesco.year == null || newesco.tot_wom == "" || newesco.tot_wom == null || newesco.tot_man == "" || newesco.tot_man == null || newesco.tot_esco == "" || newesco.tot_esco == null) {
    			$$invalidate(4, color = "danger");
    			$$invalidate(2, checkMSG = "Debe completar todos los campos");
    			$$invalidate(3, visible = "true");
    		} else {
    			console.log("Inserting esco...." + JSON.stringify(newesco));

    			await fetch("/api/v1/esco-stats", {
    				method: "POST",
    				body: JSON.stringify(newesco),
    				headers: { "Content-Type": "application/json" }
    			}).then(function (res) {
    				if (res.status == 201) {
    					$$invalidate(4, color = "success");
    					$$invalidate(2, checkMSG = "Entrada introducida con éxito");
    					$$invalidate(3, visible = "true");
    					$$invalidate(5, newesco.country = null, newesco);
    					$$invalidate(5, newesco.year = null, newesco);
    					$$invalidate(5, newesco.tot_wom = null, newesco);
    					$$invalidate(5, newesco.tot_man = null, newesco);
    					$$invalidate(5, newesco.tot_esco = null, newesco);
    					getesco();
    				} else if (res.status == 409) {
    					$$invalidate(4, color = "danger"); //window.alert("Entrada introducida con éxito");
    					$$invalidate(2, checkMSG = "Ya existe ese recurso en la base de datos");
    					$$invalidate(3, visible = "true");

    					//window.alert("Ya existe ese recurso en la base de datos");
    					console.log("ERROR There is already a data with that country and year in the database");
    				}
    			});
    		}
    	}

    	async function Borraresco(name, year) {
    		console.log("Deleting esco....");

    		await fetch("/api/v1/esco-stats/" + name + "/" + year, { method: "DELETE" }).then(function (res) {
    			getesco();

    			if (res.status == 200) {
    				$$invalidate(4, color = "success");
    				$$invalidate(2, checkMSG = name + " entrada borrada correctamente");
    				$$invalidate(3, visible = "true");
    				console.log("Deleted " + name);
    			} else {
    				$$invalidate(4, color = "danger"); //window.alert(name + " elimida con éxito");           
    				$$invalidate(2, checkMSG = name + "no se ha podido borrar la entrada");
    				$$invalidate(3, visible = "true");

    				//window.alert(name + " no se ha podida eliminar");
    				console.log("DATA NOT FOUND");
    			}
    		});
    	}

    	async function BorrarescosAll() {
    		console.log("Deleting escos....");

    		await fetch("/api/v1/esco-stats/", { method: "DELETE" }).then(function (res) {
    			$$invalidate(4, color = "success");
    			$$invalidate(2, checkMSG = "Entradas elimidas con éxito");
    			$$invalidate(3, visible = "true");
    			getesco();
    		}); //window.alert("Entradas elimidas con éxito");
    	}

    	async function Loadesco() {
    		console.log("Loading esco....");

    		await fetch("/api/v1/esco-stats/loadInitialData", { method: "GET" }).then(function (res) {
    			$$invalidate(4, color = "success");
    			$$invalidate(2, checkMSG = "Entradas cargadas con éxito");
    			$$invalidate(3, visible = "true");
    			getesco();
    		}); //window.alert("Entradas cargadas con éxito");
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$r.warn(`<Esco> was created with unknown prop '${key}'`);
    	});

    	const func = () => $$invalidate(3, visible = false);

    	function input0_input_handler() {
    		from = to_number(this.value);
    		$$invalidate(0, from);
    	}

    	function input1_input_handler() {
    		to = to_number(this.value);
    		$$invalidate(1, to);
    	}

    	const click_handler = () => {
    		if (from == null || to == null) {
    			$$invalidate(4, color = "success");
    			$$invalidate(2, checkMSG = "Los campos fecha inicio y fecha fin no pueden estar vacíos");
    			$$invalidate(3, visible = "true");
    		} else {
    			getesco(); //window.alert('Los campos fecha inicio y fecha fin no pueden estar vacíos')
    		}
    	};

    	const click_handler_1 = () => {
    		$$invalidate(0, from = null);
    		$$invalidate(1, to = null);
    		getesco();
    	};

    	function input0_input_handler_1() {
    		newesco.country = this.value;
    		$$invalidate(5, newesco);
    	}

    	function input1_input_handler_1() {
    		newesco.year = to_number(this.value);
    		$$invalidate(5, newesco);
    	}

    	function input2_input_handler() {
    		newesco.tot_wom = to_number(this.value);
    		$$invalidate(5, newesco);
    	}

    	function input3_input_handler() {
    		newesco.tot_man = to_number(this.value);
    		$$invalidate(5, newesco);
    	}

    	function input4_input_handler() {
    		newesco.tot_esco = to_number(this.value);
    		$$invalidate(5, newesco);
    	}

    	const click_handler_2 = () => {
    		$$invalidate(5, newesco.country = null, newesco);
    		$$invalidate(5, newesco.year = null, newesco);
    		$$invalidate(5, newesco.tot_wom = null, newesco);
    		$$invalidate(5, newesco.tot_man = null, newesco);
    		$$invalidate(5, newesco.tot_esco = null, newesco);
    	};

    	const click_handler_3 = function (escoa) {
    		window.location.href = `/#/esco/${escoa.country}/${escoa.year}`;
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		Table,
    		Button,
    		Alert,
    		Navbar,
    		Nav,
    		NavItem,
    		NavLink,
    		NavbarBrand,
    		Dropdown,
    		DropdownToggle,
    		DropdownMenu,
    		DropdownItem,
    		esco,
    		from,
    		to,
    		offset,
    		limit,
    		checkMSG,
    		visible,
    		color,
    		numEntries,
    		newesco,
    		getesco,
    		getPgAnt,
    		getPgSig,
    		insertesco,
    		Borraresco,
    		BorrarescosAll,
    		Loadesco
    	});

    	$$self.$inject_state = $$props => {
    		if ('esco' in $$props) $$invalidate(6, esco = $$props.esco);
    		if ('from' in $$props) $$invalidate(0, from = $$props.from);
    		if ('to' in $$props) $$invalidate(1, to = $$props.to);
    		if ('offset' in $$props) offset = $$props.offset;
    		if ('limit' in $$props) limit = $$props.limit;
    		if ('checkMSG' in $$props) $$invalidate(2, checkMSG = $$props.checkMSG);
    		if ('visible' in $$props) $$invalidate(3, visible = $$props.visible);
    		if ('color' in $$props) $$invalidate(4, color = $$props.color);
    		if ('numEntries' in $$props) numEntries = $$props.numEntries;
    		if ('newesco' in $$props) $$invalidate(5, newesco = $$props.newesco);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		from,
    		to,
    		checkMSG,
    		visible,
    		color,
    		newesco,
    		esco,
    		getesco,
    		getPgAnt,
    		getPgSig,
    		insertesco,
    		Borraresco,
    		BorrarescosAll,
    		Loadesco,
    		func,
    		input0_input_handler,
    		input1_input_handler,
    		click_handler,
    		click_handler_1,
    		input0_input_handler_1,
    		input1_input_handler_1,
    		input2_input_handler,
    		input3_input_handler,
    		input4_input_handler,
    		click_handler_2,
    		click_handler_3
    	];
    }

    class Esco extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$u, create_fragment$u, safe_not_equal, {}, null, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Esco",
    			options,
    			id: create_fragment$u.name
    		});
    	}
    }

    /* src\front\esco-stats\Editesco.svelte generated by Svelte v3.47.0 */

    const { console: console_1$q } = globals;

    const file$t = "src\\front\\esco-stats\\Editesco.svelte";

    // (95:2) <NavbarBrand href="#/info">
    function create_default_slot_25$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("INICIO");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_25$5.name,
    		type: "slot",
    		source: "(95:2) <NavbarBrand href=\\\"#/info\\\">",
    		ctx
    	});

    	return block;
    }

    // (98:4) <DropdownToggle nav caret>
    function create_default_slot_24$6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("API");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_24$6.name,
    		type: "slot",
    		source: "(98:4) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (100:6) <DropdownItem href="./api/v2/economies">
    function create_default_slot_23$c(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_23$c.name,
    		type: "slot",
    		source: "(100:6) <DropdownItem href=\\\"./api/v2/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (102:6) <DropdownItem href="./api/v1/esco-stats">
    function create_default_slot_22$k(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_22$k.name,
    		type: "slot",
    		source: "(102:6) <DropdownItem href=\\\"./api/v1/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (104:6) <DropdownItem href="./api/v1/expo-stats">
    function create_default_slot_21$o(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_21$o.name,
    		type: "slot",
    		source: "(104:6) <DropdownItem href=\\\"./api/v1/expo-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (99:4) <DropdownMenu end>
    function create_default_slot_20$o(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./api/v2/economies",
    				$$slots: { default: [create_default_slot_23$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "./api/v1/esco-stats",
    				$$slots: { default: [create_default_slot_22$k] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "./api/v1/expo-stats",
    				$$slots: { default: [create_default_slot_21$o] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_20$o.name,
    		type: "slot",
    		source: "(99:4) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (97:3) <Dropdown >
    function create_default_slot_19$o(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_24$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_20$o] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_19$o.name,
    		type: "slot",
    		source: "(97:3) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (109:4) <DropdownToggle nav caret>
    function create_default_slot_18$o(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_18$o.name,
    		type: "slot",
    		source: "(109:4) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (111:6) <DropdownItem href="./#/economies">
    function create_default_slot_17$o(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Economies FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17$o.name,
    		type: "slot",
    		source: "(111:6) <DropdownItem href=\\\"./#/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (113:6) <DropdownItem href="./#/esco-stats">
    function create_default_slot_16$o(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco FRONT_END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16$o.name,
    		type: "slot",
    		source: "(113:6) <DropdownItem href=\\\"./#/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (115:6) <DropdownItem href="#/expo-stats">
    function create_default_slot_15$o(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15$o.name,
    		type: "slot",
    		source: "(115:6) <DropdownItem href=\\\"#/expo-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (110:4) <DropdownMenu end>
    function create_default_slot_14$o(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies",
    				$$slots: { default: [create_default_slot_17$o] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "./#/esco-stats",
    				$$slots: { default: [create_default_slot_16$o] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/expo-stats",
    				$$slots: { default: [create_default_slot_15$o] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14$o.name,
    		type: "slot",
    		source: "(110:4) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (108:12) <Dropdown>
    function create_default_slot_13$o(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_18$o] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_14$o] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13$o.name,
    		type: "slot",
    		source: "(108:12) <Dropdown>",
    		ctx
    	});

    	return block;
    }

    // (120:4) <DropdownToggle nav caret>
    function create_default_slot_12$o(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Gráficas");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12$o.name,
    		type: "slot",
    		source: "(120:4) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (122:6) <DropdownItem href="./#/economies-graph">
    function create_default_slot_11$o(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$o.name,
    		type: "slot",
    		source: "(122:6) <DropdownItem href=\\\"./#/economies-graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (123:6) <DropdownItem href="./#/graphesco">
    function create_default_slot_10$o(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$o.name,
    		type: "slot",
    		source: "(123:6) <DropdownItem href=\\\"./#/graphesco\\\">",
    		ctx
    	});

    	return block;
    }

    // (124:6) <DropdownItem href="#/graphexpo">
    function create_default_slot_9$o(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$o.name,
    		type: "slot",
    		source: "(124:6) <DropdownItem href=\\\"#/graphexpo\\\">",
    		ctx
    	});

    	return block;
    }

    // (126:18) <DropdownItem href="./#/graph">
    function create_default_slot_8$o(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Grafica comun");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$o.name,
    		type: "slot",
    		source: "(126:18) <DropdownItem href=\\\"./#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (121:4) <DropdownMenu end>
    function create_default_slot_7$o(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies-graph",
    				$$slots: { default: [create_default_slot_11$o] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({
    			props: {
    				href: "./#/graphesco",
    				$$slots: { default: [create_default_slot_10$o] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "#/graphexpo",
    				$$slots: { default: [create_default_slot_9$o] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "./#/graph",
    				$$slots: { default: [create_default_slot_8$o] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem1_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				dropdownitem1_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem1.$set(dropdownitem1_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$o.name,
    		type: "slot",
    		source: "(121:4) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (119:5) <Dropdown >
    function create_default_slot_6$o(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_12$o] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_7$o] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$o.name,
    		type: "slot",
    		source: "(119:5) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (96:2) <Nav navbar>
    function create_default_slot_5$o(ctx) {
    	let dropdown0;
    	let t0;
    	let dropdown1;
    	let t1;
    	let dropdown2;
    	let current;

    	dropdown0 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_19$o] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown1 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_13$o] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown2 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_6$o] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdown0.$$.fragment);
    			t0 = space();
    			create_component(dropdown1.$$.fragment);
    			t1 = space();
    			create_component(dropdown2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdown0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdown1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdown2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdown0_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				dropdown0_changes.$$scope = { dirty, ctx };
    			}

    			dropdown0.$set(dropdown0_changes);
    			const dropdown1_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				dropdown1_changes.$$scope = { dirty, ctx };
    			}

    			dropdown1.$set(dropdown1_changes);
    			const dropdown2_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				dropdown2_changes.$$scope = { dirty, ctx };
    			}

    			dropdown2.$set(dropdown2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdown0.$$.fragment, local);
    			transition_in(dropdown1.$$.fragment, local);
    			transition_in(dropdown2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdown0.$$.fragment, local);
    			transition_out(dropdown1.$$.fragment, local);
    			transition_out(dropdown2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdown0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdown1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdown2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$o.name,
    		type: "slot",
    		source: "(96:2) <Nav navbar>",
    		ctx
    	});

    	return block;
    }

    // (94:4) <Navbar style="background-color: lightgreen; color:white;" light expand="lg" >
    function create_default_slot_4$p(ctx) {
    	let navbarbrand;
    	let t;
    	let nav;
    	let current;

    	navbarbrand = new NavbarBrand({
    			props: {
    				href: "#/info",
    				$$slots: { default: [create_default_slot_25$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	nav = new Nav({
    			props: {
    				navbar: true,
    				$$slots: { default: [create_default_slot_5$o] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navbarbrand.$$.fragment);
    			t = space();
    			create_component(nav.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbarbrand, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(nav, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navbarbrand_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				navbarbrand_changes.$$scope = { dirty, ctx };
    			}

    			navbarbrand.$set(navbarbrand_changes);
    			const nav_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				nav_changes.$$scope = { dirty, ctx };
    			}

    			nav.$set(nav_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbarbrand.$$.fragment, local);
    			transition_in(nav.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbarbrand.$$.fragment, local);
    			transition_out(nav.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbarbrand, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(nav, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$p.name,
    		type: "slot",
    		source: "(94:4) <Navbar style=\\\"background-color: lightgreen; color:white;\\\" light expand=\\\"lg\\\" >",
    		ctx
    	});

    	return block;
    }

    // (136:2) {#if checkMSG}
    function create_if_block$7(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1(/*checkMSG*/ ctx[1]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*checkMSG*/ 2) set_data_dev(t, /*checkMSG*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(136:2) {#if checkMSG}",
    		ctx
    	});

    	return block;
    }

    // (135:4) <Alert color={color} isOpen={visible} toggle={() => (visible = false)}>
    function create_default_slot_3$p(ctx) {
    	let if_block_anchor;
    	let if_block = /*checkMSG*/ ctx[1] && create_if_block$7(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*checkMSG*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$7(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$p.name,
    		type: "slot",
    		source: "(135:4) <Alert color={color} isOpen={visible} toggle={() => (visible = false)}>",
    		ctx
    	});

    	return block;
    }

    // (1:0) <script>        export let params={}
    function create_catch_block$4(ctx) {
    	const block = {
    		c: noop$4,
    		m: noop$4,
    		p: noop$4,
    		i: noop$4,
    		o: noop$4,
    		d: noop$4
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block$4.name,
    		type: "catch",
    		source: "(1:0) <script>        export let params={}",
    		ctx
    	});

    	return block;
    }

    // (142:8) {:then esco}
    function create_then_block$4(ctx) {
    	let table;
    	let current;

    	table = new Table({
    			props: {
    				bordered: true,
    				$$slots: { default: [create_default_slot_1$p] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(table.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(table, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const table_changes = {};

    			if (dirty & /*$$scope, updatedtot_esco, updatedtot_man, updatedtot_wom, updatedYear, params*/ 65777) {
    				table_changes.$$scope = { dirty, ctx };
    			}

    			table.$set(table_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(table.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(table.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(table, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block$4.name,
    		type: "then",
    		source: "(142:8) {:then esco}",
    		ctx
    	});

    	return block;
    }

    // (162:24) <Button outline color="primary" on:click="{Editesco}">
    function create_default_slot_2$p(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Editar");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$p.name,
    		type: "slot",
    		source: "(162:24) <Button outline color=\\\"primary\\\" on:click=\\\"{Editesco}\\\">",
    		ctx
    	});

    	return block;
    }

    // (144:8) <Table bordered>
    function create_default_slot_1$p(ctx) {
    	let thead;
    	let tr0;
    	let th0;
    	let t1;
    	let th1;
    	let t3;
    	let th2;
    	let t5;
    	let th3;
    	let t7;
    	let th4;
    	let t9;
    	let tbody;
    	let tr1;
    	let td0;
    	let t10_value = /*params*/ ctx[0].country + "";
    	let t10;
    	let t11;
    	let td1;
    	let t12;
    	let t13;
    	let td2;
    	let input0;
    	let t14;
    	let td3;
    	let input1;
    	let t15;
    	let td4;
    	let input2;
    	let t16;
    	let td5;
    	let button;
    	let current;
    	let mounted;
    	let dispose;

    	button = new Button({
    			props: {
    				outline: true,
    				color: "primary",
    				$$slots: { default: [create_default_slot_2$p] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*Editesco*/ ctx[9]);

    	const block = {
    		c: function create() {
    			thead = element$1("thead");
    			tr0 = element$1("tr");
    			th0 = element$1("th");
    			th0.textContent = "País";
    			t1 = space();
    			th1 = element$1("th");
    			th1.textContent = "Año";
    			t3 = space();
    			th2 = element$1("th");
    			th2.textContent = "Escolarizacion total";
    			t5 = space();
    			th3 = element$1("th");
    			th3.textContent = "Escolarizacion hombres";
    			t7 = space();
    			th4 = element$1("th");
    			th4.textContent = "Escolarizacion mujeres";
    			t9 = space();
    			tbody = element$1("tbody");
    			tr1 = element$1("tr");
    			td0 = element$1("td");
    			t10 = text$1(t10_value);
    			t11 = space();
    			td1 = element$1("td");
    			t12 = text$1(/*updatedYear*/ ctx[4]);
    			t13 = space();
    			td2 = element$1("td");
    			input0 = element$1("input");
    			t14 = space();
    			td3 = element$1("td");
    			input1 = element$1("input");
    			t15 = space();
    			td4 = element$1("td");
    			input2 = element$1("input");
    			t16 = space();
    			td5 = element$1("td");
    			create_component(button.$$.fragment);
    			add_location(th0, file$t, 146, 20, 4460);
    			add_location(th1, file$t, 147, 20, 4495);
    			add_location(th2, file$t, 148, 20, 4529);
    			add_location(th3, file$t, 149, 20, 4580);
    			add_location(th4, file$t, 150, 20, 4633);
    			add_location(tr0, file$t, 145, 16, 4434);
    			add_location(thead, file$t, 144, 12, 4409);
    			add_location(td0, file$t, 155, 20, 4774);
    			add_location(td1, file$t, 156, 20, 4821);
    			add_location(input0, file$t, 157, 24, 4869);
    			add_location(td2, file$t, 157, 20, 4865);
    			add_location(input1, file$t, 158, 24, 4937);
    			add_location(td3, file$t, 158, 20, 4933);
    			add_location(input2, file$t, 159, 24, 5005);
    			add_location(td4, file$t, 159, 20, 5001);
    			add_location(td5, file$t, 161, 20, 5076);
    			add_location(tr1, file$t, 154, 16, 4748);
    			add_location(tbody, file$t, 153, 12, 4723);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, thead, anchor);
    			append_dev(thead, tr0);
    			append_dev(tr0, th0);
    			append_dev(tr0, t1);
    			append_dev(tr0, th1);
    			append_dev(tr0, t3);
    			append_dev(tr0, th2);
    			append_dev(tr0, t5);
    			append_dev(tr0, th3);
    			append_dev(tr0, t7);
    			append_dev(tr0, th4);
    			insert_dev(target, t9, anchor);
    			insert_dev(target, tbody, anchor);
    			append_dev(tbody, tr1);
    			append_dev(tr1, td0);
    			append_dev(td0, t10);
    			append_dev(tr1, t11);
    			append_dev(tr1, td1);
    			append_dev(td1, t12);
    			append_dev(tr1, t13);
    			append_dev(tr1, td2);
    			append_dev(td2, input0);
    			set_input_value(input0, /*updatedtot_wom*/ ctx[5]);
    			append_dev(tr1, t14);
    			append_dev(tr1, td3);
    			append_dev(td3, input1);
    			set_input_value(input1, /*updatedtot_man*/ ctx[6]);
    			append_dev(tr1, t15);
    			append_dev(tr1, td4);
    			append_dev(td4, input2);
    			set_input_value(input2, /*updatedtot_esco*/ ctx[7]);
    			append_dev(tr1, t16);
    			append_dev(tr1, td5);
    			mount_component(button, td5, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[11]),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[12]),
    					listen_dev(input2, "input", /*input2_input_handler*/ ctx[13])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*params*/ 1) && t10_value !== (t10_value = /*params*/ ctx[0].country + "")) set_data_dev(t10, t10_value);
    			if (!current || dirty & /*updatedYear*/ 16) set_data_dev(t12, /*updatedYear*/ ctx[4]);

    			if (dirty & /*updatedtot_wom*/ 32 && input0.value !== /*updatedtot_wom*/ ctx[5]) {
    				set_input_value(input0, /*updatedtot_wom*/ ctx[5]);
    			}

    			if (dirty & /*updatedtot_man*/ 64 && input1.value !== /*updatedtot_man*/ ctx[6]) {
    				set_input_value(input1, /*updatedtot_man*/ ctx[6]);
    			}

    			if (dirty & /*updatedtot_esco*/ 128 && input2.value !== /*updatedtot_esco*/ ctx[7]) {
    				set_input_value(input2, /*updatedtot_esco*/ ctx[7]);
    			}

    			const button_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(thead);
    			if (detaching) detach_dev(t9);
    			if (detaching) detach_dev(tbody);
    			destroy_component(button);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$p.name,
    		type: "slot",
    		source: "(144:8) <Table bordered>",
    		ctx
    	});

    	return block;
    }

    // (140:17)       loading          {:then esco}
    function create_pending_block$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("loading");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop$4,
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block$4.name,
    		type: "pending",
    		source: "(140:17)       loading          {:then esco}",
    		ctx
    	});

    	return block;
    }

    // (171:4) <Button outline color="secondary" on:click= "{pop}">
    function create_default_slot$p(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Volver");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$p.name,
    		type: "slot",
    		source: "(171:4) <Button outline color=\\\"secondary\\\" on:click= \\\"{pop}\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$t(ctx) {
    	let main;
    	let navbar;
    	let t0;
    	let h1;
    	let t1;
    	let t2_value = /*params*/ ctx[0].country + "";
    	let t2;
    	let t3;
    	let t4;
    	let alert;
    	let t5;
    	let promise;
    	let t6;
    	let button;
    	let current;

    	navbar = new Navbar({
    			props: {
    				style: "background-color: lightgreen; color:white;",
    				light: true,
    				expand: "lg",
    				$$slots: { default: [create_default_slot_4$p] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	alert = new Alert({
    			props: {
    				color: /*color*/ ctx[3],
    				isOpen: /*visible*/ ctx[2],
    				toggle: /*func*/ ctx[10],
    				$$slots: { default: [create_default_slot_3$p] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: false,
    		pending: create_pending_block$4,
    		then: create_then_block$4,
    		catch: create_catch_block$4,
    		value: 8,
    		blocks: [,,,]
    	};

    	handle_promise(promise = /*esco*/ ctx[8], info);

    	button = new Button({
    			props: {
    				outline: true,
    				color: "secondary",
    				$$slots: { default: [create_default_slot$p] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", pop);

    	const block = {
    		c: function create() {
    			main = element$1("main");
    			create_component(navbar.$$.fragment);
    			t0 = space();
    			h1 = element$1("h1");
    			t1 = text$1("Editar \"");
    			t2 = text$1(t2_value);
    			t3 = text$1("\"");
    			t4 = space();
    			create_component(alert.$$.fragment);
    			t5 = space();
    			info.block.c();
    			t6 = space();
    			create_component(button.$$.fragment);
    			add_location(h1, file$t, 133, 4, 4143);
    			add_location(main, file$t, 92, 0, 2470);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			mount_component(navbar, main, null);
    			append_dev(main, t0);
    			append_dev(main, h1);
    			append_dev(h1, t1);
    			append_dev(h1, t2);
    			append_dev(h1, t3);
    			append_dev(main, t4);
    			mount_component(alert, main, null);
    			append_dev(main, t5);
    			info.block.m(main, info.anchor = null);
    			info.mount = () => main;
    			info.anchor = t6;
    			append_dev(main, t6);
    			mount_component(button, main, null);
    			current = true;
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;
    			const navbar_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				navbar_changes.$$scope = { dirty, ctx };
    			}

    			navbar.$set(navbar_changes);
    			if ((!current || dirty & /*params*/ 1) && t2_value !== (t2_value = /*params*/ ctx[0].country + "")) set_data_dev(t2, t2_value);
    			const alert_changes = {};
    			if (dirty & /*color*/ 8) alert_changes.color = /*color*/ ctx[3];
    			if (dirty & /*visible*/ 4) alert_changes.isOpen = /*visible*/ ctx[2];
    			if (dirty & /*visible*/ 4) alert_changes.toggle = /*func*/ ctx[10];

    			if (dirty & /*$$scope, checkMSG*/ 65538) {
    				alert_changes.$$scope = { dirty, ctx };
    			}

    			alert.$set(alert_changes);
    			info.ctx = ctx;

    			if (dirty & /*esco*/ 256 && promise !== (promise = /*esco*/ ctx[8]) && handle_promise(promise, info)) ; else {
    				update_await_block_branch(info, ctx, dirty);
    			}

    			const button_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			transition_in(alert.$$.fragment, local);
    			transition_in(info.block);
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			transition_out(alert.$$.fragment, local);

    			for (let i = 0; i < 3; i += 1) {
    				const block = info.blocks[i];
    				transition_out(block);
    			}

    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(navbar);
    			destroy_component(alert);
    			info.block.d();
    			info.token = null;
    			info = null;
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    async function Fallos$2(code, entrada) {
    	let msg;

    	if (code == 404) {
    		msg = "No se encuentra " + entrada;
    	}

    	if (code == 400) {
    		msg = "solicitud incorrecta";
    	}

    	if (code == 409) {
    		msg = "El dato introducido ya existe";
    	}

    	if (code == 401) {
    		msg = "No autorizado";
    	}

    	if (code == 405) {
    		msg = "Método no permitido";
    	}

    	window.alert(msg);
    	return;
    }

    function instance$t($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Editesco', slots, []);
    	let { params = {} } = $$props;
    	let esco = {};
    	let checkMSG = "";
    	let visible = false;
    	let color = "danger";
    	let updatedCountry;
    	let updatedYear;
    	let updatedtot_wom;
    	let updatedtot_man;
    	let updatedtot_esco;
    	onMount(getesco);

    	async function getesco() {
    		console.log("fetching esco ....");
    		const res = await fetch("/api/v1/esco-stats/" + params.country + "/" + params.year);

    		if (res.ok) {
    			const data = await res.json();
    			$$invalidate(8, esco = data);
    			updatedCountry = esco.country;
    			$$invalidate(4, updatedYear = esco.year);
    			$$invalidate(5, updatedtot_wom = esco.tot_wom);
    			$$invalidate(6, updatedtot_man = esco.tot_man);
    			$$invalidate(7, updatedtot_esco = esco.tot_esco);
    		} else {
    			Fallos$2(res.status, params.country);
    			pop();
    		}
    	}

    	async function Editesco() {
    		console.log("Updating esco...." + updatedCountry);

    		await fetch("/api/v1/esco-stats/" + params.country + "/" + params.year, {
    			method: "PUT",
    			body: JSON.stringify({
    				country: updatedCountry,
    				year: updatedYear,
    				tot_wom: parseInt(updatedtot_wom),
    				tot_man: parseInt(updatedtot_man),
    				tot_esco: parseInt(updatedtot_esco)
    			}),
    			headers: { "Content-Type": "application/json" }
    		});

    		$$invalidate(3, color = "success");
    		$$invalidate(1, checkMSG = "Se ha editado correctamente");
    		$$invalidate(2, visible = "true");
    	} //window.alert("Se ha editado correctamente"); 

    	const writable_props = ['params'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$q.warn(`<Editesco> was created with unknown prop '${key}'`);
    	});

    	const func = () => $$invalidate(2, visible = false);

    	function input0_input_handler() {
    		updatedtot_wom = this.value;
    		$$invalidate(5, updatedtot_wom);
    	}

    	function input1_input_handler() {
    		updatedtot_man = this.value;
    		$$invalidate(6, updatedtot_man);
    	}

    	function input2_input_handler() {
    		updatedtot_esco = this.value;
    		$$invalidate(7, updatedtot_esco);
    	}

    	$$self.$$set = $$props => {
    		if ('params' in $$props) $$invalidate(0, params = $$props.params);
    	};

    	$$self.$capture_state = () => ({
    		params,
    		pop,
    		onMount,
    		Button,
    		Table,
    		Alert,
    		Navbar,
    		Nav,
    		NavItem,
    		NavLink,
    		NavbarBrand,
    		Dropdown,
    		DropdownToggle,
    		DropdownMenu,
    		DropdownItem,
    		esco,
    		checkMSG,
    		visible,
    		color,
    		updatedCountry,
    		updatedYear,
    		updatedtot_wom,
    		updatedtot_man,
    		updatedtot_esco,
    		getesco,
    		Editesco,
    		Fallos: Fallos$2
    	});

    	$$self.$inject_state = $$props => {
    		if ('params' in $$props) $$invalidate(0, params = $$props.params);
    		if ('esco' in $$props) $$invalidate(8, esco = $$props.esco);
    		if ('checkMSG' in $$props) $$invalidate(1, checkMSG = $$props.checkMSG);
    		if ('visible' in $$props) $$invalidate(2, visible = $$props.visible);
    		if ('color' in $$props) $$invalidate(3, color = $$props.color);
    		if ('updatedCountry' in $$props) updatedCountry = $$props.updatedCountry;
    		if ('updatedYear' in $$props) $$invalidate(4, updatedYear = $$props.updatedYear);
    		if ('updatedtot_wom' in $$props) $$invalidate(5, updatedtot_wom = $$props.updatedtot_wom);
    		if ('updatedtot_man' in $$props) $$invalidate(6, updatedtot_man = $$props.updatedtot_man);
    		if ('updatedtot_esco' in $$props) $$invalidate(7, updatedtot_esco = $$props.updatedtot_esco);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		params,
    		checkMSG,
    		visible,
    		color,
    		updatedYear,
    		updatedtot_wom,
    		updatedtot_man,
    		updatedtot_esco,
    		esco,
    		Editesco,
    		func,
    		input0_input_handler,
    		input1_input_handler,
    		input2_input_handler
    	];
    }

    class Editesco_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$t, create_fragment$t, safe_not_equal, { params: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Editesco_1",
    			options,
    			id: create_fragment$t.name
    		});
    	}

    	get params() {
    		throw new Error("<Editesco>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set params(value) {
    		throw new Error("<Editesco>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\front\esco-stats\MyGraphesco.svelte generated by Svelte v3.47.0 */

    const { console: console_1$p } = globals;

    const file$s = "src\\front\\esco-stats\\MyGraphesco.svelte";

    // (127:2) <NavbarBrand href="#/info">
    function create_default_slot_21$n(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("INICIO");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_21$n.name,
    		type: "slot",
    		source: "(127:2) <NavbarBrand href=\\\"#/info\\\">",
    		ctx
    	});

    	return block;
    }

    // (130:4) <DropdownToggle nav caret>
    function create_default_slot_20$n(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("API");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_20$n.name,
    		type: "slot",
    		source: "(130:4) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (132:6) <DropdownItem href="./api/v2/economies">
    function create_default_slot_19$n(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_19$n.name,
    		type: "slot",
    		source: "(132:6) <DropdownItem href=\\\"./api/v2/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (134:6) <DropdownItem href="./api/v1/esco-stats">
    function create_default_slot_18$n(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_18$n.name,
    		type: "slot",
    		source: "(134:6) <DropdownItem href=\\\"./api/v1/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (136:6) <DropdownItem href="./api/v1/expo-stats">
    function create_default_slot_17$n(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17$n.name,
    		type: "slot",
    		source: "(136:6) <DropdownItem href=\\\"./api/v1/expo-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (131:4) <DropdownMenu end>
    function create_default_slot_16$n(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./api/v2/economies",
    				$$slots: { default: [create_default_slot_19$n] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "./api/v1/esco-stats",
    				$$slots: { default: [create_default_slot_18$n] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "./api/v1/expo-stats",
    				$$slots: { default: [create_default_slot_17$n] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16$n.name,
    		type: "slot",
    		source: "(131:4) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (129:3) <Dropdown >
    function create_default_slot_15$n(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_20$n] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_16$n] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15$n.name,
    		type: "slot",
    		source: "(129:3) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (141:4) <DropdownToggle nav caret>
    function create_default_slot_14$n(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14$n.name,
    		type: "slot",
    		source: "(141:4) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (143:6) <DropdownItem href="./#/economies">
    function create_default_slot_13$n(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13$n.name,
    		type: "slot",
    		source: "(143:6) <DropdownItem href=\\\"./#/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (145:6) <DropdownItem href="./#/esco-stats">
    function create_default_slot_12$n(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco FRONT_END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12$n.name,
    		type: "slot",
    		source: "(145:6) <DropdownItem href=\\\"./#/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (147:6) <DropdownItem href="#/expo-stats">
    function create_default_slot_11$n(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$n.name,
    		type: "slot",
    		source: "(147:6) <DropdownItem href=\\\"#/expo-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (142:4) <DropdownMenu end>
    function create_default_slot_10$n(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies",
    				$$slots: { default: [create_default_slot_13$n] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "./#/esco-stats",
    				$$slots: { default: [create_default_slot_12$n] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/expo-stats",
    				$$slots: { default: [create_default_slot_11$n] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$n.name,
    		type: "slot",
    		source: "(142:4) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (140:12) <Dropdown>
    function create_default_slot_9$n(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_14$n] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_10$n] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$n.name,
    		type: "slot",
    		source: "(140:12) <Dropdown>",
    		ctx
    	});

    	return block;
    }

    // (152:4) <DropdownToggle nav caret>
    function create_default_slot_8$n(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Gráficas");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$n.name,
    		type: "slot",
    		source: "(152:4) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (154:6) <DropdownItem href="./#/economies-graph">
    function create_default_slot_7$n(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$n.name,
    		type: "slot",
    		source: "(154:6) <DropdownItem href=\\\"./#/economies-graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (156:6) <DropdownItem href="./#/graphesco">
    function create_default_slot_6$n(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$n.name,
    		type: "slot",
    		source: "(156:6) <DropdownItem href=\\\"./#/graphesco\\\">",
    		ctx
    	});

    	return block;
    }

    // (158:6) <DropdownItem href="#/graphexpo">
    function create_default_slot_5$n(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$n.name,
    		type: "slot",
    		source: "(158:6) <DropdownItem href=\\\"#/graphexpo\\\">",
    		ctx
    	});

    	return block;
    }

    // (160:18) <DropdownItem href="./#/graph">
    function create_default_slot_4$o(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Grafica comun");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$o.name,
    		type: "slot",
    		source: "(160:18) <DropdownItem href=\\\"./#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (153:4) <DropdownMenu end>
    function create_default_slot_3$o(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let t4;
    	let dropdownitem5;
    	let t5;
    	let dropdownitem6;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies-graph",
    				$$slots: { default: [create_default_slot_7$n] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "./#/graphesco",
    				$$slots: { default: [create_default_slot_6$n] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/graphexpo",
    				$$slots: { default: [create_default_slot_5$n] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem5 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem6 = new DropdownItem({
    			props: {
    				href: "./#/graph",
    				$$slots: { default: [create_default_slot_4$o] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    			t4 = space();
    			create_component(dropdownitem5.$$.fragment);
    			t5 = space();
    			create_component(dropdownitem6.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(dropdownitem5, target, anchor);
    			insert_dev(target, t5, anchor);
    			mount_component(dropdownitem6, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    			const dropdownitem6_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdownitem6_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem6.$set(dropdownitem6_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			transition_in(dropdownitem5.$$.fragment, local);
    			transition_in(dropdownitem6.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			transition_out(dropdownitem5.$$.fragment, local);
    			transition_out(dropdownitem6.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(dropdownitem5, detaching);
    			if (detaching) detach_dev(t5);
    			destroy_component(dropdownitem6, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$o.name,
    		type: "slot",
    		source: "(153:4) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (151:5) <Dropdown >
    function create_default_slot_2$o(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_8$n] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_3$o] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$o.name,
    		type: "slot",
    		source: "(151:5) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (128:2) <Nav navbar>
    function create_default_slot_1$o(ctx) {
    	let dropdown0;
    	let t0;
    	let dropdown1;
    	let t1;
    	let dropdown2;
    	let current;

    	dropdown0 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_15$n] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown1 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_9$n] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown2 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_2$o] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdown0.$$.fragment);
    			t0 = space();
    			create_component(dropdown1.$$.fragment);
    			t1 = space();
    			create_component(dropdown2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdown0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdown1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdown2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdown0_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdown0_changes.$$scope = { dirty, ctx };
    			}

    			dropdown0.$set(dropdown0_changes);
    			const dropdown1_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdown1_changes.$$scope = { dirty, ctx };
    			}

    			dropdown1.$set(dropdown1_changes);
    			const dropdown2_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdown2_changes.$$scope = { dirty, ctx };
    			}

    			dropdown2.$set(dropdown2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdown0.$$.fragment, local);
    			transition_in(dropdown1.$$.fragment, local);
    			transition_in(dropdown2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdown0.$$.fragment, local);
    			transition_out(dropdown1.$$.fragment, local);
    			transition_out(dropdown2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdown0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdown1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdown2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$o.name,
    		type: "slot",
    		source: "(128:2) <Nav navbar>",
    		ctx
    	});

    	return block;
    }

    // (126:4) <Navbar style="background-color: lightgreen; color:white;" light expand="lg" >
    function create_default_slot$o(ctx) {
    	let navbarbrand;
    	let t;
    	let nav;
    	let current;

    	navbarbrand = new NavbarBrand({
    			props: {
    				href: "#/info",
    				$$slots: { default: [create_default_slot_21$n] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	nav = new Nav({
    			props: {
    				navbar: true,
    				$$slots: { default: [create_default_slot_1$o] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navbarbrand.$$.fragment);
    			t = space();
    			create_component(nav.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbarbrand, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(nav, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navbarbrand_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				navbarbrand_changes.$$scope = { dirty, ctx };
    			}

    			navbarbrand.$set(navbarbrand_changes);
    			const nav_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				nav_changes.$$scope = { dirty, ctx };
    			}

    			nav.$set(nav_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbarbrand.$$.fragment, local);
    			transition_in(nav.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbarbrand.$$.fragment, local);
    			transition_out(nav.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbarbrand, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(nav, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$o.name,
    		type: "slot",
    		source: "(126:4) <Navbar style=\\\"background-color: lightgreen; color:white;\\\" light expand=\\\"lg\\\" >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$s(ctx) {
    	let script0;
    	let script0_src_value;
    	let script1;
    	let script1_src_value;
    	let script2;
    	let script2_src_value;
    	let script3;
    	let script3_src_value;
    	let t0;
    	let main;
    	let navbar;
    	let t1;
    	let figure;
    	let div;
    	let t2;
    	let p;
    	let current;
    	let mounted;
    	let dispose;

    	navbar = new Navbar({
    			props: {
    				style: "background-color: lightgreen; color:white;",
    				light: true,
    				expand: "lg",
    				$$slots: { default: [create_default_slot$o] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			script0 = element$1("script");
    			script1 = element$1("script");
    			script2 = element$1("script");
    			script3 = element$1("script");
    			t0 = space();
    			main = element$1("main");
    			create_component(navbar.$$.fragment);
    			t1 = space();
    			figure = element$1("figure");
    			div = element$1("div");
    			t2 = space();
    			p = element$1("p");
    			p.textContent = "Este gráfico compara los valores de escolarizacion en distintas edades";
    			if (!src_url_equal(script0.src, script0_src_value = "https://code.highcharts.com/highcharts.js")) attr_dev(script0, "src", script0_src_value);
    			add_location(script0, file$s, 118, 4, 3921);
    			if (!src_url_equal(script1.src, script1_src_value = "https://code.highcharts.com/modules/exporting.js")) attr_dev(script1, "src", script1_src_value);
    			add_location(script1, file$s, 119, 4, 3992);
    			if (!src_url_equal(script2.src, script2_src_value = "https://code.highcharts.com/modules/export-data.js")) attr_dev(script2, "src", script2_src_value);
    			add_location(script2, file$s, 120, 4, 4070);
    			if (!src_url_equal(script3.src, script3_src_value = "https://code.highcharts.com/modules/accessibility.js")) attr_dev(script3, "src", script3_src_value);
    			add_location(script3, file$s, 121, 4, 4150);
    			attr_dev(div, "id", "container");
    			add_location(div, file$s, 168, 8, 6083);
    			attr_dev(p, "class", "highcharts-description");
    			add_location(p, file$s, 169, 8, 6115);
    			attr_dev(figure, "class", "highcharts-figure");
    			add_location(figure, file$s, 167, 4, 6039);
    			add_location(main, file$s, 124, 0, 4268);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			append_dev(document.head, script0);
    			append_dev(document.head, script1);
    			append_dev(document.head, script2);
    			append_dev(document.head, script3);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			mount_component(navbar, main, null);
    			append_dev(main, t1);
    			append_dev(main, figure);
    			append_dev(figure, div);
    			append_dev(figure, t2);
    			append_dev(figure, p);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(script3, "load", /*loadGraph*/ ctx[0], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const navbar_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				navbar_changes.$$scope = { dirty, ctx };
    			}

    			navbar.$set(navbar_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			detach_dev(script0);
    			detach_dev(script1);
    			detach_dev(script2);
    			detach_dev(script3);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			destroy_component(navbar);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$s($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MyGraphesco', slots, []);
    	const delay = ms => new Promise(res => setTimeout(res, ms));
    	let escos = [];
    	let country = [];
    	let year = [];
    	let tot_wom = [];
    	let tot_man = [];
    	let tot_esco = [];
    	let datosOrdenados = [];

    	async function getData() {
    		console.log("Fetching esco....");
    		const res = await fetch("/api/v1/esco-stats");

    		if (res.ok) {
    			const data = await res.json();
    			escos = data;

    			if (escos.length == 0) {
    				await fetch("/api/v1/esco-stats/loadInitialData");
    				console.log("Entradas recibidas: " + escos.length);

    				//con la siguiente funcion ordeno los datos por años de menor a mayor
    				datosOrdenados = escos.sort(function (a, b) {
    					return a.year - b.year;
    				});

    				console.log("Ordenadas correctamente");

    				datosOrdenados.forEach(esco => {
    					year.push(esco.year);
    					country.push(esco.country + "-" + esco.year);
    					tot_wom.push(esco.tot_wom);
    					tot_man.push(esco.tot_man);
    					tot_esco.push(esco.tot_esco);
    				});

    				location.reload();
    			} else {
    				console.log("Entradas recibidas: " + escos.length);

    				//con la siguiente funcion ordeno los datos por años de menor a mayor
    				datosOrdenados = escos.sort(function (a, b) {
    					return a.year - b.year;
    				});

    				console.log("Ordenadas correctamente");

    				datosOrdenados.forEach(esco => {
    					year.push(esco.year);
    					country.push(esco.country + "-" + esco.year);
    					tot_wom.push(esco.tot_wom);
    					tot_man.push(esco.tot_man);
    					tot_esco.push(esco.tot_esco);
    				});
    			}
    		} else {
    			console.log("Error, can`t charge data");
    		}
    	}

    	async function loadGraph() {
    		Highcharts.chart("container", {
    			chart: { type: "column" },
    			title: { text: "escolarizacion" },
    			subtitle: {
    				text: "Source: https://ourworldindata.org/esco"
    			},
    			xAxis: { categories: country, crosshair: true },
    			yAxis: {
    				min: 0,
    				title: { text: "escolarizacion" }
    			},
    			tooltip: {
    				headerFormat: '<span style="font-size:10px">{point.key}</span><table>',
    				pointFormat: '<tr><td style="color:{series.color};padding:0">{series.name}: </td>' + '<td style="padding:0"><b>{point.y} muertes</b></td></tr>',
    				footerFormat: "</table>",
    				shared: true,
    				useHTML: true
    			},
    			plotOptions: {
    				column: { pointPadding: 0.2, borderWidth: 0 }
    			},
    			series: [
    				{
    					name: 'Escolarizacion Total',
    					data: tot_esco
    				},
    				{
    					name: 'Escolarización Hombres',
    					data: tot_man
    				},
    				{
    					name: 'Escolarización Mujeres',
    					data: tot_wom
    				}
    			]
    		});
    	}

    	onMount(getData);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$p.warn(`<MyGraphesco> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		Navbar,
    		Nav,
    		NavItem,
    		NavLink,
    		NavbarBrand,
    		Dropdown,
    		DropdownToggle,
    		DropdownMenu,
    		DropdownItem,
    		Button,
    		delay,
    		escos,
    		country,
    		year,
    		tot_wom,
    		tot_man,
    		tot_esco,
    		datosOrdenados,
    		getData,
    		loadGraph
    	});

    	$$self.$inject_state = $$props => {
    		if ('escos' in $$props) escos = $$props.escos;
    		if ('country' in $$props) country = $$props.country;
    		if ('year' in $$props) year = $$props.year;
    		if ('tot_wom' in $$props) tot_wom = $$props.tot_wom;
    		if ('tot_man' in $$props) tot_man = $$props.tot_man;
    		if ('tot_esco' in $$props) tot_esco = $$props.tot_esco;
    		if ('datosOrdenados' in $$props) datosOrdenados = $$props.datosOrdenados;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [loadGraph];
    }

    class MyGraphesco extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$s, create_fragment$s, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MyGraphesco",
    			options,
    			id: create_fragment$s.name
    		});
    	}
    }

    /* src\front\frontEconomies\economies.svelte generated by Svelte v3.47.0 */

    const { console: console_1$o } = globals;

    const file$r = "src\\front\\frontEconomies\\economies.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[32] = list[i];
    	return child_ctx;
    }

    // (201:2) <NavbarBrand href="#/info">
    function create_default_slot_36$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("INICIO");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_36$1.name,
    		type: "slot",
    		source: "(201:2) <NavbarBrand href=\\\"#/info\\\">",
    		ctx
    	});

    	return block;
    }

    // (204:4) <DropdownToggle nav caret>
    function create_default_slot_35$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("API");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_35$1.name,
    		type: "slot",
    		source: "(204:4) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (206:6) <DropdownItem href="./api/v2/economies">
    function create_default_slot_34$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_34$1.name,
    		type: "slot",
    		source: "(206:6) <DropdownItem href=\\\"./api/v2/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (208:6) <DropdownItem href="./api/v1/esco-stats">
    function create_default_slot_33$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_33$1.name,
    		type: "slot",
    		source: "(208:6) <DropdownItem href=\\\"./api/v1/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (210:6) <DropdownItem href="./api/v1/expo">
    function create_default_slot_32$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_32$1.name,
    		type: "slot",
    		source: "(210:6) <DropdownItem href=\\\"./api/v1/expo\\\">",
    		ctx
    	});

    	return block;
    }

    // (205:4) <DropdownMenu end>
    function create_default_slot_31$1(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./api/v2/economies",
    				$$slots: { default: [create_default_slot_34$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "./api/v1/esco-stats",
    				$$slots: { default: [create_default_slot_33$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "./api/v1/expo",
    				$$slots: { default: [create_default_slot_32$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty[1] & /*$$scope*/ 16) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem2_changes = {};

    			if (dirty[1] & /*$$scope*/ 16) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty[1] & /*$$scope*/ 16) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_31$1.name,
    		type: "slot",
    		source: "(205:4) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (203:3) <Dropdown >
    function create_default_slot_30$1(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_35$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_31$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty[1] & /*$$scope*/ 16) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty[1] & /*$$scope*/ 16) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_30$1.name,
    		type: "slot",
    		source: "(203:3) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (215:4) <DropdownToggle nav caret>
    function create_default_slot_29$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_29$1.name,
    		type: "slot",
    		source: "(215:4) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (217:6) <DropdownItem href="./#/economies">
    function create_default_slot_28$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_28$1.name,
    		type: "slot",
    		source: "(217:6) <DropdownItem href=\\\"./#/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (218:6) <DropdownItem href="./#/esco-stats">
    function create_default_slot_27$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_27$2.name,
    		type: "slot",
    		source: "(218:6) <DropdownItem href=\\\"./#/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (219:6) <DropdownItem href="./#/expo">
    function create_default_slot_26$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_26$2.name,
    		type: "slot",
    		source: "(219:6) <DropdownItem href=\\\"./#/expo\\\">",
    		ctx
    	});

    	return block;
    }

    // (221:6) <DropdownItem href="#/graph">
    function create_default_slot_25$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Conjunto");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_25$4.name,
    		type: "slot",
    		source: "(221:6) <DropdownItem href=\\\"#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (216:4) <DropdownMenu end>
    function create_default_slot_24$5(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies",
    				$$slots: { default: [create_default_slot_28$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({
    			props: {
    				href: "./#/esco-stats",
    				$$slots: { default: [create_default_slot_27$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "./#/expo",
    				$$slots: { default: [create_default_slot_26$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/graph",
    				$$slots: { default: [create_default_slot_25$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty[1] & /*$$scope*/ 16) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem1_changes = {};

    			if (dirty[1] & /*$$scope*/ 16) {
    				dropdownitem1_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem1.$set(dropdownitem1_changes);
    			const dropdownitem2_changes = {};

    			if (dirty[1] & /*$$scope*/ 16) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty[1] & /*$$scope*/ 16) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_24$5.name,
    		type: "slot",
    		source: "(216:4) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (214:12) <Dropdown>
    function create_default_slot_23$b(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_29$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_24$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty[1] & /*$$scope*/ 16) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty[1] & /*$$scope*/ 16) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_23$b.name,
    		type: "slot",
    		source: "(214:12) <Dropdown>",
    		ctx
    	});

    	return block;
    }

    // (226:4) <DropdownToggle nav caret>
    function create_default_slot_22$j(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Gráficas");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_22$j.name,
    		type: "slot",
    		source: "(226:4) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (228:6) <DropdownItem href="./#/economies-graph">
    function create_default_slot_21$m(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_21$m.name,
    		type: "slot",
    		source: "(228:6) <DropdownItem href=\\\"./#/economies-graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (229:6) <DropdownItem href="./#/graphesco">
    function create_default_slot_20$m(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_20$m.name,
    		type: "slot",
    		source: "(229:6) <DropdownItem href=\\\"./#/graphesco\\\">",
    		ctx
    	});

    	return block;
    }

    // (230:6) <DropdownItem href="./#/graphexpo">
    function create_default_slot_19$m(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_19$m.name,
    		type: "slot",
    		source: "(230:6) <DropdownItem href=\\\"./#/graphexpo\\\">",
    		ctx
    	});

    	return block;
    }

    // (232:6) <DropdownItem href="#/graph">
    function create_default_slot_18$m(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Conjunto");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_18$m.name,
    		type: "slot",
    		source: "(232:6) <DropdownItem href=\\\"#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (227:4) <DropdownMenu end>
    function create_default_slot_17$m(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies-graph",
    				$$slots: { default: [create_default_slot_21$m] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({
    			props: {
    				href: "./#/graphesco",
    				$$slots: { default: [create_default_slot_20$m] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "./#/graphexpo",
    				$$slots: { default: [create_default_slot_19$m] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/graph",
    				$$slots: { default: [create_default_slot_18$m] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty[1] & /*$$scope*/ 16) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem1_changes = {};

    			if (dirty[1] & /*$$scope*/ 16) {
    				dropdownitem1_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem1.$set(dropdownitem1_changes);
    			const dropdownitem2_changes = {};

    			if (dirty[1] & /*$$scope*/ 16) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty[1] & /*$$scope*/ 16) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17$m.name,
    		type: "slot",
    		source: "(227:4) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (225:5) <Dropdown >
    function create_default_slot_16$m(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_22$j] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_17$m] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty[1] & /*$$scope*/ 16) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty[1] & /*$$scope*/ 16) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16$m.name,
    		type: "slot",
    		source: "(225:5) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (202:2) <Nav navbar>
    function create_default_slot_15$m(ctx) {
    	let dropdown0;
    	let t0;
    	let dropdown1;
    	let t1;
    	let dropdown2;
    	let current;

    	dropdown0 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_30$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown1 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_23$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown2 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_16$m] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdown0.$$.fragment);
    			t0 = space();
    			create_component(dropdown1.$$.fragment);
    			t1 = space();
    			create_component(dropdown2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdown0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdown1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdown2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdown0_changes = {};

    			if (dirty[1] & /*$$scope*/ 16) {
    				dropdown0_changes.$$scope = { dirty, ctx };
    			}

    			dropdown0.$set(dropdown0_changes);
    			const dropdown1_changes = {};

    			if (dirty[1] & /*$$scope*/ 16) {
    				dropdown1_changes.$$scope = { dirty, ctx };
    			}

    			dropdown1.$set(dropdown1_changes);
    			const dropdown2_changes = {};

    			if (dirty[1] & /*$$scope*/ 16) {
    				dropdown2_changes.$$scope = { dirty, ctx };
    			}

    			dropdown2.$set(dropdown2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdown0.$$.fragment, local);
    			transition_in(dropdown1.$$.fragment, local);
    			transition_in(dropdown2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdown0.$$.fragment, local);
    			transition_out(dropdown1.$$.fragment, local);
    			transition_out(dropdown2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdown0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdown1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdown2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15$m.name,
    		type: "slot",
    		source: "(202:2) <Nav navbar>",
    		ctx
    	});

    	return block;
    }

    // (200:1) <Navbar style="background-color: lightgreen; color:white;" light expand="lg" >
    function create_default_slot_14$m(ctx) {
    	let navbarbrand;
    	let t;
    	let nav;
    	let current;

    	navbarbrand = new NavbarBrand({
    			props: {
    				href: "#/info",
    				$$slots: { default: [create_default_slot_36$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	nav = new Nav({
    			props: {
    				navbar: true,
    				$$slots: { default: [create_default_slot_15$m] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navbarbrand.$$.fragment);
    			t = space();
    			create_component(nav.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbarbrand, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(nav, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navbarbrand_changes = {};

    			if (dirty[1] & /*$$scope*/ 16) {
    				navbarbrand_changes.$$scope = { dirty, ctx };
    			}

    			navbarbrand.$set(navbarbrand_changes);
    			const nav_changes = {};

    			if (dirty[1] & /*$$scope*/ 16) {
    				nav_changes.$$scope = { dirty, ctx };
    			}

    			nav.$set(nav_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbarbrand.$$.fragment, local);
    			transition_in(nav.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbarbrand.$$.fragment, local);
    			transition_out(nav.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbarbrand, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(nav, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14$m.name,
    		type: "slot",
    		source: "(200:1) <Navbar style=\\\"background-color: lightgreen; color:white;\\\" light expand=\\\"lg\\\" >",
    		ctx
    	});

    	return block;
    }

    // (243:2) {#if msg}
    function create_if_block_1$1(ctx) {
    	let p;
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			p = element$1("p");
    			t0 = text$1("ERROR: ");
    			t1 = text$1(/*msg*/ ctx[4]);
    			add_location(p, file$r, 243, 3, 7594);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t0);
    			append_dev(p, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*msg*/ 16) set_data_dev(t1, /*msg*/ ctx[4]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(243:2) {#if msg}",
    		ctx
    	});

    	return block;
    }

    // (242:1) <Alert color="danger" isOpen={visibleError} toggle={() => (visibleError = false)}>
    function create_default_slot_13$m(ctx) {
    	let if_block_anchor;
    	let if_block = /*msg*/ ctx[4] && create_if_block_1$1(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*msg*/ ctx[4]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1$1(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13$m.name,
    		type: "slot",
    		source: "(242:1) <Alert color=\\\"danger\\\" isOpen={visibleError} toggle={() => (visibleError = false)}>",
    		ctx
    	});

    	return block;
    }

    // (248:2) {#if msg}
    function create_if_block$6(ctx) {
    	let p;
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			p = element$1("p");
    			t0 = text$1("Correcto: ");
    			t1 = text$1(/*msg*/ ctx[4]);
    			add_location(p, file$r, 248, 3, 7736);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t0);
    			append_dev(p, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*msg*/ 16) set_data_dev(t1, /*msg*/ ctx[4]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(248:2) {#if msg}",
    		ctx
    	});

    	return block;
    }

    // (247:1) <Alert color="success" isOpen={visibleMsg} toggle={() => (visibleMsg = false)}>
    function create_default_slot_12$m(ctx) {
    	let if_block_anchor;
    	let if_block = /*msg*/ ctx[4] && create_if_block$6(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*msg*/ ctx[4]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$6(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12$m.name,
    		type: "slot",
    		source: "(247:1) <Alert color=\\\"success\\\" isOpen={visibleMsg} toggle={() => (visibleMsg = false)}>",
    		ctx
    	});

    	return block;
    }

    // (252:1) <Button on:click="{getPgAnt}">
    function create_default_slot_11$m(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Página Anterior");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$m.name,
    		type: "slot",
    		source: "(252:1) <Button on:click=\\\"{getPgAnt}\\\">",
    		ctx
    	});

    	return block;
    }

    // (255:1) <Button on:click="{getPgSig}">
    function create_default_slot_10$m(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Página Siguiente");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$m.name,
    		type: "slot",
    		source: "(255:1) <Button on:click=\\\"{getPgSig}\\\">",
    		ctx
    	});

    	return block;
    }

    // (1:0) <script>      import {onMount}
    function create_catch_block$3(ctx) {
    	const block = {
    		c: noop$4,
    		m: noop$4,
    		p: noop$4,
    		i: noop$4,
    		o: noop$4,
    		d: noop$4
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block$3.name,
    		type: "catch",
    		source: "(1:0) <script>      import {onMount}",
    		ctx
    	});

    	return block;
    }

    // (260:1) {:then economies}
    function create_then_block$3(ctx) {
    	let table0;
    	let t;
    	let table1;
    	let current;

    	table0 = new Table({
    			props: {
    				bordered: true,
    				$$slots: { default: [create_default_slot_7$m] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	table1 = new Table({
    			props: {
    				bordered: true,
    				$$slots: { default: [create_default_slot$n] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(table0.$$.fragment);
    			t = space();
    			create_component(table1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(table0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(table1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const table0_changes = {};

    			if (dirty[0] & /*from, to, visibleError, visibleMsg, msg*/ 31 | dirty[1] & /*$$scope*/ 16) {
    				table0_changes.$$scope = { dirty, ctx };
    			}

    			table0.$set(table0_changes);
    			const table1_changes = {};

    			if (dirty[0] & /*economies, neweconomies*/ 96 | dirty[1] & /*$$scope*/ 16) {
    				table1_changes.$$scope = { dirty, ctx };
    			}

    			table1.$set(table1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(table0.$$.fragment, local);
    			transition_in(table1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(table0.$$.fragment, local);
    			transition_out(table1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(table0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(table1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block$3.name,
    		type: "then",
    		source: "(260:1) {:then economies}",
    		ctx
    	});

    	return block;
    }

    // (274:31) <Button outline color="dark" on:click="{()=>{                  if (from == null || to == null) {                      //window.alert('Los campos fecha inicio y fecha fin no pueden estar vacíos')       visibleError = true;       visibleMsg = false;       msg = "Los campos fecha inicio y fecha fin no pueden estar vacíos";                  }else{                      getEconomies();                  }              }}">
    function create_default_slot_9$m(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Buscar");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$m.name,
    		type: "slot",
    		source: "(274:31) <Button outline color=\\\"dark\\\" on:click=\\\"{()=>{                  if (from == null || to == null) {                      //window.alert('Los campos fecha inicio y fecha fin no pueden estar vacíos')       visibleError = true;       visibleMsg = false;       msg = \\\"Los campos fecha inicio y fecha fin no pueden estar vacíos\\\";                  }else{                      getEconomies();                  }              }}\\\">",
    		ctx
    	});

    	return block;
    }

    // (287:31) <Button outline color="info" on:click="{()=>{                  from = null;                  to = null;                  getEconomies();                                }}">
    function create_default_slot_8$m(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Limpiar Búsqueda");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$m.name,
    		type: "slot",
    		source: "(287:31) <Button outline color=\\\"info\\\" on:click=\\\"{()=>{                  from = null;                  to = null;                  getEconomies();                                }}\\\">",
    		ctx
    	});

    	return block;
    }

    // (261:1) <Table bordered>
    function create_default_slot_7$m(ctx) {
    	let thead;
    	let tr0;
    	let th0;
    	let t1;
    	let th1;
    	let t3;
    	let tbody;
    	let tr1;
    	let td0;
    	let input0;
    	let t4;
    	let td1;
    	let input1;
    	let t5;
    	let td2;
    	let button0;
    	let t6;
    	let td3;
    	let button1;
    	let current;
    	let mounted;
    	let dispose;

    	button0 = new Button({
    			props: {
    				outline: true,
    				color: "dark",
    				$$slots: { default: [create_default_slot_9$m] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button0.$on("click", /*click_handler*/ ctx[18]);

    	button1 = new Button({
    			props: {
    				outline: true,
    				color: "info",
    				$$slots: { default: [create_default_slot_8$m] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1.$on("click", /*click_handler_1*/ ctx[19]);

    	const block = {
    		c: function create() {
    			thead = element$1("thead");
    			tr0 = element$1("tr");
    			th0 = element$1("th");
    			th0.textContent = "Fecha de inicio";
    			t1 = space();
    			th1 = element$1("th");
    			th1.textContent = "Fecha fin";
    			t3 = space();
    			tbody = element$1("tbody");
    			tr1 = element$1("tr");
    			td0 = element$1("td");
    			input0 = element$1("input");
    			t4 = space();
    			td1 = element$1("td");
    			input1 = element$1("input");
    			t5 = space();
    			td2 = element$1("td");
    			create_component(button0.$$.fragment);
    			t6 = space();
    			td3 = element$1("td");
    			create_component(button1.$$.fragment);
    			add_location(th0, file$r, 263, 16, 8032);
    			add_location(th1, file$r, 264, 16, 8074);
    			add_location(tr0, file$r, 262, 12, 8010);
    			add_location(thead, file$r, 261, 8, 7989);
    			attr_dev(input0, "type", "number");
    			attr_dev(input0, "min", "0");
    			add_location(input0, file$r, 271, 16, 8190);
    			add_location(td0, file$r, 271, 12, 8186);
    			attr_dev(input1, "type", "number");
    			attr_dev(input1, "min", "0");
    			add_location(input1, file$r, 272, 16, 8262);
    			add_location(td1, file$r, 272, 12, 8258);
    			attr_dev(td2, "align", "center");
    			add_location(td2, file$r, 273, 12, 8328);
    			attr_dev(td3, "align", "center");
    			add_location(td3, file$r, 286, 12, 8850);
    			add_location(tr1, file$r, 270, 8, 8168);
    			add_location(tbody, file$r, 267, 8, 8139);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, thead, anchor);
    			append_dev(thead, tr0);
    			append_dev(tr0, th0);
    			append_dev(tr0, t1);
    			append_dev(tr0, th1);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, tbody, anchor);
    			append_dev(tbody, tr1);
    			append_dev(tr1, td0);
    			append_dev(td0, input0);
    			set_input_value(input0, /*from*/ ctx[0]);
    			append_dev(tr1, t4);
    			append_dev(tr1, td1);
    			append_dev(td1, input1);
    			set_input_value(input1, /*to*/ ctx[1]);
    			append_dev(tr1, t5);
    			append_dev(tr1, td2);
    			mount_component(button0, td2, null);
    			append_dev(tr1, t6);
    			append_dev(tr1, td3);
    			mount_component(button1, td3, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[16]),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[17])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*from*/ 1 && to_number(input0.value) !== /*from*/ ctx[0]) {
    				set_input_value(input0, /*from*/ ctx[0]);
    			}

    			if (dirty[0] & /*to*/ 2 && to_number(input1.value) !== /*to*/ ctx[1]) {
    				set_input_value(input1, /*to*/ ctx[1]);
    			}

    			const button0_changes = {};

    			if (dirty[1] & /*$$scope*/ 16) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty[1] & /*$$scope*/ 16) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(thead);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(tbody);
    			destroy_component(button0);
    			destroy_component(button1);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$m.name,
    		type: "slot",
    		source: "(261:1) <Table bordered>",
    		ctx
    	});

    	return block;
    }

    // (317:23) <Button outline color="primary" on:click="{insertEconomies}">
    function create_default_slot_6$m(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Añadir");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$m.name,
    		type: "slot",
    		source: "(317:23) <Button outline color=\\\"primary\\\" on:click=\\\"{insertEconomies}\\\">",
    		ctx
    	});

    	return block;
    }

    // (322:23) <Button outline color="primary" on:click="{()=>{       neweconomies.country = null;       neweconomies.year = null;       neweconomies.percapita = null;       neweconomies.currency = null;       neweconomies.currentprices = null;      }}">
    function create_default_slot_5$m(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Limpiar");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$m.name,
    		type: "slot",
    		source: "(322:23) <Button outline color=\\\"primary\\\" on:click=\\\"{()=>{       neweconomies.country = null;       neweconomies.year = null;       neweconomies.percapita = null;       neweconomies.currency = null;       neweconomies.currentprices = null;      }}\\\">",
    		ctx
    	});

    	return block;
    }

    // (343:23) <Button outline color="warning" on:click={function (){       window.location.href = `/#/economies/${cd.country+"/"+cd.year}`      }}>
    function create_default_slot_4$n(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Editar");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$n.name,
    		type: "slot",
    		source: "(343:23) <Button outline color=\\\"warning\\\" on:click={function (){       window.location.href = `/#/economies/${cd.country+\\\"/\\\"+cd.year}`      }}>",
    		ctx
    	});

    	return block;
    }

    // (348:23) <Button outline color="danger" on:click={BorrarEconomies(cd.country,cd.year)}>
    function create_default_slot_3$n(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Borrar");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$n.name,
    		type: "slot",
    		source: "(348:23) <Button outline color=\\\"danger\\\" on:click={BorrarEconomies(cd.country,cd.year)}>",
    		ctx
    	});

    	return block;
    }

    // (335:3) {#each economies as cd}
    function create_each_block$1(ctx) {
    	let tr;
    	let td0;
    	let t0_value = /*cd*/ ctx[32].country + "";
    	let t0;
    	let t1;
    	let td1;
    	let t2_value = /*cd*/ ctx[32].year + "";
    	let t2;
    	let t3;
    	let td2;
    	let t4_value = /*cd*/ ctx[32].percapita + "";
    	let t4;
    	let t5;
    	let td3;
    	let t6_value = /*cd*/ ctx[32].currency + "";
    	let t6;
    	let t7;
    	let td4;
    	let t8_value = /*cd*/ ctx[32].currentprices + "";
    	let t8;
    	let t9;
    	let td5;
    	let button0;
    	let t10;
    	let td6;
    	let button1;
    	let current;

    	function click_handler_3() {
    		return /*click_handler_3*/ ctx[26](/*cd*/ ctx[32]);
    	}

    	button0 = new Button({
    			props: {
    				outline: true,
    				color: "warning",
    				$$slots: { default: [create_default_slot_4$n] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button0.$on("click", click_handler_3);

    	button1 = new Button({
    			props: {
    				outline: true,
    				color: "danger",
    				$$slots: { default: [create_default_slot_3$n] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1.$on("click", function () {
    		if (is_function(/*BorrarEconomies*/ ctx[11](/*cd*/ ctx[32].country, /*cd*/ ctx[32].year))) /*BorrarEconomies*/ ctx[11](/*cd*/ ctx[32].country, /*cd*/ ctx[32].year).apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			tr = element$1("tr");
    			td0 = element$1("td");
    			t0 = text$1(t0_value);
    			t1 = space();
    			td1 = element$1("td");
    			t2 = text$1(t2_value);
    			t3 = space();
    			td2 = element$1("td");
    			t4 = text$1(t4_value);
    			t5 = space();
    			td3 = element$1("td");
    			t6 = text$1(t6_value);
    			t7 = space();
    			td4 = element$1("td");
    			t8 = text$1(t8_value);
    			t9 = space();
    			td5 = element$1("td");
    			create_component(button0.$$.fragment);
    			t10 = space();
    			td6 = element$1("td");
    			create_component(button1.$$.fragment);
    			add_location(td0, file$r, 336, 4, 10253);
    			add_location(td1, file$r, 337, 4, 10280);
    			add_location(td2, file$r, 338, 16, 10316);
    			add_location(td3, file$r, 339, 16, 10357);
    			add_location(td4, file$r, 340, 16, 10397);
    			attr_dev(td5, "align", "center");
    			add_location(td5, file$r, 342, 4, 10432);
    			attr_dev(td6, "align", "center");
    			add_location(td6, file$r, 347, 4, 10618);
    			add_location(tr, file$r, 335, 3, 10243);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, t0);
    			append_dev(tr, t1);
    			append_dev(tr, td1);
    			append_dev(td1, t2);
    			append_dev(tr, t3);
    			append_dev(tr, td2);
    			append_dev(td2, t4);
    			append_dev(tr, t5);
    			append_dev(tr, td3);
    			append_dev(td3, t6);
    			append_dev(tr, t7);
    			append_dev(tr, td4);
    			append_dev(td4, t8);
    			append_dev(tr, t9);
    			append_dev(tr, td5);
    			mount_component(button0, td5, null);
    			append_dev(td5, t10);
    			append_dev(tr, td6);
    			mount_component(button1, td6, null);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if ((!current || dirty[0] & /*economies*/ 64) && t0_value !== (t0_value = /*cd*/ ctx[32].country + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty[0] & /*economies*/ 64) && t2_value !== (t2_value = /*cd*/ ctx[32].year + "")) set_data_dev(t2, t2_value);
    			if ((!current || dirty[0] & /*economies*/ 64) && t4_value !== (t4_value = /*cd*/ ctx[32].percapita + "")) set_data_dev(t4, t4_value);
    			if ((!current || dirty[0] & /*economies*/ 64) && t6_value !== (t6_value = /*cd*/ ctx[32].currency + "")) set_data_dev(t6, t6_value);
    			if ((!current || dirty[0] & /*economies*/ 64) && t8_value !== (t8_value = /*cd*/ ctx[32].currentprices + "")) set_data_dev(t8, t8_value);
    			const button0_changes = {};

    			if (dirty[1] & /*$$scope*/ 16) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty[1] & /*$$scope*/ 16) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			destroy_component(button0);
    			destroy_component(button1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(335:3) {#each economies as cd}",
    		ctx
    	});

    	return block;
    }

    // (355:8) <Button outline color="success" on:click={LoadEconomies}>
    function create_default_slot_2$n(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Cargar datos");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$n.name,
    		type: "slot",
    		source: "(355:8) <Button outline color=\\\"success\\\" on:click={LoadEconomies}>",
    		ctx
    	});

    	return block;
    }

    // (358:8) <Button outline color="danger" on:click={BorrarEconomiesAll}>
    function create_default_slot_1$n(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Borrar todo");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$n.name,
    		type: "slot",
    		source: "(358:8) <Button outline color=\\\"danger\\\" on:click={BorrarEconomiesAll}>",
    		ctx
    	});

    	return block;
    }

    // (299:1) <Table bordered>
    function create_default_slot$n(ctx) {
    	let thead;
    	let tr0;
    	let th0;
    	let t1;
    	let th1;
    	let t3;
    	let th2;
    	let t5;
    	let th3;
    	let t7;
    	let th4;
    	let t9;
    	let tbody;
    	let tr1;
    	let td0;
    	let input0;
    	let t10;
    	let td1;
    	let input1;
    	let t11;
    	let td2;
    	let input2;
    	let t12;
    	let td3;
    	let input3;
    	let t13;
    	let td4;
    	let input4;
    	let t14;
    	let td5;
    	let button0;
    	let t15;
    	let td6;
    	let button1;
    	let t16;
    	let t17;
    	let tr2;
    	let td7;
    	let button2;
    	let t18;
    	let td8;
    	let button3;
    	let current;
    	let mounted;
    	let dispose;

    	button0 = new Button({
    			props: {
    				outline: true,
    				color: "primary",
    				$$slots: { default: [create_default_slot_6$m] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button0.$on("click", /*insertEconomies*/ ctx[10]);

    	button1 = new Button({
    			props: {
    				outline: true,
    				color: "primary",
    				$$slots: { default: [create_default_slot_5$m] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1.$on("click", /*click_handler_2*/ ctx[25]);
    	let each_value = /*economies*/ ctx[6];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	button2 = new Button({
    			props: {
    				outline: true,
    				color: "success",
    				$$slots: { default: [create_default_slot_2$n] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button2.$on("click", /*LoadEconomies*/ ctx[13]);

    	button3 = new Button({
    			props: {
    				outline: true,
    				color: "danger",
    				$$slots: { default: [create_default_slot_1$n] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button3.$on("click", /*BorrarEconomiesAll*/ ctx[12]);

    	const block = {
    		c: function create() {
    			thead = element$1("thead");
    			tr0 = element$1("tr");
    			th0 = element$1("th");
    			th0.textContent = "País";
    			t1 = space();
    			th1 = element$1("th");
    			th1.textContent = "Año";
    			t3 = space();
    			th2 = element$1("th");
    			th2.textContent = "percapita";
    			t5 = space();
    			th3 = element$1("th");
    			th3.textContent = "currency";
    			t7 = space();
    			th4 = element$1("th");
    			th4.textContent = "currentprices";
    			t9 = space();
    			tbody = element$1("tbody");
    			tr1 = element$1("tr");
    			td0 = element$1("td");
    			input0 = element$1("input");
    			t10 = space();
    			td1 = element$1("td");
    			input1 = element$1("input");
    			t11 = space();
    			td2 = element$1("td");
    			input2 = element$1("input");
    			t12 = space();
    			td3 = element$1("td");
    			input3 = element$1("input");
    			t13 = space();
    			td4 = element$1("td");
    			input4 = element$1("input");
    			t14 = space();
    			td5 = element$1("td");
    			create_component(button0.$$.fragment);
    			t15 = space();
    			td6 = element$1("td");
    			create_component(button1.$$.fragment);
    			t16 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t17 = space();
    			tr2 = element$1("tr");
    			td7 = element$1("td");
    			create_component(button2.$$.fragment);
    			t18 = space();
    			td8 = element$1("td");
    			create_component(button3.$$.fragment);
    			add_location(th0, file$r, 301, 4, 9213);
    			add_location(th1, file$r, 302, 4, 9232);
    			add_location(th2, file$r, 303, 16, 9262);
    			add_location(th3, file$r, 304, 16, 9298);
    			add_location(th4, file$r, 305, 16, 9333);
    			add_location(tr0, file$r, 300, 3, 9203);
    			add_location(thead, file$r, 299, 2, 9191);
    			add_location(input0, file$r, 310, 8, 9407);
    			add_location(td0, file$r, 310, 4, 9403);
    			attr_dev(input1, "type", "number");
    			add_location(input1, file$r, 311, 8, 9465);
    			add_location(td1, file$r, 311, 4, 9461);
    			attr_dev(input2, "type", "number");
    			add_location(input2, file$r, 312, 8, 9534);
    			add_location(td2, file$r, 312, 4, 9530);
    			attr_dev(input3, "type", "number");
    			add_location(input3, file$r, 313, 8, 9608);
    			add_location(td3, file$r, 313, 4, 9604);
    			attr_dev(input4, "type", "number");
    			add_location(input4, file$r, 314, 8, 9681);
    			add_location(td4, file$r, 314, 4, 9677);
    			attr_dev(td5, "align", "center");
    			add_location(td5, file$r, 316, 4, 9757);
    			attr_dev(td6, "align", "center");
    			add_location(td6, file$r, 321, 4, 9890);
    			add_location(tr1, file$r, 309, 3, 9393);
    			add_location(td7, file$r, 354, 4, 10791);
    			add_location(td8, file$r, 357, 4, 10897);
    			add_location(tr2, file$r, 353, 3, 10781);
    			add_location(tbody, file$r, 308, 2, 9381);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, thead, anchor);
    			append_dev(thead, tr0);
    			append_dev(tr0, th0);
    			append_dev(tr0, t1);
    			append_dev(tr0, th1);
    			append_dev(tr0, t3);
    			append_dev(tr0, th2);
    			append_dev(tr0, t5);
    			append_dev(tr0, th3);
    			append_dev(tr0, t7);
    			append_dev(tr0, th4);
    			insert_dev(target, t9, anchor);
    			insert_dev(target, tbody, anchor);
    			append_dev(tbody, tr1);
    			append_dev(tr1, td0);
    			append_dev(td0, input0);
    			set_input_value(input0, /*neweconomies*/ ctx[5].country);
    			append_dev(tr1, t10);
    			append_dev(tr1, td1);
    			append_dev(td1, input1);
    			set_input_value(input1, /*neweconomies*/ ctx[5].year);
    			append_dev(tr1, t11);
    			append_dev(tr1, td2);
    			append_dev(td2, input2);
    			set_input_value(input2, /*neweconomies*/ ctx[5].percapita);
    			append_dev(tr1, t12);
    			append_dev(tr1, td3);
    			append_dev(td3, input3);
    			set_input_value(input3, /*neweconomies*/ ctx[5].currency);
    			append_dev(tr1, t13);
    			append_dev(tr1, td4);
    			append_dev(td4, input4);
    			set_input_value(input4, /*neweconomies*/ ctx[5].currentprices);
    			append_dev(tr1, t14);
    			append_dev(tr1, td5);
    			mount_component(button0, td5, null);
    			append_dev(tr1, t15);
    			append_dev(tr1, td6);
    			mount_component(button1, td6, null);
    			append_dev(tbody, t16);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}

    			append_dev(tbody, t17);
    			append_dev(tbody, tr2);
    			append_dev(tr2, td7);
    			mount_component(button2, td7, null);
    			append_dev(tr2, t18);
    			append_dev(tr2, td8);
    			mount_component(button3, td8, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "input", /*input0_input_handler_1*/ ctx[20]),
    					listen_dev(input1, "input", /*input1_input_handler_1*/ ctx[21]),
    					listen_dev(input2, "input", /*input2_input_handler*/ ctx[22]),
    					listen_dev(input3, "input", /*input3_input_handler*/ ctx[23]),
    					listen_dev(input4, "input", /*input4_input_handler*/ ctx[24])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*neweconomies*/ 32 && input0.value !== /*neweconomies*/ ctx[5].country) {
    				set_input_value(input0, /*neweconomies*/ ctx[5].country);
    			}

    			if (dirty[0] & /*neweconomies*/ 32 && to_number(input1.value) !== /*neweconomies*/ ctx[5].year) {
    				set_input_value(input1, /*neweconomies*/ ctx[5].year);
    			}

    			if (dirty[0] & /*neweconomies*/ 32 && to_number(input2.value) !== /*neweconomies*/ ctx[5].percapita) {
    				set_input_value(input2, /*neweconomies*/ ctx[5].percapita);
    			}

    			if (dirty[0] & /*neweconomies*/ 32 && to_number(input3.value) !== /*neweconomies*/ ctx[5].currency) {
    				set_input_value(input3, /*neweconomies*/ ctx[5].currency);
    			}

    			if (dirty[0] & /*neweconomies*/ 32 && to_number(input4.value) !== /*neweconomies*/ ctx[5].currentprices) {
    				set_input_value(input4, /*neweconomies*/ ctx[5].currentprices);
    			}

    			const button0_changes = {};

    			if (dirty[1] & /*$$scope*/ 16) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty[1] & /*$$scope*/ 16) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);

    			if (dirty[0] & /*BorrarEconomies, economies*/ 2112) {
    				each_value = /*economies*/ ctx[6];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(tbody, t17);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			const button2_changes = {};

    			if (dirty[1] & /*$$scope*/ 16) {
    				button2_changes.$$scope = { dirty, ctx };
    			}

    			button2.$set(button2_changes);
    			const button3_changes = {};

    			if (dirty[1] & /*$$scope*/ 16) {
    				button3_changes.$$scope = { dirty, ctx };
    			}

    			button3.$set(button3_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(button2.$$.fragment, local);
    			transition_in(button3.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(button2.$$.fragment, local);
    			transition_out(button3.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(thead);
    			if (detaching) detach_dev(t9);
    			if (detaching) detach_dev(tbody);
    			destroy_component(button0);
    			destroy_component(button1);
    			destroy_each(each_blocks, detaching);
    			destroy_component(button2);
    			destroy_component(button3);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$n.name,
    		type: "slot",
    		source: "(299:1) <Table bordered>",
    		ctx
    	});

    	return block;
    }

    // (258:22)   loading   {:then economies}
    function create_pending_block$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("loading");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop$4,
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block$3.name,
    		type: "pending",
    		source: "(258:22)   loading   {:then economies}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$r(ctx) {
    	let main;
    	let navbar;
    	let t0;
    	let h1;
    	let t2;
    	let alert0;
    	let t3;
    	let alert1;
    	let t4;
    	let button0;
    	let t5;
    	let button1;
    	let t6;
    	let promise;
    	let current;

    	navbar = new Navbar({
    			props: {
    				style: "background-color: lightgreen; color:white;",
    				light: true,
    				expand: "lg",
    				$$slots: { default: [create_default_slot_14$m] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	alert0 = new Alert({
    			props: {
    				color: "danger",
    				isOpen: /*visibleError*/ ctx[2],
    				toggle: /*func*/ ctx[14],
    				$$slots: { default: [create_default_slot_13$m] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	alert1 = new Alert({
    			props: {
    				color: "success",
    				isOpen: /*visibleMsg*/ ctx[3],
    				toggle: /*func_1*/ ctx[15],
    				$$slots: { default: [create_default_slot_12$m] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button0 = new Button({
    			props: {
    				$$slots: { default: [create_default_slot_11$m] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button0.$on("click", /*getPgAnt*/ ctx[8]);

    	button1 = new Button({
    			props: {
    				$$slots: { default: [create_default_slot_10$m] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1.$on("click", /*getPgSig*/ ctx[9]);

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: false,
    		pending: create_pending_block$3,
    		then: create_then_block$3,
    		catch: create_catch_block$3,
    		value: 6,
    		blocks: [,,,]
    	};

    	handle_promise(promise = /*economies*/ ctx[6], info);

    	const block = {
    		c: function create() {
    			main = element$1("main");
    			create_component(navbar.$$.fragment);
    			t0 = space();
    			h1 = element$1("h1");
    			h1.textContent = "Economia Mundial";
    			t2 = space();
    			create_component(alert0.$$.fragment);
    			t3 = space();
    			create_component(alert1.$$.fragment);
    			t4 = space();
    			create_component(button0.$$.fragment);
    			t5 = space();
    			create_component(button1.$$.fragment);
    			t6 = space();
    			info.block.c();
    			add_location(h1, file$r, 240, 4, 7466);
    			add_location(main, file$r, 197, 0, 5779);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			mount_component(navbar, main, null);
    			append_dev(main, t0);
    			append_dev(main, h1);
    			append_dev(main, t2);
    			mount_component(alert0, main, null);
    			append_dev(main, t3);
    			mount_component(alert1, main, null);
    			append_dev(main, t4);
    			mount_component(button0, main, null);
    			append_dev(main, t5);
    			mount_component(button1, main, null);
    			append_dev(main, t6);
    			info.block.m(main, info.anchor = null);
    			info.mount = () => main;
    			info.anchor = null;
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const navbar_changes = {};

    			if (dirty[1] & /*$$scope*/ 16) {
    				navbar_changes.$$scope = { dirty, ctx };
    			}

    			navbar.$set(navbar_changes);
    			const alert0_changes = {};
    			if (dirty[0] & /*visibleError*/ 4) alert0_changes.isOpen = /*visibleError*/ ctx[2];
    			if (dirty[0] & /*visibleError*/ 4) alert0_changes.toggle = /*func*/ ctx[14];

    			if (dirty[0] & /*msg*/ 16 | dirty[1] & /*$$scope*/ 16) {
    				alert0_changes.$$scope = { dirty, ctx };
    			}

    			alert0.$set(alert0_changes);
    			const alert1_changes = {};
    			if (dirty[0] & /*visibleMsg*/ 8) alert1_changes.isOpen = /*visibleMsg*/ ctx[3];
    			if (dirty[0] & /*visibleMsg*/ 8) alert1_changes.toggle = /*func_1*/ ctx[15];

    			if (dirty[0] & /*msg*/ 16 | dirty[1] & /*$$scope*/ 16) {
    				alert1_changes.$$scope = { dirty, ctx };
    			}

    			alert1.$set(alert1_changes);
    			const button0_changes = {};

    			if (dirty[1] & /*$$scope*/ 16) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty[1] & /*$$scope*/ 16) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    			info.ctx = ctx;

    			if (dirty[0] & /*economies*/ 64 && promise !== (promise = /*economies*/ ctx[6]) && handle_promise(promise, info)) ; else {
    				update_await_block_branch(info, ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			transition_in(alert0.$$.fragment, local);
    			transition_in(alert1.$$.fragment, local);
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			transition_in(info.block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			transition_out(alert0.$$.fragment, local);
    			transition_out(alert1.$$.fragment, local);
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);

    			for (let i = 0; i < 3; i += 1) {
    				const block = info.blocks[i];
    				transition_out(block);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(navbar);
    			destroy_component(alert0);
    			destroy_component(alert1);
    			destroy_component(button0);
    			destroy_component(button1);
    			info.block.d();
    			info.token = null;
    			info = null;
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$r($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Economies', slots, []);
    	let economies = [];
    	let datos2 = [];
    	let offset = 0;
    	let limit = 10;
    	let numEntries;
    	let from = null;
    	let to = null;
    	let visibleError = false;
    	let visibleMsg = false;
    	let errorMsg = "";
    	let msg = "";

    	let neweconomies = {
    		country: "",
    		year: "",
    		percapita: "",
    		currency: "",
    		currentprices: ""
    	};

    	onMount(getEconomies);

    	async function getEconomies() {
    		console.log("fetching economies ....");
    		let cadena = `/api/v2/economies?offset=+${offset}+&limit=+${limit}`;

    		if (from != null) {
    			cadena = cadena + `&from=${from}&`;
    		}

    		if (to != null) {
    			cadena = cadena + `to=${to}`;
    		}

    		const res = await fetch(cadena);

    		if (res.ok) {
    			const data = await res.json();
    			datos2 = data;

    			$$invalidate(6, economies = datos2.sort(function (a, b) {
    				return a.year - b.year;
    			}));

    			numEntries = economies.length;
    			console.log("Received economies: " + economies.length);
    		} else {
    			$$invalidate(2, visibleError = true);
    			$$invalidate(3, visibleMsg = false);
    			$$invalidate(4, msg = "No hay ningún dato entre " + from + " y " + to);
    		} //window.alert("No hay ningún dato entre estos límites")
    	}

    	async function getPgAnt() {
    		if (offset >= 10) {
    			offset = offset - 10;
    		}

    		//limit=limit+10;
    		console.log("fetching economies ....");

    		let cadena = `/api/v2/economies?offset=+${offset}+&limit=+${limit}`;

    		if (from != null) {
    			cadena = cadena + `&from=${from}&`;
    		}

    		if (to != null) {
    			cadena = cadena + `to=${to}`;
    		}

    		const res = await fetch(cadena);

    		if (res.ok) {
    			const data = await res.json();
    			datos2 = data;

    			$$invalidate(6, economies = datos2.sort(function (a, b) {
    				return a.year - b.year;
    			}));

    			console.log("Received economies: " + economies.length);
    		}
    	}

    	async function getPgSig() {
    		if (economies.length >= 10) {
    			offset = offset + 10;
    		}

    		//limit=limit+10;
    		console.log("fetching economies ....");

    		let cadena = `/api/v2/economies?offset=+${offset}+&limit=+${limit}`;

    		if (from != null) {
    			cadena = cadena + `&from=${from}&`;
    		}

    		if (to != null) {
    			cadena = cadena + `to=${to}`;
    		}

    		const res = await fetch(cadena);

    		if (res.ok) {
    			const data = await res.json();
    			datos2 = data;

    			$$invalidate(6, economies = datos2.sort(function (a, b) {
    				return a.year - b.year;
    			}));

    			console.log("Received economies: " + economies.length);
    		}
    	}

    	async function insertEconomies() {
    		if (neweconomies.country == "" || neweconomies.country == null || neweconomies.year == "" || neweconomies.year == null || neweconomies.percapita == "" || neweconomies.percapita == null || neweconomies.currency == "" || neweconomies.currency == null || neweconomies.currentprices == "" || neweconomies.currentprices == null) {
    			$$invalidate(2, visibleError = true);
    			$$invalidate(3, visibleMsg = false);
    			$$invalidate(4, msg = "Debe de rellenar todos los campos");
    		} else {
    			console.log("Inserting economies...." + JSON.stringify(neweconomies));

    			await fetch("/api/v2/economies", {
    				method: "POST",
    				body: JSON.stringify(neweconomies),
    				headers: { "Content-Type": "application/json" }
    			}).then(function (res) {
    				if (res.status == 201) {
    					getEconomies();
    					$$invalidate(5, neweconomies.country = null, neweconomies);
    					$$invalidate(5, neweconomies.year = null, neweconomies);
    					$$invalidate(5, neweconomies.percapita = null, neweconomies);
    					$$invalidate(5, neweconomies.currency = null, neweconomies);
    					$$invalidate(5, neweconomies.currentprices = null, neweconomies);
    					$$invalidate(2, visibleError = false);
    					$$invalidate(3, visibleMsg = true);
    					$$invalidate(4, msg = "Entrada introducida con éxito");
    				} else if (res.status == 409) {
    					$$invalidate(2, visibleError = true);
    					$$invalidate(3, visibleMsg = false);
    					$$invalidate(4, msg = "Ya existe ese recurso en la base de datos");
    					console.log("ERROR There is already a data with that country and year in the database");
    				}
    			});
    		}
    	}

    	async function BorrarEconomies(name, year) {
    		await fetch("/api/v2/economies/" + name + "/" + year, { method: "DELETE" }).then(function (res) {
    			getEconomies();

    			if (res.status == 200) {
    				console.log("Deleted " + name);

    				//window.alert(name + " elimida con éxito"); 
    				$$invalidate(2, visibleError = false);

    				$$invalidate(3, visibleMsg = true);
    				$$invalidate(4, msg = name + " elimida con éxito");
    			} else {
    				//window.alert(name + " no se ha podida eliminar");
    				$$invalidate(2, visibleError = true);

    				$$invalidate(3, visibleMsg = flase);
    				$$invalidate(4, msg = name + " no se ha podida eliminar");
    				console.log("DATA NOT FOUND");
    			}
    		});
    	}

    	async function BorrarEconomiesAll() {
    		console.log("Deleting economies....");

    		await fetch("/api/v2/economies/", { method: "DELETE" }).then(function (res) {
    			getEconomies();

    			//window.alert("Entradas elimidas con éxito");
    			$$invalidate(2, visibleError = false);

    			$$invalidate(3, visibleMsg = true);
    			$$invalidate(4, msg = "Entradas elimidas con éxito");
    		});
    	}

    	async function LoadEconomies() {
    		console.log("Loading economies....");

    		await fetch("/api/v2/economies/loadInitialData", { method: "GET" }).then(function (res) {
    			getEconomies();

    			//window.alert("Entradas cargadas con éxito");
    			$$invalidate(2, visibleError = false);

    			$$invalidate(3, visibleMsg = true);
    			$$invalidate(4, msg = "Entradas cargadas con éxito");
    		});
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$o.warn(`<Economies> was created with unknown prop '${key}'`);
    	});

    	const func = () => $$invalidate(2, visibleError = false);
    	const func_1 = () => $$invalidate(3, visibleMsg = false);

    	function input0_input_handler() {
    		from = to_number(this.value);
    		$$invalidate(0, from);
    	}

    	function input1_input_handler() {
    		to = to_number(this.value);
    		$$invalidate(1, to);
    	}

    	const click_handler = () => {
    		if (from == null || to == null) {
    			//window.alert('Los campos fecha inicio y fecha fin no pueden estar vacíos')
    			$$invalidate(2, visibleError = true);

    			$$invalidate(3, visibleMsg = false);
    			$$invalidate(4, msg = "Los campos fecha inicio y fecha fin no pueden estar vacíos");
    		} else {
    			getEconomies();
    		}
    	};

    	const click_handler_1 = () => {
    		$$invalidate(0, from = null);
    		$$invalidate(1, to = null);
    		getEconomies();
    	};

    	function input0_input_handler_1() {
    		neweconomies.country = this.value;
    		$$invalidate(5, neweconomies);
    	}

    	function input1_input_handler_1() {
    		neweconomies.year = to_number(this.value);
    		$$invalidate(5, neweconomies);
    	}

    	function input2_input_handler() {
    		neweconomies.percapita = to_number(this.value);
    		$$invalidate(5, neweconomies);
    	}

    	function input3_input_handler() {
    		neweconomies.currency = to_number(this.value);
    		$$invalidate(5, neweconomies);
    	}

    	function input4_input_handler() {
    		neweconomies.currentprices = to_number(this.value);
    		$$invalidate(5, neweconomies);
    	}

    	const click_handler_2 = () => {
    		$$invalidate(5, neweconomies.country = null, neweconomies);
    		$$invalidate(5, neweconomies.year = null, neweconomies);
    		$$invalidate(5, neweconomies.percapita = null, neweconomies);
    		$$invalidate(5, neweconomies.currency = null, neweconomies);
    		$$invalidate(5, neweconomies.currentprices = null, neweconomies);
    	};

    	const click_handler_3 = function (cd) {
    		window.location.href = `/#/economies/${cd.country + "/" + cd.year}`;
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		Table,
    		Button,
    		Alert,
    		Navbar,
    		Nav,
    		NavItem,
    		NavLink,
    		NavbarBrand,
    		Dropdown,
    		DropdownToggle,
    		DropdownMenu,
    		DropdownItem,
    		economies,
    		datos2,
    		offset,
    		limit,
    		numEntries,
    		from,
    		to,
    		visibleError,
    		visibleMsg,
    		errorMsg,
    		msg,
    		neweconomies,
    		getEconomies,
    		getPgAnt,
    		getPgSig,
    		insertEconomies,
    		BorrarEconomies,
    		BorrarEconomiesAll,
    		LoadEconomies
    	});

    	$$self.$inject_state = $$props => {
    		if ('economies' in $$props) $$invalidate(6, economies = $$props.economies);
    		if ('datos2' in $$props) datos2 = $$props.datos2;
    		if ('offset' in $$props) offset = $$props.offset;
    		if ('limit' in $$props) limit = $$props.limit;
    		if ('numEntries' in $$props) numEntries = $$props.numEntries;
    		if ('from' in $$props) $$invalidate(0, from = $$props.from);
    		if ('to' in $$props) $$invalidate(1, to = $$props.to);
    		if ('visibleError' in $$props) $$invalidate(2, visibleError = $$props.visibleError);
    		if ('visibleMsg' in $$props) $$invalidate(3, visibleMsg = $$props.visibleMsg);
    		if ('errorMsg' in $$props) errorMsg = $$props.errorMsg;
    		if ('msg' in $$props) $$invalidate(4, msg = $$props.msg);
    		if ('neweconomies' in $$props) $$invalidate(5, neweconomies = $$props.neweconomies);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		from,
    		to,
    		visibleError,
    		visibleMsg,
    		msg,
    		neweconomies,
    		economies,
    		getEconomies,
    		getPgAnt,
    		getPgSig,
    		insertEconomies,
    		BorrarEconomies,
    		BorrarEconomiesAll,
    		LoadEconomies,
    		func,
    		func_1,
    		input0_input_handler,
    		input1_input_handler,
    		click_handler,
    		click_handler_1,
    		input0_input_handler_1,
    		input1_input_handler_1,
    		input2_input_handler,
    		input3_input_handler,
    		input4_input_handler,
    		click_handler_2,
    		click_handler_3
    	];
    }

    class Economies extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$r, create_fragment$r, safe_not_equal, {}, null, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Economies",
    			options,
    			id: create_fragment$r.name
    		});
    	}
    }

    /* src\front\frontEconomies\EditEconomies.svelte generated by Svelte v3.47.0 */

    const { console: console_1$n } = globals;
    const file$q = "src\\front\\frontEconomies\\EditEconomies.svelte";

    // (97:2) {#if msg}
    function create_if_block_1(ctx) {
    	let p;
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			p = element$1("p");
    			t0 = text$1("ERROR: ");
    			t1 = text$1(/*msg*/ ctx[3]);
    			add_location(p, file$q, 97, 3, 2696);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t0);
    			append_dev(p, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*msg*/ 8) set_data_dev(t1, /*msg*/ ctx[3]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(97:2) {#if msg}",
    		ctx
    	});

    	return block;
    }

    // (96:4) <Alert color="danger" isOpen={visibleError} toggle={() => (visibleError = false)}>
    function create_default_slot_4$m(ctx) {
    	let if_block_anchor;
    	let if_block = /*msg*/ ctx[3] && create_if_block_1(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*msg*/ ctx[3]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$m.name,
    		type: "slot",
    		source: "(96:4) <Alert color=\\\"danger\\\" isOpen={visibleError} toggle={() => (visibleError = false)}>",
    		ctx
    	});

    	return block;
    }

    // (102:2) {#if msg}
    function create_if_block$5(ctx) {
    	let p;
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			p = element$1("p");
    			t0 = text$1("Correcto: ");
    			t1 = text$1(/*msg*/ ctx[3]);
    			add_location(p, file$q, 102, 3, 2838);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t0);
    			append_dev(p, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*msg*/ 8) set_data_dev(t1, /*msg*/ ctx[3]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(102:2) {#if msg}",
    		ctx
    	});

    	return block;
    }

    // (101:1) <Alert color="success" isOpen={visibleMsg} toggle={() => (visibleMsg = false)}>
    function create_default_slot_3$m(ctx) {
    	let if_block_anchor;
    	let if_block = /*msg*/ ctx[3] && create_if_block$5(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*msg*/ ctx[3]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$5(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$m.name,
    		type: "slot",
    		source: "(101:1) <Alert color=\\\"success\\\" isOpen={visibleMsg} toggle={() => (visibleMsg = false)}>",
    		ctx
    	});

    	return block;
    }

    // (1:0) <script>        export let params={}
    function create_catch_block$2(ctx) {
    	const block = {
    		c: noop$4,
    		m: noop$4,
    		p: noop$4,
    		i: noop$4,
    		o: noop$4,
    		d: noop$4
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block$2.name,
    		type: "catch",
    		source: "(1:0) <script>        export let params={}",
    		ctx
    	});

    	return block;
    }

    // (108:8) {:then economies}
    function create_then_block$2(ctx) {
    	let table;
    	let current;

    	table = new Table({
    			props: {
    				bordered: true,
    				$$slots: { default: [create_default_slot_1$m] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(table.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(table, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const table_changes = {};

    			if (dirty & /*$$scope, updatedcurrentprices, updatedcurrency, updatedpercapita, params*/ 262257) {
    				table_changes.$$scope = { dirty, ctx };
    			}

    			table.$set(table_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(table.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(table.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(table, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block$2.name,
    		type: "then",
    		source: "(108:8) {:then economies}",
    		ctx
    	});

    	return block;
    }

    // (128:24) <Button outline color="primary" on:click="{EditEconomies}">
    function create_default_slot_2$m(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Editar");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$m.name,
    		type: "slot",
    		source: "(128:24) <Button outline color=\\\"primary\\\" on:click=\\\"{EditEconomies}\\\">",
    		ctx
    	});

    	return block;
    }

    // (110:8) <Table bordered>
    function create_default_slot_1$m(ctx) {
    	let thead;
    	let tr0;
    	let th0;
    	let t1;
    	let th1;
    	let t3;
    	let th2;
    	let t5;
    	let th3;
    	let t7;
    	let th4;
    	let t9;
    	let tbody;
    	let tr1;
    	let td0;
    	let t10_value = /*params*/ ctx[0].country + "";
    	let t10;
    	let t11;
    	let td1;
    	let t12_value = /*params*/ ctx[0].year + "";
    	let t12;
    	let t13;
    	let td2;
    	let input0;
    	let t14;
    	let td3;
    	let input1;
    	let t15;
    	let td4;
    	let input2;
    	let t16;
    	let td5;
    	let button;
    	let current;
    	let mounted;
    	let dispose;

    	button = new Button({
    			props: {
    				outline: true,
    				color: "primary",
    				$$slots: { default: [create_default_slot_2$m] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*EditEconomies*/ ctx[8]);

    	const block = {
    		c: function create() {
    			thead = element$1("thead");
    			tr0 = element$1("tr");
    			th0 = element$1("th");
    			th0.textContent = "País";
    			t1 = space();
    			th1 = element$1("th");
    			th1.textContent = "Año";
    			t3 = space();
    			th2 = element$1("th");
    			th2.textContent = "percapita";
    			t5 = space();
    			th3 = element$1("th");
    			th3.textContent = "currency";
    			t7 = space();
    			th4 = element$1("th");
    			th4.textContent = "currentprices";
    			t9 = space();
    			tbody = element$1("tbody");
    			tr1 = element$1("tr");
    			td0 = element$1("td");
    			t10 = text$1(t10_value);
    			t11 = space();
    			td1 = element$1("td");
    			t12 = text$1(t12_value);
    			t13 = space();
    			td2 = element$1("td");
    			input0 = element$1("input");
    			t14 = space();
    			td3 = element$1("td");
    			input1 = element$1("input");
    			t15 = space();
    			td4 = element$1("td");
    			input2 = element$1("input");
    			t16 = space();
    			td5 = element$1("td");
    			create_component(button.$$.fragment);
    			add_location(th0, file$q, 112, 20, 3041);
    			add_location(th1, file$q, 113, 20, 3076);
    			add_location(th2, file$q, 114, 20, 3110);
    			add_location(th3, file$q, 115, 20, 3150);
    			add_location(th4, file$q, 116, 20, 3189);
    			add_location(tr0, file$q, 111, 16, 3015);
    			add_location(thead, file$q, 110, 12, 2990);
    			add_location(td0, file$q, 121, 20, 3321);
    			add_location(td1, file$q, 122, 20, 3368);
    			add_location(input0, file$q, 123, 24, 3416);
    			add_location(td2, file$q, 123, 20, 3412);
    			add_location(input1, file$q, 124, 24, 3486);
    			add_location(td3, file$q, 124, 20, 3482);
    			add_location(input2, file$q, 125, 24, 3555);
    			add_location(td4, file$q, 125, 20, 3551);
    			add_location(td5, file$q, 127, 20, 3631);
    			add_location(tr1, file$q, 120, 16, 3295);
    			add_location(tbody, file$q, 119, 12, 3270);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, thead, anchor);
    			append_dev(thead, tr0);
    			append_dev(tr0, th0);
    			append_dev(tr0, t1);
    			append_dev(tr0, th1);
    			append_dev(tr0, t3);
    			append_dev(tr0, th2);
    			append_dev(tr0, t5);
    			append_dev(tr0, th3);
    			append_dev(tr0, t7);
    			append_dev(tr0, th4);
    			insert_dev(target, t9, anchor);
    			insert_dev(target, tbody, anchor);
    			append_dev(tbody, tr1);
    			append_dev(tr1, td0);
    			append_dev(td0, t10);
    			append_dev(tr1, t11);
    			append_dev(tr1, td1);
    			append_dev(td1, t12);
    			append_dev(tr1, t13);
    			append_dev(tr1, td2);
    			append_dev(td2, input0);
    			set_input_value(input0, /*updatedpercapita*/ ctx[4]);
    			append_dev(tr1, t14);
    			append_dev(tr1, td3);
    			append_dev(td3, input1);
    			set_input_value(input1, /*updatedcurrency*/ ctx[5]);
    			append_dev(tr1, t15);
    			append_dev(tr1, td4);
    			append_dev(td4, input2);
    			set_input_value(input2, /*updatedcurrentprices*/ ctx[6]);
    			append_dev(tr1, t16);
    			append_dev(tr1, td5);
    			mount_component(button, td5, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[11]),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[12]),
    					listen_dev(input2, "input", /*input2_input_handler*/ ctx[13])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*params*/ 1) && t10_value !== (t10_value = /*params*/ ctx[0].country + "")) set_data_dev(t10, t10_value);
    			if ((!current || dirty & /*params*/ 1) && t12_value !== (t12_value = /*params*/ ctx[0].year + "")) set_data_dev(t12, t12_value);

    			if (dirty & /*updatedpercapita*/ 16 && input0.value !== /*updatedpercapita*/ ctx[4]) {
    				set_input_value(input0, /*updatedpercapita*/ ctx[4]);
    			}

    			if (dirty & /*updatedcurrency*/ 32 && input1.value !== /*updatedcurrency*/ ctx[5]) {
    				set_input_value(input1, /*updatedcurrency*/ ctx[5]);
    			}

    			if (dirty & /*updatedcurrentprices*/ 64 && input2.value !== /*updatedcurrentprices*/ ctx[6]) {
    				set_input_value(input2, /*updatedcurrentprices*/ ctx[6]);
    			}

    			const button_changes = {};

    			if (dirty & /*$$scope*/ 262144) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(thead);
    			if (detaching) detach_dev(t9);
    			if (detaching) detach_dev(tbody);
    			destroy_component(button);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$m.name,
    		type: "slot",
    		source: "(110:8) <Table bordered>",
    		ctx
    	});

    	return block;
    }

    // (106:22)       loading          {:then economies}
    function create_pending_block$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("loading");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop$4,
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block$2.name,
    		type: "pending",
    		source: "(106:22)       loading          {:then economies}",
    		ctx
    	});

    	return block;
    }

    // (137:4) <Button outline color="secondary" on:click= "{pop}">
    function create_default_slot$m(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Volver");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$m.name,
    		type: "slot",
    		source: "(137:4) <Button outline color=\\\"secondary\\\" on:click= \\\"{pop}\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$q(ctx) {
    	let main;
    	let h1;
    	let t0;
    	let t1_value = /*params*/ ctx[0].country + "";
    	let t1;
    	let t2;
    	let t3;
    	let alert0;
    	let t4;
    	let alert1;
    	let t5;
    	let promise;
    	let t6;
    	let button;
    	let current;

    	alert0 = new Alert({
    			props: {
    				color: "danger",
    				isOpen: /*visibleError*/ ctx[1],
    				toggle: /*func*/ ctx[9],
    				$$slots: { default: [create_default_slot_4$m] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	alert1 = new Alert({
    			props: {
    				color: "success",
    				isOpen: /*visibleMsg*/ ctx[2],
    				toggle: /*func_1*/ ctx[10],
    				$$slots: { default: [create_default_slot_3$m] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: false,
    		pending: create_pending_block$2,
    		then: create_then_block$2,
    		catch: create_catch_block$2,
    		value: 7,
    		blocks: [,,,]
    	};

    	handle_promise(promise = /*economies*/ ctx[7], info);

    	button = new Button({
    			props: {
    				outline: true,
    				color: "secondary",
    				$$slots: { default: [create_default_slot$m] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", pop);

    	const block = {
    		c: function create() {
    			main = element$1("main");
    			h1 = element$1("h1");
    			t0 = text$1("Editar \"");
    			t1 = text$1(t1_value);
    			t2 = text$1("\"");
    			t3 = space();
    			create_component(alert0.$$.fragment);
    			t4 = space();
    			create_component(alert1.$$.fragment);
    			t5 = space();
    			info.block.c();
    			t6 = space();
    			create_component(button.$$.fragment);
    			add_location(h1, file$q, 94, 4, 2554);
    			add_location(main, file$q, 93, 0, 2542);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, h1);
    			append_dev(h1, t0);
    			append_dev(h1, t1);
    			append_dev(h1, t2);
    			append_dev(main, t3);
    			mount_component(alert0, main, null);
    			append_dev(main, t4);
    			mount_component(alert1, main, null);
    			append_dev(main, t5);
    			info.block.m(main, info.anchor = null);
    			info.mount = () => main;
    			info.anchor = t6;
    			append_dev(main, t6);
    			mount_component(button, main, null);
    			current = true;
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;
    			if ((!current || dirty & /*params*/ 1) && t1_value !== (t1_value = /*params*/ ctx[0].country + "")) set_data_dev(t1, t1_value);
    			const alert0_changes = {};
    			if (dirty & /*visibleError*/ 2) alert0_changes.isOpen = /*visibleError*/ ctx[1];
    			if (dirty & /*visibleError*/ 2) alert0_changes.toggle = /*func*/ ctx[9];

    			if (dirty & /*$$scope, msg*/ 262152) {
    				alert0_changes.$$scope = { dirty, ctx };
    			}

    			alert0.$set(alert0_changes);
    			const alert1_changes = {};
    			if (dirty & /*visibleMsg*/ 4) alert1_changes.isOpen = /*visibleMsg*/ ctx[2];
    			if (dirty & /*visibleMsg*/ 4) alert1_changes.toggle = /*func_1*/ ctx[10];

    			if (dirty & /*$$scope, msg*/ 262152) {
    				alert1_changes.$$scope = { dirty, ctx };
    			}

    			alert1.$set(alert1_changes);
    			info.ctx = ctx;

    			if (dirty & /*economies*/ 128 && promise !== (promise = /*economies*/ ctx[7]) && handle_promise(promise, info)) ; else {
    				update_await_block_branch(info, ctx, dirty);
    			}

    			const button_changes = {};

    			if (dirty & /*$$scope*/ 262144) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(alert0.$$.fragment, local);
    			transition_in(alert1.$$.fragment, local);
    			transition_in(info.block);
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(alert0.$$.fragment, local);
    			transition_out(alert1.$$.fragment, local);

    			for (let i = 0; i < 3; i += 1) {
    				const block = info.blocks[i];
    				transition_out(block);
    			}

    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(alert0);
    			destroy_component(alert1);
    			info.block.d();
    			info.token = null;
    			info = null;
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    async function Fallos$1(code, entrada) {
    	let msg;

    	if (code == 404) {
    		msg = "No se encuentra " + entrada;
    	}

    	if (code == 400) {
    		msg = "solicitud incorrecta";
    	}

    	if (code == 409) {
    		msg = "El dato introducido ya existe";
    	}

    	if (code == 401) {
    		msg = "No autorizado";
    	}

    	if (code == 405) {
    		msg = "Método no permitido";
    	}

    	window.alert(msg);
    	return;
    }

    function instance$q($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('EditEconomies', slots, []);
    	let { params = {} } = $$props;
    	let visibleError = false;
    	let visibleMsg = false;
    	let errorMsg = "";
    	let msg = "";
    	let economies = {};
    	let updatedCountry;
    	let updatedYear;
    	let updatedpercapita;
    	let updatedcurrency;
    	let updatedcurrentprices;
    	onMount(getEconomies);

    	async function getEconomies() {
    		console.log("fetching Economies ...." + params.country + " " + params.year);
    		const res = await fetch("/api/v2/economies/" + params.country + "/" + params.year);

    		if (res.ok) {
    			const data = await res.json();
    			$$invalidate(7, economies = data);
    			updatedCountry = economies.country;
    			updatedYear = economies.year;
    			$$invalidate(4, updatedpercapita = economies.percapita);
    			$$invalidate(5, updatedcurrency = economies.currency);
    			$$invalidate(6, updatedcurrentprices = economies.currentprices);
    		} else {
    			Fallos$1(res.status, params.country);
    			pop();
    		}
    	}

    	async function EditEconomies() {
    		console.log("Updating economies...." + params.country + " " + params.year);

    		await fetch("/api/v2/economies/" + params.country + "/" + params.year, {
    			method: "PUT",
    			body: JSON.stringify({
    				country: updatedCountry,
    				year: updatedYear,
    				percapita: parseInt(updatedpercapita),
    				currency: parseInt(updatedcurrency),
    				currentprices: parseInt(updatedcurrentprices)
    			}),
    			headers: { "Content-Type": "application/json" }
    		});

    		$$invalidate(1, visibleError = false);
    		$$invalidate(2, visibleMsg = true);
    		$$invalidate(3, msg = updatedCountry + " se ha editado correctamente");
    	} //window.alert("Se ha editado correctamente");

    	const writable_props = ['params'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$n.warn(`<EditEconomies> was created with unknown prop '${key}'`);
    	});

    	const func = () => $$invalidate(1, visibleError = false);
    	const func_1 = () => $$invalidate(2, visibleMsg = false);

    	function input0_input_handler() {
    		updatedpercapita = this.value;
    		$$invalidate(4, updatedpercapita);
    	}

    	function input1_input_handler() {
    		updatedcurrency = this.value;
    		$$invalidate(5, updatedcurrency);
    	}

    	function input2_input_handler() {
    		updatedcurrentprices = this.value;
    		$$invalidate(6, updatedcurrentprices);
    	}

    	$$self.$$set = $$props => {
    		if ('params' in $$props) $$invalidate(0, params = $$props.params);
    	};

    	$$self.$capture_state = () => ({
    		params,
    		pop,
    		onMount,
    		Button,
    		Table,
    		Alert,
    		visibleError,
    		visibleMsg,
    		errorMsg,
    		msg,
    		economies,
    		updatedCountry,
    		updatedYear,
    		updatedpercapita,
    		updatedcurrency,
    		updatedcurrentprices,
    		getEconomies,
    		EditEconomies,
    		Fallos: Fallos$1
    	});

    	$$self.$inject_state = $$props => {
    		if ('params' in $$props) $$invalidate(0, params = $$props.params);
    		if ('visibleError' in $$props) $$invalidate(1, visibleError = $$props.visibleError);
    		if ('visibleMsg' in $$props) $$invalidate(2, visibleMsg = $$props.visibleMsg);
    		if ('errorMsg' in $$props) errorMsg = $$props.errorMsg;
    		if ('msg' in $$props) $$invalidate(3, msg = $$props.msg);
    		if ('economies' in $$props) $$invalidate(7, economies = $$props.economies);
    		if ('updatedCountry' in $$props) updatedCountry = $$props.updatedCountry;
    		if ('updatedYear' in $$props) updatedYear = $$props.updatedYear;
    		if ('updatedpercapita' in $$props) $$invalidate(4, updatedpercapita = $$props.updatedpercapita);
    		if ('updatedcurrency' in $$props) $$invalidate(5, updatedcurrency = $$props.updatedcurrency);
    		if ('updatedcurrentprices' in $$props) $$invalidate(6, updatedcurrentprices = $$props.updatedcurrentprices);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		params,
    		visibleError,
    		visibleMsg,
    		msg,
    		updatedpercapita,
    		updatedcurrency,
    		updatedcurrentprices,
    		economies,
    		EditEconomies,
    		func,
    		func_1,
    		input0_input_handler,
    		input1_input_handler,
    		input2_input_handler
    	];
    }

    class EditEconomies_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$q, create_fragment$q, safe_not_equal, { params: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EditEconomies_1",
    			options,
    			id: create_fragment$q.name
    		});
    	}

    	get params() {
    		throw new Error("<EditEconomies>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set params(value) {
    		throw new Error("<EditEconomies>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\front\frontEconomies\MyGraphEconomies.svelte generated by Svelte v3.47.0 */

    const { console: console_1$m } = globals;

    const file$p = "src\\front\\frontEconomies\\MyGraphEconomies.svelte";

    // (107:2) <NavbarBrand href="#/info">
    function create_default_slot_22$i(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("INICIO");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_22$i.name,
    		type: "slot",
    		source: "(107:2) <NavbarBrand href=\\\"#/info\\\">",
    		ctx
    	});

    	return block;
    }

    // (110:4) <DropdownToggle nav caret>
    function create_default_slot_21$l(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("API");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_21$l.name,
    		type: "slot",
    		source: "(110:4) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (112:6) <DropdownItem href="./api/v2/economies">
    function create_default_slot_20$l(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_20$l.name,
    		type: "slot",
    		source: "(112:6) <DropdownItem href=\\\"./api/v2/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (114:6) <DropdownItem href="./api/v1/esco-stats">
    function create_default_slot_19$l(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_19$l.name,
    		type: "slot",
    		source: "(114:6) <DropdownItem href=\\\"./api/v1/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (116:6) <DropdownItem href="./api/v1/expo-stats">
    function create_default_slot_18$l(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_18$l.name,
    		type: "slot",
    		source: "(116:6) <DropdownItem href=\\\"./api/v1/expo-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (111:4) <DropdownMenu end>
    function create_default_slot_17$l(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./api/v2/economies",
    				$$slots: { default: [create_default_slot_20$l] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "./api/v1/esco-stats",
    				$$slots: { default: [create_default_slot_19$l] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "./api/v1/expo-stats",
    				$$slots: { default: [create_default_slot_18$l] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17$l.name,
    		type: "slot",
    		source: "(111:4) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (109:3) <Dropdown >
    function create_default_slot_16$l(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_21$l] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_17$l] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16$l.name,
    		type: "slot",
    		source: "(109:3) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (121:4) <DropdownToggle nav caret>
    function create_default_slot_15$l(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15$l.name,
    		type: "slot",
    		source: "(121:4) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (123:6) <DropdownItem href="./#/economies">
    function create_default_slot_14$l(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14$l.name,
    		type: "slot",
    		source: "(123:6) <DropdownItem href=\\\"./#/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (124:6) <DropdownItem href="#/esco-stats">
    function create_default_slot_13$l(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13$l.name,
    		type: "slot",
    		source: "(124:6) <DropdownItem href=\\\"#/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (125:6) <DropdownItem href="#/expo">
    function create_default_slot_12$l(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo-Stats FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12$l.name,
    		type: "slot",
    		source: "(125:6) <DropdownItem href=\\\"#/expo\\\">",
    		ctx
    	});

    	return block;
    }

    // (127:6) <DropdownItem href="#/graph">
    function create_default_slot_11$l(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Conjunto");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$l.name,
    		type: "slot",
    		source: "(127:6) <DropdownItem href=\\\"#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (122:4) <DropdownMenu end>
    function create_default_slot_10$l(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies",
    				$$slots: { default: [create_default_slot_14$l] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({
    			props: {
    				href: "#/esco-stats",
    				$$slots: { default: [create_default_slot_13$l] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "#/expo",
    				$$slots: { default: [create_default_slot_12$l] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/graph",
    				$$slots: { default: [create_default_slot_11$l] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem1_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdownitem1_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem1.$set(dropdownitem1_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$l.name,
    		type: "slot",
    		source: "(122:4) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (120:12) <Dropdown>
    function create_default_slot_9$l(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_15$l] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_10$l] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$l.name,
    		type: "slot",
    		source: "(120:12) <Dropdown>",
    		ctx
    	});

    	return block;
    }

    // (132:4) <DropdownToggle nav caret>
    function create_default_slot_8$l(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Gráficas");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$l.name,
    		type: "slot",
    		source: "(132:4) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (134:6) <DropdownItem href="./#/economies-graph">
    function create_default_slot_7$l(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$l.name,
    		type: "slot",
    		source: "(134:6) <DropdownItem href=\\\"./#/economies-graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (135:6) <DropdownItem href="#/graphesco">
    function create_default_slot_6$l(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$l.name,
    		type: "slot",
    		source: "(135:6) <DropdownItem href=\\\"#/graphesco\\\">",
    		ctx
    	});

    	return block;
    }

    // (136:6) <DropdownItem href="#/graphexpo">
    function create_default_slot_5$l(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$l.name,
    		type: "slot",
    		source: "(136:6) <DropdownItem href=\\\"#/graphexpo\\\">",
    		ctx
    	});

    	return block;
    }

    // (138:6) <DropdownItem href="#/graph">
    function create_default_slot_4$l(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Conjunto");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$l.name,
    		type: "slot",
    		source: "(138:6) <DropdownItem href=\\\"#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (133:4) <DropdownMenu end>
    function create_default_slot_3$l(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies-graph",
    				$$slots: { default: [create_default_slot_7$l] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({
    			props: {
    				href: "#/graphesco",
    				$$slots: { default: [create_default_slot_6$l] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "#/graphexpo",
    				$$slots: { default: [create_default_slot_5$l] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/graph",
    				$$slots: { default: [create_default_slot_4$l] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem1_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdownitem1_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem1.$set(dropdownitem1_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$l.name,
    		type: "slot",
    		source: "(133:4) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (131:5) <Dropdown >
    function create_default_slot_2$l(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_8$l] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_3$l] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$l.name,
    		type: "slot",
    		source: "(131:5) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (108:2) <Nav navbar>
    function create_default_slot_1$l(ctx) {
    	let dropdown0;
    	let t0;
    	let dropdown1;
    	let t1;
    	let dropdown2;
    	let current;

    	dropdown0 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_16$l] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown1 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_9$l] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown2 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_2$l] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdown0.$$.fragment);
    			t0 = space();
    			create_component(dropdown1.$$.fragment);
    			t1 = space();
    			create_component(dropdown2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdown0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdown1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdown2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdown0_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdown0_changes.$$scope = { dirty, ctx };
    			}

    			dropdown0.$set(dropdown0_changes);
    			const dropdown1_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdown1_changes.$$scope = { dirty, ctx };
    			}

    			dropdown1.$set(dropdown1_changes);
    			const dropdown2_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdown2_changes.$$scope = { dirty, ctx };
    			}

    			dropdown2.$set(dropdown2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdown0.$$.fragment, local);
    			transition_in(dropdown1.$$.fragment, local);
    			transition_in(dropdown2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdown0.$$.fragment, local);
    			transition_out(dropdown1.$$.fragment, local);
    			transition_out(dropdown2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdown0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdown1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdown2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$l.name,
    		type: "slot",
    		source: "(108:2) <Nav navbar>",
    		ctx
    	});

    	return block;
    }

    // (106:1) <Navbar style="background-color: lightgreen; color:white;" light expand="lg" >
    function create_default_slot$l(ctx) {
    	let navbarbrand;
    	let t;
    	let nav;
    	let current;

    	navbarbrand = new NavbarBrand({
    			props: {
    				href: "#/info",
    				$$slots: { default: [create_default_slot_22$i] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	nav = new Nav({
    			props: {
    				navbar: true,
    				$$slots: { default: [create_default_slot_1$l] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navbarbrand.$$.fragment);
    			t = space();
    			create_component(nav.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbarbrand, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(nav, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navbarbrand_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				navbarbrand_changes.$$scope = { dirty, ctx };
    			}

    			navbarbrand.$set(navbarbrand_changes);
    			const nav_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				nav_changes.$$scope = { dirty, ctx };
    			}

    			nav.$set(nav_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbarbrand.$$.fragment, local);
    			transition_in(nav.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbarbrand.$$.fragment, local);
    			transition_out(nav.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbarbrand, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(nav, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$l.name,
    		type: "slot",
    		source: "(106:1) <Navbar style=\\\"background-color: lightgreen; color:white;\\\" light expand=\\\"lg\\\" >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$p(ctx) {
    	let script0;
    	let script0_src_value;
    	let script1;
    	let script1_src_value;
    	let script2;
    	let script2_src_value;
    	let script3;
    	let script3_src_value;
    	let t0;
    	let main;
    	let navbar;
    	let t1;
    	let br;
    	let t2;
    	let figure;
    	let div;
    	let t3;
    	let p;
    	let current;
    	let mounted;
    	let dispose;

    	navbar = new Navbar({
    			props: {
    				style: "background-color: lightgreen; color:white;",
    				light: true,
    				expand: "lg",
    				$$slots: { default: [create_default_slot$l] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			script0 = element$1("script");
    			script1 = element$1("script");
    			script2 = element$1("script");
    			script3 = element$1("script");
    			t0 = space();
    			main = element$1("main");
    			create_component(navbar.$$.fragment);
    			t1 = space();
    			br = element$1("br");
    			t2 = space();
    			figure = element$1("figure");
    			div = element$1("div");
    			t3 = space();
    			p = element$1("p");
    			p.textContent = "A simple demo showcasing an area chart with negative values and multiple\r\n            data series. Note that interacting with one data series will dim the\r\n            others, making it easier to distinguish between them.";
    			if (!src_url_equal(script0.src, script0_src_value = "https://code.highcharts.com/highcharts.js")) attr_dev(script0, "src", script0_src_value);
    			add_location(script0, file$p, 95, 4, 3056);
    			if (!src_url_equal(script1.src, script1_src_value = "https://code.highcharts.com/modules/exporting.js")) attr_dev(script1, "src", script1_src_value);
    			add_location(script1, file$p, 96, 4, 3127);
    			if (!src_url_equal(script2.src, script2_src_value = "https://code.highcharts.com/modules/export-data.js")) attr_dev(script2, "src", script2_src_value);
    			add_location(script2, file$p, 97, 4, 3205);
    			if (!src_url_equal(script3.src, script3_src_value = "https://code.highcharts.com/modules/accessibility.js")) attr_dev(script3, "src", script3_src_value);
    			add_location(script3, file$p, 98, 4, 3285);
    			add_location(br, file$p, 146, 4, 5106);
    			attr_dev(div, "id", "container");
    			add_location(div, file$p, 148, 8, 5160);
    			attr_dev(p, "class", "highcharts-description");
    			add_location(p, file$p, 149, 8, 5196);
    			attr_dev(figure, "class", "highcharts-figure");
    			add_location(figure, file$p, 147, 4, 5116);
    			add_location(main, file$p, 103, 0, 3406);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			append_dev(document.head, script0);
    			append_dev(document.head, script1);
    			append_dev(document.head, script2);
    			append_dev(document.head, script3);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			mount_component(navbar, main, null);
    			append_dev(main, t1);
    			append_dev(main, br);
    			append_dev(main, t2);
    			append_dev(main, figure);
    			append_dev(figure, div);
    			append_dev(figure, t3);
    			append_dev(figure, p);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(script3, "load", /*loadGraph*/ ctx[0], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const navbar_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				navbar_changes.$$scope = { dirty, ctx };
    			}

    			navbar.$set(navbar_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			detach_dev(script0);
    			detach_dev(script1);
    			detach_dev(script2);
    			detach_dev(script3);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			destroy_component(navbar);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$p($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MyGraphEconomies', slots, []);
    	const delay = ms => new Promise(res => setTimeout(res, ms));
    	let year = [];
    	let country = [];
    	let percapita = [];
    	let currency = [];
    	let currentprices = [];
    	let datos = [];
    	let datosOrdenados = [];

    	//creo 2 let datos para poder ordenado los datos por año
    	async function getData() {
    		console.log("Fetching Economies....");
    		const res = await fetch("/api/v2/economies");

    		if (res.ok) {
    			const data = await res.json();
    			datos = data;

    			if (datos.length == 0) {
    				await fetch("/api/v2/economies/loadInitialData");
    				console.log("Entradas recibidas: " + datos.length);

    				datosOrdenados = datos.sort(function (a, b) {
    					return a.year - b.year;
    				});

    				console.log("Ordenadas correctamente");

    				datosOrdenados.forEach(dato => {
    					year.push(dato.year);
    					country.push(dato.country + "-" + dato.year);
    					percapita.push(dato.percapita);
    					currency.push(dato.currency);
    					currentprices.push(dato.currentprices);
    				});

    				location.reload();
    			} else {
    				console.log("Entradas recibidas: " + datos.length);

    				//con la siguiente funcion ordeno los datos por años de menor a mayor
    				datosOrdenados = datos.sort(function (a, b) {
    					return a.year - b.year;
    				});

    				console.log("Ordenadas correctamente");

    				datosOrdenados.forEach(dato => {
    					year.push(dato.year);
    					country.push(dato.country + "-" + dato.year);
    					percapita.push(dato.percapita);
    					currency.push(dato.currency);
    					currentprices.push(dato.currentprices);
    				});
    			}
    		} else {
    			console.log("Error, can`t charge data");
    		}
    	}

    	async function loadGraph() {
    		Highcharts.chart('container', {
    			chart: { type: 'area' },
    			title: { text: 'Economia Mundial' },
    			xAxis: { categories: country },
    			credits: { enabled: false },
    			series: [
    				{ name: 'percapita', data: percapita },
    				{ name: 'currency', data: currency },
    				{
    					name: 'currentprices',
    					data: currentprices
    				}
    			]
    		});
    	}

    	onMount(getData);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$m.warn(`<MyGraphEconomies> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		Navbar,
    		Nav,
    		NavItem,
    		NavLink,
    		NavbarBrand,
    		Dropdown,
    		DropdownToggle,
    		DropdownMenu,
    		DropdownItem,
    		Button,
    		delay,
    		year,
    		country,
    		percapita,
    		currency,
    		currentprices,
    		datos,
    		datosOrdenados,
    		getData,
    		loadGraph
    	});

    	$$self.$inject_state = $$props => {
    		if ('year' in $$props) year = $$props.year;
    		if ('country' in $$props) country = $$props.country;
    		if ('percapita' in $$props) percapita = $$props.percapita;
    		if ('currency' in $$props) currency = $$props.currency;
    		if ('currentprices' in $$props) currentprices = $$props.currentprices;
    		if ('datos' in $$props) datos = $$props.datos;
    		if ('datosOrdenados' in $$props) datosOrdenados = $$props.datosOrdenados;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [loadGraph];
    }

    class MyGraphEconomies extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$p, create_fragment$p, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MyGraphEconomies",
    			options,
    			id: create_fragment$p.name
    		});
    	}
    }

    /* src\front\expo-stats\Expo.svelte generated by Svelte v3.47.0 */

    const { console: console_1$l } = globals;

    const file$o = "src\\front\\expo-stats\\Expo.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[29] = list[i];
    	return child_ctx;
    }

    // (175:2) <NavbarBrand href="#/info">
    function create_default_slot_36(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("INICIO");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_36.name,
    		type: "slot",
    		source: "(175:2) <NavbarBrand href=\\\"#/info\\\">",
    		ctx
    	});

    	return block;
    }

    // (178:4) <DropdownToggle nav caret>
    function create_default_slot_35(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("API");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_35.name,
    		type: "slot",
    		source: "(178:4) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (180:6) <DropdownItem href="./api/v2/economies">
    function create_default_slot_34(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_34.name,
    		type: "slot",
    		source: "(180:6) <DropdownItem href=\\\"./api/v2/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (182:6) <DropdownItem href="./api/v1/esco-stats">
    function create_default_slot_33(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_33.name,
    		type: "slot",
    		source: "(182:6) <DropdownItem href=\\\"./api/v1/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (184:6) <DropdownItem href="./api/v1/expo">
    function create_default_slot_32(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_32.name,
    		type: "slot",
    		source: "(184:6) <DropdownItem href=\\\"./api/v1/expo\\\">",
    		ctx
    	});

    	return block;
    }

    // (179:4) <DropdownMenu end>
    function create_default_slot_31(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./api/v2/economies",
    				$$slots: { default: [create_default_slot_34] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "./api/v1/esco-stats",
    				$$slots: { default: [create_default_slot_33] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "./api/v1/expo",
    				$$slots: { default: [create_default_slot_32] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem2_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_31.name,
    		type: "slot",
    		source: "(179:4) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (177:3) <Dropdown >
    function create_default_slot_30(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_35] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_31] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_30.name,
    		type: "slot",
    		source: "(177:3) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (189:4) <DropdownToggle nav caret>
    function create_default_slot_29(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_29.name,
    		type: "slot",
    		source: "(189:4) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (191:6) <DropdownItem href="./#/economies">
    function create_default_slot_28(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Economies FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_28.name,
    		type: "slot",
    		source: "(191:6) <DropdownItem href=\\\"./#/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (192:6) <DropdownItem href="./#/esco-stats">
    function create_default_slot_27$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco FRONT_END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_27$1.name,
    		type: "slot",
    		source: "(192:6) <DropdownItem href=\\\"./#/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (193:6) <DropdownItem href="#/expo">
    function create_default_slot_26$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Expo FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_26$1.name,
    		type: "slot",
    		source: "(193:6) <DropdownItem href=\\\"#/expo\\\">",
    		ctx
    	});

    	return block;
    }

    // (195:6) <DropdownItem href="#/graph">
    function create_default_slot_25$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Conjunto");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_25$3.name,
    		type: "slot",
    		source: "(195:6) <DropdownItem href=\\\"#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (190:4) <DropdownMenu end>
    function create_default_slot_24$4(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies",
    				$$slots: { default: [create_default_slot_28] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({
    			props: {
    				href: "./#/esco-stats",
    				$$slots: { default: [create_default_slot_27$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "#/expo",
    				$$slots: { default: [create_default_slot_26$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/graph",
    				$$slots: { default: [create_default_slot_25$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem1_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				dropdownitem1_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem1.$set(dropdownitem1_changes);
    			const dropdownitem2_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_24$4.name,
    		type: "slot",
    		source: "(190:4) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (188:12) <Dropdown>
    function create_default_slot_23$a(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_29] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_24$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_23$a.name,
    		type: "slot",
    		source: "(188:12) <Dropdown>",
    		ctx
    	});

    	return block;
    }

    // (200:4) <DropdownToggle nav caret>
    function create_default_slot_22$h(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Gráficas");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_22$h.name,
    		type: "slot",
    		source: "(200:4) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (202:6) <DropdownItem href="./#/economies-graph">
    function create_default_slot_21$k(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_21$k.name,
    		type: "slot",
    		source: "(202:6) <DropdownItem href=\\\"./#/economies-graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (203:6) <DropdownItem href="./#/graphesco">
    function create_default_slot_20$k(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_20$k.name,
    		type: "slot",
    		source: "(203:6) <DropdownItem href=\\\"./#/graphesco\\\">",
    		ctx
    	});

    	return block;
    }

    // (204:6) <DropdownItem href="#/graphexpo">
    function create_default_slot_19$k(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_19$k.name,
    		type: "slot",
    		source: "(204:6) <DropdownItem href=\\\"#/graphexpo\\\">",
    		ctx
    	});

    	return block;
    }

    // (205:18) <DropdownItem href="#/graph">
    function create_default_slot_18$k(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Grafica comun");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_18$k.name,
    		type: "slot",
    		source: "(205:18) <DropdownItem href=\\\"#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (207:6) <DropdownItem href="#/graph">
    function create_default_slot_17$k(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Conjunto");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17$k.name,
    		type: "slot",
    		source: "(207:6) <DropdownItem href=\\\"#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (201:4) <DropdownMenu end>
    function create_default_slot_16$k(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let t4;
    	let dropdownitem5;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies-graph",
    				$$slots: { default: [create_default_slot_21$k] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({
    			props: {
    				href: "./#/graphesco",
    				$$slots: { default: [create_default_slot_20$k] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "#/graphexpo",
    				$$slots: { default: [create_default_slot_19$k] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({
    			props: {
    				href: "#/graph",
    				$$slots: { default: [create_default_slot_18$k] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem4 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem5 = new DropdownItem({
    			props: {
    				href: "#/graph",
    				$$slots: { default: [create_default_slot_17$k] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    			t4 = space();
    			create_component(dropdownitem5.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(dropdownitem5, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem1_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				dropdownitem1_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem1.$set(dropdownitem1_changes);
    			const dropdownitem2_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem3_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				dropdownitem3_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem3.$set(dropdownitem3_changes);
    			const dropdownitem5_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				dropdownitem5_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem5.$set(dropdownitem5_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			transition_in(dropdownitem5.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			transition_out(dropdownitem5.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(dropdownitem5, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16$k.name,
    		type: "slot",
    		source: "(201:4) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (199:5) <Dropdown >
    function create_default_slot_15$k(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_22$h] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_16$k] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15$k.name,
    		type: "slot",
    		source: "(199:5) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (176:2) <Nav navbar>
    function create_default_slot_14$k(ctx) {
    	let dropdown0;
    	let t0;
    	let dropdown1;
    	let t1;
    	let dropdown2;
    	let current;

    	dropdown0 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_30] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown1 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_23$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown2 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_15$k] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdown0.$$.fragment);
    			t0 = space();
    			create_component(dropdown1.$$.fragment);
    			t1 = space();
    			create_component(dropdown2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdown0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdown1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdown2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdown0_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				dropdown0_changes.$$scope = { dirty, ctx };
    			}

    			dropdown0.$set(dropdown0_changes);
    			const dropdown1_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				dropdown1_changes.$$scope = { dirty, ctx };
    			}

    			dropdown1.$set(dropdown1_changes);
    			const dropdown2_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				dropdown2_changes.$$scope = { dirty, ctx };
    			}

    			dropdown2.$set(dropdown2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdown0.$$.fragment, local);
    			transition_in(dropdown1.$$.fragment, local);
    			transition_in(dropdown2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdown0.$$.fragment, local);
    			transition_out(dropdown1.$$.fragment, local);
    			transition_out(dropdown2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdown0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdown1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdown2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14$k.name,
    		type: "slot",
    		source: "(176:2) <Nav navbar>",
    		ctx
    	});

    	return block;
    }

    // (174:1) <Navbar style="background-color: lightgreen; color:white;" light expand="lg" >
    function create_default_slot_13$k(ctx) {
    	let navbarbrand;
    	let t;
    	let nav;
    	let current;

    	navbarbrand = new NavbarBrand({
    			props: {
    				href: "#/info",
    				$$slots: { default: [create_default_slot_36] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	nav = new Nav({
    			props: {
    				navbar: true,
    				$$slots: { default: [create_default_slot_14$k] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navbarbrand.$$.fragment);
    			t = space();
    			create_component(nav.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbarbrand, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(nav, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navbarbrand_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				navbarbrand_changes.$$scope = { dirty, ctx };
    			}

    			navbarbrand.$set(navbarbrand_changes);
    			const nav_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				nav_changes.$$scope = { dirty, ctx };
    			}

    			nav.$set(nav_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbarbrand.$$.fragment, local);
    			transition_in(nav.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbarbrand.$$.fragment, local);
    			transition_out(nav.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbarbrand, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(nav, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13$k.name,
    		type: "slot",
    		source: "(174:1) <Navbar style=\\\"background-color: lightgreen; color:white;\\\" light expand=\\\"lg\\\" >",
    		ctx
    	});

    	return block;
    }

    // (216:1) <Button on:click="{getPgAnt}">
    function create_default_slot_12$k(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Página Anterior");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12$k.name,
    		type: "slot",
    		source: "(216:1) <Button on:click=\\\"{getPgAnt}\\\">",
    		ctx
    	});

    	return block;
    }

    // (219:1) <Button on:click="{getPgSig}">
    function create_default_slot_11$k(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Página Siguiente");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$k.name,
    		type: "slot",
    		source: "(219:1) <Button on:click=\\\"{getPgSig}\\\">",
    		ctx
    	});

    	return block;
    }

    // (1:0) <script>      import {onMount}
    function create_catch_block$1(ctx) {
    	const block = {
    		c: noop$4,
    		m: noop$4,
    		p: noop$4,
    		i: noop$4,
    		o: noop$4,
    		d: noop$4
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block$1.name,
    		type: "catch",
    		source: "(1:0) <script>      import {onMount}",
    		ctx
    	});

    	return block;
    }

    // (224:1) {:then expo}
    function create_then_block$1(ctx) {
    	let alert;
    	let t0;
    	let table0;
    	let t1;
    	let table1;
    	let current;

    	alert = new Alert({
    			props: {
    				color: /*color*/ ctx[4],
    				isOpen: /*visible*/ ctx[3],
    				toggle: /*func*/ ctx[14],
    				$$slots: { default: [create_default_slot_10$k] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	table0 = new Table({
    			props: {
    				bordered: true,
    				$$slots: { default: [create_default_slot_7$k] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	table1 = new Table({
    			props: {
    				bordered: true,
    				$$slots: { default: [create_default_slot$k] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(alert.$$.fragment);
    			t0 = space();
    			create_component(table0.$$.fragment);
    			t1 = space();
    			create_component(table1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(alert, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(table0, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(table1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const alert_changes = {};
    			if (dirty[0] & /*color*/ 16) alert_changes.color = /*color*/ ctx[4];
    			if (dirty[0] & /*visible*/ 8) alert_changes.isOpen = /*visible*/ ctx[3];
    			if (dirty[0] & /*visible*/ 8) alert_changes.toggle = /*func*/ ctx[14];

    			if (dirty[0] & /*checkMSG*/ 4 | dirty[1] & /*$$scope*/ 2) {
    				alert_changes.$$scope = { dirty, ctx };
    			}

    			alert.$set(alert_changes);
    			const table0_changes = {};

    			if (dirty[0] & /*from, to, color, checkMSG, visible*/ 31 | dirty[1] & /*$$scope*/ 2) {
    				table0_changes.$$scope = { dirty, ctx };
    			}

    			table0.$set(table0_changes);
    			const table1_changes = {};

    			if (dirty[0] & /*expo, newExpo*/ 96 | dirty[1] & /*$$scope*/ 2) {
    				table1_changes.$$scope = { dirty, ctx };
    			}

    			table1.$set(table1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(alert.$$.fragment, local);
    			transition_in(table0.$$.fragment, local);
    			transition_in(table1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(alert.$$.fragment, local);
    			transition_out(table0.$$.fragment, local);
    			transition_out(table1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(alert, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(table0, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(table1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block$1.name,
    		type: "then",
    		source: "(224:1) {:then expo}",
    		ctx
    	});

    	return block;
    }

    // (226:2) {#if checkMSG}
    function create_if_block$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1(/*checkMSG*/ ctx[2]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*checkMSG*/ 4) set_data_dev(t, /*checkMSG*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(226:2) {#if checkMSG}",
    		ctx
    	});

    	return block;
    }

    // (225:1) <Alert color={color} isOpen={visible} toggle={() => (visible = false)}>
    function create_default_slot_10$k(ctx) {
    	let if_block_anchor;
    	let if_block = /*checkMSG*/ ctx[2] && create_if_block$4(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*checkMSG*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$4(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$k.name,
    		type: "slot",
    		source: "(225:1) <Alert color={color} isOpen={visible} toggle={() => (visible = false)}>",
    		ctx
    	});

    	return block;
    }

    // (244:22) <Button outline color="dark" on:click="{()=>{      if (from == null || to == null) {       color="success";       checkMSG="Los campos fecha inicio y fecha fin no pueden estar vacíos";       visible="true";      }else{       getExpo();      }     }}">
    function create_default_slot_9$k(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Buscar");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$k.name,
    		type: "slot",
    		source: "(244:22) <Button outline color=\\\"dark\\\" on:click=\\\"{()=>{      if (from == null || to == null) {       color=\\\"success\\\";       checkMSG=\\\"Los campos fecha inicio y fecha fin no pueden estar vacíos\\\";       visible=\\\"true\\\";      }else{       getExpo();      }     }}\\\">",
    		ctx
    	});

    	return block;
    }

    // (256:22) <Button outline color="info" on:click="{()=>{      from = null;      to = null;      getExpo();           }}">
    function create_default_slot_8$k(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Limpiar Búsqueda");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$k.name,
    		type: "slot",
    		source: "(256:22) <Button outline color=\\\"info\\\" on:click=\\\"{()=>{      from = null;      to = null;      getExpo();           }}\\\">",
    		ctx
    	});

    	return block;
    }

    // (231:1) <Table bordered>
    function create_default_slot_7$k(ctx) {
    	let thead;
    	let tr0;
    	let th0;
    	let t1;
    	let th1;
    	let t3;
    	let tbody;
    	let tr1;
    	let td0;
    	let input0;
    	let t4;
    	let td1;
    	let input1;
    	let t5;
    	let td2;
    	let button0;
    	let t6;
    	let td3;
    	let button1;
    	let current;
    	let mounted;
    	let dispose;

    	button0 = new Button({
    			props: {
    				outline: true,
    				color: "dark",
    				$$slots: { default: [create_default_slot_9$k] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button0.$on("click", /*click_handler*/ ctx[17]);

    	button1 = new Button({
    			props: {
    				outline: true,
    				color: "info",
    				$$slots: { default: [create_default_slot_8$k] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1.$on("click", /*click_handler_1*/ ctx[18]);

    	const block = {
    		c: function create() {
    			thead = element$1("thead");
    			tr0 = element$1("tr");
    			th0 = element$1("th");
    			th0.textContent = "Fecha de inicio";
    			t1 = space();
    			th1 = element$1("th");
    			th1.textContent = "Fecha fin";
    			t3 = space();
    			tbody = element$1("tbody");
    			tr1 = element$1("tr");
    			td0 = element$1("td");
    			input0 = element$1("input");
    			t4 = space();
    			td1 = element$1("td");
    			input1 = element$1("input");
    			t5 = space();
    			td2 = element$1("td");
    			create_component(button0.$$.fragment);
    			t6 = space();
    			td3 = element$1("td");
    			create_component(button1.$$.fragment);
    			add_location(th0, file$o, 233, 4, 6617);
    			add_location(th1, file$o, 234, 4, 6647);
    			add_location(tr0, file$o, 232, 3, 6607);
    			add_location(thead, file$o, 231, 2, 6595);
    			attr_dev(input0, "type", "number");
    			attr_dev(input0, "min", "0");
    			add_location(input0, file$o, 241, 7, 6721);
    			add_location(td0, file$o, 241, 3, 6717);
    			attr_dev(input1, "type", "number");
    			attr_dev(input1, "min", "0");
    			add_location(input1, file$o, 242, 7, 6784);
    			add_location(td1, file$o, 242, 3, 6780);
    			attr_dev(td2, "align", "center");
    			add_location(td2, file$o, 243, 3, 6841);
    			attr_dev(td3, "align", "center");
    			add_location(td3, file$o, 255, 3, 7153);
    			add_location(tr1, file$o, 240, 2, 6708);
    			add_location(tbody, file$o, 237, 2, 6691);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, thead, anchor);
    			append_dev(thead, tr0);
    			append_dev(tr0, th0);
    			append_dev(tr0, t1);
    			append_dev(tr0, th1);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, tbody, anchor);
    			append_dev(tbody, tr1);
    			append_dev(tr1, td0);
    			append_dev(td0, input0);
    			set_input_value(input0, /*from*/ ctx[0]);
    			append_dev(tr1, t4);
    			append_dev(tr1, td1);
    			append_dev(td1, input1);
    			set_input_value(input1, /*to*/ ctx[1]);
    			append_dev(tr1, t5);
    			append_dev(tr1, td2);
    			mount_component(button0, td2, null);
    			append_dev(tr1, t6);
    			append_dev(tr1, td3);
    			mount_component(button1, td3, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[15]),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[16])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*from*/ 1 && to_number(input0.value) !== /*from*/ ctx[0]) {
    				set_input_value(input0, /*from*/ ctx[0]);
    			}

    			if (dirty[0] & /*to*/ 2 && to_number(input1.value) !== /*to*/ ctx[1]) {
    				set_input_value(input1, /*to*/ ctx[1]);
    			}

    			const button0_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(thead);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(tbody);
    			destroy_component(button0);
    			destroy_component(button1);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$k.name,
    		type: "slot",
    		source: "(231:1) <Table bordered>",
    		ctx
    	});

    	return block;
    }

    // (288:8) <Button outline color="primary" on:click="{insertExpo}">
    function create_default_slot_6$k(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Añadir");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$k.name,
    		type: "slot",
    		source: "(288:8) <Button outline color=\\\"primary\\\" on:click=\\\"{insertExpo}\\\">",
    		ctx
    	});

    	return block;
    }

    // (292:23) <Button outline color="primary" on:click="{()=>{       newExpo.country = null;       newExpo.year = null;       newExpo.expo_tec = null;       newExpo.expo_m = null;       newExpo.tot_esco= null;      }}">
    function create_default_slot_5$k(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Limpiar");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$k.name,
    		type: "slot",
    		source: "(292:23) <Button outline color=\\\"primary\\\" on:click=\\\"{()=>{       newExpo.country = null;       newExpo.year = null;       newExpo.expo_tec = null;       newExpo.expo_m = null;       newExpo.tot_esco= null;      }}\\\">",
    		ctx
    	});

    	return block;
    }

    // (311:8) <Button outline color="warning" on:click={function (){       window.location.href = `/#/expo/${expos.country}/${expos.year}`      }}>
    function create_default_slot_4$k(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Editar");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$k.name,
    		type: "slot",
    		source: "(311:8) <Button outline color=\\\"warning\\\" on:click={function (){       window.location.href = `/#/expo/${expos.country}/${expos.year}`      }}>",
    		ctx
    	});

    	return block;
    }

    // (316:8) <Button outline color="danger" on:click={BorrarExpo(expos.country,expos.year)}>
    function create_default_slot_3$k(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Borrar");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$k.name,
    		type: "slot",
    		source: "(316:8) <Button outline color=\\\"danger\\\" on:click={BorrarExpo(expos.country,expos.year)}>",
    		ctx
    	});

    	return block;
    }

    // (303:3) {#each expo as expos}
    function create_each_block(ctx) {
    	let tr;
    	let td0;
    	let t0_value = /*expos*/ ctx[29].country + "";
    	let t0;
    	let t1;
    	let td1;
    	let t2_value = /*expos*/ ctx[29].year + "";
    	let t2;
    	let t3;
    	let td2;
    	let t4_value = /*expos*/ ctx[29].expo_tec + "";
    	let t4;
    	let t5;
    	let td3;
    	let t6_value = /*expos*/ ctx[29].expo_m + "";
    	let t6;
    	let t7;
    	let td4;
    	let t8_value = /*expos*/ ctx[29].tot_esco + "";
    	let t8;
    	let t9;
    	let td5;
    	let button0;
    	let t10;
    	let td6;
    	let button1;
    	let current;

    	function click_handler_3() {
    		return /*click_handler_3*/ ctx[25](/*expos*/ ctx[29]);
    	}

    	button0 = new Button({
    			props: {
    				outline: true,
    				color: "warning",
    				$$slots: { default: [create_default_slot_4$k] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button0.$on("click", click_handler_3);

    	button1 = new Button({
    			props: {
    				outline: true,
    				color: "danger",
    				$$slots: { default: [create_default_slot_3$k] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1.$on("click", function () {
    		if (is_function(/*BorrarExpo*/ ctx[11](/*expos*/ ctx[29].country, /*expos*/ ctx[29].year))) /*BorrarExpo*/ ctx[11](/*expos*/ ctx[29].country, /*expos*/ ctx[29].year).apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			tr = element$1("tr");
    			td0 = element$1("td");
    			t0 = text$1(t0_value);
    			t1 = space();
    			td1 = element$1("td");
    			t2 = text$1(t2_value);
    			t3 = space();
    			td2 = element$1("td");
    			t4 = text$1(t4_value);
    			t5 = space();
    			td3 = element$1("td");
    			t6 = text$1(t6_value);
    			t7 = space();
    			td4 = element$1("td");
    			t8 = text$1(t8_value);
    			t9 = space();
    			td5 = element$1("td");
    			create_component(button0.$$.fragment);
    			t10 = space();
    			td6 = element$1("td");
    			create_component(button1.$$.fragment);
    			add_location(td0, file$o, 304, 4, 8367);
    			add_location(td1, file$o, 305, 4, 8397);
    			add_location(td2, file$o, 306, 16, 8436);
    			add_location(td3, file$o, 307, 16, 8479);
    			add_location(td4, file$o, 308, 16, 8520);
    			add_location(td5, file$o, 310, 4, 8553);
    			add_location(td6, file$o, 315, 4, 8724);
    			add_location(tr, file$o, 303, 3, 8357);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, t0);
    			append_dev(tr, t1);
    			append_dev(tr, td1);
    			append_dev(td1, t2);
    			append_dev(tr, t3);
    			append_dev(tr, td2);
    			append_dev(td2, t4);
    			append_dev(tr, t5);
    			append_dev(tr, td3);
    			append_dev(td3, t6);
    			append_dev(tr, t7);
    			append_dev(tr, td4);
    			append_dev(td4, t8);
    			append_dev(tr, t9);
    			append_dev(tr, td5);
    			mount_component(button0, td5, null);
    			append_dev(td5, t10);
    			append_dev(tr, td6);
    			mount_component(button1, td6, null);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if ((!current || dirty[0] & /*expo*/ 64) && t0_value !== (t0_value = /*expos*/ ctx[29].country + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty[0] & /*expo*/ 64) && t2_value !== (t2_value = /*expos*/ ctx[29].year + "")) set_data_dev(t2, t2_value);
    			if ((!current || dirty[0] & /*expo*/ 64) && t4_value !== (t4_value = /*expos*/ ctx[29].expo_tec + "")) set_data_dev(t4, t4_value);
    			if ((!current || dirty[0] & /*expo*/ 64) && t6_value !== (t6_value = /*expos*/ ctx[29].expo_m + "")) set_data_dev(t6, t6_value);
    			if ((!current || dirty[0] & /*expo*/ 64) && t8_value !== (t8_value = /*expos*/ ctx[29].tot_esco + "")) set_data_dev(t8, t8_value);
    			const button0_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			destroy_component(button0);
    			destroy_component(button1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(303:3) {#each expo as expos}",
    		ctx
    	});

    	return block;
    }

    // (323:8) <Button outline color="success" on:click={LoadExpo}>
    function create_default_slot_2$k(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Cargar datos");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$k.name,
    		type: "slot",
    		source: "(323:8) <Button outline color=\\\"success\\\" on:click={LoadExpo}>",
    		ctx
    	});

    	return block;
    }

    // (326:8) <Button outline color="danger" on:click={BorrarExpoAll}>
    function create_default_slot_1$k(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Borrar todo");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$k.name,
    		type: "slot",
    		source: "(326:8) <Button outline color=\\\"danger\\\" on:click={BorrarExpoAll}>",
    		ctx
    	});

    	return block;
    }

    // (270:1) <Table bordered>
    function create_default_slot$k(ctx) {
    	let thead;
    	let tr0;
    	let th0;
    	let t1;
    	let th1;
    	let t3;
    	let th2;
    	let t5;
    	let th3;
    	let t7;
    	let th4;
    	let t9;
    	let tbody;
    	let tr1;
    	let td0;
    	let input0;
    	let t10;
    	let td1;
    	let input1;
    	let t11;
    	let td2;
    	let input2;
    	let t12;
    	let td3;
    	let input3;
    	let t13;
    	let td4;
    	let input4;
    	let t14;
    	let td5;
    	let button0;
    	let t15;
    	let td6;
    	let button1;
    	let t16;
    	let t17;
    	let tr2;
    	let td7;
    	let button2;
    	let t18;
    	let td8;
    	let button3;
    	let current;
    	let mounted;
    	let dispose;

    	button0 = new Button({
    			props: {
    				outline: true,
    				color: "primary",
    				$$slots: { default: [create_default_slot_6$k] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button0.$on("click", /*insertExpo*/ ctx[10]);

    	button1 = new Button({
    			props: {
    				outline: true,
    				color: "primary",
    				$$slots: { default: [create_default_slot_5$k] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1.$on("click", /*click_handler_2*/ ctx[24]);
    	let each_value = /*expo*/ ctx[6];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	button2 = new Button({
    			props: {
    				outline: true,
    				color: "success",
    				$$slots: { default: [create_default_slot_2$k] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button2.$on("click", /*LoadExpo*/ ctx[13]);

    	button3 = new Button({
    			props: {
    				outline: true,
    				color: "danger",
    				$$slots: { default: [create_default_slot_1$k] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button3.$on("click", /*BorrarExpoAll*/ ctx[12]);

    	const block = {
    		c: function create() {
    			thead = element$1("thead");
    			tr0 = element$1("tr");
    			th0 = element$1("th");
    			th0.textContent = "País";
    			t1 = space();
    			th1 = element$1("th");
    			th1.textContent = "Año";
    			t3 = space();
    			th2 = element$1("th");
    			th2.textContent = "Exportaciones Tecnológicas";
    			t5 = space();
    			th3 = element$1("th");
    			th3.textContent = "Exportaciones Productos Manufacturados";
    			t7 = space();
    			th4 = element$1("th");
    			th4.textContent = "Exportaciones Bienes y Servicios";
    			t9 = space();
    			tbody = element$1("tbody");
    			tr1 = element$1("tr");
    			td0 = element$1("td");
    			input0 = element$1("input");
    			t10 = space();
    			td1 = element$1("td");
    			input1 = element$1("input");
    			t11 = space();
    			td2 = element$1("td");
    			input2 = element$1("input");
    			t12 = space();
    			td3 = element$1("td");
    			input3 = element$1("input");
    			t13 = space();
    			td4 = element$1("td");
    			input4 = element$1("input");
    			t14 = space();
    			td5 = element$1("td");
    			create_component(button0.$$.fragment);
    			t15 = space();
    			td6 = element$1("td");
    			create_component(button1.$$.fragment);
    			t16 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t17 = space();
    			tr2 = element$1("tr");
    			td7 = element$1("td");
    			create_component(button2.$$.fragment);
    			t18 = space();
    			td8 = element$1("td");
    			create_component(button3.$$.fragment);
    			add_location(th0, file$o, 272, 4, 7410);
    			add_location(th1, file$o, 273, 4, 7429);
    			add_location(th2, file$o, 274, 16, 7459);
    			add_location(th3, file$o, 275, 16, 7512);
    			add_location(th4, file$o, 276, 16, 7577);
    			add_location(tr0, file$o, 271, 3, 7400);
    			add_location(thead, file$o, 270, 2, 7388);
    			add_location(input0, file$o, 281, 8, 7670);
    			add_location(td0, file$o, 281, 4, 7666);
    			attr_dev(input1, "type", "number");
    			add_location(input1, file$o, 282, 8, 7723);
    			add_location(td1, file$o, 282, 4, 7719);
    			add_location(input2, file$o, 283, 8, 7787);
    			add_location(td2, file$o, 283, 4, 7783);
    			add_location(input3, file$o, 284, 8, 7841);
    			add_location(td3, file$o, 284, 4, 7837);
    			add_location(input4, file$o, 285, 8, 7893);
    			add_location(td4, file$o, 285, 4, 7889);
    			add_location(td5, file$o, 287, 4, 7945);
    			attr_dev(td6, "align", "center");
    			add_location(td6, file$o, 291, 4, 8051);
    			add_location(tr1, file$o, 280, 3, 7656);
    			add_location(td7, file$o, 322, 4, 8883);
    			add_location(td8, file$o, 325, 4, 8984);
    			add_location(tr2, file$o, 321, 3, 8873);
    			add_location(tbody, file$o, 279, 2, 7644);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, thead, anchor);
    			append_dev(thead, tr0);
    			append_dev(tr0, th0);
    			append_dev(tr0, t1);
    			append_dev(tr0, th1);
    			append_dev(tr0, t3);
    			append_dev(tr0, th2);
    			append_dev(tr0, t5);
    			append_dev(tr0, th3);
    			append_dev(tr0, t7);
    			append_dev(tr0, th4);
    			insert_dev(target, t9, anchor);
    			insert_dev(target, tbody, anchor);
    			append_dev(tbody, tr1);
    			append_dev(tr1, td0);
    			append_dev(td0, input0);
    			set_input_value(input0, /*newExpo*/ ctx[5].country);
    			append_dev(tr1, t10);
    			append_dev(tr1, td1);
    			append_dev(td1, input1);
    			set_input_value(input1, /*newExpo*/ ctx[5].year);
    			append_dev(tr1, t11);
    			append_dev(tr1, td2);
    			append_dev(td2, input2);
    			set_input_value(input2, /*newExpo*/ ctx[5].expo_tec);
    			append_dev(tr1, t12);
    			append_dev(tr1, td3);
    			append_dev(td3, input3);
    			set_input_value(input3, /*newExpo*/ ctx[5].expo_m);
    			append_dev(tr1, t13);
    			append_dev(tr1, td4);
    			append_dev(td4, input4);
    			set_input_value(input4, /*newExpo*/ ctx[5].tot_esco);
    			append_dev(tr1, t14);
    			append_dev(tr1, td5);
    			mount_component(button0, td5, null);
    			append_dev(tr1, t15);
    			append_dev(tr1, td6);
    			mount_component(button1, td6, null);
    			append_dev(tbody, t16);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}

    			append_dev(tbody, t17);
    			append_dev(tbody, tr2);
    			append_dev(tr2, td7);
    			mount_component(button2, td7, null);
    			append_dev(tr2, t18);
    			append_dev(tr2, td8);
    			mount_component(button3, td8, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "input", /*input0_input_handler_1*/ ctx[19]),
    					listen_dev(input1, "input", /*input1_input_handler_1*/ ctx[20]),
    					listen_dev(input2, "input", /*input2_input_handler*/ ctx[21]),
    					listen_dev(input3, "input", /*input3_input_handler*/ ctx[22]),
    					listen_dev(input4, "input", /*input4_input_handler*/ ctx[23])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*newExpo*/ 32 && input0.value !== /*newExpo*/ ctx[5].country) {
    				set_input_value(input0, /*newExpo*/ ctx[5].country);
    			}

    			if (dirty[0] & /*newExpo*/ 32 && to_number(input1.value) !== /*newExpo*/ ctx[5].year) {
    				set_input_value(input1, /*newExpo*/ ctx[5].year);
    			}

    			if (dirty[0] & /*newExpo*/ 32 && input2.value !== /*newExpo*/ ctx[5].expo_tec) {
    				set_input_value(input2, /*newExpo*/ ctx[5].expo_tec);
    			}

    			if (dirty[0] & /*newExpo*/ 32 && input3.value !== /*newExpo*/ ctx[5].expo_m) {
    				set_input_value(input3, /*newExpo*/ ctx[5].expo_m);
    			}

    			if (dirty[0] & /*newExpo*/ 32 && input4.value !== /*newExpo*/ ctx[5].tot_esco) {
    				set_input_value(input4, /*newExpo*/ ctx[5].tot_esco);
    			}

    			const button0_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);

    			if (dirty[0] & /*BorrarExpo, expo*/ 2112) {
    				each_value = /*expo*/ ctx[6];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(tbody, t17);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			const button2_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				button2_changes.$$scope = { dirty, ctx };
    			}

    			button2.$set(button2_changes);
    			const button3_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				button3_changes.$$scope = { dirty, ctx };
    			}

    			button3.$set(button3_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(button2.$$.fragment, local);
    			transition_in(button3.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(button2.$$.fragment, local);
    			transition_out(button3.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(thead);
    			if (detaching) detach_dev(t9);
    			if (detaching) detach_dev(tbody);
    			destroy_component(button0);
    			destroy_component(button1);
    			destroy_each(each_blocks, detaching);
    			destroy_component(button2);
    			destroy_component(button3);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$k.name,
    		type: "slot",
    		source: "(270:1) <Table bordered>",
    		ctx
    	});

    	return block;
    }

    // (222:17)   loading   {:then expo}
    function create_pending_block$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("loading");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop$4,
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block$1.name,
    		type: "pending",
    		source: "(222:17)   loading   {:then expo}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$o(ctx) {
    	let main;
    	let navbar;
    	let t0;
    	let h1;
    	let t2;
    	let button0;
    	let t3;
    	let button1;
    	let t4;
    	let promise;
    	let current;

    	navbar = new Navbar({
    			props: {
    				style: "background-color: lightgreen; color:white;",
    				light: true,
    				expand: "lg",
    				$$slots: { default: [create_default_slot_13$k] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button0 = new Button({
    			props: {
    				$$slots: { default: [create_default_slot_12$k] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button0.$on("click", /*getPgAnt*/ ctx[8]);

    	button1 = new Button({
    			props: {
    				$$slots: { default: [create_default_slot_11$k] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1.$on("click", /*getPgSig*/ ctx[9]);

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: false,
    		pending: create_pending_block$1,
    		then: create_then_block$1,
    		catch: create_catch_block$1,
    		value: 6,
    		blocks: [,,,]
    	};

    	handle_promise(promise = /*expo*/ ctx[6], info);

    	const block = {
    		c: function create() {
    			main = element$1("main");
    			create_component(navbar.$$.fragment);
    			t0 = space();
    			h1 = element$1("h1");
    			h1.textContent = "Exportaciones";
    			t2 = space();
    			create_component(button0.$$.fragment);
    			t3 = space();
    			create_component(button1.$$.fragment);
    			t4 = space();
    			info.block.c();
    			add_location(h1, file$o, 214, 4, 6249);
    			add_location(main, file$o, 172, 0, 4534);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			mount_component(navbar, main, null);
    			append_dev(main, t0);
    			append_dev(main, h1);
    			append_dev(main, t2);
    			mount_component(button0, main, null);
    			append_dev(main, t3);
    			mount_component(button1, main, null);
    			append_dev(main, t4);
    			info.block.m(main, info.anchor = null);
    			info.mount = () => main;
    			info.anchor = null;
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const navbar_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				navbar_changes.$$scope = { dirty, ctx };
    			}

    			navbar.$set(navbar_changes);
    			const button0_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    			info.ctx = ctx;

    			if (dirty[0] & /*expo*/ 64 && promise !== (promise = /*expo*/ ctx[6]) && handle_promise(promise, info)) ; else {
    				update_await_block_branch(info, ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			transition_in(info.block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);

    			for (let i = 0; i < 3; i += 1) {
    				const block = info.blocks[i];
    				transition_out(block);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(navbar);
    			destroy_component(button0);
    			destroy_component(button1);
    			info.block.d();
    			info.token = null;
    			info = null;
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$o($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Expo', slots, []);
    	let expo = [];
    	let from = null;
    	let to = null;
    	let offset = 0;
    	let limit = 10;
    	let numEntries;
    	let checkMSG = "";
    	let visible = false;
    	let color = "danger";

    	let newExpo = {
    		country: "",
    		year: "",
    		expo_tec: "",
    		expo_m: "",
    		tot_esco: ""
    	};

    	onMount(getExpo);

    	async function getExpo() {
    		console.log("fetching exports ....");
    		let cadena = `/api/v1/expo?offset=+${offset}+&limit=+${limit}`;

    		if (from != null) {
    			cadena = cadena + `&from=${from}&`;
    		}

    		if (to != null) {
    			cadena = cadena + `to=${to}`;
    		}

    		const res = await fetch(cadena);

    		if (res.ok) {
    			const data = await res.json();
    			$$invalidate(6, expo = data);
    			numEntries = expo.length;
    			console.log("Received expo: " + expo.length);
    		} else {
    			$$invalidate(4, color = "danger");
    			$$invalidate(2, checkMSG = "No hay entradas para esas fechas");
    			$$invalidate(3, visible = "true");
    		}
    	}

    	async function getPgAnt() {
    		if (offset >= 10) {
    			offset = offset - 10;
    		}

    		//limit=limit+10;
    		console.log("fetching exports ....");

    		let cadena = `/api/v1/expo?offset=+${offset}+&limit=+${limit}`;

    		if (from != null) {
    			cadena = cadena + `&from=${from}&`;
    		}

    		if (to != null) {
    			cadena = cadena + `to=${to}`;
    		}

    		const res = await fetch(cadena);

    		if (res.ok) {
    			const data = await res.json();
    			$$invalidate(6, expo = data);
    			console.log("Received expo: " + expo.length);
    		}
    	}

    	async function getPgSig() {
    		if (expo.length >= 10) {
    			offset = offset + 10;
    		}

    		//limit=limit+10;
    		console.log("fetching expo ....");

    		let cadena = `/api/v1/expo?offset=+${offset}+&limit=+${limit}`;

    		if (from != null) {
    			cadena = cadena + `&from=${from}&`;
    		}

    		if (to != null) {
    			cadena = cadena + `to=${to}`;
    		}

    		const res = await fetch(cadena);

    		if (res.ok) {
    			const data = await res.json();
    			$$invalidate(6, expo = data);
    			console.log("Received expo: " + expo.length);
    		}
    	}

    	async function insertExpo() {
    		if (newExpo.country == "" || newExpo.country == null || newExpo.year == "" || newExpo.year == null) {
    			$$invalidate(4, color = "danger");
    			$$invalidate(2, checkMSG = "Debes insertar el nombre del país y el año.");
    			$$invalidate(3, visible = "true");
    		} else {
    			console.log("Inserting Expo...." + JSON.stringify(newExpo));

    			await fetch("/api/v1/expo", {
    				method: "POST",
    				body: JSON.stringify(newExpo),
    				headers: { "Content-Type": "application/json" }
    			}).then(function (res) {
    				if (res.status == 201) {
    					$$invalidate(4, color = "success");
    					$$invalidate(2, checkMSG = "Entrada introducida con éxito");
    					$$invalidate(3, visible = "true");
    					getExpo();
    				} else if (res.status == 409) {
    					$$invalidate(4, color = "danger");
    					$$invalidate(2, checkMSG = "Ya existe ese recurso en la base de datos");
    					$$invalidate(3, visible = "true");
    					console.log("ERROR There is already a data with that country and year in the database");
    				}
    			});
    		}
    	}

    	async function BorrarExpo(name, year) {
    		await fetch("/api/v1/expo/" + name + "/" + year, { method: "DELETE" }).then(function (res) {
    			getExpo();

    			if (res.status == 200) {
    				$$invalidate(4, color = "success");
    				$$invalidate(2, checkMSG = name + " entrada borrada correctamente");
    				$$invalidate(3, visible = "true");
    				console.log("Deleted " + name);
    			} else {
    				$$invalidate(4, color = "danger");
    				$$invalidate(2, checkMSG = name + "no se ha podido borrar la entrada");
    				$$invalidate(3, visible = "true");
    				console.log("DATA NOT FOUND");
    			}
    		});
    	}

    	async function BorrarExpoAll() {
    		console.log("Deleting Expo....");

    		await fetch("/api/v1/expo/", { method: "DELETE" }).then(function (res) {
    			$$invalidate(4, color = "success");
    			$$invalidate(2, checkMSG = "Entradas elimidas con éxito");
    			$$invalidate(3, visible = "true");
    			getExpo();
    		});
    	}

    	async function LoadExpo() {
    		console.log("Loading expo....");

    		await fetch("/api/v1/expo/loadInitialData", { method: "GET" }).then(function (res) {
    			getExpo();
    			$$invalidate(4, color = "success");
    			$$invalidate(2, checkMSG = "Entradas cargadas con éxito");
    			$$invalidate(3, visible = "true");
    		});
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$l.warn(`<Expo> was created with unknown prop '${key}'`);
    	});

    	const func = () => $$invalidate(3, visible = false);

    	function input0_input_handler() {
    		from = to_number(this.value);
    		$$invalidate(0, from);
    	}

    	function input1_input_handler() {
    		to = to_number(this.value);
    		$$invalidate(1, to);
    	}

    	const click_handler = () => {
    		if (from == null || to == null) {
    			$$invalidate(4, color = "success");
    			$$invalidate(2, checkMSG = "Los campos fecha inicio y fecha fin no pueden estar vacíos");
    			$$invalidate(3, visible = "true");
    		} else {
    			getExpo();
    		}
    	};

    	const click_handler_1 = () => {
    		$$invalidate(0, from = null);
    		$$invalidate(1, to = null);
    		getExpo();
    	};

    	function input0_input_handler_1() {
    		newExpo.country = this.value;
    		$$invalidate(5, newExpo);
    	}

    	function input1_input_handler_1() {
    		newExpo.year = to_number(this.value);
    		$$invalidate(5, newExpo);
    	}

    	function input2_input_handler() {
    		newExpo.expo_tec = this.value;
    		$$invalidate(5, newExpo);
    	}

    	function input3_input_handler() {
    		newExpo.expo_m = this.value;
    		$$invalidate(5, newExpo);
    	}

    	function input4_input_handler() {
    		newExpo.tot_esco = this.value;
    		$$invalidate(5, newExpo);
    	}

    	const click_handler_2 = () => {
    		$$invalidate(5, newExpo.country = null, newExpo);
    		$$invalidate(5, newExpo.year = null, newExpo);
    		$$invalidate(5, newExpo.expo_tec = null, newExpo);
    		$$invalidate(5, newExpo.expo_m = null, newExpo);
    		$$invalidate(5, newExpo.tot_esco = null, newExpo);
    	};

    	const click_handler_3 = function (expos) {
    		window.location.href = `/#/expo/${expos.country}/${expos.year}`;
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		Table,
    		Button,
    		Alert,
    		Navbar,
    		Nav,
    		NavItem,
    		NavLink,
    		NavbarBrand,
    		Dropdown,
    		DropdownToggle,
    		DropdownMenu,
    		DropdownItem,
    		expo,
    		from,
    		to,
    		offset,
    		limit,
    		numEntries,
    		checkMSG,
    		visible,
    		color,
    		newExpo,
    		getExpo,
    		getPgAnt,
    		getPgSig,
    		insertExpo,
    		BorrarExpo,
    		BorrarExpoAll,
    		LoadExpo
    	});

    	$$self.$inject_state = $$props => {
    		if ('expo' in $$props) $$invalidate(6, expo = $$props.expo);
    		if ('from' in $$props) $$invalidate(0, from = $$props.from);
    		if ('to' in $$props) $$invalidate(1, to = $$props.to);
    		if ('offset' in $$props) offset = $$props.offset;
    		if ('limit' in $$props) limit = $$props.limit;
    		if ('numEntries' in $$props) numEntries = $$props.numEntries;
    		if ('checkMSG' in $$props) $$invalidate(2, checkMSG = $$props.checkMSG);
    		if ('visible' in $$props) $$invalidate(3, visible = $$props.visible);
    		if ('color' in $$props) $$invalidate(4, color = $$props.color);
    		if ('newExpo' in $$props) $$invalidate(5, newExpo = $$props.newExpo);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		from,
    		to,
    		checkMSG,
    		visible,
    		color,
    		newExpo,
    		expo,
    		getExpo,
    		getPgAnt,
    		getPgSig,
    		insertExpo,
    		BorrarExpo,
    		BorrarExpoAll,
    		LoadExpo,
    		func,
    		input0_input_handler,
    		input1_input_handler,
    		click_handler,
    		click_handler_1,
    		input0_input_handler_1,
    		input1_input_handler_1,
    		input2_input_handler,
    		input3_input_handler,
    		input4_input_handler,
    		click_handler_2,
    		click_handler_3
    	];
    }

    class Expo extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$o, create_fragment$o, safe_not_equal, {}, null, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Expo",
    			options,
    			id: create_fragment$o.name
    		});
    	}
    }

    /* src\front\expo-stats\EditExpo.svelte generated by Svelte v3.47.0 */

    const { console: console_1$k } = globals;

    const file$n = "src\\front\\expo-stats\\EditExpo.svelte";

    // (92:2) <NavbarBrand href="#/info">
    function create_default_slot_27(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("INICIO");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_27.name,
    		type: "slot",
    		source: "(92:2) <NavbarBrand href=\\\"#/info\\\">",
    		ctx
    	});

    	return block;
    }

    // (95:4) <DropdownToggle nav caret>
    function create_default_slot_26(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("API");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_26.name,
    		type: "slot",
    		source: "(95:4) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (97:6) <DropdownItem href="./api/v2/economies">
    function create_default_slot_25$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_25$2.name,
    		type: "slot",
    		source: "(97:6) <DropdownItem href=\\\"./api/v2/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (99:6) <DropdownItem href="./api/v1/esco-stats">
    function create_default_slot_24$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_24$3.name,
    		type: "slot",
    		source: "(99:6) <DropdownItem href=\\\"./api/v1/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (101:6) <DropdownItem href="./api/v1/expo">
    function create_default_slot_23$9(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_23$9.name,
    		type: "slot",
    		source: "(101:6) <DropdownItem href=\\\"./api/v1/expo\\\">",
    		ctx
    	});

    	return block;
    }

    // (96:4) <DropdownMenu end>
    function create_default_slot_22$g(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./api/v2/economies",
    				$$slots: { default: [create_default_slot_25$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "./api/v1/esco-stats",
    				$$slots: { default: [create_default_slot_24$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "./api/v1/expo",
    				$$slots: { default: [create_default_slot_23$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_22$g.name,
    		type: "slot",
    		source: "(96:4) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (94:3) <Dropdown >
    function create_default_slot_21$j(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_26] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_22$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_21$j.name,
    		type: "slot",
    		source: "(94:3) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (106:4) <DropdownToggle nav caret>
    function create_default_slot_20$j(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_20$j.name,
    		type: "slot",
    		source: "(106:4) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (108:6) <DropdownItem href="./#/economies">
    function create_default_slot_19$j(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_19$j.name,
    		type: "slot",
    		source: "(108:6) <DropdownItem href=\\\"./#/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (109:6) <DropdownItem href="./#/esco-stats">
    function create_default_slot_18$j(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco FRONT_END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_18$j.name,
    		type: "slot",
    		source: "(109:6) <DropdownItem href=\\\"./#/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (110:6) <DropdownItem href="#/expo">
    function create_default_slot_17$j(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17$j.name,
    		type: "slot",
    		source: "(110:6) <DropdownItem href=\\\"#/expo\\\">",
    		ctx
    	});

    	return block;
    }

    // (112:6) <DropdownItem href="#/graph">
    function create_default_slot_16$j(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Conjunto");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16$j.name,
    		type: "slot",
    		source: "(112:6) <DropdownItem href=\\\"#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (107:4) <DropdownMenu end>
    function create_default_slot_15$j(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies",
    				$$slots: { default: [create_default_slot_19$j] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({
    			props: {
    				href: "./#/esco-stats",
    				$$slots: { default: [create_default_slot_18$j] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "#/expo",
    				$$slots: { default: [create_default_slot_17$j] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/graph",
    				$$slots: { default: [create_default_slot_16$j] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem1_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				dropdownitem1_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem1.$set(dropdownitem1_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15$j.name,
    		type: "slot",
    		source: "(107:4) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (105:12) <Dropdown>
    function create_default_slot_14$j(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_20$j] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_15$j] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14$j.name,
    		type: "slot",
    		source: "(105:12) <Dropdown>",
    		ctx
    	});

    	return block;
    }

    // (117:4) <DropdownToggle nav caret>
    function create_default_slot_13$j(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Gráficas");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13$j.name,
    		type: "slot",
    		source: "(117:4) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (119:6) <DropdownItem href="./#/economies-graph">
    function create_default_slot_12$j(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12$j.name,
    		type: "slot",
    		source: "(119:6) <DropdownItem href=\\\"./#/economies-graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (120:6) <DropdownItem href="./#/graphesco">
    function create_default_slot_11$j(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$j.name,
    		type: "slot",
    		source: "(120:6) <DropdownItem href=\\\"./#/graphesco\\\">",
    		ctx
    	});

    	return block;
    }

    // (121:6) <DropdownItem href="#/graphexpo">
    function create_default_slot_10$j(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$j.name,
    		type: "slot",
    		source: "(121:6) <DropdownItem href=\\\"#/graphexpo\\\">",
    		ctx
    	});

    	return block;
    }

    // (122:18) <DropdownItem href="#/graph">
    function create_default_slot_9$j(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Grafica comun");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$j.name,
    		type: "slot",
    		source: "(122:18) <DropdownItem href=\\\"#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (124:6) <DropdownItem href="#/graph">
    function create_default_slot_8$j(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Conjunto");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$j.name,
    		type: "slot",
    		source: "(124:6) <DropdownItem href=\\\"#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (118:4) <DropdownMenu end>
    function create_default_slot_7$j(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let t4;
    	let dropdownitem5;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies-graph",
    				$$slots: { default: [create_default_slot_12$j] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({
    			props: {
    				href: "./#/graphesco",
    				$$slots: { default: [create_default_slot_11$j] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "#/graphexpo",
    				$$slots: { default: [create_default_slot_10$j] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({
    			props: {
    				href: "#/graph",
    				$$slots: { default: [create_default_slot_9$j] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem4 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem5 = new DropdownItem({
    			props: {
    				href: "#/graph",
    				$$slots: { default: [create_default_slot_8$j] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    			t4 = space();
    			create_component(dropdownitem5.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(dropdownitem5, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem1_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				dropdownitem1_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem1.$set(dropdownitem1_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem3_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				dropdownitem3_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem3.$set(dropdownitem3_changes);
    			const dropdownitem5_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				dropdownitem5_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem5.$set(dropdownitem5_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			transition_in(dropdownitem5.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			transition_out(dropdownitem5.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(dropdownitem5, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$j.name,
    		type: "slot",
    		source: "(118:4) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (116:5) <Dropdown >
    function create_default_slot_6$j(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_13$j] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_7$j] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$j.name,
    		type: "slot",
    		source: "(116:5) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (93:2) <Nav navbar>
    function create_default_slot_5$j(ctx) {
    	let dropdown0;
    	let t0;
    	let dropdown1;
    	let t1;
    	let dropdown2;
    	let current;

    	dropdown0 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_21$j] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown1 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_14$j] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown2 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_6$j] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdown0.$$.fragment);
    			t0 = space();
    			create_component(dropdown1.$$.fragment);
    			t1 = space();
    			create_component(dropdown2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdown0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdown1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdown2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdown0_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				dropdown0_changes.$$scope = { dirty, ctx };
    			}

    			dropdown0.$set(dropdown0_changes);
    			const dropdown1_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				dropdown1_changes.$$scope = { dirty, ctx };
    			}

    			dropdown1.$set(dropdown1_changes);
    			const dropdown2_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				dropdown2_changes.$$scope = { dirty, ctx };
    			}

    			dropdown2.$set(dropdown2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdown0.$$.fragment, local);
    			transition_in(dropdown1.$$.fragment, local);
    			transition_in(dropdown2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdown0.$$.fragment, local);
    			transition_out(dropdown1.$$.fragment, local);
    			transition_out(dropdown2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdown0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdown1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdown2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$j.name,
    		type: "slot",
    		source: "(93:2) <Nav navbar>",
    		ctx
    	});

    	return block;
    }

    // (91:4) <Navbar style="background-color: lightgreen; color:white;" light expand="lg" >
    function create_default_slot_4$j(ctx) {
    	let navbarbrand;
    	let t;
    	let nav;
    	let current;

    	navbarbrand = new NavbarBrand({
    			props: {
    				href: "#/info",
    				$$slots: { default: [create_default_slot_27] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	nav = new Nav({
    			props: {
    				navbar: true,
    				$$slots: { default: [create_default_slot_5$j] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navbarbrand.$$.fragment);
    			t = space();
    			create_component(nav.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbarbrand, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(nav, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navbarbrand_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				navbarbrand_changes.$$scope = { dirty, ctx };
    			}

    			navbarbrand.$set(navbarbrand_changes);
    			const nav_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				nav_changes.$$scope = { dirty, ctx };
    			}

    			nav.$set(nav_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbarbrand.$$.fragment, local);
    			transition_in(nav.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbarbrand.$$.fragment, local);
    			transition_out(nav.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbarbrand, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(nav, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$j.name,
    		type: "slot",
    		source: "(91:4) <Navbar style=\\\"background-color: lightgreen; color:white;\\\" light expand=\\\"lg\\\" >",
    		ctx
    	});

    	return block;
    }

    // (134:2) {#if checkMSG}
    function create_if_block$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1(/*checkMSG*/ ctx[3]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*checkMSG*/ 8) set_data_dev(t, /*checkMSG*/ ctx[3]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(134:2) {#if checkMSG}",
    		ctx
    	});

    	return block;
    }

    // (133:4) <Alert color={color} isOpen={visible} toggle={() => (visible = false)}>
    function create_default_slot_3$j(ctx) {
    	let if_block_anchor;
    	let if_block = /*checkMSG*/ ctx[3] && create_if_block$3(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*checkMSG*/ ctx[3]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$3(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$j.name,
    		type: "slot",
    		source: "(133:4) <Alert color={color} isOpen={visible} toggle={() => (visible = false)}>",
    		ctx
    	});

    	return block;
    }

    // (1:0) <script>        export let params={}
    function create_catch_block(ctx) {
    	const block = {
    		c: noop$4,
    		m: noop$4,
    		p: noop$4,
    		i: noop$4,
    		o: noop$4,
    		d: noop$4
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block.name,
    		type: "catch",
    		source: "(1:0) <script>        export let params={}",
    		ctx
    	});

    	return block;
    }

    // (140:8) {:then expo}
    function create_then_block(ctx) {
    	let table;
    	let current;

    	table = new Table({
    			props: {
    				bordered: true,
    				$$slots: { default: [create_default_slot_1$j] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(table.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(table, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const table_changes = {};

    			if (dirty & /*$$scope, updatedExpoM, updatedExpoTec, params*/ 65543) {
    				table_changes.$$scope = { dirty, ctx };
    			}

    			table.$set(table_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(table.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(table.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(table, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block.name,
    		type: "then",
    		source: "(140:8) {:then expo}",
    		ctx
    	});

    	return block;
    }

    // (160:24) <Button outline color="primary" on:click="{EditExpo}">
    function create_default_slot_2$j(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Editar");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$j.name,
    		type: "slot",
    		source: "(160:24) <Button outline color=\\\"primary\\\" on:click=\\\"{EditExpo}\\\">",
    		ctx
    	});

    	return block;
    }

    // (142:8) <Table bordered>
    function create_default_slot_1$j(ctx) {
    	let thead;
    	let tr0;
    	let th0;
    	let t1;
    	let th1;
    	let t3;
    	let th2;
    	let t5;
    	let th3;
    	let t7;
    	let th4;
    	let t9;
    	let tbody;
    	let tr1;
    	let td0;
    	let t10_value = /*params*/ ctx[0].country + "";
    	let t10;
    	let t11;
    	let td1;
    	let t12_value = /*params*/ ctx[0].year + "";
    	let t12;
    	let t13;
    	let td2;
    	let input0;
    	let t14;
    	let td3;
    	let input1;
    	let t15;
    	let td4;
    	let input2;
    	let t16;
    	let td5;
    	let button;
    	let current;
    	let mounted;
    	let dispose;

    	button = new Button({
    			props: {
    				outline: true,
    				color: "primary",
    				$$slots: { default: [create_default_slot_2$j] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*EditExpo*/ ctx[7]);

    	const block = {
    		c: function create() {
    			thead = element$1("thead");
    			tr0 = element$1("tr");
    			th0 = element$1("th");
    			th0.textContent = "País";
    			t1 = space();
    			th1 = element$1("th");
    			th1.textContent = "Año";
    			t3 = space();
    			th2 = element$1("th");
    			th2.textContent = "Exportaciones Tecnológicas";
    			t5 = space();
    			th3 = element$1("th");
    			th3.textContent = "Exportaciones Productos Manufacturados";
    			t7 = space();
    			th4 = element$1("th");
    			th4.textContent = "Exportaciones Bienes y Servicios";
    			t9 = space();
    			tbody = element$1("tbody");
    			tr1 = element$1("tr");
    			td0 = element$1("td");
    			t10 = text$1(t10_value);
    			t11 = space();
    			td1 = element$1("td");
    			t12 = text$1(t12_value);
    			t13 = space();
    			td2 = element$1("td");
    			input0 = element$1("input");
    			t14 = space();
    			td3 = element$1("td");
    			input1 = element$1("input");
    			t15 = space();
    			td4 = element$1("td");
    			input2 = element$1("input");
    			t16 = space();
    			td5 = element$1("td");
    			create_component(button.$$.fragment);
    			add_location(th0, file$n, 144, 20, 4387);
    			add_location(th1, file$n, 145, 20, 4422);
    			add_location(th2, file$n, 146, 20, 4456);
    			add_location(th3, file$n, 147, 20, 4513);
    			add_location(th4, file$n, 148, 20, 4582);
    			add_location(tr0, file$n, 143, 16, 4361);
    			add_location(thead, file$n, 142, 12, 4336);
    			add_location(td0, file$n, 153, 20, 4733);
    			add_location(td1, file$n, 154, 20, 4780);
    			add_location(input0, file$n, 155, 24, 4828);
    			add_location(td2, file$n, 155, 20, 4824);
    			add_location(input1, file$n, 156, 24, 4896);
    			add_location(td3, file$n, 156, 20, 4892);
    			add_location(input2, file$n, 157, 24, 4962);
    			add_location(td4, file$n, 157, 20, 4958);
    			add_location(td5, file$n, 159, 20, 5030);
    			add_location(tr1, file$n, 152, 16, 4707);
    			add_location(tbody, file$n, 151, 12, 4682);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, thead, anchor);
    			append_dev(thead, tr0);
    			append_dev(tr0, th0);
    			append_dev(tr0, t1);
    			append_dev(tr0, th1);
    			append_dev(tr0, t3);
    			append_dev(tr0, th2);
    			append_dev(tr0, t5);
    			append_dev(tr0, th3);
    			append_dev(tr0, t7);
    			append_dev(tr0, th4);
    			insert_dev(target, t9, anchor);
    			insert_dev(target, tbody, anchor);
    			append_dev(tbody, tr1);
    			append_dev(tr1, td0);
    			append_dev(td0, t10);
    			append_dev(tr1, t11);
    			append_dev(tr1, td1);
    			append_dev(td1, t12);
    			append_dev(tr1, t13);
    			append_dev(tr1, td2);
    			append_dev(td2, input0);
    			set_input_value(input0, /*updatedExpoTec*/ ctx[1]);
    			append_dev(tr1, t14);
    			append_dev(tr1, td3);
    			append_dev(td3, input1);
    			set_input_value(input1, /*updatedExpoM*/ ctx[2]);
    			append_dev(tr1, t15);
    			append_dev(tr1, td4);
    			append_dev(td4, input2);
    			set_input_value(input2, /*updatedExpoM*/ ctx[2]);
    			append_dev(tr1, t16);
    			append_dev(tr1, td5);
    			mount_component(button, td5, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[9]),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[10]),
    					listen_dev(input2, "input", /*input2_input_handler*/ ctx[11])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*params*/ 1) && t10_value !== (t10_value = /*params*/ ctx[0].country + "")) set_data_dev(t10, t10_value);
    			if ((!current || dirty & /*params*/ 1) && t12_value !== (t12_value = /*params*/ ctx[0].year + "")) set_data_dev(t12, t12_value);

    			if (dirty & /*updatedExpoTec*/ 2 && input0.value !== /*updatedExpoTec*/ ctx[1]) {
    				set_input_value(input0, /*updatedExpoTec*/ ctx[1]);
    			}

    			if (dirty & /*updatedExpoM*/ 4 && input1.value !== /*updatedExpoM*/ ctx[2]) {
    				set_input_value(input1, /*updatedExpoM*/ ctx[2]);
    			}

    			if (dirty & /*updatedExpoM*/ 4 && input2.value !== /*updatedExpoM*/ ctx[2]) {
    				set_input_value(input2, /*updatedExpoM*/ ctx[2]);
    			}

    			const button_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(thead);
    			if (detaching) detach_dev(t9);
    			if (detaching) detach_dev(tbody);
    			destroy_component(button);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$j.name,
    		type: "slot",
    		source: "(142:8) <Table bordered>",
    		ctx
    	});

    	return block;
    }

    // (138:17)       loading          {:then expo}
    function create_pending_block(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("loading");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop$4,
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block.name,
    		type: "pending",
    		source: "(138:17)       loading          {:then expo}",
    		ctx
    	});

    	return block;
    }

    // (169:4) <Button outline color="secondary" on:click= "{pop}">
    function create_default_slot$j(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Volver");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$j.name,
    		type: "slot",
    		source: "(169:4) <Button outline color=\\\"secondary\\\" on:click= \\\"{pop}\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$n(ctx) {
    	let main;
    	let navbar;
    	let t0;
    	let h1;
    	let t1;
    	let t2_value = /*params*/ ctx[0].country + "";
    	let t2;
    	let t3;
    	let t4;
    	let alert;
    	let t5;
    	let promise;
    	let t6;
    	let button;
    	let current;

    	navbar = new Navbar({
    			props: {
    				style: "background-color: lightgreen; color:white;",
    				light: true,
    				expand: "lg",
    				$$slots: { default: [create_default_slot_4$j] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	alert = new Alert({
    			props: {
    				color: /*color*/ ctx[5],
    				isOpen: /*visible*/ ctx[4],
    				toggle: /*func*/ ctx[8],
    				$$slots: { default: [create_default_slot_3$j] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: false,
    		pending: create_pending_block,
    		then: create_then_block,
    		catch: create_catch_block,
    		value: 6,
    		blocks: [,,,]
    	};

    	handle_promise(promise = /*expo*/ ctx[6], info);

    	button = new Button({
    			props: {
    				outline: true,
    				color: "secondary",
    				$$slots: { default: [create_default_slot$j] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", pop);

    	const block = {
    		c: function create() {
    			main = element$1("main");
    			create_component(navbar.$$.fragment);
    			t0 = space();
    			h1 = element$1("h1");
    			t1 = text$1("Editar \"");
    			t2 = text$1(t2_value);
    			t3 = text$1("\"");
    			t4 = space();
    			create_component(alert.$$.fragment);
    			t5 = space();
    			info.block.c();
    			t6 = space();
    			create_component(button.$$.fragment);
    			add_location(h1, file$n, 131, 4, 4070);
    			add_location(main, file$n, 89, 0, 2346);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			mount_component(navbar, main, null);
    			append_dev(main, t0);
    			append_dev(main, h1);
    			append_dev(h1, t1);
    			append_dev(h1, t2);
    			append_dev(h1, t3);
    			append_dev(main, t4);
    			mount_component(alert, main, null);
    			append_dev(main, t5);
    			info.block.m(main, info.anchor = null);
    			info.mount = () => main;
    			info.anchor = t6;
    			append_dev(main, t6);
    			mount_component(button, main, null);
    			current = true;
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;
    			const navbar_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				navbar_changes.$$scope = { dirty, ctx };
    			}

    			navbar.$set(navbar_changes);
    			if ((!current || dirty & /*params*/ 1) && t2_value !== (t2_value = /*params*/ ctx[0].country + "")) set_data_dev(t2, t2_value);
    			const alert_changes = {};
    			if (dirty & /*color*/ 32) alert_changes.color = /*color*/ ctx[5];
    			if (dirty & /*visible*/ 16) alert_changes.isOpen = /*visible*/ ctx[4];
    			if (dirty & /*visible*/ 16) alert_changes.toggle = /*func*/ ctx[8];

    			if (dirty & /*$$scope, checkMSG*/ 65544) {
    				alert_changes.$$scope = { dirty, ctx };
    			}

    			alert.$set(alert_changes);
    			info.ctx = ctx;

    			if (dirty & /*expo*/ 64 && promise !== (promise = /*expo*/ ctx[6]) && handle_promise(promise, info)) ; else {
    				update_await_block_branch(info, ctx, dirty);
    			}

    			const button_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			transition_in(alert.$$.fragment, local);
    			transition_in(info.block);
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			transition_out(alert.$$.fragment, local);

    			for (let i = 0; i < 3; i += 1) {
    				const block = info.blocks[i];
    				transition_out(block);
    			}

    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(navbar);
    			destroy_component(alert);
    			info.block.d();
    			info.token = null;
    			info = null;
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    async function Fallos(code, entrada) {
    	let msg;

    	if (code == 404) {
    		msg = "No se encuentra " + entrada;
    	}

    	if (code == 400) {
    		msg = "solicitud incorrecta";
    	}

    	if (code == 409) {
    		msg = "El dato introducido ya existe";
    	}

    	if (code == 401) {
    		msg = "No autorizado";
    	}

    	if (code == 405) {
    		msg = "Método no permitido";
    	}

    	window.alert(msg);
    	return;
    }

    function instance$n($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('EditExpo', slots, []);
    	let { params = {} } = $$props;
    	let expo = {};
    	let updatedCountry;
    	let updatedYear;
    	let updatedExpoTec;
    	let updatedExpoM;
    	let updatedExpoByS;
    	let checkMSG = "";
    	let visible = false;
    	let color = "danger";
    	onMount(getExpo);

    	async function getExpo() {
    		console.log("fetching expos ....");
    		const res = await fetch("/api/v1/expo/" + params.country + "/" + params.year);

    		if (res.ok) {
    			const data = await res.json();
    			$$invalidate(6, expo = data);
    			updatedCountry = expo.country;
    			updatedYear = expo.year;
    			$$invalidate(1, updatedExpoTec = expo.expo_tec);
    			$$invalidate(2, updatedExpoM = expo.expo_m);
    			$$invalidate(2, updatedExpoM = expo.tot_esco);
    		} else {
    			Fallos(res.status, params.country);
    			pop();
    		}
    	}

    	async function EditExpo() {
    		console.log("Updating expo...." + updatedCountry);

    		await fetch("/api/v1/expo/" + params.country + "/" + params.year, {
    			method: "PUT",
    			body: JSON.stringify({
    				country: updatedCountry,
    				year: updatedYear,
    				expo_tec: updatedExpoTec,
    				expo_m: updatedExpoM,
    				tot_esco: updatedExpoM
    			}),
    			headers: { "Content-Type": "application/json" }
    		});

    		$$invalidate(5, color = "success");
    		$$invalidate(3, checkMSG = "Se ha editado correctamente");
    		$$invalidate(4, visible = "true");
    	}

    	const writable_props = ['params'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$k.warn(`<EditExpo> was created with unknown prop '${key}'`);
    	});

    	const func = () => $$invalidate(4, visible = false);

    	function input0_input_handler() {
    		updatedExpoTec = this.value;
    		$$invalidate(1, updatedExpoTec);
    	}

    	function input1_input_handler() {
    		updatedExpoM = this.value;
    		$$invalidate(2, updatedExpoM);
    	}

    	function input2_input_handler() {
    		updatedExpoM = this.value;
    		$$invalidate(2, updatedExpoM);
    	}

    	$$self.$$set = $$props => {
    		if ('params' in $$props) $$invalidate(0, params = $$props.params);
    	};

    	$$self.$capture_state = () => ({
    		params,
    		pop,
    		onMount,
    		Button,
    		Table,
    		Alert,
    		Navbar,
    		Nav,
    		NavItem,
    		NavLink,
    		NavbarBrand,
    		Dropdown,
    		DropdownToggle,
    		DropdownMenu,
    		DropdownItem,
    		expo,
    		updatedCountry,
    		updatedYear,
    		updatedExpoTec,
    		updatedExpoM,
    		updatedExpoByS,
    		checkMSG,
    		visible,
    		color,
    		getExpo,
    		EditExpo,
    		Fallos
    	});

    	$$self.$inject_state = $$props => {
    		if ('params' in $$props) $$invalidate(0, params = $$props.params);
    		if ('expo' in $$props) $$invalidate(6, expo = $$props.expo);
    		if ('updatedCountry' in $$props) updatedCountry = $$props.updatedCountry;
    		if ('updatedYear' in $$props) updatedYear = $$props.updatedYear;
    		if ('updatedExpoTec' in $$props) $$invalidate(1, updatedExpoTec = $$props.updatedExpoTec);
    		if ('updatedExpoM' in $$props) $$invalidate(2, updatedExpoM = $$props.updatedExpoM);
    		if ('updatedExpoByS' in $$props) updatedExpoByS = $$props.updatedExpoByS;
    		if ('checkMSG' in $$props) $$invalidate(3, checkMSG = $$props.checkMSG);
    		if ('visible' in $$props) $$invalidate(4, visible = $$props.visible);
    		if ('color' in $$props) $$invalidate(5, color = $$props.color);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		params,
    		updatedExpoTec,
    		updatedExpoM,
    		checkMSG,
    		visible,
    		color,
    		expo,
    		EditExpo,
    		func,
    		input0_input_handler,
    		input1_input_handler,
    		input2_input_handler
    	];
    }

    class EditExpo_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$n, create_fragment$n, safe_not_equal, { params: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EditExpo_1",
    			options,
    			id: create_fragment$n.name
    		});
    	}

    	get params() {
    		throw new Error("<EditExpo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set params(value) {
    		throw new Error("<EditExpo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\front\expo-stats\ExpoGraph.svelte generated by Svelte v3.47.0 */

    const { console: console_1$j } = globals;

    const file$m = "src\\front\\expo-stats\\ExpoGraph.svelte";

    // (127:2) <NavbarBrand href="#/info">
    function create_default_slot_21$i(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("INICIO");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_21$i.name,
    		type: "slot",
    		source: "(127:2) <NavbarBrand href=\\\"#/info\\\">",
    		ctx
    	});

    	return block;
    }

    // (130:4) <DropdownToggle nav caret>
    function create_default_slot_20$i(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("API");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_20$i.name,
    		type: "slot",
    		source: "(130:4) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (132:6) <DropdownItem href="./api/v2/economies">
    function create_default_slot_19$i(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_19$i.name,
    		type: "slot",
    		source: "(132:6) <DropdownItem href=\\\"./api/v2/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (134:6) <DropdownItem href="./api/v1/esco-stats">
    function create_default_slot_18$i(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_18$i.name,
    		type: "slot",
    		source: "(134:6) <DropdownItem href=\\\"./api/v1/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (136:6) <DropdownItem href="./api/v1/expo">
    function create_default_slot_17$i(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17$i.name,
    		type: "slot",
    		source: "(136:6) <DropdownItem href=\\\"./api/v1/expo\\\">",
    		ctx
    	});

    	return block;
    }

    // (131:4) <DropdownMenu end>
    function create_default_slot_16$i(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./api/v2/economies",
    				$$slots: { default: [create_default_slot_19$i] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "./api/v1/esco-stats",
    				$$slots: { default: [create_default_slot_18$i] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "./api/v1/expo",
    				$$slots: { default: [create_default_slot_17$i] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16$i.name,
    		type: "slot",
    		source: "(131:4) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (129:3) <Dropdown >
    function create_default_slot_15$i(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_20$i] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_16$i] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15$i.name,
    		type: "slot",
    		source: "(129:3) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (141:4) <DropdownToggle nav caret>
    function create_default_slot_14$i(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14$i.name,
    		type: "slot",
    		source: "(141:4) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (143:6) <DropdownItem href="./#/economies">
    function create_default_slot_13$i(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13$i.name,
    		type: "slot",
    		source: "(143:6) <DropdownItem href=\\\"./#/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (145:6) <DropdownItem href="./#/esco-stats">
    function create_default_slot_12$i(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco FRONT_END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12$i.name,
    		type: "slot",
    		source: "(145:6) <DropdownItem href=\\\"./#/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (147:6) <DropdownItem href="#/expo">
    function create_default_slot_11$i(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$i.name,
    		type: "slot",
    		source: "(147:6) <DropdownItem href=\\\"#/expo\\\">",
    		ctx
    	});

    	return block;
    }

    // (142:4) <DropdownMenu end>
    function create_default_slot_10$i(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies",
    				$$slots: { default: [create_default_slot_13$i] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "./#/esco-stats",
    				$$slots: { default: [create_default_slot_12$i] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/expo",
    				$$slots: { default: [create_default_slot_11$i] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$i.name,
    		type: "slot",
    		source: "(142:4) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (140:12) <Dropdown>
    function create_default_slot_9$i(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_14$i] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_10$i] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$i.name,
    		type: "slot",
    		source: "(140:12) <Dropdown>",
    		ctx
    	});

    	return block;
    }

    // (152:4) <DropdownToggle nav caret>
    function create_default_slot_8$i(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Gráficas");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$i.name,
    		type: "slot",
    		source: "(152:4) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (154:6) <DropdownItem href="./#/economies-graph">
    function create_default_slot_7$i(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$i.name,
    		type: "slot",
    		source: "(154:6) <DropdownItem href=\\\"./#/economies-graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (156:6) <DropdownItem href="./#/graphesco">
    function create_default_slot_6$i(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$i.name,
    		type: "slot",
    		source: "(156:6) <DropdownItem href=\\\"./#/graphesco\\\">",
    		ctx
    	});

    	return block;
    }

    // (158:6) <DropdownItem href="#/graphexpo">
    function create_default_slot_5$i(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$i.name,
    		type: "slot",
    		source: "(158:6) <DropdownItem href=\\\"#/graphexpo\\\">",
    		ctx
    	});

    	return block;
    }

    // (160:18) <DropdownItem href="./#/graph">
    function create_default_slot_4$i(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Grafica comun");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$i.name,
    		type: "slot",
    		source: "(160:18) <DropdownItem href=\\\"./#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (153:4) <DropdownMenu end>
    function create_default_slot_3$i(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let t4;
    	let dropdownitem5;
    	let t5;
    	let dropdownitem6;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies-graph",
    				$$slots: { default: [create_default_slot_7$i] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "./#/graphesco",
    				$$slots: { default: [create_default_slot_6$i] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/graphexpo",
    				$$slots: { default: [create_default_slot_5$i] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem5 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem6 = new DropdownItem({
    			props: {
    				href: "./#/graph",
    				$$slots: { default: [create_default_slot_4$i] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    			t4 = space();
    			create_component(dropdownitem5.$$.fragment);
    			t5 = space();
    			create_component(dropdownitem6.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(dropdownitem5, target, anchor);
    			insert_dev(target, t5, anchor);
    			mount_component(dropdownitem6, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    			const dropdownitem6_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdownitem6_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem6.$set(dropdownitem6_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			transition_in(dropdownitem5.$$.fragment, local);
    			transition_in(dropdownitem6.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			transition_out(dropdownitem5.$$.fragment, local);
    			transition_out(dropdownitem6.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(dropdownitem5, detaching);
    			if (detaching) detach_dev(t5);
    			destroy_component(dropdownitem6, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$i.name,
    		type: "slot",
    		source: "(153:4) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (151:5) <Dropdown >
    function create_default_slot_2$i(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_8$i] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_3$i] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$i.name,
    		type: "slot",
    		source: "(151:5) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (128:2) <Nav navbar>
    function create_default_slot_1$i(ctx) {
    	let dropdown0;
    	let t0;
    	let dropdown1;
    	let t1;
    	let dropdown2;
    	let current;

    	dropdown0 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_15$i] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown1 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_9$i] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown2 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_2$i] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdown0.$$.fragment);
    			t0 = space();
    			create_component(dropdown1.$$.fragment);
    			t1 = space();
    			create_component(dropdown2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdown0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdown1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdown2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdown0_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdown0_changes.$$scope = { dirty, ctx };
    			}

    			dropdown0.$set(dropdown0_changes);
    			const dropdown1_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdown1_changes.$$scope = { dirty, ctx };
    			}

    			dropdown1.$set(dropdown1_changes);
    			const dropdown2_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dropdown2_changes.$$scope = { dirty, ctx };
    			}

    			dropdown2.$set(dropdown2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdown0.$$.fragment, local);
    			transition_in(dropdown1.$$.fragment, local);
    			transition_in(dropdown2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdown0.$$.fragment, local);
    			transition_out(dropdown1.$$.fragment, local);
    			transition_out(dropdown2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdown0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdown1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdown2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$i.name,
    		type: "slot",
    		source: "(128:2) <Nav navbar>",
    		ctx
    	});

    	return block;
    }

    // (126:4) <Navbar style="background-color: lightgreen; color:white;" light expand="lg" >
    function create_default_slot$i(ctx) {
    	let navbarbrand;
    	let t;
    	let nav;
    	let current;

    	navbarbrand = new NavbarBrand({
    			props: {
    				href: "#/info",
    				$$slots: { default: [create_default_slot_21$i] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	nav = new Nav({
    			props: {
    				navbar: true,
    				$$slots: { default: [create_default_slot_1$i] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navbarbrand.$$.fragment);
    			t = space();
    			create_component(nav.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbarbrand, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(nav, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navbarbrand_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				navbarbrand_changes.$$scope = { dirty, ctx };
    			}

    			navbarbrand.$set(navbarbrand_changes);
    			const nav_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				nav_changes.$$scope = { dirty, ctx };
    			}

    			nav.$set(nav_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbarbrand.$$.fragment, local);
    			transition_in(nav.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbarbrand.$$.fragment, local);
    			transition_out(nav.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbarbrand, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(nav, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$i.name,
    		type: "slot",
    		source: "(126:4) <Navbar style=\\\"background-color: lightgreen; color:white;\\\" light expand=\\\"lg\\\" >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$m(ctx) {
    	let script0;
    	let script0_src_value;
    	let script1;
    	let script1_src_value;
    	let script2;
    	let script2_src_value;
    	let script3;
    	let script3_src_value;
    	let t0;
    	let main;
    	let navbar;
    	let t1;
    	let figure;
    	let div;
    	let t2;
    	let p;
    	let current;
    	let mounted;
    	let dispose;

    	navbar = new Navbar({
    			props: {
    				style: "background-color: lightgreen; color:white;",
    				light: true,
    				expand: "lg",
    				$$slots: { default: [create_default_slot$i] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			script0 = element$1("script");
    			script1 = element$1("script");
    			script2 = element$1("script");
    			script3 = element$1("script");
    			t0 = space();
    			main = element$1("main");
    			create_component(navbar.$$.fragment);
    			t1 = space();
    			figure = element$1("figure");
    			div = element$1("div");
    			t2 = space();
    			p = element$1("p");
    			p.textContent = "Este gráfico compara las exportaciones de diferentes paises";
    			if (!src_url_equal(script0.src, script0_src_value = "https://code.highcharts.com/highcharts.js")) attr_dev(script0, "src", script0_src_value);
    			add_location(script0, file$m, 118, 4, 3942);
    			if (!src_url_equal(script1.src, script1_src_value = "https://code.highcharts.com/modules/exporting.js")) attr_dev(script1, "src", script1_src_value);
    			add_location(script1, file$m, 119, 4, 4013);
    			if (!src_url_equal(script2.src, script2_src_value = "https://code.highcharts.com/modules/export-data.js")) attr_dev(script2, "src", script2_src_value);
    			add_location(script2, file$m, 120, 4, 4091);
    			if (!src_url_equal(script3.src, script3_src_value = "https://code.highcharts.com/modules/accessibility.js")) attr_dev(script3, "src", script3_src_value);
    			add_location(script3, file$m, 121, 4, 4171);
    			attr_dev(div, "id", "container");
    			add_location(div, file$m, 168, 8, 6092);
    			attr_dev(p, "class", "highcharts-description");
    			add_location(p, file$m, 169, 8, 6124);
    			attr_dev(figure, "class", "highcharts-figure");
    			add_location(figure, file$m, 167, 4, 6048);
    			add_location(main, file$m, 124, 0, 4289);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			append_dev(document.head, script0);
    			append_dev(document.head, script1);
    			append_dev(document.head, script2);
    			append_dev(document.head, script3);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			mount_component(navbar, main, null);
    			append_dev(main, t1);
    			append_dev(main, figure);
    			append_dev(figure, div);
    			append_dev(figure, t2);
    			append_dev(figure, p);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(script3, "load", /*loadGraph*/ ctx[0], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const navbar_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				navbar_changes.$$scope = { dirty, ctx };
    			}

    			navbar.$set(navbar_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			detach_dev(script0);
    			detach_dev(script1);
    			detach_dev(script2);
    			detach_dev(script3);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			destroy_component(navbar);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$m($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ExpoGraph', slots, []);
    	const delay = ms => new Promise(res => setTimeout(res, ms));
    	let expos = [];
    	let country = [];
    	let year = [];
    	let expo_tec = [];
    	let expo_m = [];
    	let tot_esco = [];
    	let datosOrdenados = [];

    	async function getData() {
    		console.log("Fetching expo....");
    		const res = await fetch("/api/v1/expo");

    		if (res.ok) {
    			const data = await res.json();
    			expos = data;

    			if (expos.length == 0) {
    				await fetch("/api/v1/expo-stats/loadInitialData");
    				console.log("Entradas recibidas: " + expos.length);

    				//con la siguiente funcion ordeno los datos por años de menor a mayor
    				datosOrdenados = expos.sort(function (a, b) {
    					return a.year - b.year;
    				});

    				console.log("Ordenadas correctamente");

    				datosOrdenados.forEach(expo => {
    					year.push(expo.year);
    					country.push(expo.country + "-" + expo.year);
    					expo_tec.push(expo.expo_tec);
    					expo_m.push(expo.expo_m);
    					tot_esco.push(expo.tot_esco);
    				});

    				location.reload();
    			} else {
    				console.log("Entradas recibidas: " + expos.length);

    				//con la siguiente funcion ordeno los datos por años de menor a mayor
    				datosOrdenados = expos.sort(function (a, b) {
    					return a.year - b.year;
    				});

    				console.log("Ordenadas correctamente");

    				datosOrdenados.forEach(expo => {
    					year.push(expo.year);
    					country.push(expo.country + "-" + expo.year);
    					expo_tec.push(expo.expo_tec);
    					expo_m.push(expo.expo_m);
    					tot_esco.push(expo.tot_esco);
    				});
    			}
    		} else {
    			console.log("Error, can`t charge data");
    		}
    	}

    	async function loadGraph() {
    		Highcharts.chart("container", {
    			chart: { type: "bar" },
    			title: { text: "País" },
    			subtitle: {
    				text: "Source: https://ourworldindata.org/expo"
    			},
    			xAxis: { categories: country, crosshair: true },
    			yAxis: {
    				min: 0,
    				title: { text: "%(Según el PIB)" }
    			},
    			tooltip: {
    				headerFormat: '<span style="font-size:10px">{point.key}</span><table>',
    				pointFormat: '<tr><td style="color:{series.color};padding:0">{series.name}: </td>' + '<td style="padding:0"><b>{point.y} % de exportaciones</b></td></tr>',
    				footerFormat: "</table>",
    				shared: true,
    				useHTML: true
    			},
    			plotOptions: {
    				column: { pointPadding: 0.2, borderWidth: 0 }
    			},
    			series: [
    				{
    					name: 'Exportaciones Bienes y Servicios',
    					data: tot_esco
    				},
    				{
    					name: 'Exportaciones Prod. Manufacturados',
    					data: expo_m
    				},
    				{
    					name: 'Exportaciones Tecnológicas',
    					data: expo_tec
    				}
    			]
    		});
    	}

    	onMount(getData);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$j.warn(`<ExpoGraph> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		Navbar,
    		Nav,
    		NavItem,
    		NavLink,
    		NavbarBrand,
    		Dropdown,
    		DropdownToggle,
    		DropdownMenu,
    		DropdownItem,
    		Button,
    		delay,
    		expos,
    		country,
    		year,
    		expo_tec,
    		expo_m,
    		tot_esco,
    		datosOrdenados,
    		getData,
    		loadGraph
    	});

    	$$self.$inject_state = $$props => {
    		if ('expos' in $$props) expos = $$props.expos;
    		if ('country' in $$props) country = $$props.country;
    		if ('year' in $$props) year = $$props.year;
    		if ('expo_tec' in $$props) expo_tec = $$props.expo_tec;
    		if ('expo_m' in $$props) expo_m = $$props.expo_m;
    		if ('tot_esco' in $$props) tot_esco = $$props.tot_esco;
    		if ('datosOrdenados' in $$props) datosOrdenados = $$props.datosOrdenados;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [loadGraph];
    }

    class ExpoGraph extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$m, create_fragment$m, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ExpoGraph",
    			options,
    			id: create_fragment$m.name
    		});
    	}
    }

    /* src\front\MyGraph.svelte generated by Svelte v3.47.0 */

    const { console: console_1$i } = globals;
    const file$l = "src\\front\\MyGraph.svelte";

    function create_fragment$l(ctx) {
    	let script0;
    	let script0_src_value;
    	let script1;
    	let script1_src_value;
    	let script2;
    	let script2_src_value;
    	let script3;
    	let script3_src_value;
    	let script4;
    	let script4_src_value;
    	let t0;
    	let main;
    	let figure;
    	let div;
    	let t1;
    	let p;
    	let t2;
    	let code;
    	let t4;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			script0 = element$1("script");
    			script1 = element$1("script");
    			script2 = element$1("script");
    			script3 = element$1("script");
    			script4 = element$1("script");
    			t0 = space();
    			main = element$1("main");
    			figure = element$1("figure");
    			div = element$1("div");
    			t1 = space();
    			p = element$1("p");
    			t2 = text$1("Basic line chart showing trends in a dataset. This chart includes the\r\n            ");
    			code = element$1("code");
    			code.textContent = "series-label";
    			t4 = text$1(" module, which adds a label to each line for\r\n            enhanced readability.");
    			if (!src_url_equal(script0.src, script0_src_value = "https://code.highcharts.com/highcharts.js")) attr_dev(script0, "src", script0_src_value);
    			add_location(script0, file$l, 137, 4, 3576);
    			if (!src_url_equal(script1.src, script1_src_value = "https://code.highcharts.com/modules/series-label.js")) attr_dev(script1, "src", script1_src_value);
    			add_location(script1, file$l, 138, 4, 3669);
    			if (!src_url_equal(script2.src, script2_src_value = "https://code.highcharts.com/modules/exporting.js")) attr_dev(script2, "src", script2_src_value);
    			add_location(script2, file$l, 139, 4, 3772);
    			if (!src_url_equal(script3.src, script3_src_value = "https://code.highcharts.com/modules/export-data.js")) attr_dev(script3, "src", script3_src_value);
    			add_location(script3, file$l, 140, 4, 3872);
    			if (!src_url_equal(script4.src, script4_src_value = "https://code.highcharts.com/modules/accessibility.js")) attr_dev(script4, "src", script4_src_value);
    			add_location(script4, file$l, 141, 4, 3974);
    			attr_dev(div, "id", "container");
    			add_location(div, file$l, 148, 8, 4152);
    			add_location(code, file$l, 151, 12, 4319);
    			attr_dev(p, "class", "highcharts-description");
    			add_location(p, file$l, 149, 8, 4188);
    			attr_dev(figure, "class", "highcharts-figure");
    			add_location(figure, file$l, 147, 4, 4108);
    			add_location(main, file$l, 145, 0, 4094);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			append_dev(document.head, script0);
    			append_dev(document.head, script1);
    			append_dev(document.head, script2);
    			append_dev(document.head, script3);
    			append_dev(document.head, script4);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			append_dev(main, figure);
    			append_dev(figure, div);
    			append_dev(figure, t1);
    			append_dev(figure, p);
    			append_dev(p, t2);
    			append_dev(p, code);
    			append_dev(p, t4);

    			if (!mounted) {
    				dispose = [
    					listen_dev(script0, "load", /*loadGraph*/ ctx[0], false, false, false),
    					listen_dev(script1, "load", /*loadGraph*/ ctx[0], false, false, false),
    					listen_dev(script2, "load", /*loadGraph*/ ctx[0], false, false, false),
    					listen_dev(script3, "load", /*loadGraph*/ ctx[0], false, false, false),
    					listen_dev(script4, "load", /*loadGraph*/ ctx[0], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop$4,
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			detach_dev(script0);
    			detach_dev(script1);
    			detach_dev(script2);
    			detach_dev(script3);
    			detach_dev(script4);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$l($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MyGraph', slots, []);
    	let expos = [];
    	let escos = [];
    	let economies = [];
    	let country = [];
    	let year = [];
    	let tot_esco = [];
    	let tot_wom = [];
    	let tot_man = [];
    	let expo_m = [];
    	let expo_tec = [];
    	let percapita = [];
    	let currency = [];
    	let currentprices = [];
    	let ages1 = [];
    	let ages2 = [];
    	let ages3 = [];

    	async function loadGraph() {
    		const res1 = await fetch("/api/v1/expo");
    		const res2 = await fetch("/api/v2/economies");
    		const res3 = await fetch("/api/v1/esco-stats");

    		if (res1.ok && res2.ok && res3.ok) {
    			const data1 = await res1.json();
    			const data3 = await res2.json();
    			const data2 = await res3.json();
    			expos = data1;
    			console.log("Recibido: " + expos.length);

    			//inicializamos los arrays para mostrar los datos
    			expos.forEach(expo => {
    				country.push(expo.country + "-" + expo.year);
    				year.push(expo.year);
    				ages1.push(expo.tot_esco + expo.expo_m + expo.expo_tec);
    				expo_m.push(expo.expo_m);
    				expo_tec.push(expo.expo_tec);
    			});

    			economies = data3;
    			console.log("Recibido: " + economies.length);

    			economies.forEach(economies => {
    				percapita.push(economies.percapita);
    				currency.push(economies.currency);
    				ages3.push(economies.percapita + economies.currency + economies.currentprices);
    				currentprices.push(economies.currentprices);
    			});

    			escos = data2;
    			console.log("Recibido: " + escos.length);

    			escos.forEach(esco => {
    				// year.push(esco.year);
    				//country.push(esco.country);
    				tot_wom.push(esco.tot_wom);

    				tot_man.push(esco.tot_man);
    				ages2.push(esco.tot_esco + esco.tot_man + esco.tot_wom);
    				tot_esco.push(esco.tot_esco);
    			});
    		} else {
    			console.log("Error in request");
    		}

    		Highcharts.chart("container", {
    			title: {
    				text: "Economia, escolarizacion y exportaciones"
    			},
    			subtitle: { text: "" },
    			yAxis: {
    				title: {
    					text: "economia escolarizacion y exportaciones"
    				}
    			},
    			xAxis: {
    				title: { text: "Pais-año" },
    				categories: country
    			},
    			legend: {
    				layout: "vertical",
    				align: "right",
    				verticalAlign: "middle"
    			},
    			series: [
    				{ name: 'expo', data: ages1 },
    				{ name: 'esco', data: ages2 },
    				{ name: 'economies', data: ages3 }
    			],
    			responsive: {
    				rules: [
    					{
    						condition: { maxWidth: 500 },
    						chartOptions: {
    							legend: {
    								layout: "horizontal",
    								align: "center",
    								verticalAlign: "bottom"
    							}
    						}
    					}
    				]
    			}
    		});
    	}

    	onMount(loadGraph);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$i.warn(`<MyGraph> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		expos,
    		escos,
    		economies,
    		country,
    		year,
    		tot_esco,
    		tot_wom,
    		tot_man,
    		expo_m,
    		expo_tec,
    		percapita,
    		currency,
    		currentprices,
    		ages1,
    		ages2,
    		ages3,
    		loadGraph
    	});

    	$$self.$inject_state = $$props => {
    		if ('expos' in $$props) expos = $$props.expos;
    		if ('escos' in $$props) escos = $$props.escos;
    		if ('economies' in $$props) economies = $$props.economies;
    		if ('country' in $$props) country = $$props.country;
    		if ('year' in $$props) year = $$props.year;
    		if ('tot_esco' in $$props) tot_esco = $$props.tot_esco;
    		if ('tot_wom' in $$props) tot_wom = $$props.tot_wom;
    		if ('tot_man' in $$props) tot_man = $$props.tot_man;
    		if ('expo_m' in $$props) expo_m = $$props.expo_m;
    		if ('expo_tec' in $$props) expo_tec = $$props.expo_tec;
    		if ('percapita' in $$props) percapita = $$props.percapita;
    		if ('currency' in $$props) currency = $$props.currency;
    		if ('currentprices' in $$props) currentprices = $$props.currentprices;
    		if ('ages1' in $$props) ages1 = $$props.ages1;
    		if ('ages2' in $$props) ages2 = $$props.ages2;
    		if ('ages3' in $$props) ages3 = $$props.ages3;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [loadGraph];
    }

    class MyGraph extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$l, create_fragment$l, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MyGraph",
    			options,
    			id: create_fragment$l.name
    		});
    	}
    }

    /* src\front\about.svelte generated by Svelte v3.47.0 */

    const file$k = "src\\front\\about.svelte";

    // (8:2) <NavbarBrand href="#/info">
    function create_default_slot_21$h(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("INICIO");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_21$h.name,
    		type: "slot",
    		source: "(8:2) <NavbarBrand href=\\\"#/info\\\">",
    		ctx
    	});

    	return block;
    }

    // (11:4) <DropdownToggle nav caret>
    function create_default_slot_20$h(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("API");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_20$h.name,
    		type: "slot",
    		source: "(11:4) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (13:6) <DropdownItem href="./api/v2/economies">
    function create_default_slot_19$h(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_19$h.name,
    		type: "slot",
    		source: "(13:6) <DropdownItem href=\\\"./api/v2/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (15:6) <DropdownItem href="./api/v1/esco-stats">
    function create_default_slot_18$h(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_18$h.name,
    		type: "slot",
    		source: "(15:6) <DropdownItem href=\\\"./api/v1/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (17:6) <DropdownItem href="./api/v1/expo">
    function create_default_slot_17$h(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17$h.name,
    		type: "slot",
    		source: "(17:6) <DropdownItem href=\\\"./api/v1/expo\\\">",
    		ctx
    	});

    	return block;
    }

    // (12:4) <DropdownMenu end>
    function create_default_slot_16$h(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./api/v2/economies",
    				$$slots: { default: [create_default_slot_19$h] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "./api/v1/esco-stats",
    				$$slots: { default: [create_default_slot_18$h] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "./api/v1/expo",
    				$$slots: { default: [create_default_slot_17$h] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16$h.name,
    		type: "slot",
    		source: "(12:4) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (10:3) <Dropdown >
    function create_default_slot_15$h(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_20$h] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_16$h] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15$h.name,
    		type: "slot",
    		source: "(10:3) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (22:4) <DropdownToggle nav caret>
    function create_default_slot_14$h(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14$h.name,
    		type: "slot",
    		source: "(22:4) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (24:6) <DropdownItem href="./#/economies">
    function create_default_slot_13$h(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13$h.name,
    		type: "slot",
    		source: "(24:6) <DropdownItem href=\\\"./#/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (26:6) <DropdownItem href="./#/esco-stats">
    function create_default_slot_12$h(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12$h.name,
    		type: "slot",
    		source: "(26:6) <DropdownItem href=\\\"./#/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (28:6) <DropdownItem href="#/expo">
    function create_default_slot_11$h(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Expo FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$h.name,
    		type: "slot",
    		source: "(28:6) <DropdownItem href=\\\"#/expo\\\">",
    		ctx
    	});

    	return block;
    }

    // (23:4) <DropdownMenu end>
    function create_default_slot_10$h(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies",
    				$$slots: { default: [create_default_slot_13$h] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "./#/esco-stats",
    				$$slots: { default: [create_default_slot_12$h] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/expo",
    				$$slots: { default: [create_default_slot_11$h] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$h.name,
    		type: "slot",
    		source: "(23:4) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (21:12) <Dropdown>
    function create_default_slot_9$h(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_14$h] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_10$h] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$h.name,
    		type: "slot",
    		source: "(21:12) <Dropdown>",
    		ctx
    	});

    	return block;
    }

    // (33:3) <DropdownToggle nav caret>
    function create_default_slot_8$h(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Gráficas");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$h.name,
    		type: "slot",
    		source: "(33:3) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (35:5) <DropdownItem href="./#/economies-graph">
    function create_default_slot_7$h(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$h.name,
    		type: "slot",
    		source: "(35:5) <DropdownItem href=\\\"./#/economies-graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (37:5) <DropdownItem href="./#/graphesco">
    function create_default_slot_6$h(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$h.name,
    		type: "slot",
    		source: "(37:5) <DropdownItem href=\\\"./#/graphesco\\\">",
    		ctx
    	});

    	return block;
    }

    // (39:5) <DropdownItem href="#/graphexpo">
    function create_default_slot_5$h(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$h.name,
    		type: "slot",
    		source: "(39:5) <DropdownItem href=\\\"#/graphexpo\\\">",
    		ctx
    	});

    	return block;
    }

    // (41:13) <DropdownItem href="./#/graph">
    function create_default_slot_4$h(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Grafica comun");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$h.name,
    		type: "slot",
    		source: "(41:13) <DropdownItem href=\\\"./#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (34:3) <DropdownMenu end>
    function create_default_slot_3$h(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let t4;
    	let dropdownitem5;
    	let t5;
    	let dropdownitem6;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies-graph",
    				$$slots: { default: [create_default_slot_7$h] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "./#/graphesco",
    				$$slots: { default: [create_default_slot_6$h] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/graphexpo",
    				$$slots: { default: [create_default_slot_5$h] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem5 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem6 = new DropdownItem({
    			props: {
    				href: "./#/graph",
    				$$slots: { default: [create_default_slot_4$h] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    			t4 = space();
    			create_component(dropdownitem5.$$.fragment);
    			t5 = space();
    			create_component(dropdownitem6.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(dropdownitem5, target, anchor);
    			insert_dev(target, t5, anchor);
    			mount_component(dropdownitem6, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    			const dropdownitem6_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdownitem6_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem6.$set(dropdownitem6_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			transition_in(dropdownitem5.$$.fragment, local);
    			transition_in(dropdownitem6.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			transition_out(dropdownitem5.$$.fragment, local);
    			transition_out(dropdownitem6.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(dropdownitem5, detaching);
    			if (detaching) detach_dev(t5);
    			destroy_component(dropdownitem6, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$h.name,
    		type: "slot",
    		source: "(34:3) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (32:4) <Dropdown >
    function create_default_slot_2$h(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_8$h] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_3$h] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$h.name,
    		type: "slot",
    		source: "(32:4) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (9:2) <Nav navbar>
    function create_default_slot_1$h(ctx) {
    	let dropdown0;
    	let t0;
    	let dropdown1;
    	let t1;
    	let dropdown2;
    	let current;

    	dropdown0 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_15$h] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown1 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_9$h] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown2 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_2$h] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdown0.$$.fragment);
    			t0 = space();
    			create_component(dropdown1.$$.fragment);
    			t1 = space();
    			create_component(dropdown2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdown0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdown1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdown2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdown0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdown0_changes.$$scope = { dirty, ctx };
    			}

    			dropdown0.$set(dropdown0_changes);
    			const dropdown1_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdown1_changes.$$scope = { dirty, ctx };
    			}

    			dropdown1.$set(dropdown1_changes);
    			const dropdown2_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdown2_changes.$$scope = { dirty, ctx };
    			}

    			dropdown2.$set(dropdown2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdown0.$$.fragment, local);
    			transition_in(dropdown1.$$.fragment, local);
    			transition_in(dropdown2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdown0.$$.fragment, local);
    			transition_out(dropdown1.$$.fragment, local);
    			transition_out(dropdown2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdown0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdown1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdown2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$h.name,
    		type: "slot",
    		source: "(9:2) <Nav navbar>",
    		ctx
    	});

    	return block;
    }

    // (7:4) <Navbar style="background-color: lightgreen; color:white;" light expand="lg" >
    function create_default_slot$h(ctx) {
    	let navbarbrand;
    	let t;
    	let nav;
    	let current;

    	navbarbrand = new NavbarBrand({
    			props: {
    				href: "#/info",
    				$$slots: { default: [create_default_slot_21$h] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	nav = new Nav({
    			props: {
    				navbar: true,
    				$$slots: { default: [create_default_slot_1$h] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navbarbrand.$$.fragment);
    			t = space();
    			create_component(nav.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbarbrand, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(nav, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navbarbrand_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				navbarbrand_changes.$$scope = { dirty, ctx };
    			}

    			navbarbrand.$set(navbarbrand_changes);
    			const nav_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				nav_changes.$$scope = { dirty, ctx };
    			}

    			nav.$set(nav_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbarbrand.$$.fragment, local);
    			transition_in(nav.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbarbrand.$$.fragment, local);
    			transition_out(nav.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbarbrand, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(nav, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$h.name,
    		type: "slot",
    		source: "(7:4) <Navbar style=\\\"background-color: lightgreen; color:white;\\\" light expand=\\\"lg\\\" >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$k(ctx) {
    	let body;
    	let navbar;
    	let t0;
    	let main;
    	let h3;
    	let t2;
    	let p0;
    	let t3;
    	let a0;
    	let t5;
    	let p1;
    	let t6;
    	let a1;
    	let t8;
    	let p2;
    	let t9;
    	let a2;
    	let t11;
    	let br;
    	let current;

    	navbar = new Navbar({
    			props: {
    				style: "background-color: lightgreen; color:white;",
    				light: true,
    				expand: "lg",
    				$$slots: { default: [create_default_slot$h] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			body = element$1("body");
    			create_component(navbar.$$.fragment);
    			t0 = space();
    			main = element$1("main");
    			h3 = element$1("h3");
    			h3.textContent = "Videos";
    			t2 = space();
    			p0 = element$1("p");
    			t3 = text$1("- ");
    			a0 = element$1("a");
    			a0.textContent = "Enlace video  Damian Gonzalez Carrasco";
    			t5 = space();
    			p1 = element$1("p");
    			t6 = text$1("- ");
    			a1 = element$1("a");
    			a1.textContent = "Enlace video Angel Simon Mesa";
    			t8 = space();
    			p2 = element$1("p");
    			t9 = text$1("- ");
    			a2 = element$1("a");
    			a2.textContent = "Enlace video Adrián Pérez Gómez";
    			t11 = space();
    			br = element$1("br");
    			add_location(body, file$k, 5, 0, 162);
    			add_location(h3, file$k, 52, 4, 1868);
    			attr_dev(a0, "href", "https://github.com/damiangc99");
    			add_location(a0, file$k, 53, 9, 1894);
    			add_location(p0, file$k, 53, 4, 1889);
    			attr_dev(a1, "href", "https://github.com/AngelSM11");
    			add_location(a1, file$k, 54, 9, 1991);
    			add_location(p1, file$k, 54, 4, 1986);
    			attr_dev(a2, "href", "https://github.com/adriperez01");
    			add_location(a2, file$k, 55, 9, 2079);
    			add_location(p2, file$k, 55, 4, 2074);
    			add_location(br, file$k, 56, 4, 2165);
    			attr_dev(main, "class", "svelte-ri70vu");
    			add_location(main, file$k, 49, 0, 1852);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, body, anchor);
    			mount_component(navbar, body, null);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			append_dev(main, h3);
    			append_dev(main, t2);
    			append_dev(main, p0);
    			append_dev(p0, t3);
    			append_dev(p0, a0);
    			append_dev(main, t5);
    			append_dev(main, p1);
    			append_dev(p1, t6);
    			append_dev(p1, a1);
    			append_dev(main, t8);
    			append_dev(main, p2);
    			append_dev(p2, t9);
    			append_dev(p2, a2);
    			append_dev(main, t11);
    			append_dev(main, br);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const navbar_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				navbar_changes.$$scope = { dirty, ctx };
    			}

    			navbar.$set(navbar_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(body);
    			destroy_component(navbar);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('About', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<About> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Navbar,
    		Nav,
    		NavItem,
    		NavLink,
    		NavbarBrand,
    		Dropdown,
    		DropdownToggle,
    		DropdownMenu,
    		DropdownItem,
    		Button
    	});

    	return [];
    }

    class About extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$k, create_fragment$k, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "About",
    			options,
    			id: create_fragment$k.name
    		});
    	}
    }

    /* src\front\integration.svelte generated by Svelte v3.47.0 */

    const file$j = "src\\front\\integration.svelte";

    // (8:2) <NavbarBrand href="#/info">
    function create_default_slot_21$g(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("INICIO");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_21$g.name,
    		type: "slot",
    		source: "(8:2) <NavbarBrand href=\\\"#/info\\\">",
    		ctx
    	});

    	return block;
    }

    // (11:4) <DropdownToggle nav caret>
    function create_default_slot_20$g(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("API");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_20$g.name,
    		type: "slot",
    		source: "(11:4) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (13:6) <DropdownItem href="./api/v2/economies">
    function create_default_slot_19$g(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_19$g.name,
    		type: "slot",
    		source: "(13:6) <DropdownItem href=\\\"./api/v2/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (15:6) <DropdownItem href="./api/v1/esco-stats">
    function create_default_slot_18$g(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_18$g.name,
    		type: "slot",
    		source: "(15:6) <DropdownItem href=\\\"./api/v1/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (17:6) <DropdownItem href="./api/v1/expo">
    function create_default_slot_17$g(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17$g.name,
    		type: "slot",
    		source: "(17:6) <DropdownItem href=\\\"./api/v1/expo\\\">",
    		ctx
    	});

    	return block;
    }

    // (12:4) <DropdownMenu end>
    function create_default_slot_16$g(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./api/v2/economies",
    				$$slots: { default: [create_default_slot_19$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "./api/v1/esco-stats",
    				$$slots: { default: [create_default_slot_18$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "./api/v1/expo",
    				$$slots: { default: [create_default_slot_17$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16$g.name,
    		type: "slot",
    		source: "(12:4) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (10:3) <Dropdown >
    function create_default_slot_15$g(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_20$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_16$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15$g.name,
    		type: "slot",
    		source: "(10:3) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (22:4) <DropdownToggle nav caret>
    function create_default_slot_14$g(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14$g.name,
    		type: "slot",
    		source: "(22:4) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (24:6) <DropdownItem href="./#/economies">
    function create_default_slot_13$g(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13$g.name,
    		type: "slot",
    		source: "(24:6) <DropdownItem href=\\\"./#/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (26:6) <DropdownItem href="./#/esco-stats">
    function create_default_slot_12$g(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12$g.name,
    		type: "slot",
    		source: "(26:6) <DropdownItem href=\\\"./#/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (28:6) <DropdownItem href="#/expo">
    function create_default_slot_11$g(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Expo FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$g.name,
    		type: "slot",
    		source: "(28:6) <DropdownItem href=\\\"#/expo\\\">",
    		ctx
    	});

    	return block;
    }

    // (23:4) <DropdownMenu end>
    function create_default_slot_10$g(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies",
    				$$slots: { default: [create_default_slot_13$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "./#/esco-stats",
    				$$slots: { default: [create_default_slot_12$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/expo",
    				$$slots: { default: [create_default_slot_11$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$g.name,
    		type: "slot",
    		source: "(23:4) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (21:12) <Dropdown>
    function create_default_slot_9$g(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_14$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_10$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$g.name,
    		type: "slot",
    		source: "(21:12) <Dropdown>",
    		ctx
    	});

    	return block;
    }

    // (33:3) <DropdownToggle nav caret>
    function create_default_slot_8$g(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Gráficas");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$g.name,
    		type: "slot",
    		source: "(33:3) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (35:5) <DropdownItem href="./#/economies-graph">
    function create_default_slot_7$g(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$g.name,
    		type: "slot",
    		source: "(35:5) <DropdownItem href=\\\"./#/economies-graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (37:5) <DropdownItem href="./#/graphesco">
    function create_default_slot_6$g(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$g.name,
    		type: "slot",
    		source: "(37:5) <DropdownItem href=\\\"./#/graphesco\\\">",
    		ctx
    	});

    	return block;
    }

    // (39:5) <DropdownItem href="#/graphexpo">
    function create_default_slot_5$g(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$g.name,
    		type: "slot",
    		source: "(39:5) <DropdownItem href=\\\"#/graphexpo\\\">",
    		ctx
    	});

    	return block;
    }

    // (41:13) <DropdownItem href="./#/graph">
    function create_default_slot_4$g(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Grafica comun");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$g.name,
    		type: "slot",
    		source: "(41:13) <DropdownItem href=\\\"./#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (34:3) <DropdownMenu end>
    function create_default_slot_3$g(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let t4;
    	let dropdownitem5;
    	let t5;
    	let dropdownitem6;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies-graph",
    				$$slots: { default: [create_default_slot_7$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "./#/graphesco",
    				$$slots: { default: [create_default_slot_6$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/graphexpo",
    				$$slots: { default: [create_default_slot_5$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem5 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem6 = new DropdownItem({
    			props: {
    				href: "./#/graph",
    				$$slots: { default: [create_default_slot_4$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    			t4 = space();
    			create_component(dropdownitem5.$$.fragment);
    			t5 = space();
    			create_component(dropdownitem6.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(dropdownitem5, target, anchor);
    			insert_dev(target, t5, anchor);
    			mount_component(dropdownitem6, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    			const dropdownitem6_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdownitem6_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem6.$set(dropdownitem6_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			transition_in(dropdownitem5.$$.fragment, local);
    			transition_in(dropdownitem6.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			transition_out(dropdownitem5.$$.fragment, local);
    			transition_out(dropdownitem6.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(dropdownitem5, detaching);
    			if (detaching) detach_dev(t5);
    			destroy_component(dropdownitem6, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$g.name,
    		type: "slot",
    		source: "(34:3) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (32:4) <Dropdown >
    function create_default_slot_2$g(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_8$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_3$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$g.name,
    		type: "slot",
    		source: "(32:4) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (9:2) <Nav navbar>
    function create_default_slot_1$g(ctx) {
    	let dropdown0;
    	let t0;
    	let dropdown1;
    	let t1;
    	let dropdown2;
    	let current;

    	dropdown0 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_15$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown1 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_9$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown2 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_2$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdown0.$$.fragment);
    			t0 = space();
    			create_component(dropdown1.$$.fragment);
    			t1 = space();
    			create_component(dropdown2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdown0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdown1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdown2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdown0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdown0_changes.$$scope = { dirty, ctx };
    			}

    			dropdown0.$set(dropdown0_changes);
    			const dropdown1_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdown1_changes.$$scope = { dirty, ctx };
    			}

    			dropdown1.$set(dropdown1_changes);
    			const dropdown2_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				dropdown2_changes.$$scope = { dirty, ctx };
    			}

    			dropdown2.$set(dropdown2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdown0.$$.fragment, local);
    			transition_in(dropdown1.$$.fragment, local);
    			transition_in(dropdown2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdown0.$$.fragment, local);
    			transition_out(dropdown1.$$.fragment, local);
    			transition_out(dropdown2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdown0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdown1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdown2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$g.name,
    		type: "slot",
    		source: "(9:2) <Nav navbar>",
    		ctx
    	});

    	return block;
    }

    // (7:4) <Navbar style="background-color: lightgreen; color:white;" light expand="lg" >
    function create_default_slot$g(ctx) {
    	let navbarbrand;
    	let t;
    	let nav;
    	let current;

    	navbarbrand = new NavbarBrand({
    			props: {
    				href: "#/info",
    				$$slots: { default: [create_default_slot_21$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	nav = new Nav({
    			props: {
    				navbar: true,
    				$$slots: { default: [create_default_slot_1$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navbarbrand.$$.fragment);
    			t = space();
    			create_component(nav.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbarbrand, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(nav, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navbarbrand_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				navbarbrand_changes.$$scope = { dirty, ctx };
    			}

    			navbarbrand.$set(navbarbrand_changes);
    			const nav_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				nav_changes.$$scope = { dirty, ctx };
    			}

    			nav.$set(nav_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbarbrand.$$.fragment, local);
    			transition_in(nav.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbarbrand.$$.fragment, local);
    			transition_out(nav.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbarbrand, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(nav, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$g.name,
    		type: "slot",
    		source: "(7:4) <Navbar style=\\\"background-color: lightgreen; color:white;\\\" light expand=\\\"lg\\\" >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$j(ctx) {
    	let body;
    	let navbar;
    	let t0;
    	let main;
    	let h30;
    	let t2;
    	let p0;
    	let t3;
    	let a0;
    	let t5;
    	let p1;
    	let t6;
    	let a1;
    	let t8;
    	let p2;
    	let t9;
    	let a2;
    	let t11;
    	let br0;
    	let t12;
    	let h31;
    	let t14;
    	let br1;
    	let t15;
    	let h32;
    	let t17;
    	let p3;
    	let t18;
    	let a3;
    	let t20;
    	let p4;
    	let t21;
    	let a4;
    	let t23;
    	let p5;
    	let t24;
    	let a5;
    	let t26;
    	let p6;
    	let t27;
    	let a6;
    	let t29;
    	let p7;
    	let t30;
    	let a7;
    	let t32;
    	let p8;
    	let t33;
    	let a8;
    	let t35;
    	let p9;
    	let t36;
    	let a9;
    	let t38;
    	let p10;
    	let t39;
    	let a10;
    	let current;

    	navbar = new Navbar({
    			props: {
    				style: "background-color: lightgreen; color:white;",
    				light: true,
    				expand: "lg",
    				$$slots: { default: [create_default_slot$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			body = element$1("body");
    			create_component(navbar.$$.fragment);
    			t0 = space();
    			main = element$1("main");
    			h30 = element$1("h3");
    			h30.textContent = "Integraciones Damián González Carrasco:";
    			t2 = space();
    			p0 = element$1("p");
    			t3 = text$1("- ");
    			a0 = element$1("a");
    			a0.textContent = "https://SOS2122-25.herokuapp.com/#/economies/integracion1";
    			t5 = space();
    			p1 = element$1("p");
    			t6 = text$1("- ");
    			a1 = element$1("a");
    			a1.textContent = "https://SOS2122-25.herokuapp.com/#/economies/integracion2";
    			t8 = space();
    			p2 = element$1("p");
    			t9 = text$1("- ");
    			a2 = element$1("a");
    			a2.textContent = "https://SOS2122-25.herokuapp.com/#/economies/integracion3";
    			t11 = space();
    			br0 = element$1("br");
    			t12 = space();
    			h31 = element$1("h3");
    			h31.textContent = "Integraciones Adrián Pérez:";
    			t14 = space();
    			br1 = element$1("br");
    			t15 = space();
    			h32 = element$1("h3");
    			h32.textContent = "Integraciones Ángel Simón Mesa:";
    			t17 = space();
    			p3 = element$1("p");
    			t18 = text$1("- ");
    			a3 = element$1("a");
    			a3.textContent = "https://SOS2122-25.herokuapp.com/#/integracion1";
    			t20 = space();
    			p4 = element$1("p");
    			t21 = text$1("- ");
    			a4 = element$1("a");
    			a4.textContent = "https://SOS2122-25.herokuapp.com/#/integracion2";
    			t23 = space();
    			p5 = element$1("p");
    			t24 = text$1("- ");
    			a5 = element$1("a");
    			a5.textContent = "https://SOS2122-25.herokuapp.com/#/integracion3";
    			t26 = space();
    			p6 = element$1("p");
    			t27 = text$1("- ");
    			a6 = element$1("a");
    			a6.textContent = "https://SOS2122-25.herokuapp.com/#/integracion4";
    			t29 = space();
    			p7 = element$1("p");
    			t30 = text$1("- ");
    			a7 = element$1("a");
    			a7.textContent = "https://SOS2122-25.herokuapp.com/#/integracion5";
    			t32 = space();
    			p8 = element$1("p");
    			t33 = text$1("- ");
    			a8 = element$1("a");
    			a8.textContent = "https://SOS2122-25.herokuapp.com/#/integracion5b";
    			t35 = space();
    			p9 = element$1("p");
    			t36 = text$1("- ");
    			a9 = element$1("a");
    			a9.textContent = "https://SOS2122-25.herokuapp.com/#/integracion6";
    			t38 = space();
    			p10 = element$1("p");
    			t39 = text$1("- ");
    			a10 = element$1("a");
    			a10.textContent = "https://SOS2122-25.herokuapp.com/#/integracion7";
    			add_location(body, file$j, 5, 0, 162);
    			add_location(h30, file$j, 50, 4, 1864);
    			attr_dev(a0, "href", "https://SOS2122-25.herokuapp.com/#/economies/integracion1");
    			add_location(a0, file$j, 51, 6, 1920);
    			add_location(p0, file$j, 51, 1, 1915);
    			attr_dev(a1, "href", "https://SOS2122-25.herokuapp.com/#/economies/integracion2");
    			add_location(a1, file$j, 52, 6, 2062);
    			add_location(p1, file$j, 52, 1, 2057);
    			attr_dev(a2, "href", "https://SOS2122-25.herokuapp.com/#/economies/integracion3");
    			add_location(a2, file$j, 53, 6, 2204);
    			add_location(p2, file$j, 53, 1, 2199);
    			add_location(br0, file$j, 54, 4, 2344);
    			add_location(h31, file$j, 55, 4, 2354);
    			add_location(br1, file$j, 56, 4, 2396);
    			add_location(h32, file$j, 57, 1, 2403);
    			attr_dev(a3, "href", "https://SOS2122-25.herokuapp.com/#/integracion1");
    			add_location(a3, file$j, 58, 6, 2451);
    			add_location(p3, file$j, 58, 1, 2446);
    			attr_dev(a4, "href", "https://SOS2122-25.herokuapp.com/#/integracion2");
    			add_location(a4, file$j, 59, 6, 2573);
    			add_location(p4, file$j, 59, 1, 2568);
    			attr_dev(a5, "href", "https://SOS2122-25.herokuapp.com/#/integracion3");
    			add_location(a5, file$j, 60, 6, 2695);
    			add_location(p5, file$j, 60, 1, 2690);
    			attr_dev(a6, "href", "https://SOS2122-25.herokuapp.com/#/integracion4");
    			add_location(a6, file$j, 61, 6, 2817);
    			add_location(p6, file$j, 61, 1, 2812);
    			attr_dev(a7, "href", "https://SOS2122-25.herokuapp.com/#/integracion5");
    			add_location(a7, file$j, 62, 6, 2939);
    			add_location(p7, file$j, 62, 1, 2934);
    			attr_dev(a8, "href", "https://SOS2122-25.herokuapp.com/#/integracion5b");
    			add_location(a8, file$j, 63, 6, 3061);
    			add_location(p8, file$j, 63, 1, 3056);
    			attr_dev(a9, "href", "https://SOS2122-25.herokuapp.com/#/integracion6");
    			add_location(a9, file$j, 64, 6, 3185);
    			add_location(p9, file$j, 64, 1, 3180);
    			attr_dev(a10, "href", "https://SOS2122-25.herokuapp.com/#/integracion7");
    			add_location(a10, file$j, 65, 6, 3307);
    			add_location(p10, file$j, 65, 1, 3302);
    			attr_dev(main, "class", "svelte-1h6otfa");
    			add_location(main, file$j, 49, 0, 1852);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, body, anchor);
    			mount_component(navbar, body, null);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			append_dev(main, h30);
    			append_dev(main, t2);
    			append_dev(main, p0);
    			append_dev(p0, t3);
    			append_dev(p0, a0);
    			append_dev(main, t5);
    			append_dev(main, p1);
    			append_dev(p1, t6);
    			append_dev(p1, a1);
    			append_dev(main, t8);
    			append_dev(main, p2);
    			append_dev(p2, t9);
    			append_dev(p2, a2);
    			append_dev(main, t11);
    			append_dev(main, br0);
    			append_dev(main, t12);
    			append_dev(main, h31);
    			append_dev(main, t14);
    			append_dev(main, br1);
    			append_dev(main, t15);
    			append_dev(main, h32);
    			append_dev(main, t17);
    			append_dev(main, p3);
    			append_dev(p3, t18);
    			append_dev(p3, a3);
    			append_dev(main, t20);
    			append_dev(main, p4);
    			append_dev(p4, t21);
    			append_dev(p4, a4);
    			append_dev(main, t23);
    			append_dev(main, p5);
    			append_dev(p5, t24);
    			append_dev(p5, a5);
    			append_dev(main, t26);
    			append_dev(main, p6);
    			append_dev(p6, t27);
    			append_dev(p6, a6);
    			append_dev(main, t29);
    			append_dev(main, p7);
    			append_dev(p7, t30);
    			append_dev(p7, a7);
    			append_dev(main, t32);
    			append_dev(main, p8);
    			append_dev(p8, t33);
    			append_dev(p8, a8);
    			append_dev(main, t35);
    			append_dev(main, p9);
    			append_dev(p9, t36);
    			append_dev(p9, a9);
    			append_dev(main, t38);
    			append_dev(main, p10);
    			append_dev(p10, t39);
    			append_dev(p10, a10);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const navbar_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				navbar_changes.$$scope = { dirty, ctx };
    			}

    			navbar.$set(navbar_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(body);
    			destroy_component(navbar);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$j($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Integration', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Integration> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Navbar,
    		Nav,
    		NavItem,
    		NavLink,
    		NavbarBrand,
    		Dropdown,
    		DropdownToggle,
    		DropdownMenu,
    		DropdownItem,
    		Button
    	});

    	return [];
    }

    class Integration extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$j, create_fragment$j, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Integration",
    			options,
    			id: create_fragment$j.name
    		});
    	}
    }

    /* src\front\frontEconomies\integrationApi1.svelte generated by Svelte v3.47.0 */

    const { console: console_1$h } = globals;
    const file$i = "src\\front\\frontEconomies\\integrationApi1.svelte";

    // (136:12) <NavbarBrand href="#/info">
    function create_default_slot_22$f(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("INICIO");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_22$f.name,
    		type: "slot",
    		source: "(136:12) <NavbarBrand href=\\\"#/info\\\">",
    		ctx
    	});

    	return block;
    }

    // (139:20) <DropdownToggle nav caret>
    function create_default_slot_21$f(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("API");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_21$f.name,
    		type: "slot",
    		source: "(139:20) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (141:20) <DropdownItem href="./api/v2/economies">
    function create_default_slot_20$f(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_20$f.name,
    		type: "slot",
    		source: "(141:20) <DropdownItem href=\\\"./api/v2/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (143:20) <DropdownItem href="./api/v1/esco-stats">
    function create_default_slot_19$f(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_19$f.name,
    		type: "slot",
    		source: "(143:20) <DropdownItem href=\\\"./api/v1/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (145:20) <DropdownItem href="./api/v1/expo-stats">
    function create_default_slot_18$f(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_18$f.name,
    		type: "slot",
    		source: "(145:20) <DropdownItem href=\\\"./api/v1/expo-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (140:20) <DropdownMenu end>
    function create_default_slot_17$f(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./api/v2/economies",
    				$$slots: { default: [create_default_slot_20$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "./api/v1/esco-stats",
    				$$slots: { default: [create_default_slot_19$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "./api/v1/expo-stats",
    				$$slots: { default: [create_default_slot_18$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17$f.name,
    		type: "slot",
    		source: "(140:20) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (138:16) <Dropdown >
    function create_default_slot_16$f(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_21$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_17$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16$f.name,
    		type: "slot",
    		source: "(138:16) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (150:20) <DropdownToggle nav caret>
    function create_default_slot_15$f(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15$f.name,
    		type: "slot",
    		source: "(150:20) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (152:20) <DropdownItem href="./#/economies">
    function create_default_slot_14$f(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14$f.name,
    		type: "slot",
    		source: "(152:20) <DropdownItem href=\\\"./#/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (153:20) <DropdownItem href="#/esco-stats">
    function create_default_slot_13$f(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13$f.name,
    		type: "slot",
    		source: "(153:20) <DropdownItem href=\\\"#/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (154:20) <DropdownItem href="#/expo">
    function create_default_slot_12$f(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo-Stats FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12$f.name,
    		type: "slot",
    		source: "(154:20) <DropdownItem href=\\\"#/expo\\\">",
    		ctx
    	});

    	return block;
    }

    // (156:20) <DropdownItem href="#/graph">
    function create_default_slot_11$f(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Conjunto");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$f.name,
    		type: "slot",
    		source: "(156:20) <DropdownItem href=\\\"#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (151:20) <DropdownMenu end>
    function create_default_slot_10$f(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies",
    				$$slots: { default: [create_default_slot_14$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({
    			props: {
    				href: "#/esco-stats",
    				$$slots: { default: [create_default_slot_13$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "#/expo",
    				$$slots: { default: [create_default_slot_12$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/graph",
    				$$slots: { default: [create_default_slot_11$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem1_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem1_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem1.$set(dropdownitem1_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$f.name,
    		type: "slot",
    		source: "(151:20) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (149:16) <Dropdown>
    function create_default_slot_9$f(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_15$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_10$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$f.name,
    		type: "slot",
    		source: "(149:16) <Dropdown>",
    		ctx
    	});

    	return block;
    }

    // (161:20) <DropdownToggle nav caret>
    function create_default_slot_8$f(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Gráficas");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$f.name,
    		type: "slot",
    		source: "(161:20) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (163:20) <DropdownItem href="./#/economies-graph">
    function create_default_slot_7$f(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$f.name,
    		type: "slot",
    		source: "(163:20) <DropdownItem href=\\\"./#/economies-graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (164:20) <DropdownItem href="#/graphesco">
    function create_default_slot_6$f(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$f.name,
    		type: "slot",
    		source: "(164:20) <DropdownItem href=\\\"#/graphesco\\\">",
    		ctx
    	});

    	return block;
    }

    // (165:20) <DropdownItem href="#/graphexpo">
    function create_default_slot_5$f(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$f.name,
    		type: "slot",
    		source: "(165:20) <DropdownItem href=\\\"#/graphexpo\\\">",
    		ctx
    	});

    	return block;
    }

    // (167:20) <DropdownItem href="#/graph">
    function create_default_slot_4$f(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Conjunto");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$f.name,
    		type: "slot",
    		source: "(167:20) <DropdownItem href=\\\"#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (162:20) <DropdownMenu end>
    function create_default_slot_3$f(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies-graph",
    				$$slots: { default: [create_default_slot_7$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({
    			props: {
    				href: "#/graphesco",
    				$$slots: { default: [create_default_slot_6$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "#/graphexpo",
    				$$slots: { default: [create_default_slot_5$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/graph",
    				$$slots: { default: [create_default_slot_4$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem1_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem1_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem1.$set(dropdownitem1_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$f.name,
    		type: "slot",
    		source: "(162:20) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (160:16) <Dropdown >
    function create_default_slot_2$f(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_8$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_3$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$f.name,
    		type: "slot",
    		source: "(160:16) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (137:12) <Nav navbar>
    function create_default_slot_1$f(ctx) {
    	let dropdown0;
    	let t0;
    	let dropdown1;
    	let t1;
    	let dropdown2;
    	let current;

    	dropdown0 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_16$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown1 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_9$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown2 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_2$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdown0.$$.fragment);
    			t0 = space();
    			create_component(dropdown1.$$.fragment);
    			t1 = space();
    			create_component(dropdown2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdown0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdown1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdown2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdown0_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdown0_changes.$$scope = { dirty, ctx };
    			}

    			dropdown0.$set(dropdown0_changes);
    			const dropdown1_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdown1_changes.$$scope = { dirty, ctx };
    			}

    			dropdown1.$set(dropdown1_changes);
    			const dropdown2_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdown2_changes.$$scope = { dirty, ctx };
    			}

    			dropdown2.$set(dropdown2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdown0.$$.fragment, local);
    			transition_in(dropdown1.$$.fragment, local);
    			transition_in(dropdown2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdown0.$$.fragment, local);
    			transition_out(dropdown1.$$.fragment, local);
    			transition_out(dropdown2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdown0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdown1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdown2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$f.name,
    		type: "slot",
    		source: "(137:12) <Nav navbar>",
    		ctx
    	});

    	return block;
    }

    // (135:8) <Navbar style="background-color: lightgreen; color:white;" light expand="lg" >
    function create_default_slot$f(ctx) {
    	let navbarbrand;
    	let t;
    	let nav;
    	let current;

    	navbarbrand = new NavbarBrand({
    			props: {
    				href: "#/info",
    				$$slots: { default: [create_default_slot_22$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	nav = new Nav({
    			props: {
    				navbar: true,
    				$$slots: { default: [create_default_slot_1$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navbarbrand.$$.fragment);
    			t = space();
    			create_component(nav.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbarbrand, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(nav, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navbarbrand_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				navbarbrand_changes.$$scope = { dirty, ctx };
    			}

    			navbarbrand.$set(navbarbrand_changes);
    			const nav_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				nav_changes.$$scope = { dirty, ctx };
    			}

    			nav.$set(nav_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbarbrand.$$.fragment, local);
    			transition_in(nav.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbarbrand.$$.fragment, local);
    			transition_out(nav.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbarbrand, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(nav, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$f.name,
    		type: "slot",
    		source: "(135:8) <Navbar style=\\\"background-color: lightgreen; color:white;\\\" light expand=\\\"lg\\\" >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$i(ctx) {
    	let script0;
    	let script0_src_value;
    	let script1;
    	let script1_src_value;
    	let script2;
    	let script2_src_value;
    	let t0;
    	let main;
    	let navbar;
    	let t1;
    	let div;
    	let current;

    	navbar = new Navbar({
    			props: {
    				style: "background-color: lightgreen; color:white;",
    				light: true,
    				expand: "lg",
    				$$slots: { default: [create_default_slot$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			script0 = element$1("script");
    			script1 = element$1("script");
    			script2 = element$1("script");
    			t0 = space();
    			main = element$1("main");
    			create_component(navbar.$$.fragment);
    			t1 = space();
    			div = element$1("div");
    			if (!src_url_equal(script0.src, script0_src_value = "https://d3js.org/d3.v6.min.js")) attr_dev(script0, "src", script0_src_value);
    			add_location(script0, file$i, 124, 8, 4445);
    			if (!src_url_equal(script1.src, script1_src_value = "https://cdnjs.cloudflare.com/ajax/libs/billboard.js/3.4.1/billboard.min.js")) attr_dev(script1, "src", script1_src_value);
    			add_location(script1, file$i, 125, 8, 4508);
    			if (!src_url_equal(script2.src, script2_src_value = "https://cdnjs.cloudflare.com/ajax/libs/billboard.js/3.4.1/billboard.min.css")) attr_dev(script2, "src", script2_src_value);
    			add_location(script2, file$i, 126, 8, 4616);
    			attr_dev(div, "id", "chart");
    			add_location(div, file$i, 175, 8, 6955);
    			add_location(main, file$i, 131, 4, 4763);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			append_dev(document.head, script0);
    			append_dev(document.head, script1);
    			append_dev(document.head, script2);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			mount_component(navbar, main, null);
    			append_dev(main, t1);
    			append_dev(main, div);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const navbar_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				navbar_changes.$$scope = { dirty, ctx };
    			}

    			navbar.$set(navbar_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			detach_dev(script0);
    			detach_dev(script1);
    			detach_dev(script2);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			destroy_component(navbar);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('IntegrationApi1', slots, []);
    	let apiData = {};
    	const delay = ms => new Promise(res => setTimeout(res, ms));
    	let stats = [];
    	let economies = [];
    	let country = [];
    	let year = [];
    	let percapita = ["percapita"];
    	let currency = ["currency"];
    	let currentprices = ["currentprices"];
    	let quantity = ["quantity"];
    	let absolute_change = ["absolute_change"];
    	let relative_change = ["relative_change"];

    	async function loadGraph() {
    		console.log("Fetching stats....");
    		const res1 = await fetch("/economies/remoteAPI");
    		const res2 = await fetch("/api/v2/economies");

    		if (res1.ok && res2.ok) {
    			const data1 = await res1.json();
    			const data2 = await res2.json();
    			stats = data1;
    			console.log("Estadísticas recibidas: " + stats.length);

    			//inicializamos los arrays para mostrar los datos
    			stats.forEach(stat => {
    				country.push(stat.country + "-" + stat.year);
    				year.push(stat.year);
    				quantity.push(stat.quantity);
    				absolute_change.push(stat.absolute_change);
    				relative_change.push(stat.relative_change);
    			});

    			economies = data2;

    			if (economies.length == 0) {
    				await fetch("/api/v2/economies/loadInitialData");
    			}

    			console.log("Recibido: " + economies.length);

    			economies.forEach(economy => {
    				percapita.push(economy.percapita);
    				currency.push(economy.currency);
    				currentprices.push(economy.currentprices);
    			});
    		} else {
    			console.log("Error cargando los datos");
    		}

    		console.log("Comprobando");
    		await delay(500);

    		var chart = bb.generate({
    			data: {
    				axis: { x: { type: country } },
    				columns: [],
    				types: {
    					quantity: "area", // for ESM specify as: area()
    					relative_change: "area-spline",
    					absolute_change: "area-spline",
    					percapita: "area-spline",
    					currency: "area-spline",
    					currentprices: "area-spline"
    				}
    			},
    			bindto: "#areaChart"
    		});

    		setTimeout(
    			function () {
    				chart.load({ columns: [quantity] });
    			},
    			500
    		);

    		setTimeout(
    			function () {
    				chart.load({ columns: [relative_change] });
    			},
    			1000
    		);

    		setTimeout(
    			function () {
    				chart.load({ columns: [absolute_change] });
    			},
    			1500
    		);

    		console.log(quantity);

    		setTimeout(
    			function () {
    				chart.load({ columns: [percapita] });
    			},
    			1500
    		);

    		setTimeout(
    			function () {
    				chart.load({ columns: [currency] });
    			},
    			1500
    		);

    		setTimeout(
    			function () {
    				chart.load({ columns: [currentprices] });
    			},
    			1500
    		);

    		console.log(quantity);
    	}

    	onMount(loadGraph);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$h.warn(`<IntegrationApi1> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		Navbar,
    		Nav,
    		NavItem,
    		NavLink,
    		NavbarBrand,
    		Dropdown,
    		DropdownToggle,
    		DropdownMenu,
    		DropdownItem,
    		Button,
    		Table,
    		pop,
    		apiData,
    		delay,
    		stats,
    		economies,
    		country,
    		year,
    		percapita,
    		currency,
    		currentprices,
    		quantity,
    		absolute_change,
    		relative_change,
    		loadGraph
    	});

    	$$self.$inject_state = $$props => {
    		if ('apiData' in $$props) apiData = $$props.apiData;
    		if ('stats' in $$props) stats = $$props.stats;
    		if ('economies' in $$props) economies = $$props.economies;
    		if ('country' in $$props) country = $$props.country;
    		if ('year' in $$props) year = $$props.year;
    		if ('percapita' in $$props) percapita = $$props.percapita;
    		if ('currency' in $$props) currency = $$props.currency;
    		if ('currentprices' in $$props) currentprices = $$props.currentprices;
    		if ('quantity' in $$props) quantity = $$props.quantity;
    		if ('absolute_change' in $$props) absolute_change = $$props.absolute_change;
    		if ('relative_change' in $$props) relative_change = $$props.relative_change;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [];
    }

    class IntegrationApi1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$i, create_fragment$i, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "IntegrationApi1",
    			options,
    			id: create_fragment$i.name
    		});
    	}
    }

    /* src\front\frontEconomies\integrationApi2.svelte generated by Svelte v3.47.0 */

    const { console: console_1$g } = globals;
    const file$h = "src\\front\\frontEconomies\\integrationApi2.svelte";

    // (136:12) <NavbarBrand href="#/info">
    function create_default_slot_22$e(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("INICIO");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_22$e.name,
    		type: "slot",
    		source: "(136:12) <NavbarBrand href=\\\"#/info\\\">",
    		ctx
    	});

    	return block;
    }

    // (139:20) <DropdownToggle nav caret>
    function create_default_slot_21$e(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("API");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_21$e.name,
    		type: "slot",
    		source: "(139:20) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (141:20) <DropdownItem href="./api/v2/economies">
    function create_default_slot_20$e(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_20$e.name,
    		type: "slot",
    		source: "(141:20) <DropdownItem href=\\\"./api/v2/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (143:20) <DropdownItem href="./api/v1/esco-stats">
    function create_default_slot_19$e(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_19$e.name,
    		type: "slot",
    		source: "(143:20) <DropdownItem href=\\\"./api/v1/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (145:20) <DropdownItem href="./api/v1/expo-stats">
    function create_default_slot_18$e(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_18$e.name,
    		type: "slot",
    		source: "(145:20) <DropdownItem href=\\\"./api/v1/expo-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (140:20) <DropdownMenu end>
    function create_default_slot_17$e(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./api/v2/economies",
    				$$slots: { default: [create_default_slot_20$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "./api/v1/esco-stats",
    				$$slots: { default: [create_default_slot_19$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "./api/v1/expo-stats",
    				$$slots: { default: [create_default_slot_18$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17$e.name,
    		type: "slot",
    		source: "(140:20) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (138:16) <Dropdown >
    function create_default_slot_16$e(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_21$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_17$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16$e.name,
    		type: "slot",
    		source: "(138:16) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (150:20) <DropdownToggle nav caret>
    function create_default_slot_15$e(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15$e.name,
    		type: "slot",
    		source: "(150:20) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (152:20) <DropdownItem href="./#/economies">
    function create_default_slot_14$e(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14$e.name,
    		type: "slot",
    		source: "(152:20) <DropdownItem href=\\\"./#/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (153:20) <DropdownItem href="#/esco-stats">
    function create_default_slot_13$e(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13$e.name,
    		type: "slot",
    		source: "(153:20) <DropdownItem href=\\\"#/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (154:20) <DropdownItem href="#/expo">
    function create_default_slot_12$e(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo-Stats FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12$e.name,
    		type: "slot",
    		source: "(154:20) <DropdownItem href=\\\"#/expo\\\">",
    		ctx
    	});

    	return block;
    }

    // (156:20) <DropdownItem href="#/graph">
    function create_default_slot_11$e(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Conjunto");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$e.name,
    		type: "slot",
    		source: "(156:20) <DropdownItem href=\\\"#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (151:20) <DropdownMenu end>
    function create_default_slot_10$e(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies",
    				$$slots: { default: [create_default_slot_14$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({
    			props: {
    				href: "#/esco-stats",
    				$$slots: { default: [create_default_slot_13$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "#/expo",
    				$$slots: { default: [create_default_slot_12$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/graph",
    				$$slots: { default: [create_default_slot_11$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem1_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem1_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem1.$set(dropdownitem1_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$e.name,
    		type: "slot",
    		source: "(151:20) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (149:16) <Dropdown>
    function create_default_slot_9$e(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_15$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_10$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$e.name,
    		type: "slot",
    		source: "(149:16) <Dropdown>",
    		ctx
    	});

    	return block;
    }

    // (161:20) <DropdownToggle nav caret>
    function create_default_slot_8$e(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Gráficas");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$e.name,
    		type: "slot",
    		source: "(161:20) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (163:20) <DropdownItem href="./#/economies-graph">
    function create_default_slot_7$e(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$e.name,
    		type: "slot",
    		source: "(163:20) <DropdownItem href=\\\"./#/economies-graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (164:20) <DropdownItem href="#/graphesco">
    function create_default_slot_6$e(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$e.name,
    		type: "slot",
    		source: "(164:20) <DropdownItem href=\\\"#/graphesco\\\">",
    		ctx
    	});

    	return block;
    }

    // (165:20) <DropdownItem href="#/graphexpo">
    function create_default_slot_5$e(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$e.name,
    		type: "slot",
    		source: "(165:20) <DropdownItem href=\\\"#/graphexpo\\\">",
    		ctx
    	});

    	return block;
    }

    // (167:20) <DropdownItem href="#/graph">
    function create_default_slot_4$e(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Conjunto");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$e.name,
    		type: "slot",
    		source: "(167:20) <DropdownItem href=\\\"#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (162:20) <DropdownMenu end>
    function create_default_slot_3$e(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies-graph",
    				$$slots: { default: [create_default_slot_7$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({
    			props: {
    				href: "#/graphesco",
    				$$slots: { default: [create_default_slot_6$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "#/graphexpo",
    				$$slots: { default: [create_default_slot_5$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/graph",
    				$$slots: { default: [create_default_slot_4$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem1_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem1_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem1.$set(dropdownitem1_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$e.name,
    		type: "slot",
    		source: "(162:20) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (160:16) <Dropdown >
    function create_default_slot_2$e(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_8$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_3$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$e.name,
    		type: "slot",
    		source: "(160:16) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (137:12) <Nav navbar>
    function create_default_slot_1$e(ctx) {
    	let dropdown0;
    	let t0;
    	let dropdown1;
    	let t1;
    	let dropdown2;
    	let current;

    	dropdown0 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_16$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown1 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_9$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown2 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_2$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdown0.$$.fragment);
    			t0 = space();
    			create_component(dropdown1.$$.fragment);
    			t1 = space();
    			create_component(dropdown2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdown0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdown1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdown2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdown0_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdown0_changes.$$scope = { dirty, ctx };
    			}

    			dropdown0.$set(dropdown0_changes);
    			const dropdown1_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdown1_changes.$$scope = { dirty, ctx };
    			}

    			dropdown1.$set(dropdown1_changes);
    			const dropdown2_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdown2_changes.$$scope = { dirty, ctx };
    			}

    			dropdown2.$set(dropdown2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdown0.$$.fragment, local);
    			transition_in(dropdown1.$$.fragment, local);
    			transition_in(dropdown2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdown0.$$.fragment, local);
    			transition_out(dropdown1.$$.fragment, local);
    			transition_out(dropdown2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdown0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdown1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdown2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$e.name,
    		type: "slot",
    		source: "(137:12) <Nav navbar>",
    		ctx
    	});

    	return block;
    }

    // (135:8) <Navbar style="background-color: lightgreen; color:white;" light expand="lg" >
    function create_default_slot$e(ctx) {
    	let navbarbrand;
    	let t;
    	let nav;
    	let current;

    	navbarbrand = new NavbarBrand({
    			props: {
    				href: "#/info",
    				$$slots: { default: [create_default_slot_22$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	nav = new Nav({
    			props: {
    				navbar: true,
    				$$slots: { default: [create_default_slot_1$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navbarbrand.$$.fragment);
    			t = space();
    			create_component(nav.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbarbrand, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(nav, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navbarbrand_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				navbarbrand_changes.$$scope = { dirty, ctx };
    			}

    			navbarbrand.$set(navbarbrand_changes);
    			const nav_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				nav_changes.$$scope = { dirty, ctx };
    			}

    			nav.$set(nav_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbarbrand.$$.fragment, local);
    			transition_in(nav.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbarbrand.$$.fragment, local);
    			transition_out(nav.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbarbrand, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(nav, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$e.name,
    		type: "slot",
    		source: "(135:8) <Navbar style=\\\"background-color: lightgreen; color:white;\\\" light expand=\\\"lg\\\" >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$h(ctx) {
    	let script0;
    	let script0_src_value;
    	let script1;
    	let script1_src_value;
    	let script2;
    	let script2_src_value;
    	let t0;
    	let main;
    	let navbar;
    	let t1;
    	let div;
    	let current;

    	navbar = new Navbar({
    			props: {
    				style: "background-color: lightgreen; color:white;",
    				light: true,
    				expand: "lg",
    				$$slots: { default: [create_default_slot$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			script0 = element$1("script");
    			script1 = element$1("script");
    			script2 = element$1("script");
    			t0 = space();
    			main = element$1("main");
    			create_component(navbar.$$.fragment);
    			t1 = space();
    			div = element$1("div");
    			if (!src_url_equal(script0.src, script0_src_value = "https://d3js.org/d3.v6.min.js")) attr_dev(script0, "src", script0_src_value);
    			add_location(script0, file$h, 125, 8, 4434);
    			if (!src_url_equal(script1.src, script1_src_value = "https://cdnjs.cloudflare.com/ajax/libs/billboard.js/3.4.1/billboard.min.js")) attr_dev(script1, "src", script1_src_value);
    			add_location(script1, file$h, 126, 8, 4497);
    			if (!src_url_equal(script2.src, script2_src_value = "https://cdnjs.cloudflare.com/ajax/libs/billboard.js/3.4.1/billboard.min.css")) attr_dev(script2, "src", script2_src_value);
    			add_location(script2, file$h, 127, 8, 4605);
    			attr_dev(div, "id", "chart");
    			add_location(div, file$h, 176, 12, 6922);
    			add_location(main, file$h, 132, 4, 4752);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			append_dev(document.head, script0);
    			append_dev(document.head, script1);
    			append_dev(document.head, script2);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			mount_component(navbar, main, null);
    			append_dev(main, t1);
    			append_dev(main, div);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const navbar_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				navbar_changes.$$scope = { dirty, ctx };
    			}

    			navbar.$set(navbar_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			detach_dev(script0);
    			detach_dev(script1);
    			detach_dev(script2);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			destroy_component(navbar);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('IntegrationApi2', slots, []);
    	let apiData = {};
    	const delay = ms => new Promise(res => setTimeout(res, ms));
    	let stats = [];
    	let economies = [];
    	let country = [];
    	let year = [];
    	let percapita = ["percapita"];
    	let currency = ["currency"];
    	let currentprices = ["currentprices"];
    	let coefficients = ["coefficients"];
    	let lifes = ["lifes"];
    	let educations = ["educations"];

    	async function loadGraph() {
    		console.log("Fetching stats....");
    		const res1 = await fetch("/economies/remoteAPI2");
    		const res2 = await fetch("/api/v2/economies");

    		if (res1.ok && res2.ok) {
    			const data1 = await res1.json();
    			const data2 = await res2.json();
    			stats = data1;
    			console.log("Estadísticas recibidas: " + stats.length);

    			//inicializamos los arrays para mostrar los datos
    			stats.forEach(stat => {
    				country.push(stat.country + "-" + stat.year);
    				year.push(stat.year);
    				coefficients.push(stat.coefficients);
    				lifes.push(stat.lifes);
    				educations.push(stat.educations);
    			});

    			economies = data2;

    			if (economies.length == 0) {
    				await fetch("/api/v2/economies/loadInitialData");
    			}

    			console.log("Recibido: " + economies.length);

    			economies.forEach(economy => {
    				percapita.push(economy.percapita);
    				currency.push(economy.currency);
    				currentprices.push(economy.currentprices);
    			});
    		} else {
    			console.log("Error cargando los datos");
    		}

    		console.log("Comprobando");
    		await delay(500);

    		var chart = bb.generate({
    			data: {
    				axis: { x: { type: country } },
    				columns: [],
    				types: {
    					coefficients: "area", // for ESM specify as: area()
    					educations: "area-spline",
    					lifes: "area-spline",
    					percapita: "area-spline",
    					currency: "area-spline",
    					currentprices: "area-spline"
    				}
    			},
    			bindto: "#areaChart"
    		});

    		setTimeout(
    			function () {
    				chart.load({ columns: [coefficients] });
    			},
    			500
    		);

    		setTimeout(
    			function () {
    				chart.load({ columns: [educations] });
    			},
    			1000
    		);

    		setTimeout(
    			function () {
    				chart.load({ columns: [lifes] });
    			},
    			1500
    		);

    		console.log(coefficients);

    		setTimeout(
    			function () {
    				chart.load({ columns: [percapita] });
    			},
    			1500
    		);

    		setTimeout(
    			function () {
    				chart.load({ columns: [currency] });
    			},
    			1500
    		);

    		setTimeout(
    			function () {
    				chart.load({ columns: [currentprices] });
    			},
    			1500
    		);

    		console.log(coefficients);
    	}

    	onMount(loadGraph);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$g.warn(`<IntegrationApi2> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		Navbar,
    		Nav,
    		NavItem,
    		NavLink,
    		NavbarBrand,
    		Dropdown,
    		DropdownToggle,
    		DropdownMenu,
    		DropdownItem,
    		Button,
    		Table,
    		pop,
    		Economies,
    		apiData,
    		delay,
    		stats,
    		economies,
    		country,
    		year,
    		percapita,
    		currency,
    		currentprices,
    		coefficients,
    		lifes,
    		educations,
    		loadGraph
    	});

    	$$self.$inject_state = $$props => {
    		if ('apiData' in $$props) apiData = $$props.apiData;
    		if ('stats' in $$props) stats = $$props.stats;
    		if ('economies' in $$props) economies = $$props.economies;
    		if ('country' in $$props) country = $$props.country;
    		if ('year' in $$props) year = $$props.year;
    		if ('percapita' in $$props) percapita = $$props.percapita;
    		if ('currency' in $$props) currency = $$props.currency;
    		if ('currentprices' in $$props) currentprices = $$props.currentprices;
    		if ('coefficients' in $$props) coefficients = $$props.coefficients;
    		if ('lifes' in $$props) lifes = $$props.lifes;
    		if ('educations' in $$props) educations = $$props.educations;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [];
    }

    class IntegrationApi2 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$h, create_fragment$h, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "IntegrationApi2",
    			options,
    			id: create_fragment$h.name
    		});
    	}
    }

    /* src\front\frontEconomies\integrationApi3.svelte generated by Svelte v3.47.0 */

    const { console: console_1$f } = globals;
    const file$g = "src\\front\\frontEconomies\\integrationApi3.svelte";

    // (101:12) <NavbarBrand href="#/info">
    function create_default_slot_22$d(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("INICIO");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_22$d.name,
    		type: "slot",
    		source: "(101:12) <NavbarBrand href=\\\"#/info\\\">",
    		ctx
    	});

    	return block;
    }

    // (104:20) <DropdownToggle nav caret>
    function create_default_slot_21$d(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("API");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_21$d.name,
    		type: "slot",
    		source: "(104:20) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (106:20) <DropdownItem href="./api/v2/economies">
    function create_default_slot_20$d(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_20$d.name,
    		type: "slot",
    		source: "(106:20) <DropdownItem href=\\\"./api/v2/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (108:20) <DropdownItem href="./api/v1/esco-stats">
    function create_default_slot_19$d(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_19$d.name,
    		type: "slot",
    		source: "(108:20) <DropdownItem href=\\\"./api/v1/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (110:20) <DropdownItem href="./api/v1/expo-stats">
    function create_default_slot_18$d(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_18$d.name,
    		type: "slot",
    		source: "(110:20) <DropdownItem href=\\\"./api/v1/expo-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (105:20) <DropdownMenu end>
    function create_default_slot_17$d(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./api/v2/economies",
    				$$slots: { default: [create_default_slot_20$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "./api/v1/esco-stats",
    				$$slots: { default: [create_default_slot_19$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "./api/v1/expo-stats",
    				$$slots: { default: [create_default_slot_18$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17$d.name,
    		type: "slot",
    		source: "(105:20) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (103:16) <Dropdown >
    function create_default_slot_16$d(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_21$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_17$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16$d.name,
    		type: "slot",
    		source: "(103:16) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (115:20) <DropdownToggle nav caret>
    function create_default_slot_15$d(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15$d.name,
    		type: "slot",
    		source: "(115:20) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (117:20) <DropdownItem href="./#/economies">
    function create_default_slot_14$d(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14$d.name,
    		type: "slot",
    		source: "(117:20) <DropdownItem href=\\\"./#/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (118:20) <DropdownItem href="#/esco-stats">
    function create_default_slot_13$d(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13$d.name,
    		type: "slot",
    		source: "(118:20) <DropdownItem href=\\\"#/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (119:20) <DropdownItem href="#/expo">
    function create_default_slot_12$d(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo-Stats FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12$d.name,
    		type: "slot",
    		source: "(119:20) <DropdownItem href=\\\"#/expo\\\">",
    		ctx
    	});

    	return block;
    }

    // (121:20) <DropdownItem href="#/graph">
    function create_default_slot_11$d(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Conjunto");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$d.name,
    		type: "slot",
    		source: "(121:20) <DropdownItem href=\\\"#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (116:20) <DropdownMenu end>
    function create_default_slot_10$d(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies",
    				$$slots: { default: [create_default_slot_14$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({
    			props: {
    				href: "#/esco-stats",
    				$$slots: { default: [create_default_slot_13$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "#/expo",
    				$$slots: { default: [create_default_slot_12$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/graph",
    				$$slots: { default: [create_default_slot_11$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem1_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem1_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem1.$set(dropdownitem1_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$d.name,
    		type: "slot",
    		source: "(116:20) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (114:16) <Dropdown>
    function create_default_slot_9$d(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_15$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_10$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$d.name,
    		type: "slot",
    		source: "(114:16) <Dropdown>",
    		ctx
    	});

    	return block;
    }

    // (126:20) <DropdownToggle nav caret>
    function create_default_slot_8$d(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Gráficas");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$d.name,
    		type: "slot",
    		source: "(126:20) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (128:20) <DropdownItem href="./#/economies-graph">
    function create_default_slot_7$d(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$d.name,
    		type: "slot",
    		source: "(128:20) <DropdownItem href=\\\"./#/economies-graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (129:20) <DropdownItem href="#/graphesco">
    function create_default_slot_6$d(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$d.name,
    		type: "slot",
    		source: "(129:20) <DropdownItem href=\\\"#/graphesco\\\">",
    		ctx
    	});

    	return block;
    }

    // (130:20) <DropdownItem href="#/graphexpo">
    function create_default_slot_5$d(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$d.name,
    		type: "slot",
    		source: "(130:20) <DropdownItem href=\\\"#/graphexpo\\\">",
    		ctx
    	});

    	return block;
    }

    // (132:20) <DropdownItem href="#/graph">
    function create_default_slot_4$d(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Conjunto");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$d.name,
    		type: "slot",
    		source: "(132:20) <DropdownItem href=\\\"#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (127:20) <DropdownMenu end>
    function create_default_slot_3$d(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies-graph",
    				$$slots: { default: [create_default_slot_7$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({
    			props: {
    				href: "#/graphesco",
    				$$slots: { default: [create_default_slot_6$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "#/graphexpo",
    				$$slots: { default: [create_default_slot_5$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/graph",
    				$$slots: { default: [create_default_slot_4$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem1_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem1_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem1.$set(dropdownitem1_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$d.name,
    		type: "slot",
    		source: "(127:20) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (125:16) <Dropdown >
    function create_default_slot_2$d(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_8$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_3$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$d.name,
    		type: "slot",
    		source: "(125:16) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (102:12) <Nav navbar>
    function create_default_slot_1$d(ctx) {
    	let dropdown0;
    	let t0;
    	let dropdown1;
    	let t1;
    	let dropdown2;
    	let current;

    	dropdown0 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_16$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown1 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_9$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown2 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_2$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdown0.$$.fragment);
    			t0 = space();
    			create_component(dropdown1.$$.fragment);
    			t1 = space();
    			create_component(dropdown2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdown0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdown1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdown2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdown0_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdown0_changes.$$scope = { dirty, ctx };
    			}

    			dropdown0.$set(dropdown0_changes);
    			const dropdown1_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdown1_changes.$$scope = { dirty, ctx };
    			}

    			dropdown1.$set(dropdown1_changes);
    			const dropdown2_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdown2_changes.$$scope = { dirty, ctx };
    			}

    			dropdown2.$set(dropdown2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdown0.$$.fragment, local);
    			transition_in(dropdown1.$$.fragment, local);
    			transition_in(dropdown2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdown0.$$.fragment, local);
    			transition_out(dropdown1.$$.fragment, local);
    			transition_out(dropdown2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdown0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdown1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdown2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$d.name,
    		type: "slot",
    		source: "(102:12) <Nav navbar>",
    		ctx
    	});

    	return block;
    }

    // (100:8) <Navbar style="background-color: lightgreen; color:white;" light expand="lg" >
    function create_default_slot$d(ctx) {
    	let navbarbrand;
    	let t;
    	let nav;
    	let current;

    	navbarbrand = new NavbarBrand({
    			props: {
    				href: "#/info",
    				$$slots: { default: [create_default_slot_22$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	nav = new Nav({
    			props: {
    				navbar: true,
    				$$slots: { default: [create_default_slot_1$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navbarbrand.$$.fragment);
    			t = space();
    			create_component(nav.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbarbrand, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(nav, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navbarbrand_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				navbarbrand_changes.$$scope = { dirty, ctx };
    			}

    			navbarbrand.$set(navbarbrand_changes);
    			const nav_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				nav_changes.$$scope = { dirty, ctx };
    			}

    			nav.$set(nav_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbarbrand.$$.fragment, local);
    			transition_in(nav.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbarbrand.$$.fragment, local);
    			transition_out(nav.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbarbrand, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(nav, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$d.name,
    		type: "slot",
    		source: "(100:8) <Navbar style=\\\"background-color: lightgreen; color:white;\\\" light expand=\\\"lg\\\" >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$g(ctx) {
    	let script0;
    	let script0_src_value;
    	let script1;
    	let script1_src_value;
    	let script2;
    	let script2_src_value;
    	let t0;
    	let main;
    	let navbar;
    	let t1;
    	let div;
    	let current;

    	navbar = new Navbar({
    			props: {
    				style: "background-color: lightgreen; color:white;",
    				light: true,
    				expand: "lg",
    				$$slots: { default: [create_default_slot$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			script0 = element$1("script");
    			script1 = element$1("script");
    			script2 = element$1("script");
    			t0 = space();
    			main = element$1("main");
    			create_component(navbar.$$.fragment);
    			t1 = space();
    			div = element$1("div");
    			if (!src_url_equal(script0.src, script0_src_value = "https://d3js.org/d3.v6.min.js")) attr_dev(script0, "src", script0_src_value);
    			add_location(script0, file$g, 90, 8, 3569);
    			if (!src_url_equal(script1.src, script1_src_value = "https://cdnjs.cloudflare.com/ajax/libs/billboard.js/3.4.1/billboard.min.js")) attr_dev(script1, "src", script1_src_value);
    			add_location(script1, file$g, 91, 8, 3632);
    			if (!src_url_equal(script2.src, script2_src_value = "https://cdnjs.cloudflare.com/ajax/libs/billboard.js/3.4.1/billboard.min.css")) attr_dev(script2, "src", script2_src_value);
    			add_location(script2, file$g, 92, 8, 3740);
    			attr_dev(div, "id", "chart");
    			add_location(div, file$g, 141, 8, 6053);
    			add_location(main, file$g, 97, 4, 3887);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			append_dev(document.head, script0);
    			append_dev(document.head, script1);
    			append_dev(document.head, script2);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			mount_component(navbar, main, null);
    			append_dev(main, t1);
    			append_dev(main, div);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const navbar_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				navbar_changes.$$scope = { dirty, ctx };
    			}

    			navbar.$set(navbar_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			detach_dev(script0);
    			detach_dev(script1);
    			detach_dev(script2);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			destroy_component(navbar);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('IntegrationApi3', slots, []);
    	let apiData = {};
    	const delay = ms => new Promise(res => setTimeout(res, ms));
    	let stats = [];
    	let country = [];
    	let year = [];
    	let code = ["code"];
    	let built_area = ["built_area"];
    	let grazing_area = ["grazing_area"];
    	let economies = [];
    	let percapita = ["percapita"];
    	let currency = ["currency"];
    	let currentprices = ["currentprices"];

    	async function loadGraph() {
    		console.log("Fetching stats....");
    		const res1 = await fetch("/economies/remoteAPI3");
    		const res2 = await fetch("/api/v2/economies");

    		if (res1.ok && res2.ok) {
    			const data = await res1.json();
    			const data2 = await res2.json();
    			stats = data;

    			if (stats.length == 0) {
    				await fetch("/economies/remoteAPI3/loadInitialData");
    			}

    			console.log("Estadísticas recibidas: " + stats.length);

    			//inicializamos los arrays para mostrar los datos
    			stats.forEach(stat => {
    				country.push(stat.country + "-" + stat.year);
    				year.push(stat.year);
    				code.push(stat.code);
    				built_area.push(stat.built_area);
    				grazing_area.push(stat.grazing_area);
    			});

    			economies = data2;

    			if (economies.length == 0) {
    				await fetch("/api/v2/economies/loadInitialData");
    			}

    			console.log("Recibido: " + economies.length);

    			economies.forEach(economy => {
    				percapita.push(economy.percapita);
    				currency.push(economy.currency);
    				currentprices.push(economy.currentprices);
    			});
    		} else {
    			console.log("Error cargando los datos");
    		}

    		console.log("Comprobando");
    		await delay(500);

    		var chart = bb.generate({
    			data: {
    				axis: { x: { type: "category" } },
    				columns: [],
    				types: {
    					code: "area", // for ESM specify as: area()
    					grazing_area: "area-spline",
    					built_area: "area-spline", // for ESM specify as: areaSpline()
    					percapita: "area-spline",
    					currency: "area-spline",
    					currentprices: "area-spline"
    				}
    			},
    			bindto: "#areaChart"
    		});

    		setTimeout(
    			function () {
    				chart.load({
    					columns: [code, built_area, grazing_area, percapita, currency, currentprices]
    				});
    			},
    			500
    		);
    	}

    	onMount(loadGraph);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$f.warn(`<IntegrationApi3> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		Navbar,
    		Nav,
    		NavItem,
    		NavLink,
    		NavbarBrand,
    		Dropdown,
    		DropdownToggle,
    		DropdownMenu,
    		DropdownItem,
    		Button,
    		Table,
    		pop,
    		apiData,
    		delay,
    		stats,
    		country,
    		year,
    		code,
    		built_area,
    		grazing_area,
    		economies,
    		percapita,
    		currency,
    		currentprices,
    		loadGraph
    	});

    	$$self.$inject_state = $$props => {
    		if ('apiData' in $$props) apiData = $$props.apiData;
    		if ('stats' in $$props) stats = $$props.stats;
    		if ('country' in $$props) country = $$props.country;
    		if ('year' in $$props) year = $$props.year;
    		if ('code' in $$props) code = $$props.code;
    		if ('built_area' in $$props) built_area = $$props.built_area;
    		if ('grazing_area' in $$props) grazing_area = $$props.grazing_area;
    		if ('economies' in $$props) economies = $$props.economies;
    		if ('percapita' in $$props) percapita = $$props.percapita;
    		if ('currency' in $$props) currency = $$props.currency;
    		if ('currentprices' in $$props) currentprices = $$props.currentprices;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [];
    }

    class IntegrationApi3 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$g, create_fragment$g, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "IntegrationApi3",
    			options,
    			id: create_fragment$g.name
    		});
    	}
    }

    /* src\front\frontEconomies\integrationApi4.svelte generated by Svelte v3.47.0 */

    const { console: console_1$e } = globals;
    const file$f = "src\\front\\frontEconomies\\integrationApi4.svelte";

    // (96:12) <NavbarBrand href="#/info">
    function create_default_slot_22$c(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("INICIO");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_22$c.name,
    		type: "slot",
    		source: "(96:12) <NavbarBrand href=\\\"#/info\\\">",
    		ctx
    	});

    	return block;
    }

    // (99:20) <DropdownToggle nav caret>
    function create_default_slot_21$c(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("API");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_21$c.name,
    		type: "slot",
    		source: "(99:20) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (101:20) <DropdownItem href="./api/v2/economies">
    function create_default_slot_20$c(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_20$c.name,
    		type: "slot",
    		source: "(101:20) <DropdownItem href=\\\"./api/v2/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (103:20) <DropdownItem href="./api/v1/esco-stats">
    function create_default_slot_19$c(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_19$c.name,
    		type: "slot",
    		source: "(103:20) <DropdownItem href=\\\"./api/v1/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (105:20) <DropdownItem href="./api/v1/expo-stats">
    function create_default_slot_18$c(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_18$c.name,
    		type: "slot",
    		source: "(105:20) <DropdownItem href=\\\"./api/v1/expo-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (100:20) <DropdownMenu end>
    function create_default_slot_17$c(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./api/v2/economies",
    				$$slots: { default: [create_default_slot_20$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "./api/v1/esco-stats",
    				$$slots: { default: [create_default_slot_19$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "./api/v1/expo-stats",
    				$$slots: { default: [create_default_slot_18$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17$c.name,
    		type: "slot",
    		source: "(100:20) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (98:16) <Dropdown >
    function create_default_slot_16$c(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_21$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_17$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16$c.name,
    		type: "slot",
    		source: "(98:16) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (110:20) <DropdownToggle nav caret>
    function create_default_slot_15$c(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15$c.name,
    		type: "slot",
    		source: "(110:20) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (112:20) <DropdownItem href="./#/economies">
    function create_default_slot_14$c(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14$c.name,
    		type: "slot",
    		source: "(112:20) <DropdownItem href=\\\"./#/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (113:20) <DropdownItem href="#/esco-stats">
    function create_default_slot_13$c(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13$c.name,
    		type: "slot",
    		source: "(113:20) <DropdownItem href=\\\"#/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (114:20) <DropdownItem href="#/expo">
    function create_default_slot_12$c(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo-Stats FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12$c.name,
    		type: "slot",
    		source: "(114:20) <DropdownItem href=\\\"#/expo\\\">",
    		ctx
    	});

    	return block;
    }

    // (116:20) <DropdownItem href="#/graph">
    function create_default_slot_11$c(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Conjunto");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$c.name,
    		type: "slot",
    		source: "(116:20) <DropdownItem href=\\\"#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (111:20) <DropdownMenu end>
    function create_default_slot_10$c(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies",
    				$$slots: { default: [create_default_slot_14$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({
    			props: {
    				href: "#/esco-stats",
    				$$slots: { default: [create_default_slot_13$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "#/expo",
    				$$slots: { default: [create_default_slot_12$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/graph",
    				$$slots: { default: [create_default_slot_11$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem1_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem1_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem1.$set(dropdownitem1_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$c.name,
    		type: "slot",
    		source: "(111:20) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (109:16) <Dropdown>
    function create_default_slot_9$c(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_15$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_10$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$c.name,
    		type: "slot",
    		source: "(109:16) <Dropdown>",
    		ctx
    	});

    	return block;
    }

    // (121:20) <DropdownToggle nav caret>
    function create_default_slot_8$c(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Gráficas");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$c.name,
    		type: "slot",
    		source: "(121:20) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (123:20) <DropdownItem href="./#/economies-graph">
    function create_default_slot_7$c(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$c.name,
    		type: "slot",
    		source: "(123:20) <DropdownItem href=\\\"./#/economies-graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (124:20) <DropdownItem href="#/graphesco">
    function create_default_slot_6$c(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$c.name,
    		type: "slot",
    		source: "(124:20) <DropdownItem href=\\\"#/graphesco\\\">",
    		ctx
    	});

    	return block;
    }

    // (125:20) <DropdownItem href="#/graphexpo">
    function create_default_slot_5$c(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$c.name,
    		type: "slot",
    		source: "(125:20) <DropdownItem href=\\\"#/graphexpo\\\">",
    		ctx
    	});

    	return block;
    }

    // (127:20) <DropdownItem href="#/graph">
    function create_default_slot_4$c(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Conjunto");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$c.name,
    		type: "slot",
    		source: "(127:20) <DropdownItem href=\\\"#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (122:20) <DropdownMenu end>
    function create_default_slot_3$c(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies-graph",
    				$$slots: { default: [create_default_slot_7$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({
    			props: {
    				href: "#/graphesco",
    				$$slots: { default: [create_default_slot_6$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "#/graphexpo",
    				$$slots: { default: [create_default_slot_5$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/graph",
    				$$slots: { default: [create_default_slot_4$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem1_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem1_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem1.$set(dropdownitem1_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$c.name,
    		type: "slot",
    		source: "(122:20) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (120:16) <Dropdown >
    function create_default_slot_2$c(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_8$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_3$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$c.name,
    		type: "slot",
    		source: "(120:16) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (97:12) <Nav navbar>
    function create_default_slot_1$c(ctx) {
    	let dropdown0;
    	let t0;
    	let dropdown1;
    	let t1;
    	let dropdown2;
    	let current;

    	dropdown0 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_16$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown1 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_9$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown2 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_2$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdown0.$$.fragment);
    			t0 = space();
    			create_component(dropdown1.$$.fragment);
    			t1 = space();
    			create_component(dropdown2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdown0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdown1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdown2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdown0_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdown0_changes.$$scope = { dirty, ctx };
    			}

    			dropdown0.$set(dropdown0_changes);
    			const dropdown1_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdown1_changes.$$scope = { dirty, ctx };
    			}

    			dropdown1.$set(dropdown1_changes);
    			const dropdown2_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdown2_changes.$$scope = { dirty, ctx };
    			}

    			dropdown2.$set(dropdown2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdown0.$$.fragment, local);
    			transition_in(dropdown1.$$.fragment, local);
    			transition_in(dropdown2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdown0.$$.fragment, local);
    			transition_out(dropdown1.$$.fragment, local);
    			transition_out(dropdown2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdown0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdown1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdown2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$c.name,
    		type: "slot",
    		source: "(97:12) <Nav navbar>",
    		ctx
    	});

    	return block;
    }

    // (95:8) <Navbar style="background-color: lightgreen; color:white;" light expand="lg" >
    function create_default_slot$c(ctx) {
    	let navbarbrand;
    	let t;
    	let nav;
    	let current;

    	navbarbrand = new NavbarBrand({
    			props: {
    				href: "#/info",
    				$$slots: { default: [create_default_slot_22$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	nav = new Nav({
    			props: {
    				navbar: true,
    				$$slots: { default: [create_default_slot_1$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navbarbrand.$$.fragment);
    			t = space();
    			create_component(nav.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbarbrand, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(nav, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navbarbrand_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				navbarbrand_changes.$$scope = { dirty, ctx };
    			}

    			navbarbrand.$set(navbarbrand_changes);
    			const nav_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				nav_changes.$$scope = { dirty, ctx };
    			}

    			nav.$set(nav_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbarbrand.$$.fragment, local);
    			transition_in(nav.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbarbrand.$$.fragment, local);
    			transition_out(nav.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbarbrand, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(nav, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$c.name,
    		type: "slot",
    		source: "(95:8) <Navbar style=\\\"background-color: lightgreen; color:white;\\\" light expand=\\\"lg\\\" >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$f(ctx) {
    	let script0;
    	let script0_src_value;
    	let script1;
    	let script1_src_value;
    	let script2;
    	let script2_src_value;
    	let t0;
    	let main;
    	let navbar;
    	let t1;
    	let div;
    	let current;

    	navbar = new Navbar({
    			props: {
    				style: "background-color: lightgreen; color:white;",
    				light: true,
    				expand: "lg",
    				$$slots: { default: [create_default_slot$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			script0 = element$1("script");
    			script1 = element$1("script");
    			script2 = element$1("script");
    			t0 = space();
    			main = element$1("main");
    			create_component(navbar.$$.fragment);
    			t1 = space();
    			div = element$1("div");
    			if (!src_url_equal(script0.src, script0_src_value = "https://d3js.org/d3.v6.min.js")) attr_dev(script0, "src", script0_src_value);
    			add_location(script0, file$f, 85, 8, 3240);
    			if (!src_url_equal(script1.src, script1_src_value = "https://cdnjs.cloudflare.com/ajax/libs/billboard.js/3.4.1/billboard.min.js")) attr_dev(script1, "src", script1_src_value);
    			add_location(script1, file$f, 86, 8, 3303);
    			if (!src_url_equal(script2.src, script2_src_value = "https://cdnjs.cloudflare.com/ajax/libs/billboard.js/3.4.1/billboard.min.css")) attr_dev(script2, "src", script2_src_value);
    			add_location(script2, file$f, 87, 8, 3411);
    			attr_dev(div, "id", "chart");
    			add_location(div, file$f, 136, 8, 5724);
    			add_location(main, file$f, 92, 4, 3558);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			append_dev(document.head, script0);
    			append_dev(document.head, script1);
    			append_dev(document.head, script2);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			mount_component(navbar, main, null);
    			append_dev(main, t1);
    			append_dev(main, div);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const navbar_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				navbar_changes.$$scope = { dirty, ctx };
    			}

    			navbar.$set(navbar_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			detach_dev(script0);
    			detach_dev(script1);
    			detach_dev(script2);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			destroy_component(navbar);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$f($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('IntegrationApi4', slots, []);
    	let apiData = {};
    	const delay = ms => new Promise(res => setTimeout(res, ms));
    	let stats = [];
    	let id = ["id"];
    	let postId = ["postId"];
    	let email = ["email"];
    	let economies = [];
    	let country = [];
    	let year = [];
    	let percapita = ["percapita"];
    	let currency = ["currency"];
    	let currentprices = ["currentprices"];

    	async function loadGraph() {
    		console.log("Fetching stats....");
    		const res1 = await fetch("https://jsonplaceholder.typicode.com/comments");
    		const res2 = await fetch("/api/v2/economies");

    		if (res1.ok && res2.ok) {
    			const data = await res1.json();
    			const data2 = await res2.json();
    			stats = data;
    			console.log("Estadísticas recibidas: " + stats.length);

    			//inicializamos los arrays para mostrar los datos
    			stats.forEach(stat => {
    				id.push(stat.id);
    				postId.push(stat.postId);
    				email.push(stat.email);
    			});

    			economies = data2;

    			if (economies.length == 0) {
    				await fetch("/api/v2/economies/loadInitialData");
    			}

    			console.log("Recibido: " + economies.length);

    			economies.forEach(economy => {
    				percapita.push(economy.percapita);
    				currency.push(economy.currency);
    				currentprices.push(economy.currentprices);
    			});
    		} else {
    			console.log("Error cargando los datos");
    		}

    		console.log("Comprobando");
    		await delay(500);

    		var chart = bb.generate({
    			data: {
    				axis: { x: { type: email } },
    				columns: [email],
    				types: {
    					id: "area", // for ESM specify as: area()
    					postId: "area", // for ESM specify as: areaSpline()
    					percapita: "area-spline",
    					currency: "area-spline",
    					currentprices: "area-spline"
    				}
    			},
    			bindto: "#areaChart"
    		});

    		setTimeout(
    			function () {
    				chart.load({
    					columns: [id, postId, email, percapita, currency, currentprices]
    				});
    			},
    			500
    		);

    		console.log(id);
    	}

    	onMount(loadGraph);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$e.warn(`<IntegrationApi4> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		Navbar,
    		Nav,
    		NavItem,
    		NavLink,
    		NavbarBrand,
    		Dropdown,
    		DropdownToggle,
    		DropdownMenu,
    		DropdownItem,
    		Button,
    		Table,
    		pop,
    		apiData,
    		delay,
    		stats,
    		id,
    		postId,
    		email,
    		economies,
    		country,
    		year,
    		percapita,
    		currency,
    		currentprices,
    		loadGraph
    	});

    	$$self.$inject_state = $$props => {
    		if ('apiData' in $$props) apiData = $$props.apiData;
    		if ('stats' in $$props) stats = $$props.stats;
    		if ('id' in $$props) id = $$props.id;
    		if ('postId' in $$props) postId = $$props.postId;
    		if ('email' in $$props) email = $$props.email;
    		if ('economies' in $$props) economies = $$props.economies;
    		if ('country' in $$props) country = $$props.country;
    		if ('year' in $$props) year = $$props.year;
    		if ('percapita' in $$props) percapita = $$props.percapita;
    		if ('currency' in $$props) currency = $$props.currency;
    		if ('currentprices' in $$props) currentprices = $$props.currentprices;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [];
    }

    class IntegrationApi4 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$f, create_fragment$f, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "IntegrationApi4",
    			options,
    			id: create_fragment$f.name
    		});
    	}
    }

    /* src\front\frontEconomies\integrationApi5.svelte generated by Svelte v3.47.0 */

    const { console: console_1$d } = globals;
    const file$e = "src\\front\\frontEconomies\\integrationApi5.svelte";

    // (99:12) <NavbarBrand href="#/info">
    function create_default_slot_24$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("INICIO");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_24$2.name,
    		type: "slot",
    		source: "(99:12) <NavbarBrand href=\\\"#/info\\\">",
    		ctx
    	});

    	return block;
    }

    // (102:20) <DropdownToggle nav caret>
    function create_default_slot_23$8(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("API");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_23$8.name,
    		type: "slot",
    		source: "(102:20) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (104:20) <DropdownItem href="./api/v2/economies">
    function create_default_slot_22$b(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_22$b.name,
    		type: "slot",
    		source: "(104:20) <DropdownItem href=\\\"./api/v2/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (106:20) <DropdownItem href="./api/v1/esco-stats">
    function create_default_slot_21$b(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_21$b.name,
    		type: "slot",
    		source: "(106:20) <DropdownItem href=\\\"./api/v1/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (108:20) <DropdownItem href="./api/v1/expo-stats">
    function create_default_slot_20$b(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_20$b.name,
    		type: "slot",
    		source: "(108:20) <DropdownItem href=\\\"./api/v1/expo-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (103:20) <DropdownMenu end>
    function create_default_slot_19$b(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./api/v2/economies",
    				$$slots: { default: [create_default_slot_22$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "./api/v1/esco-stats",
    				$$slots: { default: [create_default_slot_21$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "./api/v1/expo-stats",
    				$$slots: { default: [create_default_slot_20$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 2048) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 2048) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 2048) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_19$b.name,
    		type: "slot",
    		source: "(103:20) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (101:16) <Dropdown >
    function create_default_slot_18$b(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_23$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_19$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 2048) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 2048) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_18$b.name,
    		type: "slot",
    		source: "(101:16) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (113:20) <DropdownToggle nav caret>
    function create_default_slot_17$b(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17$b.name,
    		type: "slot",
    		source: "(113:20) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (115:20) <DropdownItem href="./#/economies">
    function create_default_slot_16$b(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16$b.name,
    		type: "slot",
    		source: "(115:20) <DropdownItem href=\\\"./#/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (116:20) <DropdownItem href="#/esco-stats">
    function create_default_slot_15$b(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15$b.name,
    		type: "slot",
    		source: "(116:20) <DropdownItem href=\\\"#/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (117:20) <DropdownItem href="#/expo">
    function create_default_slot_14$b(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo-Stats FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14$b.name,
    		type: "slot",
    		source: "(117:20) <DropdownItem href=\\\"#/expo\\\">",
    		ctx
    	});

    	return block;
    }

    // (119:20) <DropdownItem href="#/graph">
    function create_default_slot_13$b(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Conjunto");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13$b.name,
    		type: "slot",
    		source: "(119:20) <DropdownItem href=\\\"#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (114:20) <DropdownMenu end>
    function create_default_slot_12$b(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies",
    				$$slots: { default: [create_default_slot_16$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({
    			props: {
    				href: "#/esco-stats",
    				$$slots: { default: [create_default_slot_15$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "#/expo",
    				$$slots: { default: [create_default_slot_14$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/graph",
    				$$slots: { default: [create_default_slot_13$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 2048) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem1_changes = {};

    			if (dirty & /*$$scope*/ 2048) {
    				dropdownitem1_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem1.$set(dropdownitem1_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 2048) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 2048) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12$b.name,
    		type: "slot",
    		source: "(114:20) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (112:16) <Dropdown>
    function create_default_slot_11$b(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_17$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_12$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 2048) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 2048) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$b.name,
    		type: "slot",
    		source: "(112:16) <Dropdown>",
    		ctx
    	});

    	return block;
    }

    // (124:20) <DropdownToggle nav caret>
    function create_default_slot_10$b(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Gráficas");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$b.name,
    		type: "slot",
    		source: "(124:20) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (126:20) <DropdownItem href="./#/economies-graph">
    function create_default_slot_9$b(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$b.name,
    		type: "slot",
    		source: "(126:20) <DropdownItem href=\\\"./#/economies-graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (127:20) <DropdownItem href="#/graphesco">
    function create_default_slot_8$b(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$b.name,
    		type: "slot",
    		source: "(127:20) <DropdownItem href=\\\"#/graphesco\\\">",
    		ctx
    	});

    	return block;
    }

    // (128:20) <DropdownItem href="#/graphexpo">
    function create_default_slot_7$b(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$b.name,
    		type: "slot",
    		source: "(128:20) <DropdownItem href=\\\"#/graphexpo\\\">",
    		ctx
    	});

    	return block;
    }

    // (130:20) <DropdownItem href="#/graph">
    function create_default_slot_6$b(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Conjunto");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$b.name,
    		type: "slot",
    		source: "(130:20) <DropdownItem href=\\\"#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (125:20) <DropdownMenu end>
    function create_default_slot_5$b(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies-graph",
    				$$slots: { default: [create_default_slot_9$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({
    			props: {
    				href: "#/graphesco",
    				$$slots: { default: [create_default_slot_8$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "#/graphexpo",
    				$$slots: { default: [create_default_slot_7$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/graph",
    				$$slots: { default: [create_default_slot_6$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 2048) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem1_changes = {};

    			if (dirty & /*$$scope*/ 2048) {
    				dropdownitem1_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem1.$set(dropdownitem1_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 2048) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 2048) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$b.name,
    		type: "slot",
    		source: "(125:20) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (123:16) <Dropdown >
    function create_default_slot_4$b(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_10$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_5$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 2048) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 2048) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$b.name,
    		type: "slot",
    		source: "(123:16) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (100:12) <Nav navbar>
    function create_default_slot_3$b(ctx) {
    	let dropdown0;
    	let t0;
    	let dropdown1;
    	let t1;
    	let dropdown2;
    	let current;

    	dropdown0 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_18$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown1 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_11$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown2 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_4$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdown0.$$.fragment);
    			t0 = space();
    			create_component(dropdown1.$$.fragment);
    			t1 = space();
    			create_component(dropdown2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdown0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdown1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdown2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdown0_changes = {};

    			if (dirty & /*$$scope*/ 2048) {
    				dropdown0_changes.$$scope = { dirty, ctx };
    			}

    			dropdown0.$set(dropdown0_changes);
    			const dropdown1_changes = {};

    			if (dirty & /*$$scope*/ 2048) {
    				dropdown1_changes.$$scope = { dirty, ctx };
    			}

    			dropdown1.$set(dropdown1_changes);
    			const dropdown2_changes = {};

    			if (dirty & /*$$scope*/ 2048) {
    				dropdown2_changes.$$scope = { dirty, ctx };
    			}

    			dropdown2.$set(dropdown2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdown0.$$.fragment, local);
    			transition_in(dropdown1.$$.fragment, local);
    			transition_in(dropdown2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdown0.$$.fragment, local);
    			transition_out(dropdown1.$$.fragment, local);
    			transition_out(dropdown2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdown0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdown1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdown2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$b.name,
    		type: "slot",
    		source: "(100:12) <Nav navbar>",
    		ctx
    	});

    	return block;
    }

    // (98:8) <Navbar style="background-color: lightgreen; color:white;" light expand="lg" >
    function create_default_slot_2$b(ctx) {
    	let navbarbrand;
    	let t;
    	let nav;
    	let current;

    	navbarbrand = new NavbarBrand({
    			props: {
    				href: "#/info",
    				$$slots: { default: [create_default_slot_24$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	nav = new Nav({
    			props: {
    				navbar: true,
    				$$slots: { default: [create_default_slot_3$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navbarbrand.$$.fragment);
    			t = space();
    			create_component(nav.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbarbrand, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(nav, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navbarbrand_changes = {};

    			if (dirty & /*$$scope*/ 2048) {
    				navbarbrand_changes.$$scope = { dirty, ctx };
    			}

    			navbarbrand.$set(navbarbrand_changes);
    			const nav_changes = {};

    			if (dirty & /*$$scope*/ 2048) {
    				nav_changes.$$scope = { dirty, ctx };
    			}

    			nav.$set(nav_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbarbrand.$$.fragment, local);
    			transition_in(nav.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbarbrand.$$.fragment, local);
    			transition_out(nav.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbarbrand, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(nav, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$b.name,
    		type: "slot",
    		source: "(98:8) <Navbar style=\\\"background-color: lightgreen; color:white;\\\" light expand=\\\"lg\\\" >",
    		ctx
    	});

    	return block;
    }

    // (141:8) <Button outline color="success" on:click={loadData}>
    function create_default_slot_1$b(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Datos creadores");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$b.name,
    		type: "slot",
    		source: "(141:8) <Button outline color=\\\"success\\\" on:click={loadData}>",
    		ctx
    	});

    	return block;
    }

    // (145:12) {#if checkMSG}
    function create_if_block$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1(/*checkMSG*/ ctx[0]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*checkMSG*/ 1) set_data_dev(t, /*checkMSG*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(145:12) {#if checkMSG}",
    		ctx
    	});

    	return block;
    }

    // (144:8) <Alert color={color} isOpen={visible} toggle={() => (visible = false)}>
    function create_default_slot$b(ctx) {
    	let if_block_anchor;
    	let if_block = /*checkMSG*/ ctx[0] && create_if_block$2(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*checkMSG*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$2(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$b.name,
    		type: "slot",
    		source: "(144:8) <Alert color={color} isOpen={visible} toggle={() => (visible = false)}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$e(ctx) {
    	let script0;
    	let script0_src_value;
    	let script1;
    	let script1_src_value;
    	let script2;
    	let script2_src_value;
    	let t0;
    	let main;
    	let navbar;
    	let t1;
    	let div;
    	let t2;
    	let button;
    	let t3;
    	let alert;
    	let current;

    	navbar = new Navbar({
    			props: {
    				style: "background-color: lightgreen; color:white;",
    				light: true,
    				expand: "lg",
    				$$slots: { default: [create_default_slot_2$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button = new Button({
    			props: {
    				outline: true,
    				color: "success",
    				$$slots: { default: [create_default_slot_1$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*loadData*/ ctx[3]);

    	alert = new Alert({
    			props: {
    				color: /*color*/ ctx[2],
    				isOpen: /*visible*/ ctx[1],
    				toggle: /*func*/ ctx[4],
    				$$slots: { default: [create_default_slot$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			script0 = element$1("script");
    			script1 = element$1("script");
    			script2 = element$1("script");
    			t0 = space();
    			main = element$1("main");
    			create_component(navbar.$$.fragment);
    			t1 = space();
    			div = element$1("div");
    			t2 = space();
    			create_component(button.$$.fragment);
    			t3 = space();
    			create_component(alert.$$.fragment);
    			if (!src_url_equal(script0.src, script0_src_value = "https://d3js.org/d3.v6.min.js")) attr_dev(script0, "src", script0_src_value);
    			add_location(script0, file$e, 88, 8, 3191);
    			if (!src_url_equal(script1.src, script1_src_value = "https://cdnjs.cloudflare.com/ajax/libs/billboard.js/3.4.1/billboard.min.js")) attr_dev(script1, "src", script1_src_value);
    			add_location(script1, file$e, 89, 8, 3254);
    			if (!src_url_equal(script2.src, script2_src_value = "https://cdnjs.cloudflare.com/ajax/libs/billboard.js/3.4.1/billboard.min.css")) attr_dev(script2, "src", script2_src_value);
    			add_location(script2, file$e, 90, 8, 3362);
    			attr_dev(div, "id", "chart");
    			add_location(div, file$e, 139, 8, 5675);
    			add_location(main, file$e, 95, 4, 3509);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			append_dev(document.head, script0);
    			append_dev(document.head, script1);
    			append_dev(document.head, script2);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			mount_component(navbar, main, null);
    			append_dev(main, t1);
    			append_dev(main, div);
    			append_dev(main, t2);
    			mount_component(button, main, null);
    			append_dev(main, t3);
    			mount_component(alert, main, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const navbar_changes = {};

    			if (dirty & /*$$scope*/ 2048) {
    				navbar_changes.$$scope = { dirty, ctx };
    			}

    			navbar.$set(navbar_changes);
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 2048) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    			const alert_changes = {};
    			if (dirty & /*visible*/ 2) alert_changes.isOpen = /*visible*/ ctx[1];
    			if (dirty & /*visible*/ 2) alert_changes.toggle = /*func*/ ctx[4];

    			if (dirty & /*$$scope, checkMSG*/ 2049) {
    				alert_changes.$$scope = { dirty, ctx };
    			}

    			alert.$set(alert_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			transition_in(button.$$.fragment, local);
    			transition_in(alert.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			transition_out(button.$$.fragment, local);
    			transition_out(alert.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			detach_dev(script0);
    			detach_dev(script1);
    			detach_dev(script2);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			destroy_component(navbar);
    			destroy_component(button);
    			destroy_component(alert);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('IntegrationApi5', slots, []);
    	let checkMSG = "";
    	let visible = false;
    	let color = "danger";
    	let economies = [];
    	let percapita = ["percapita"];
    	let currency = ["currency"];
    	let currentprices = ["currentprices"];
    	const delay = ms => new Promise(res => setTimeout(res, ms));

    	async function loadGraph() {
    		console.log("Fetching stats....");
    		const res = await fetch("/api/v2/economies");

    		if (res.ok) {
    			const data = await res.json();
    			economies = data;

    			if (economies.length == 0) {
    				await fetch("/api/v2/economies/loadInitialData");
    			}

    			console.log("Recibido: " + economies.length);

    			economies.forEach(economy => {
    				percapita.push(economy.percapita);
    				currency.push(economy.currency);
    				currentprices.push(economy.currentprices);
    			});
    		} else {
    			console.log("Error cargando los datos");
    		}

    		console.log("Comprobando");
    		await delay(500);

    		var chart = bb.generate({
    			data: {
    				axis: { x: { type: "category" } },
    				columns: [],
    				types: {
    					percapita: "area-spline",
    					currency: "area-spline",
    					currentprices: "area-spline"
    				}
    			},
    			bindto: "#areaChart"
    		});

    		setTimeout(
    			function () {
    				chart.load({
    					columns: [percapita, currency, currentprices]
    				});
    			},
    			500
    		);
    	}

    	async function loadData() {
    		let url = 'https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits';
    		let response = await fetch(url);
    		let commits = await response.json(); // leer respuesta del cuerpo y devolver como JSON
    		console.log("Estadísticas recibidas: " + commits.length);
    		$$invalidate(0, checkMSG = "Nombre: " + JSON.stringify(commits[1].author.login) + "\n" + "Id: " + JSON.stringify(commits[1].author.id) + "\n" + "email: " + JSON.stringify(commits[1].author.html_url) + "\n");
    		$$invalidate(0, checkMSG = checkMSG + "   y \n Nombre: " + JSON.stringify(commits[2].author.login) + "\n" + "Id: " + JSON.stringify(commits[2].author.id) + "\n" + "email: " + JSON.stringify(commits[2].author.html_url) + "\n");
    		$$invalidate(1, visible = "true");
    	}

    	onMount(loadGraph);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$d.warn(`<IntegrationApi5> was created with unknown prop '${key}'`);
    	});

    	const func = () => $$invalidate(1, visible = false);

    	$$self.$capture_state = () => ({
    		onMount,
    		Alert,
    		Navbar,
    		Nav,
    		NavItem,
    		NavLink,
    		NavbarBrand,
    		Dropdown,
    		DropdownToggle,
    		DropdownMenu,
    		DropdownItem,
    		Table,
    		Button,
    		pop,
    		checkMSG,
    		visible,
    		color,
    		economies,
    		percapita,
    		currency,
    		currentprices,
    		delay,
    		loadGraph,
    		loadData
    	});

    	$$self.$inject_state = $$props => {
    		if ('checkMSG' in $$props) $$invalidate(0, checkMSG = $$props.checkMSG);
    		if ('visible' in $$props) $$invalidate(1, visible = $$props.visible);
    		if ('color' in $$props) $$invalidate(2, color = $$props.color);
    		if ('economies' in $$props) economies = $$props.economies;
    		if ('percapita' in $$props) percapita = $$props.percapita;
    		if ('currency' in $$props) currency = $$props.currency;
    		if ('currentprices' in $$props) currentprices = $$props.currentprices;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [checkMSG, visible, color, loadData, func];
    }

    class IntegrationApi5 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$e, create_fragment$e, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "IntegrationApi5",
    			options,
    			id: create_fragment$e.name
    		});
    	}
    }

    /* src\front\frontEconomies\integrationApi6.svelte generated by Svelte v3.47.0 */

    const { console: console_1$c } = globals;
    const file$d = "src\\front\\frontEconomies\\integrationApi6.svelte";

    // (101:12) <NavbarBrand href="#/info">
    function create_default_slot_22$a(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("INICIO");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_22$a.name,
    		type: "slot",
    		source: "(101:12) <NavbarBrand href=\\\"#/info\\\">",
    		ctx
    	});

    	return block;
    }

    // (104:20) <DropdownToggle nav caret>
    function create_default_slot_21$a(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("API");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_21$a.name,
    		type: "slot",
    		source: "(104:20) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (106:20) <DropdownItem href="./api/v2/economies">
    function create_default_slot_20$a(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_20$a.name,
    		type: "slot",
    		source: "(106:20) <DropdownItem href=\\\"./api/v2/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (108:20) <DropdownItem href="./api/v1/esco-stats">
    function create_default_slot_19$a(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_19$a.name,
    		type: "slot",
    		source: "(108:20) <DropdownItem href=\\\"./api/v1/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (110:20) <DropdownItem href="./api/v1/expo-stats">
    function create_default_slot_18$a(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_18$a.name,
    		type: "slot",
    		source: "(110:20) <DropdownItem href=\\\"./api/v1/expo-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (105:20) <DropdownMenu end>
    function create_default_slot_17$a(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./api/v2/economies",
    				$$slots: { default: [create_default_slot_20$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "./api/v1/esco-stats",
    				$$slots: { default: [create_default_slot_19$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "./api/v1/expo-stats",
    				$$slots: { default: [create_default_slot_18$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17$a.name,
    		type: "slot",
    		source: "(105:20) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (103:16) <Dropdown >
    function create_default_slot_16$a(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_21$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_17$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16$a.name,
    		type: "slot",
    		source: "(103:16) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (115:20) <DropdownToggle nav caret>
    function create_default_slot_15$a(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15$a.name,
    		type: "slot",
    		source: "(115:20) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (117:20) <DropdownItem href="./#/economies">
    function create_default_slot_14$a(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14$a.name,
    		type: "slot",
    		source: "(117:20) <DropdownItem href=\\\"./#/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (118:20) <DropdownItem href="#/esco-stats">
    function create_default_slot_13$a(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13$a.name,
    		type: "slot",
    		source: "(118:20) <DropdownItem href=\\\"#/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (119:20) <DropdownItem href="#/expo">
    function create_default_slot_12$a(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo-Stats FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12$a.name,
    		type: "slot",
    		source: "(119:20) <DropdownItem href=\\\"#/expo\\\">",
    		ctx
    	});

    	return block;
    }

    // (121:20) <DropdownItem href="#/graph">
    function create_default_slot_11$a(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Conjunto");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$a.name,
    		type: "slot",
    		source: "(121:20) <DropdownItem href=\\\"#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (116:20) <DropdownMenu end>
    function create_default_slot_10$a(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies",
    				$$slots: { default: [create_default_slot_14$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({
    			props: {
    				href: "#/esco-stats",
    				$$slots: { default: [create_default_slot_13$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "#/expo",
    				$$slots: { default: [create_default_slot_12$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/graph",
    				$$slots: { default: [create_default_slot_11$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem1_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem1_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem1.$set(dropdownitem1_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$a.name,
    		type: "slot",
    		source: "(116:20) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (114:16) <Dropdown>
    function create_default_slot_9$a(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_15$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_10$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$a.name,
    		type: "slot",
    		source: "(114:16) <Dropdown>",
    		ctx
    	});

    	return block;
    }

    // (126:20) <DropdownToggle nav caret>
    function create_default_slot_8$a(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Gráficas");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$a.name,
    		type: "slot",
    		source: "(126:20) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (128:20) <DropdownItem href="./#/economies-graph">
    function create_default_slot_7$a(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$a.name,
    		type: "slot",
    		source: "(128:20) <DropdownItem href=\\\"./#/economies-graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (129:20) <DropdownItem href="#/graphesco">
    function create_default_slot_6$a(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$a.name,
    		type: "slot",
    		source: "(129:20) <DropdownItem href=\\\"#/graphesco\\\">",
    		ctx
    	});

    	return block;
    }

    // (130:20) <DropdownItem href="#/graphexpo">
    function create_default_slot_5$a(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$a.name,
    		type: "slot",
    		source: "(130:20) <DropdownItem href=\\\"#/graphexpo\\\">",
    		ctx
    	});

    	return block;
    }

    // (132:20) <DropdownItem href="#/graph">
    function create_default_slot_4$a(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Conjunto");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$a.name,
    		type: "slot",
    		source: "(132:20) <DropdownItem href=\\\"#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (127:20) <DropdownMenu end>
    function create_default_slot_3$a(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies-graph",
    				$$slots: { default: [create_default_slot_7$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({
    			props: {
    				href: "#/graphesco",
    				$$slots: { default: [create_default_slot_6$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "#/graphexpo",
    				$$slots: { default: [create_default_slot_5$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/graph",
    				$$slots: { default: [create_default_slot_4$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem1_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem1_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem1.$set(dropdownitem1_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$a.name,
    		type: "slot",
    		source: "(127:20) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (125:16) <Dropdown >
    function create_default_slot_2$a(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_8$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_3$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$a.name,
    		type: "slot",
    		source: "(125:16) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (102:12) <Nav navbar>
    function create_default_slot_1$a(ctx) {
    	let dropdown0;
    	let t0;
    	let dropdown1;
    	let t1;
    	let dropdown2;
    	let current;

    	dropdown0 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_16$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown1 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_9$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown2 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_2$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdown0.$$.fragment);
    			t0 = space();
    			create_component(dropdown1.$$.fragment);
    			t1 = space();
    			create_component(dropdown2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdown0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdown1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdown2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdown0_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdown0_changes.$$scope = { dirty, ctx };
    			}

    			dropdown0.$set(dropdown0_changes);
    			const dropdown1_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdown1_changes.$$scope = { dirty, ctx };
    			}

    			dropdown1.$set(dropdown1_changes);
    			const dropdown2_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdown2_changes.$$scope = { dirty, ctx };
    			}

    			dropdown2.$set(dropdown2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdown0.$$.fragment, local);
    			transition_in(dropdown1.$$.fragment, local);
    			transition_in(dropdown2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdown0.$$.fragment, local);
    			transition_out(dropdown1.$$.fragment, local);
    			transition_out(dropdown2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdown0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdown1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdown2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$a.name,
    		type: "slot",
    		source: "(102:12) <Nav navbar>",
    		ctx
    	});

    	return block;
    }

    // (100:8) <Navbar style="background-color: lightgreen; color:white;" light expand="lg" >
    function create_default_slot$a(ctx) {
    	let navbarbrand;
    	let t;
    	let nav;
    	let current;

    	navbarbrand = new NavbarBrand({
    			props: {
    				href: "#/info",
    				$$slots: { default: [create_default_slot_22$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	nav = new Nav({
    			props: {
    				navbar: true,
    				$$slots: { default: [create_default_slot_1$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navbarbrand.$$.fragment);
    			t = space();
    			create_component(nav.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbarbrand, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(nav, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navbarbrand_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				navbarbrand_changes.$$scope = { dirty, ctx };
    			}

    			navbarbrand.$set(navbarbrand_changes);
    			const nav_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				nav_changes.$$scope = { dirty, ctx };
    			}

    			nav.$set(nav_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbarbrand.$$.fragment, local);
    			transition_in(nav.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbarbrand.$$.fragment, local);
    			transition_out(nav.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbarbrand, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(nav, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$a.name,
    		type: "slot",
    		source: "(100:8) <Navbar style=\\\"background-color: lightgreen; color:white;\\\" light expand=\\\"lg\\\" >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$d(ctx) {
    	let script0;
    	let script0_src_value;
    	let script1;
    	let script1_src_value;
    	let script2;
    	let script2_src_value;
    	let t0;
    	let main;
    	let navbar;
    	let t1;
    	let p;
    	let t3;
    	let div;
    	let current;

    	navbar = new Navbar({
    			props: {
    				style: "background-color: lightgreen; color:white;",
    				light: true,
    				expand: "lg",
    				$$slots: { default: [create_default_slot$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			script0 = element$1("script");
    			script1 = element$1("script");
    			script2 = element$1("script");
    			t0 = space();
    			main = element$1("main");
    			create_component(navbar.$$.fragment);
    			t1 = space();
    			p = element$1("p");
    			p.textContent = "Comparacion del trabajo en casa";
    			t3 = space();
    			div = element$1("div");
    			if (!src_url_equal(script0.src, script0_src_value = "https://d3js.org/d3.v6.min.js")) attr_dev(script0, "src", script0_src_value);
    			add_location(script0, file$d, 90, 8, 3557);
    			if (!src_url_equal(script1.src, script1_src_value = "https://cdnjs.cloudflare.com/ajax/libs/billboard.js/3.4.1/billboard.min.js")) attr_dev(script1, "src", script1_src_value);
    			add_location(script1, file$d, 91, 8, 3620);
    			if (!src_url_equal(script2.src, script2_src_value = "https://cdnjs.cloudflare.com/ajax/libs/billboard.js/3.4.1/billboard.min.css")) attr_dev(script2, "src", script2_src_value);
    			add_location(script2, file$d, 92, 8, 3728);
    			add_location(p, file$d, 140, 8, 6035);
    			attr_dev(div, "id", "chart");
    			add_location(div, file$d, 142, 8, 6089);
    			add_location(main, file$d, 97, 4, 3875);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			append_dev(document.head, script0);
    			append_dev(document.head, script1);
    			append_dev(document.head, script2);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			mount_component(navbar, main, null);
    			append_dev(main, t1);
    			append_dev(main, p);
    			append_dev(main, t3);
    			append_dev(main, div);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const navbar_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				navbar_changes.$$scope = { dirty, ctx };
    			}

    			navbar.$set(navbar_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			detach_dev(script0);
    			detach_dev(script1);
    			detach_dev(script2);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			destroy_component(navbar);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('IntegrationApi6', slots, []);
    	let apiData = {};
    	const delay = ms => new Promise(res => setTimeout(res, ms));
    	let stats = [];
    	let country = [];
    	let year = [];
    	let average = ["average"];
    	let women = ["women"];
    	let men = ["men"];
    	let economies = [];
    	let percapita = ["percapita"];
    	let currency = ["currency"];
    	let currentprices = ["currentprices"];

    	async function loadGraph() {
    		console.log("Fetching stats....");
    		const res1 = await fetch("https://sos2122-32.herokuapp.com/api/v1/housework-stats/");
    		const res2 = await fetch("/api/v2/economies");

    		if (res1.ok && res2.ok) {
    			const data = await res1.json();
    			const data2 = await res2.json();
    			stats = data;

    			if (stats.length == 0) {
    				await fetch("https://sos2122-32.herokuapp.com/api/v1/housework-stats/");
    			}

    			console.log("Estadísticas recibidas: " + stats.length);

    			//inicializamos los arrays para mostrar los datos
    			stats.forEach(stat => {
    				country.push(stat.country + "-" + stat.year);
    				year.push(stat.year);
    				average.push(stat.average);
    				women.push(stat.women);
    				men.push(stat.men);
    			});

    			economies = data2;

    			if (economies.length == 0) {
    				await fetch("/api/v2/economies/loadInitialData");
    			}

    			console.log("Recibido: " + economies.length);

    			economies.forEach(economy => {
    				percapita.push(economy.percapita);
    				currency.push(economy.currency);
    				currentprices.push(economy.currentprices);
    			});
    		} else {
    			console.log("Error cargando los datos");
    		}

    		console.log("Comprobando");
    		await delay(500);

    		var chart = bb.generate({
    			data: {
    				axis: { x: { type: "category" } },
    				columns: [],
    				types: {
    					average: "area", // for ESM specify as: area()
    					men: "area-spline",
    					women: "area-spline", // for ESM specify as: areaSpline()
    					percapita: "area-spline",
    					currency: "area-spline",
    					currentprices: "area-spline"
    				}
    			},
    			bindto: "#areaChart"
    		});

    		setTimeout(
    			function () {
    				chart.load({
    					columns: [average, women, men, percapita, currency, currentprices]
    				});
    			},
    			500
    		);
    	}

    	onMount(loadGraph);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$c.warn(`<IntegrationApi6> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		Navbar,
    		Nav,
    		NavItem,
    		NavLink,
    		NavbarBrand,
    		Dropdown,
    		DropdownToggle,
    		DropdownMenu,
    		DropdownItem,
    		Button,
    		Table,
    		pop,
    		apiData,
    		delay,
    		stats,
    		country,
    		year,
    		average,
    		women,
    		men,
    		economies,
    		percapita,
    		currency,
    		currentprices,
    		loadGraph
    	});

    	$$self.$inject_state = $$props => {
    		if ('apiData' in $$props) apiData = $$props.apiData;
    		if ('stats' in $$props) stats = $$props.stats;
    		if ('country' in $$props) country = $$props.country;
    		if ('year' in $$props) year = $$props.year;
    		if ('average' in $$props) average = $$props.average;
    		if ('women' in $$props) women = $$props.women;
    		if ('men' in $$props) men = $$props.men;
    		if ('economies' in $$props) economies = $$props.economies;
    		if ('percapita' in $$props) percapita = $$props.percapita;
    		if ('currency' in $$props) currency = $$props.currency;
    		if ('currentprices' in $$props) currentprices = $$props.currentprices;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [];
    }

    class IntegrationApi6 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$d, create_fragment$d, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "IntegrationApi6",
    			options,
    			id: create_fragment$d.name
    		});
    	}
    }

    /* src\front\frontEconomies\integrationApi7.svelte generated by Svelte v3.47.0 */

    const { console: console_1$b } = globals;
    const file$c = "src\\front\\frontEconomies\\integrationApi7.svelte";

    // (101:12) <NavbarBrand href="#/info">
    function create_default_slot_22$9(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("INICIO");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_22$9.name,
    		type: "slot",
    		source: "(101:12) <NavbarBrand href=\\\"#/info\\\">",
    		ctx
    	});

    	return block;
    }

    // (104:20) <DropdownToggle nav caret>
    function create_default_slot_21$9(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("API");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_21$9.name,
    		type: "slot",
    		source: "(104:20) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (106:20) <DropdownItem href="./api/v2/economies">
    function create_default_slot_20$9(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_20$9.name,
    		type: "slot",
    		source: "(106:20) <DropdownItem href=\\\"./api/v2/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (108:20) <DropdownItem href="./api/v1/esco-stats">
    function create_default_slot_19$9(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_19$9.name,
    		type: "slot",
    		source: "(108:20) <DropdownItem href=\\\"./api/v1/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (110:20) <DropdownItem href="./api/v1/expo-stats">
    function create_default_slot_18$9(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_18$9.name,
    		type: "slot",
    		source: "(110:20) <DropdownItem href=\\\"./api/v1/expo-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (105:20) <DropdownMenu end>
    function create_default_slot_17$9(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./api/v2/economies",
    				$$slots: { default: [create_default_slot_20$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "./api/v1/esco-stats",
    				$$slots: { default: [create_default_slot_19$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "./api/v1/expo-stats",
    				$$slots: { default: [create_default_slot_18$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17$9.name,
    		type: "slot",
    		source: "(105:20) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (103:16) <Dropdown >
    function create_default_slot_16$9(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_21$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_17$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16$9.name,
    		type: "slot",
    		source: "(103:16) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (115:20) <DropdownToggle nav caret>
    function create_default_slot_15$9(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15$9.name,
    		type: "slot",
    		source: "(115:20) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (117:20) <DropdownItem href="./#/economies">
    function create_default_slot_14$9(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14$9.name,
    		type: "slot",
    		source: "(117:20) <DropdownItem href=\\\"./#/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (118:20) <DropdownItem href="#/esco-stats">
    function create_default_slot_13$9(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13$9.name,
    		type: "slot",
    		source: "(118:20) <DropdownItem href=\\\"#/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (119:20) <DropdownItem href="#/expo">
    function create_default_slot_12$9(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo-Stats FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12$9.name,
    		type: "slot",
    		source: "(119:20) <DropdownItem href=\\\"#/expo\\\">",
    		ctx
    	});

    	return block;
    }

    // (121:20) <DropdownItem href="#/graph">
    function create_default_slot_11$9(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Conjunto");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$9.name,
    		type: "slot",
    		source: "(121:20) <DropdownItem href=\\\"#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (116:20) <DropdownMenu end>
    function create_default_slot_10$9(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies",
    				$$slots: { default: [create_default_slot_14$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({
    			props: {
    				href: "#/esco-stats",
    				$$slots: { default: [create_default_slot_13$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "#/expo",
    				$$slots: { default: [create_default_slot_12$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/graph",
    				$$slots: { default: [create_default_slot_11$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem1_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem1_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem1.$set(dropdownitem1_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$9.name,
    		type: "slot",
    		source: "(116:20) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (114:16) <Dropdown>
    function create_default_slot_9$9(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_15$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_10$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$9.name,
    		type: "slot",
    		source: "(114:16) <Dropdown>",
    		ctx
    	});

    	return block;
    }

    // (126:20) <DropdownToggle nav caret>
    function create_default_slot_8$9(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Gráficas");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$9.name,
    		type: "slot",
    		source: "(126:20) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (128:20) <DropdownItem href="./#/economies-graph">
    function create_default_slot_7$9(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$9.name,
    		type: "slot",
    		source: "(128:20) <DropdownItem href=\\\"./#/economies-graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (129:20) <DropdownItem href="#/graphesco">
    function create_default_slot_6$9(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$9.name,
    		type: "slot",
    		source: "(129:20) <DropdownItem href=\\\"#/graphesco\\\">",
    		ctx
    	});

    	return block;
    }

    // (130:20) <DropdownItem href="#/graphexpo">
    function create_default_slot_5$9(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$9.name,
    		type: "slot",
    		source: "(130:20) <DropdownItem href=\\\"#/graphexpo\\\">",
    		ctx
    	});

    	return block;
    }

    // (132:20) <DropdownItem href="#/graph">
    function create_default_slot_4$9(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Conjunto");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$9.name,
    		type: "slot",
    		source: "(132:20) <DropdownItem href=\\\"#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (127:20) <DropdownMenu end>
    function create_default_slot_3$9(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies-graph",
    				$$slots: { default: [create_default_slot_7$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({
    			props: {
    				href: "#/graphesco",
    				$$slots: { default: [create_default_slot_6$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "#/graphexpo",
    				$$slots: { default: [create_default_slot_5$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/graph",
    				$$slots: { default: [create_default_slot_4$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem1_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem1_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem1.$set(dropdownitem1_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$9.name,
    		type: "slot",
    		source: "(127:20) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (125:16) <Dropdown >
    function create_default_slot_2$9(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_8$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_3$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$9.name,
    		type: "slot",
    		source: "(125:16) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (102:12) <Nav navbar>
    function create_default_slot_1$9(ctx) {
    	let dropdown0;
    	let t0;
    	let dropdown1;
    	let t1;
    	let dropdown2;
    	let current;

    	dropdown0 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_16$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown1 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_9$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown2 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_2$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdown0.$$.fragment);
    			t0 = space();
    			create_component(dropdown1.$$.fragment);
    			t1 = space();
    			create_component(dropdown2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdown0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdown1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdown2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdown0_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdown0_changes.$$scope = { dirty, ctx };
    			}

    			dropdown0.$set(dropdown0_changes);
    			const dropdown1_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdown1_changes.$$scope = { dirty, ctx };
    			}

    			dropdown1.$set(dropdown1_changes);
    			const dropdown2_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdown2_changes.$$scope = { dirty, ctx };
    			}

    			dropdown2.$set(dropdown2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdown0.$$.fragment, local);
    			transition_in(dropdown1.$$.fragment, local);
    			transition_in(dropdown2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdown0.$$.fragment, local);
    			transition_out(dropdown1.$$.fragment, local);
    			transition_out(dropdown2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdown0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdown1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdown2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$9.name,
    		type: "slot",
    		source: "(102:12) <Nav navbar>",
    		ctx
    	});

    	return block;
    }

    // (100:8) <Navbar style="background-color: lightgreen; color:white;" light expand="lg" >
    function create_default_slot$9(ctx) {
    	let navbarbrand;
    	let t;
    	let nav;
    	let current;

    	navbarbrand = new NavbarBrand({
    			props: {
    				href: "#/info",
    				$$slots: { default: [create_default_slot_22$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	nav = new Nav({
    			props: {
    				navbar: true,
    				$$slots: { default: [create_default_slot_1$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navbarbrand.$$.fragment);
    			t = space();
    			create_component(nav.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbarbrand, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(nav, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navbarbrand_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				navbarbrand_changes.$$scope = { dirty, ctx };
    			}

    			navbarbrand.$set(navbarbrand_changes);
    			const nav_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				nav_changes.$$scope = { dirty, ctx };
    			}

    			nav.$set(nav_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbarbrand.$$.fragment, local);
    			transition_in(nav.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbarbrand.$$.fragment, local);
    			transition_out(nav.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbarbrand, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(nav, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$9.name,
    		type: "slot",
    		source: "(100:8) <Navbar style=\\\"background-color: lightgreen; color:white;\\\" light expand=\\\"lg\\\" >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$c(ctx) {
    	let script0;
    	let script0_src_value;
    	let script1;
    	let script1_src_value;
    	let script2;
    	let script2_src_value;
    	let t0;
    	let main;
    	let navbar;
    	let t1;
    	let div;
    	let current;

    	navbar = new Navbar({
    			props: {
    				style: "background-color: lightgreen; color:white;",
    				light: true,
    				expand: "lg",
    				$$slots: { default: [create_default_slot$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			script0 = element$1("script");
    			script1 = element$1("script");
    			script2 = element$1("script");
    			t0 = space();
    			main = element$1("main");
    			create_component(navbar.$$.fragment);
    			t1 = space();
    			div = element$1("div");
    			if (!src_url_equal(script0.src, script0_src_value = "https://d3js.org/d3.v6.min.js")) attr_dev(script0, "src", script0_src_value);
    			add_location(script0, file$c, 90, 8, 3564);
    			if (!src_url_equal(script1.src, script1_src_value = "https://cdnjs.cloudflare.com/ajax/libs/billboard.js/3.4.1/billboard.min.js")) attr_dev(script1, "src", script1_src_value);
    			add_location(script1, file$c, 91, 8, 3627);
    			if (!src_url_equal(script2.src, script2_src_value = "https://cdnjs.cloudflare.com/ajax/libs/billboard.js/3.4.1/billboard.min.css")) attr_dev(script2, "src", script2_src_value);
    			add_location(script2, file$c, 92, 8, 3735);
    			attr_dev(div, "id", "chart");
    			add_location(div, file$c, 141, 8, 6048);
    			add_location(main, file$c, 97, 4, 3882);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			append_dev(document.head, script0);
    			append_dev(document.head, script1);
    			append_dev(document.head, script2);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			mount_component(navbar, main, null);
    			append_dev(main, t1);
    			append_dev(main, div);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const navbar_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				navbar_changes.$$scope = { dirty, ctx };
    			}

    			navbar.$set(navbar_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			detach_dev(script0);
    			detach_dev(script1);
    			detach_dev(script2);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			destroy_component(navbar);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('IntegrationApi7', slots, []);
    	let apiData = {};
    	const delay = ms => new Promise(res => setTimeout(res, ms));
    	let stats = [];
    	let country = [];
    	let year = [];
    	let average = ["average"];
    	let women = ["women"];
    	let men = ["men"];
    	let economies = [];
    	let percapita = ["percapita"];
    	let currency = ["currency"];
    	let currentprices = ["currentprices"];

    	async function loadGraph() {
    		console.log("Fetching stats....");
    		const res1 = await fetch("https://sos2122-32.herokuapp.com/api/v1/ending-stats");
    		const res2 = await fetch("/api/v2/economies");

    		if (res1.ok && res2.ok) {
    			const data = await res1.json();
    			const data2 = await res2.json();
    			stats = data;

    			if (stats.length == 0) {
    				await fetch("https://sos2122-32.herokuapp.com/api/v1/ending-statsloadInitialData");
    			}

    			console.log("Estadísticas recibidas: " + stats.length);

    			//inicializamos los arrays para mostrar los datos
    			stats.forEach(stat => {
    				country.push(stat.country + "-" + stat.year);
    				year.push(stat.year);
    				average.push(stat.average);
    				women.push(stat.women);
    				men.push(stat.men);
    			});

    			economies = data2;

    			if (economies.length == 0) {
    				await fetch("/api/v2/economies/loadInitialData");
    			}

    			console.log("Recibido: " + economies.length);

    			economies.forEach(economy => {
    				percapita.push(economy.percapita);
    				currency.push(economy.currency);
    				currentprices.push(economy.currentprices);
    			});
    		} else {
    			console.log("Error cargando los datos");
    		}

    		console.log("Comprobando");
    		await delay(500);

    		var chart = bb.generate({
    			data: {
    				axis: { x: { type: "category" } },
    				columns: [],
    				types: {
    					average: "area", // for ESM specify as: area()
    					men: "area-spline",
    					women: "area-spline", // for ESM specify as: areaSpline()
    					percapita: "area-spline",
    					currency: "area-spline",
    					currentprices: "area-spline"
    				}
    			},
    			bindto: "#areaChart"
    		});

    		setTimeout(
    			function () {
    				chart.load({
    					columns: [average, women, men, percapita, currency, currentprices]
    				});
    			},
    			500
    		);
    	}

    	onMount(loadGraph);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$b.warn(`<IntegrationApi7> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		Navbar,
    		Nav,
    		NavItem,
    		NavLink,
    		NavbarBrand,
    		Dropdown,
    		DropdownToggle,
    		DropdownMenu,
    		DropdownItem,
    		Button,
    		Table,
    		pop,
    		apiData,
    		delay,
    		stats,
    		country,
    		year,
    		average,
    		women,
    		men,
    		economies,
    		percapita,
    		currency,
    		currentprices,
    		loadGraph
    	});

    	$$self.$inject_state = $$props => {
    		if ('apiData' in $$props) apiData = $$props.apiData;
    		if ('stats' in $$props) stats = $$props.stats;
    		if ('country' in $$props) country = $$props.country;
    		if ('year' in $$props) year = $$props.year;
    		if ('average' in $$props) average = $$props.average;
    		if ('women' in $$props) women = $$props.women;
    		if ('men' in $$props) men = $$props.men;
    		if ('economies' in $$props) economies = $$props.economies;
    		if ('percapita' in $$props) percapita = $$props.percapita;
    		if ('currency' in $$props) currency = $$props.currency;
    		if ('currentprices' in $$props) currentprices = $$props.currentprices;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [];
    }

    class IntegrationApi7 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$c, create_fragment$c, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "IntegrationApi7",
    			options,
    			id: create_fragment$c.name
    		});
    	}
    }

    /* src\front\frontEconomies\integrationApi8.svelte generated by Svelte v3.47.0 */

    const { console: console_1$a } = globals;
    const file$b = "src\\front\\frontEconomies\\integrationApi8.svelte";

    // (101:12) <NavbarBrand href="#/info">
    function create_default_slot_22$8(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("INICIO");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_22$8.name,
    		type: "slot",
    		source: "(101:12) <NavbarBrand href=\\\"#/info\\\">",
    		ctx
    	});

    	return block;
    }

    // (104:20) <DropdownToggle nav caret>
    function create_default_slot_21$8(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("API");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_21$8.name,
    		type: "slot",
    		source: "(104:20) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (106:20) <DropdownItem href="./api/v2/economies">
    function create_default_slot_20$8(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_20$8.name,
    		type: "slot",
    		source: "(106:20) <DropdownItem href=\\\"./api/v2/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (108:20) <DropdownItem href="./api/v1/esco-stats">
    function create_default_slot_19$8(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_19$8.name,
    		type: "slot",
    		source: "(108:20) <DropdownItem href=\\\"./api/v1/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (110:20) <DropdownItem href="./api/v1/expo-stats">
    function create_default_slot_18$8(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_18$8.name,
    		type: "slot",
    		source: "(110:20) <DropdownItem href=\\\"./api/v1/expo-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (105:20) <DropdownMenu end>
    function create_default_slot_17$8(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./api/v2/economies",
    				$$slots: { default: [create_default_slot_20$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "./api/v1/esco-stats",
    				$$slots: { default: [create_default_slot_19$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "./api/v1/expo-stats",
    				$$slots: { default: [create_default_slot_18$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17$8.name,
    		type: "slot",
    		source: "(105:20) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (103:16) <Dropdown >
    function create_default_slot_16$8(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_21$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_17$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16$8.name,
    		type: "slot",
    		source: "(103:16) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (115:20) <DropdownToggle nav caret>
    function create_default_slot_15$8(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15$8.name,
    		type: "slot",
    		source: "(115:20) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (117:20) <DropdownItem href="./#/economies">
    function create_default_slot_14$8(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14$8.name,
    		type: "slot",
    		source: "(117:20) <DropdownItem href=\\\"./#/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (118:20) <DropdownItem href="#/esco-stats">
    function create_default_slot_13$8(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13$8.name,
    		type: "slot",
    		source: "(118:20) <DropdownItem href=\\\"#/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (119:20) <DropdownItem href="#/expo">
    function create_default_slot_12$8(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo-Stats FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12$8.name,
    		type: "slot",
    		source: "(119:20) <DropdownItem href=\\\"#/expo\\\">",
    		ctx
    	});

    	return block;
    }

    // (121:20) <DropdownItem href="#/graph">
    function create_default_slot_11$8(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Conjunto");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$8.name,
    		type: "slot",
    		source: "(121:20) <DropdownItem href=\\\"#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (116:20) <DropdownMenu end>
    function create_default_slot_10$8(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies",
    				$$slots: { default: [create_default_slot_14$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({
    			props: {
    				href: "#/esco-stats",
    				$$slots: { default: [create_default_slot_13$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "#/expo",
    				$$slots: { default: [create_default_slot_12$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/graph",
    				$$slots: { default: [create_default_slot_11$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem1_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem1_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem1.$set(dropdownitem1_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$8.name,
    		type: "slot",
    		source: "(116:20) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (114:16) <Dropdown>
    function create_default_slot_9$8(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_15$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_10$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$8.name,
    		type: "slot",
    		source: "(114:16) <Dropdown>",
    		ctx
    	});

    	return block;
    }

    // (126:20) <DropdownToggle nav caret>
    function create_default_slot_8$8(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Gráficas");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$8.name,
    		type: "slot",
    		source: "(126:20) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (128:20) <DropdownItem href="./#/economies-graph">
    function create_default_slot_7$8(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$8.name,
    		type: "slot",
    		source: "(128:20) <DropdownItem href=\\\"./#/economies-graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (129:20) <DropdownItem href="#/graphesco">
    function create_default_slot_6$8(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$8.name,
    		type: "slot",
    		source: "(129:20) <DropdownItem href=\\\"#/graphesco\\\">",
    		ctx
    	});

    	return block;
    }

    // (130:20) <DropdownItem href="#/graphexpo">
    function create_default_slot_5$8(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$8.name,
    		type: "slot",
    		source: "(130:20) <DropdownItem href=\\\"#/graphexpo\\\">",
    		ctx
    	});

    	return block;
    }

    // (132:20) <DropdownItem href="#/graph">
    function create_default_slot_4$8(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Conjunto");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$8.name,
    		type: "slot",
    		source: "(132:20) <DropdownItem href=\\\"#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (127:20) <DropdownMenu end>
    function create_default_slot_3$8(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies-graph",
    				$$slots: { default: [create_default_slot_7$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({
    			props: {
    				href: "#/graphesco",
    				$$slots: { default: [create_default_slot_6$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "#/graphexpo",
    				$$slots: { default: [create_default_slot_5$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/graph",
    				$$slots: { default: [create_default_slot_4$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem1_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem1_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem1.$set(dropdownitem1_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$8.name,
    		type: "slot",
    		source: "(127:20) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (125:16) <Dropdown >
    function create_default_slot_2$8(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_8$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_3$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$8.name,
    		type: "slot",
    		source: "(125:16) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (102:12) <Nav navbar>
    function create_default_slot_1$8(ctx) {
    	let dropdown0;
    	let t0;
    	let dropdown1;
    	let t1;
    	let dropdown2;
    	let current;

    	dropdown0 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_16$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown1 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_9$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown2 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_2$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdown0.$$.fragment);
    			t0 = space();
    			create_component(dropdown1.$$.fragment);
    			t1 = space();
    			create_component(dropdown2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdown0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdown1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdown2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdown0_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdown0_changes.$$scope = { dirty, ctx };
    			}

    			dropdown0.$set(dropdown0_changes);
    			const dropdown1_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdown1_changes.$$scope = { dirty, ctx };
    			}

    			dropdown1.$set(dropdown1_changes);
    			const dropdown2_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				dropdown2_changes.$$scope = { dirty, ctx };
    			}

    			dropdown2.$set(dropdown2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdown0.$$.fragment, local);
    			transition_in(dropdown1.$$.fragment, local);
    			transition_in(dropdown2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdown0.$$.fragment, local);
    			transition_out(dropdown1.$$.fragment, local);
    			transition_out(dropdown2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdown0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdown1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdown2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$8.name,
    		type: "slot",
    		source: "(102:12) <Nav navbar>",
    		ctx
    	});

    	return block;
    }

    // (100:8) <Navbar style="background-color: lightgreen; color:white;" light expand="lg" >
    function create_default_slot$8(ctx) {
    	let navbarbrand;
    	let t;
    	let nav;
    	let current;

    	navbarbrand = new NavbarBrand({
    			props: {
    				href: "#/info",
    				$$slots: { default: [create_default_slot_22$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	nav = new Nav({
    			props: {
    				navbar: true,
    				$$slots: { default: [create_default_slot_1$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navbarbrand.$$.fragment);
    			t = space();
    			create_component(nav.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbarbrand, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(nav, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navbarbrand_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				navbarbrand_changes.$$scope = { dirty, ctx };
    			}

    			navbarbrand.$set(navbarbrand_changes);
    			const nav_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				nav_changes.$$scope = { dirty, ctx };
    			}

    			nav.$set(nav_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbarbrand.$$.fragment, local);
    			transition_in(nav.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbarbrand.$$.fragment, local);
    			transition_out(nav.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbarbrand, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(nav, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$8.name,
    		type: "slot",
    		source: "(100:8) <Navbar style=\\\"background-color: lightgreen; color:white;\\\" light expand=\\\"lg\\\" >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$b(ctx) {
    	let script0;
    	let script0_src_value;
    	let script1;
    	let script1_src_value;
    	let script2;
    	let script2_src_value;
    	let t0;
    	let main;
    	let navbar;
    	let t1;
    	let div;
    	let current;

    	navbar = new Navbar({
    			props: {
    				style: "background-color: lightgreen; color:white;",
    				light: true,
    				expand: "lg",
    				$$slots: { default: [create_default_slot$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			script0 = element$1("script");
    			script1 = element$1("script");
    			script2 = element$1("script");
    			t0 = space();
    			main = element$1("main");
    			create_component(navbar.$$.fragment);
    			t1 = space();
    			div = element$1("div");
    			if (!src_url_equal(script0.src, script0_src_value = "https://d3js.org/d3.v6.min.js")) attr_dev(script0, "src", script0_src_value);
    			add_location(script0, file$b, 90, 8, 3721);
    			if (!src_url_equal(script1.src, script1_src_value = "https://cdnjs.cloudflare.com/ajax/libs/billboard.js/3.4.1/billboard.min.js")) attr_dev(script1, "src", script1_src_value);
    			add_location(script1, file$b, 91, 8, 3784);
    			if (!src_url_equal(script2.src, script2_src_value = "https://cdnjs.cloudflare.com/ajax/libs/billboard.js/3.4.1/billboard.min.css")) attr_dev(script2, "src", script2_src_value);
    			add_location(script2, file$b, 92, 8, 3892);
    			attr_dev(div, "id", "chart");
    			add_location(div, file$b, 141, 8, 6205);
    			add_location(main, file$b, 97, 4, 4039);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			append_dev(document.head, script0);
    			append_dev(document.head, script1);
    			append_dev(document.head, script2);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			mount_component(navbar, main, null);
    			append_dev(main, t1);
    			append_dev(main, div);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const navbar_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				navbar_changes.$$scope = { dirty, ctx };
    			}

    			navbar.$set(navbar_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			detach_dev(script0);
    			detach_dev(script1);
    			detach_dev(script2);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			destroy_component(navbar);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$b($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('IntegrationApi8', slots, []);
    	let apiData = {};
    	const delay = ms => new Promise(res => setTimeout(res, ms));
    	let stats = [];
    	let country = [];
    	let year = [];
    	let primarylevel = ["primarylevel"];
    	let secondarylevel = ["secondarylevel"];
    	let tertiarylevel = ["tertiarylevel"];
    	let economies = [];
    	let percapita = ["percapita"];
    	let currency = ["currency"];
    	let currentprices = ["currentprices"];

    	async function loadGraph() {
    		console.log("Fetching stats....");
    		const res1 = await fetch("https://sos2122-31.herokuapp.com/api/v1/registration-stats");
    		const res2 = await fetch("/api/v2/economies");

    		if (res1.ok && res2.ok) {
    			const data = await res1.json();
    			const data2 = await res2.json();
    			stats = data;

    			if (stats.length == 0) {
    				await fetch("https://sos2122-31.herokuapp.com/api/v1/registration-stats/loadInitialData");
    			}

    			console.log("Estadísticas recibidas: " + stats.length);

    			//inicializamos los arrays para mostrar los datos
    			stats.forEach(stat => {
    				country.push(stat.country + "-" + stat.year);
    				year.push(stat.year);
    				primarylevel.push(stat.primarylevel);
    				secondarylevel.push(stat.secondarylevel);
    				tertiarylevel.push(stat.tertiarylevel);
    			});

    			economies = data2;

    			if (economies.length == 0) {
    				await fetch("/api/v2/economies/loadInitialData");
    			}

    			console.log("Recibido: " + economies.length);

    			economies.forEach(economy => {
    				percapita.push(economy.percapita);
    				currency.push(economy.currency);
    				currentprices.push(economy.currentprices);
    			});
    		} else {
    			console.log("Error cargando los datos");
    		}

    		console.log("Comprobando");
    		await delay(500);

    		var chart = bb.generate({
    			data: {
    				axis: { x: { type: "category" } },
    				columns: [],
    				types: {
    					primarylevel: "area", // for ESM specify as: area()
    					tertiarylevel: "area-spline",
    					secondarylevel: "area-spline", // for ESM specify as: areaSpline()
    					percapita: "area-spline",
    					currency: "area-spline",
    					currentprices: "area-spline"
    				}
    			},
    			bindto: "#areaChart"
    		});

    		setTimeout(
    			function () {
    				chart.load({
    					columns: [
    						primarylevel,
    						secondarylevel,
    						tertiarylevel,
    						percapita,
    						currency,
    						currentprices
    					]
    				});
    			},
    			500
    		);
    	}

    	onMount(loadGraph);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$a.warn(`<IntegrationApi8> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		Navbar,
    		Nav,
    		NavItem,
    		NavLink,
    		NavbarBrand,
    		Dropdown,
    		DropdownToggle,
    		DropdownMenu,
    		DropdownItem,
    		Button,
    		Table,
    		pop,
    		apiData,
    		delay,
    		stats,
    		country,
    		year,
    		primarylevel,
    		secondarylevel,
    		tertiarylevel,
    		economies,
    		percapita,
    		currency,
    		currentprices,
    		loadGraph
    	});

    	$$self.$inject_state = $$props => {
    		if ('apiData' in $$props) apiData = $$props.apiData;
    		if ('stats' in $$props) stats = $$props.stats;
    		if ('country' in $$props) country = $$props.country;
    		if ('year' in $$props) year = $$props.year;
    		if ('primarylevel' in $$props) primarylevel = $$props.primarylevel;
    		if ('secondarylevel' in $$props) secondarylevel = $$props.secondarylevel;
    		if ('tertiarylevel' in $$props) tertiarylevel = $$props.tertiarylevel;
    		if ('economies' in $$props) economies = $$props.economies;
    		if ('percapita' in $$props) percapita = $$props.percapita;
    		if ('currency' in $$props) currency = $$props.currency;
    		if ('currentprices' in $$props) currentprices = $$props.currentprices;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [];
    }

    class IntegrationApi8 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$b, create_fragment$b, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "IntegrationApi8",
    			options,
    			id: create_fragment$b.name
    		});
    	}
    }

    /* src\front\expo-stats\integrationAPIpneumonia.svelte generated by Svelte v3.47.0 */

    const { console: console_1$9, document: document_1$1 } = globals;
    const file$a = "src\\front\\expo-stats\\integrationAPIpneumonia.svelte";

    function create_fragment$a(ctx) {
    	let script;
    	let script_src_value;
    	let t0;
    	let main;
    	let h2;
    	let t2;
    	let h4;
    	let t4;
    	let a;
    	let t6;
    	let canvas;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			script = element$1("script");
    			t0 = space();
    			main = element$1("main");
    			h2 = element$1("h2");
    			h2.textContent = "Integracion de API propia y API de Laura grupo 24";
    			t2 = space();
    			h4 = element$1("h4");
    			h4.textContent = "Biblioteca: Chart.js";
    			t4 = space();
    			a = element$1("a");
    			a.textContent = "Volver";
    			t6 = space();
    			canvas = element$1("canvas");
    			if (!src_url_equal(script.src, script_src_value = "https://cdn.jsdelivr.net/npm/chart.js")) attr_dev(script, "src", script_src_value);
    			add_location(script, file$a, 107, 4, 4155);
    			attr_dev(h2, "class", "svelte-1f1idld");
    			add_location(h2, file$a, 113, 4, 4286);
    			attr_dev(h4, "class", "svelte-1f1idld");
    			add_location(h4, file$a, 114, 4, 4350);
    			attr_dev(a, "href", "/#/agriculturalproduction-stats");
    			attr_dev(a, "class", "btn btn-primary btn-lg active");
    			attr_dev(a, "role", "button");
    			attr_dev(a, "aria-pressed", "true");
    			add_location(a, file$a, 117, 4, 4547);
    			attr_dev(canvas, "id", "myChart");
    			add_location(canvas, file$a, 119, 4, 4679);
    			add_location(main, file$a, 112, 0, 4274);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			append_dev(document_1$1.head, script);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			append_dev(main, h2);
    			append_dev(main, t2);
    			append_dev(main, h4);
    			append_dev(main, t4);
    			append_dev(main, a);
    			append_dev(main, t6);
    			append_dev(main, canvas);

    			if (!mounted) {
    				dispose = listen_dev(script, "load", /*loadGraph*/ ctx[0], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$4,
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			detach_dev(script);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('IntegrationAPIpneumonia', slots, []);
    	let apiData = {};
    	const delay = ms => new Promise(res => setTimeout(res, ms));
    	let stats = [];
    	let stats1 = [];
    	let country = [];
    	let tec = ["expo_tec"];
    	let m = ["expo_m"];
    	let bys = ["tot_esco"];
    	let seventy = ["ages_seventy"];
    	let fifty_seventy = ["ages_fifty_seventy"];
    	let zero_fifty = ["ages_zero_fifty"];

    	async function getData() {
    		console.log("Fetching stats....");
    		const res = await fetch("/api/v1/expo");
    		const res1 = await fetch("https://sos2122-24.herokuapp.com/api/v2/pneumonia-stats");

    		if (res.ok && res1.ok) {
    			const data = await res.json();
    			const data1 = await res1.json();
    			stats = data;
    			console.log("Estadísticas recibidas: " + stats.length);

    			//inicializamos los arrays para mostrar los datos
    			stats.forEach(stat => {
    				country.push(stat.country + "-" + stat.year);
    				tec.push(stat.expo_tec);
    				m.push(stat.expo_m);
    				bys.push(stat.tot_esco);
    				seventy.push(0);
    				fifty_seventy.push(0);
    				zero_fifty.push(0);
    			});

    			stats1 = data1;
    			console.log("Estadísticas recibidas: " + stats1.length);

    			//inicializamos los arrays para mostrar los datos
    			stats1.forEach(stat => {
    				country.push(stat.country + "-" + stat.year);
    				seventy.push(stat.ages_seventy);
    				fifty_seventy.push(stat.ages_fifty_seventy);
    				zero_fifty.push(stat.ages_zero_fifty);
    				tec.push(0);
    				m.push(0);
    				bys.push(0);
    			});
    		} else {
    			console.log("Error cargando los datos");
    		}

    		loadGraph();
    		console.log("Comprobando");
    	}

    	async function loadGraph() {
    		var ctx = document.getElementById("myChart").getContext("2d");

    		new Chart(ctx,
    		{
    				type: "bar",
    				data: {
    					labels: country,
    					datasets: [
    						{
    							label: "Muertes 0-50 años",
    							backgroundColor: "rgb(0, 128, 128)",
    							borderColor: "rgb(255, 255, 255)",
    							data: zero_fifty
    						},
    						{
    							label: "Muertes 50-70 años",
    							backgroundColor: "rgb(255, 0 ,0)",
    							borderColor: "rgb(255, 255, 255)",
    							data: fifty_seventy
    						},
    						{
    							label: "Muertes 70 años",
    							backgroundColor: "rgb(255, 255, 0)",
    							borderColor: "rgb(255, 255, 255)",
    							data: seventy
    						},
    						{
    							label: "Exportaciones Tecnológicas",
    							backgroundColor: "#0000FF",
    							borderColor: "#0000FF",
    							data: tec
    						},
    						{
    							label: "Exportaciones Prod. Manufacturados",
    							backgroundColor: "#008000",
    							borderColor: "#008000",
    							data: m
    						},
    						{
    							label: "Exportaciones Bienes y Servicios",
    							backgroundColor: "#ff8000",
    							borderColor: "#ff8000",
    							data: bys
    						}
    					]
    				},
    				options: {}
    			});
    	}

    	onMount(getData);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$9.warn(`<IntegrationAPIpneumonia> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		apiData,
    		delay,
    		stats,
    		stats1,
    		country,
    		tec,
    		m,
    		bys,
    		seventy,
    		fifty_seventy,
    		zero_fifty,
    		getData,
    		loadGraph
    	});

    	$$self.$inject_state = $$props => {
    		if ('apiData' in $$props) apiData = $$props.apiData;
    		if ('stats' in $$props) stats = $$props.stats;
    		if ('stats1' in $$props) stats1 = $$props.stats1;
    		if ('country' in $$props) country = $$props.country;
    		if ('tec' in $$props) tec = $$props.tec;
    		if ('m' in $$props) m = $$props.m;
    		if ('bys' in $$props) bys = $$props.bys;
    		if ('seventy' in $$props) seventy = $$props.seventy;
    		if ('fifty_seventy' in $$props) fifty_seventy = $$props.fifty_seventy;
    		if ('zero_fifty' in $$props) zero_fifty = $$props.zero_fifty;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [loadGraph];
    }

    class IntegrationAPIpneumonia extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$a, create_fragment$a, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "IntegrationAPIpneumonia",
    			options,
    			id: create_fragment$a.name
    		});
    	}
    }

    /* src\front\expo-stats\integrationAPIagricultural.svelte generated by Svelte v3.47.0 */

    const { console: console_1$8, document: document_1 } = globals;
    const file$9 = "src\\front\\expo-stats\\integrationAPIagricultural.svelte";

    function create_fragment$9(ctx) {
    	let script;
    	let script_src_value;
    	let t0;
    	let main;
    	let h2;
    	let t2;
    	let h4;
    	let t4;
    	let a;
    	let t6;
    	let canvas;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			script = element$1("script");
    			t0 = space();
    			main = element$1("main");
    			h2 = element$1("h2");
    			h2.textContent = "Integracion de API propia y API de Laura grupo 24";
    			t2 = space();
    			h4 = element$1("h4");
    			h4.textContent = "Biblioteca: Chart.js";
    			t4 = space();
    			a = element$1("a");
    			a.textContent = "Volver";
    			t6 = space();
    			canvas = element$1("canvas");
    			if (!src_url_equal(script.src, script_src_value = "https://cdn.jsdelivr.net/npm/chart.js")) attr_dev(script, "src", script_src_value);
    			add_location(script, file$9, 108, 4, 4023);
    			attr_dev(h2, "class", "svelte-1f1idld");
    			add_location(h2, file$9, 114, 4, 4154);
    			attr_dev(h4, "class", "svelte-1f1idld");
    			add_location(h4, file$9, 115, 4, 4218);
    			attr_dev(a, "href", "/#/agriculturalproduction-stats");
    			attr_dev(a, "class", "btn btn-primary btn-lg active");
    			attr_dev(a, "role", "button");
    			attr_dev(a, "aria-pressed", "true");
    			add_location(a, file$9, 118, 4, 4415);
    			attr_dev(canvas, "id", "myChart");
    			add_location(canvas, file$9, 120, 4, 4547);
    			add_location(main, file$9, 113, 0, 4142);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			append_dev(document_1.head, script);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			append_dev(main, h2);
    			append_dev(main, t2);
    			append_dev(main, h4);
    			append_dev(main, t4);
    			append_dev(main, a);
    			append_dev(main, t6);
    			append_dev(main, canvas);

    			if (!mounted) {
    				dispose = listen_dev(script, "load", /*loadGraph*/ ctx[0], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$4,
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			detach_dev(script);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('IntegrationAPIagricultural', slots, []);
    	let apiData = {};
    	const delay = ms => new Promise(res => setTimeout(res, ms));
    	let stats = [];
    	let stats1 = [];
    	let country = [];
    	let tec = ["expo_tec"];
    	let m = ["expo_m"];
    	let bys = ["tot_esco"];
    	let prod = ["production"];
    	let AbsC = ["absolute_change"];
    	let RelC = ["relative_change"];

    	async function getData() {
    		console.log("Fetching stats....");
    		const res = await fetch("/api/v1/expo");
    		const res1 = await fetch("https://sos2122-20.herokuapp.com/api/v1/agriculturalproduction-stats");

    		if (res.ok && res1.ok) {
    			const data = await res.json();
    			const data1 = await res1.json();
    			stats = data;
    			console.log("Estadísticas recibidas: " + stats.length);

    			//inicializamos los arrays para mostrar los datos
    			stats.forEach(stat => {
    				country.push(stat.country + "-" + stat.year);
    				tec.push(stat.expo_tec);
    				m.push(stat.expo_m);
    				bys.push(stat.tot_esco);
    				prod.push(0);
    				AbsC.push(0);
    				RelC.push(0);
    			});

    			stats1 = data1;
    			console.log("Estadísticas recibidas: " + stats1.length);

    			//inicializamos los arrays para mostrar los datos
    			stats1.forEach(stat => {
    				country.push(stat.country + "-" + stat.year);
    				prod.push(stat.production);
    				AbsC.push(stat.absolute_change);
    				RelC.push(stat.relative_change);
    				tec.push(0);
    				m.push(0);
    				bys.push(0);
    			});
    		} else {
    			console.log("Error cargando los datos");
    		}

    		loadGraph();
    		console.log("Comprobando");
    	}

    	async function loadGraph() {
    		var ctx = document.getElementById("myChart").getContext("2d");

    		new Chart(ctx,
    		{
    				type: "bar",
    				data: {
    					labels: country,
    					datasets: [
    						{
    							label: "Produccion",
    							backgroundColor: "#1111FF",
    							borderColor: "#1111FF",
    							data: prod
    						},
    						{
    							label: "Cambio Absoluto",
    							backgroundColor: "#007100",
    							borderColor: "#007100",
    							data: AbsC
    						},
    						{
    							label: "Cambio Relativo",
    							backgroundColor: "#ff9100",
    							borderColor: "#ff9100",
    							data: RelC
    						},
    						{
    							label: "Exportaciones Tecnológicas",
    							backgroundColor: "#0000FF",
    							borderColor: "#0000FF",
    							data: tec
    						},
    						{
    							label: "Exportaciones Prod. Manufacturados",
    							backgroundColor: "#008000",
    							borderColor: "#008000",
    							data: m
    						},
    						{
    							label: "Exportaciones Bienes y Servicios",
    							backgroundColor: "#ff8000",
    							borderColor: "#ff8000",
    							data: bys
    						}
    					]
    				},
    				options: {}
    			});
    	}

    	onMount(getData);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$8.warn(`<IntegrationAPIagricultural> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		apiData,
    		delay,
    		stats,
    		stats1,
    		country,
    		tec,
    		m,
    		bys,
    		prod,
    		AbsC,
    		RelC,
    		getData,
    		loadGraph
    	});

    	$$self.$inject_state = $$props => {
    		if ('apiData' in $$props) apiData = $$props.apiData;
    		if ('stats' in $$props) stats = $$props.stats;
    		if ('stats1' in $$props) stats1 = $$props.stats1;
    		if ('country' in $$props) country = $$props.country;
    		if ('tec' in $$props) tec = $$props.tec;
    		if ('m' in $$props) m = $$props.m;
    		if ('bys' in $$props) bys = $$props.bys;
    		if ('prod' in $$props) prod = $$props.prod;
    		if ('AbsC' in $$props) AbsC = $$props.AbsC;
    		if ('RelC' in $$props) RelC = $$props.RelC;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [loadGraph];
    }

    class IntegrationAPIagricultural extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$9, create_fragment$9, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "IntegrationAPIagricultural",
    			options,
    			id: create_fragment$9.name
    		});
    	}
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function getAugmentedNamespace(n) {
    	if (n.__esModule) return n;
    	var a = Object.defineProperty({}, '__esModule', {value: true});
    	Object.keys(n).forEach(function (k) {
    		var d = Object.getOwnPropertyDescriptor(n, k);
    		Object.defineProperty(a, k, d.get ? d : {
    			enumerable: true,
    			get: function () {
    				return n[k];
    			}
    		});
    	});
    	return a;
    }

    function createCommonjsModule(fn) {
      var module = { exports: {} };
    	return fn(module, module.exports), module.exports;
    }

    function commonjsRequire (target) {
    	throw new Error('Could not dynamically require "' + target + '". Please configure the dynamicRequireTargets option of @rollup/plugin-commonjs appropriately for this require call to behave properly.');
    }

    var version = "5.16.0";

    function ascending$3(a, b) {
      return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function bisector(compare) {
      if (compare.length === 1) compare = ascendingComparator(compare);
      return {
        left: function(a, x, lo, hi) {
          if (lo == null) lo = 0;
          if (hi == null) hi = a.length;
          while (lo < hi) {
            var mid = lo + hi >>> 1;
            if (compare(a[mid], x) < 0) lo = mid + 1;
            else hi = mid;
          }
          return lo;
        },
        right: function(a, x, lo, hi) {
          if (lo == null) lo = 0;
          if (hi == null) hi = a.length;
          while (lo < hi) {
            var mid = lo + hi >>> 1;
            if (compare(a[mid], x) > 0) hi = mid;
            else lo = mid + 1;
          }
          return lo;
        }
      };
    }

    function ascendingComparator(f) {
      return function(d, x) {
        return ascending$3(f(d), x);
      };
    }

    var ascendingBisect = bisector(ascending$3);
    var bisectRight = ascendingBisect.right;
    var bisectLeft = ascendingBisect.left;

    function pairs(array, f) {
      if (f == null) f = pair;
      var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);
      while (i < n) pairs[i] = f(p, p = array[++i]);
      return pairs;
    }

    function pair(a, b) {
      return [a, b];
    }

    function cross$2(values0, values1, reduce) {
      var n0 = values0.length,
          n1 = values1.length,
          values = new Array(n0 * n1),
          i0,
          i1,
          i,
          value0;

      if (reduce == null) reduce = pair;

      for (i0 = i = 0; i0 < n0; ++i0) {
        for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {
          values[i] = reduce(value0, values1[i1]);
        }
      }

      return values;
    }

    function descending$2(a, b) {
      return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
    }

    function number$3(x) {
      return x === null ? NaN : +x;
    }

    function variance(values, valueof) {
      var n = values.length,
          m = 0,
          i = -1,
          mean = 0,
          value,
          delta,
          sum = 0;

      if (valueof == null) {
        while (++i < n) {
          if (!isNaN(value = number$3(values[i]))) {
            delta = value - mean;
            mean += delta / ++m;
            sum += delta * (value - mean);
          }
        }
      }

      else {
        while (++i < n) {
          if (!isNaN(value = number$3(valueof(values[i], i, values)))) {
            delta = value - mean;
            mean += delta / ++m;
            sum += delta * (value - mean);
          }
        }
      }

      if (m > 1) return sum / (m - 1);
    }

    function deviation(array, f) {
      var v = variance(array, f);
      return v ? Math.sqrt(v) : v;
    }

    function extent$1(values, valueof) {
      var n = values.length,
          i = -1,
          value,
          min,
          max;

      if (valueof == null) {
        while (++i < n) { // Find the first comparable value.
          if ((value = values[i]) != null && value >= value) {
            min = max = value;
            while (++i < n) { // Compare the remaining values.
              if ((value = values[i]) != null) {
                if (min > value) min = value;
                if (max < value) max = value;
              }
            }
          }
        }
      }

      else {
        while (++i < n) { // Find the first comparable value.
          if ((value = valueof(values[i], i, values)) != null && value >= value) {
            min = max = value;
            while (++i < n) { // Compare the remaining values.
              if ((value = valueof(values[i], i, values)) != null) {
                if (min > value) min = value;
                if (max < value) max = value;
              }
            }
          }
        }
      }

      return [min, max];
    }

    var array$3 = Array.prototype;

    var slice$6 = array$3.slice;
    var map$3 = array$3.map;

    function constant$d(x) {
      return function() {
        return x;
      };
    }

    function identity$9(x) {
      return x;
    }

    function sequence(start, stop, step) {
      start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

      var i = -1,
          n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
          range = new Array(n);

      while (++i < n) {
        range[i] = start + i * step;
      }

      return range;
    }

    var e10 = Math.sqrt(50),
        e5 = Math.sqrt(10),
        e2 = Math.sqrt(2);

    function ticks(start, stop, count) {
      var reverse,
          i = -1,
          n,
          ticks,
          step;

      stop = +stop, start = +start, count = +count;
      if (start === stop && count > 0) return [start];
      if (reverse = stop < start) n = start, start = stop, stop = n;
      if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

      if (step > 0) {
        start = Math.ceil(start / step);
        stop = Math.floor(stop / step);
        ticks = new Array(n = Math.ceil(stop - start + 1));
        while (++i < n) ticks[i] = (start + i) * step;
      } else {
        start = Math.floor(start * step);
        stop = Math.ceil(stop * step);
        ticks = new Array(n = Math.ceil(start - stop + 1));
        while (++i < n) ticks[i] = (start - i) / step;
      }

      if (reverse) ticks.reverse();

      return ticks;
    }

    function tickIncrement(start, stop, count) {
      var step = (stop - start) / Math.max(0, count),
          power = Math.floor(Math.log(step) / Math.LN10),
          error = step / Math.pow(10, power);
      return power >= 0
          ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
          : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
    }

    function tickStep(start, stop, count) {
      var step0 = Math.abs(stop - start) / Math.max(0, count),
          step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
          error = step0 / step1;
      if (error >= e10) step1 *= 10;
      else if (error >= e5) step1 *= 5;
      else if (error >= e2) step1 *= 2;
      return stop < start ? -step1 : step1;
    }

    function thresholdSturges(values) {
      return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
    }

    function histogram() {
      var value = identity$9,
          domain = extent$1,
          threshold = thresholdSturges;

      function histogram(data) {
        var i,
            n = data.length,
            x,
            values = new Array(n);

        for (i = 0; i < n; ++i) {
          values[i] = value(data[i], i, data);
        }

        var xz = domain(values),
            x0 = xz[0],
            x1 = xz[1],
            tz = threshold(values, x0, x1);

        // Convert number of thresholds into uniform thresholds.
        if (!Array.isArray(tz)) {
          tz = tickStep(x0, x1, tz);
          tz = sequence(Math.ceil(x0 / tz) * tz, x1, tz); // exclusive
        }

        // Remove any thresholds outside the domain.
        var m = tz.length;
        while (tz[0] <= x0) tz.shift(), --m;
        while (tz[m - 1] > x1) tz.pop(), --m;

        var bins = new Array(m + 1),
            bin;

        // Initialize bins.
        for (i = 0; i <= m; ++i) {
          bin = bins[i] = [];
          bin.x0 = i > 0 ? tz[i - 1] : x0;
          bin.x1 = i < m ? tz[i] : x1;
        }

        // Assign data to bins by value, ignoring any outside the domain.
        for (i = 0; i < n; ++i) {
          x = values[i];
          if (x0 <= x && x <= x1) {
            bins[bisectRight(tz, x, 0, m)].push(data[i]);
          }
        }

        return bins;
      }

      histogram.value = function(_) {
        return arguments.length ? (value = typeof _ === "function" ? _ : constant$d(_), histogram) : value;
      };

      histogram.domain = function(_) {
        return arguments.length ? (domain = typeof _ === "function" ? _ : constant$d([_[0], _[1]]), histogram) : domain;
      };

      histogram.thresholds = function(_) {
        return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant$d(slice$6.call(_)) : constant$d(_), histogram) : threshold;
      };

      return histogram;
    }

    function threshold$1(values, p, valueof) {
      if (valueof == null) valueof = number$3;
      if (!(n = values.length)) return;
      if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
      if (p >= 1) return +valueof(values[n - 1], n - 1, values);
      var n,
          i = (n - 1) * p,
          i0 = Math.floor(i),
          value0 = +valueof(values[i0], i0, values),
          value1 = +valueof(values[i0 + 1], i0 + 1, values);
      return value0 + (value1 - value0) * (i - i0);
    }

    function freedmanDiaconis(values, min, max) {
      values = map$3.call(values, number$3).sort(ascending$3);
      return Math.ceil((max - min) / (2 * (threshold$1(values, 0.75) - threshold$1(values, 0.25)) * Math.pow(values.length, -1 / 3)));
    }

    function scott(values, min, max) {
      return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));
    }

    function max$2(values, valueof) {
      var n = values.length,
          i = -1,
          value,
          max;

      if (valueof == null) {
        while (++i < n) { // Find the first comparable value.
          if ((value = values[i]) != null && value >= value) {
            max = value;
            while (++i < n) { // Compare the remaining values.
              if ((value = values[i]) != null && value > max) {
                max = value;
              }
            }
          }
        }
      }

      else {
        while (++i < n) { // Find the first comparable value.
          if ((value = valueof(values[i], i, values)) != null && value >= value) {
            max = value;
            while (++i < n) { // Compare the remaining values.
              if ((value = valueof(values[i], i, values)) != null && value > max) {
                max = value;
              }
            }
          }
        }
      }

      return max;
    }

    function mean(values, valueof) {
      var n = values.length,
          m = n,
          i = -1,
          value,
          sum = 0;

      if (valueof == null) {
        while (++i < n) {
          if (!isNaN(value = number$3(values[i]))) sum += value;
          else --m;
        }
      }

      else {
        while (++i < n) {
          if (!isNaN(value = number$3(valueof(values[i], i, values)))) sum += value;
          else --m;
        }
      }

      if (m) return sum / m;
    }

    function median(values, valueof) {
      var n = values.length,
          i = -1,
          value,
          numbers = [];

      if (valueof == null) {
        while (++i < n) {
          if (!isNaN(value = number$3(values[i]))) {
            numbers.push(value);
          }
        }
      }

      else {
        while (++i < n) {
          if (!isNaN(value = number$3(valueof(values[i], i, values)))) {
            numbers.push(value);
          }
        }
      }

      return threshold$1(numbers.sort(ascending$3), 0.5);
    }

    function merge(arrays) {
      var n = arrays.length,
          m,
          i = -1,
          j = 0,
          merged,
          array;

      while (++i < n) j += arrays[i].length;
      merged = new Array(j);

      while (--n >= 0) {
        array = arrays[n];
        m = array.length;
        while (--m >= 0) {
          merged[--j] = array[m];
        }
      }

      return merged;
    }

    function min$1(values, valueof) {
      var n = values.length,
          i = -1,
          value,
          min;

      if (valueof == null) {
        while (++i < n) { // Find the first comparable value.
          if ((value = values[i]) != null && value >= value) {
            min = value;
            while (++i < n) { // Compare the remaining values.
              if ((value = values[i]) != null && min > value) {
                min = value;
              }
            }
          }
        }
      }

      else {
        while (++i < n) { // Find the first comparable value.
          if ((value = valueof(values[i], i, values)) != null && value >= value) {
            min = value;
            while (++i < n) { // Compare the remaining values.
              if ((value = valueof(values[i], i, values)) != null && min > value) {
                min = value;
              }
            }
          }
        }
      }

      return min;
    }

    function permute(array, indexes) {
      var i = indexes.length, permutes = new Array(i);
      while (i--) permutes[i] = array[indexes[i]];
      return permutes;
    }

    function scan(values, compare) {
      if (!(n = values.length)) return;
      var n,
          i = 0,
          j = 0,
          xi,
          xj = values[j];

      if (compare == null) compare = ascending$3;

      while (++i < n) {
        if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {
          xj = xi, j = i;
        }
      }

      if (compare(xj, xj) === 0) return j;
    }

    function shuffle$1(array, i0, i1) {
      var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
          t,
          i;

      while (m) {
        i = Math.random() * m-- | 0;
        t = array[m + i0];
        array[m + i0] = array[i + i0];
        array[i + i0] = t;
      }

      return array;
    }

    function sum$2(values, valueof) {
      var n = values.length,
          i = -1,
          value,
          sum = 0;

      if (valueof == null) {
        while (++i < n) {
          if (value = +values[i]) sum += value; // Note: zero and null are equivalent.
        }
      }

      else {
        while (++i < n) {
          if (value = +valueof(values[i], i, values)) sum += value;
        }
      }

      return sum;
    }

    function transpose(matrix) {
      if (!(n = matrix.length)) return [];
      for (var i = -1, m = min$1(matrix, length$2), transpose = new Array(m); ++i < m;) {
        for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
          row[j] = matrix[j][i];
        }
      }
      return transpose;
    }

    function length$2(d) {
      return d.length;
    }

    function zip() {
      return transpose(arguments);
    }

    var slice$5 = Array.prototype.slice;

    function identity$8(x) {
      return x;
    }

    var top = 1,
        right = 2,
        bottom = 3,
        left = 4,
        epsilon$4 = 1e-6;

    function translateX(x) {
      return "translate(" + (x + 0.5) + ",0)";
    }

    function translateY(y) {
      return "translate(0," + (y + 0.5) + ")";
    }

    function number$2(scale) {
      return function(d) {
        return +scale(d);
      };
    }

    function center$1(scale) {
      var offset = Math.max(0, scale.bandwidth() - 1) / 2; // Adjust for 0.5px offset.
      if (scale.round()) offset = Math.round(offset);
      return function(d) {
        return +scale(d) + offset;
      };
    }

    function entering() {
      return !this.__axis;
    }

    function axis(orient, scale) {
      var tickArguments = [],
          tickValues = null,
          tickFormat = null,
          tickSizeInner = 6,
          tickSizeOuter = 6,
          tickPadding = 3,
          k = orient === top || orient === left ? -1 : 1,
          x = orient === left || orient === right ? "x" : "y",
          transform = orient === top || orient === bottom ? translateX : translateY;

      function axis(context) {
        var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues,
            format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity$8) : tickFormat,
            spacing = Math.max(tickSizeInner, 0) + tickPadding,
            range = scale.range(),
            range0 = +range[0] + 0.5,
            range1 = +range[range.length - 1] + 0.5,
            position = (scale.bandwidth ? center$1 : number$2)(scale.copy()),
            selection = context.selection ? context.selection() : context,
            path = selection.selectAll(".domain").data([null]),
            tick = selection.selectAll(".tick").data(values, scale).order(),
            tickExit = tick.exit(),
            tickEnter = tick.enter().append("g").attr("class", "tick"),
            line = tick.select("line"),
            text = tick.select("text");

        path = path.merge(path.enter().insert("path", ".tick")
            .attr("class", "domain")
            .attr("stroke", "currentColor"));

        tick = tick.merge(tickEnter);

        line = line.merge(tickEnter.append("line")
            .attr("stroke", "currentColor")
            .attr(x + "2", k * tickSizeInner));

        text = text.merge(tickEnter.append("text")
            .attr("fill", "currentColor")
            .attr(x, k * spacing)
            .attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));

        if (context !== selection) {
          path = path.transition(context);
          tick = tick.transition(context);
          line = line.transition(context);
          text = text.transition(context);

          tickExit = tickExit.transition(context)
              .attr("opacity", epsilon$4)
              .attr("transform", function(d) { return isFinite(d = position(d)) ? transform(d) : this.getAttribute("transform"); });

          tickEnter
              .attr("opacity", epsilon$4)
              .attr("transform", function(d) { var p = this.parentNode.__axis; return transform(p && isFinite(p = p(d)) ? p : position(d)); });
        }

        tickExit.remove();

        path
            .attr("d", orient === left || orient == right
                ? (tickSizeOuter ? "M" + k * tickSizeOuter + "," + range0 + "H0.5V" + range1 + "H" + k * tickSizeOuter : "M0.5," + range0 + "V" + range1)
                : (tickSizeOuter ? "M" + range0 + "," + k * tickSizeOuter + "V0.5H" + range1 + "V" + k * tickSizeOuter : "M" + range0 + ",0.5H" + range1));

        tick
            .attr("opacity", 1)
            .attr("transform", function(d) { return transform(position(d)); });

        line
            .attr(x + "2", k * tickSizeInner);

        text
            .attr(x, k * spacing)
            .text(format);

        selection.filter(entering)
            .attr("fill", "none")
            .attr("font-size", 10)
            .attr("font-family", "sans-serif")
            .attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");

        selection
            .each(function() { this.__axis = position; });
      }

      axis.scale = function(_) {
        return arguments.length ? (scale = _, axis) : scale;
      };

      axis.ticks = function() {
        return tickArguments = slice$5.call(arguments), axis;
      };

      axis.tickArguments = function(_) {
        return arguments.length ? (tickArguments = _ == null ? [] : slice$5.call(_), axis) : tickArguments.slice();
      };

      axis.tickValues = function(_) {
        return arguments.length ? (tickValues = _ == null ? null : slice$5.call(_), axis) : tickValues && tickValues.slice();
      };

      axis.tickFormat = function(_) {
        return arguments.length ? (tickFormat = _, axis) : tickFormat;
      };

      axis.tickSize = function(_) {
        return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;
      };

      axis.tickSizeInner = function(_) {
        return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;
      };

      axis.tickSizeOuter = function(_) {
        return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;
      };

      axis.tickPadding = function(_) {
        return arguments.length ? (tickPadding = +_, axis) : tickPadding;
      };

      return axis;
    }

    function axisTop(scale) {
      return axis(top, scale);
    }

    function axisRight(scale) {
      return axis(right, scale);
    }

    function axisBottom(scale) {
      return axis(bottom, scale);
    }

    function axisLeft(scale) {
      return axis(left, scale);
    }

    var noop$3 = {value: function() {}};

    function dispatch() {
      for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
        if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
        _[t] = [];
      }
      return new Dispatch(_);
    }

    function Dispatch(_) {
      this._ = _;
    }

    function parseTypenames$1(typenames, types) {
      return typenames.trim().split(/^|\s+/).map(function(t) {
        var name = "", i = t.indexOf(".");
        if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
        if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
        return {type: t, name: name};
      });
    }

    Dispatch.prototype = dispatch.prototype = {
      constructor: Dispatch,
      on: function(typename, callback) {
        var _ = this._,
            T = parseTypenames$1(typename + "", _),
            t,
            i = -1,
            n = T.length;

        // If no callback was specified, return the callback of the given type and name.
        if (arguments.length < 2) {
          while (++i < n) if ((t = (typename = T[i]).type) && (t = get$1(_[t], typename.name))) return t;
          return;
        }

        // If a type was specified, set the callback for the given type and name.
        // Otherwise, if a null callback was specified, remove callbacks of the given name.
        if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
        while (++i < n) {
          if (t = (typename = T[i]).type) _[t] = set$2(_[t], typename.name, callback);
          else if (callback == null) for (t in _) _[t] = set$2(_[t], typename.name, null);
        }

        return this;
      },
      copy: function() {
        var copy = {}, _ = this._;
        for (var t in _) copy[t] = _[t].slice();
        return new Dispatch(copy);
      },
      call: function(type, that) {
        if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
        if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
        for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
      },
      apply: function(type, that, args) {
        if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
        for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
      }
    };

    function get$1(type, name) {
      for (var i = 0, n = type.length, c; i < n; ++i) {
        if ((c = type[i]).name === name) {
          return c.value;
        }
      }
    }

    function set$2(type, name, callback) {
      for (var i = 0, n = type.length; i < n; ++i) {
        if (type[i].name === name) {
          type[i] = noop$3, type = type.slice(0, i).concat(type.slice(i + 1));
          break;
        }
      }
      if (callback != null) type.push({name: name, value: callback});
      return type;
    }

    var xhtml = "http://www.w3.org/1999/xhtml";

    var namespaces = {
      svg: "http://www.w3.org/2000/svg",
      xhtml: xhtml,
      xlink: "http://www.w3.org/1999/xlink",
      xml: "http://www.w3.org/XML/1998/namespace",
      xmlns: "http://www.w3.org/2000/xmlns/"
    };

    function namespace(name) {
      var prefix = name += "", i = prefix.indexOf(":");
      if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
      return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name;
    }

    function creatorInherit(name) {
      return function() {
        var document = this.ownerDocument,
            uri = this.namespaceURI;
        return uri === xhtml && document.documentElement.namespaceURI === xhtml
            ? document.createElement(name)
            : document.createElementNS(uri, name);
      };
    }

    function creatorFixed(fullname) {
      return function() {
        return this.ownerDocument.createElementNS(fullname.space, fullname.local);
      };
    }

    function creator(name) {
      var fullname = namespace(name);
      return (fullname.local
          ? creatorFixed
          : creatorInherit)(fullname);
    }

    function none$2() {}

    function selector(selector) {
      return selector == null ? none$2 : function() {
        return this.querySelector(selector);
      };
    }

    function selection_select(select) {
      if (typeof select !== "function") select = selector(select);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
          if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
            if ("__data__" in node) subnode.__data__ = node.__data__;
            subgroup[i] = subnode;
          }
        }
      }

      return new Selection$1(subgroups, this._parents);
    }

    function empty$1() {
      return [];
    }

    function selectorAll(selector) {
      return selector == null ? empty$1 : function() {
        return this.querySelectorAll(selector);
      };
    }

    function selection_selectAll(select) {
      if (typeof select !== "function") select = selectorAll(select);

      for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            subgroups.push(select.call(node, node.__data__, i, group));
            parents.push(node);
          }
        }
      }

      return new Selection$1(subgroups, parents);
    }

    function matcher(selector) {
      return function() {
        return this.matches(selector);
      };
    }

    function selection_filter(match) {
      if (typeof match !== "function") match = matcher(match);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
          if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
            subgroup.push(node);
          }
        }
      }

      return new Selection$1(subgroups, this._parents);
    }

    function sparse(update) {
      return new Array(update.length);
    }

    function selection_enter() {
      return new Selection$1(this._enter || this._groups.map(sparse), this._parents);
    }

    function EnterNode(parent, datum) {
      this.ownerDocument = parent.ownerDocument;
      this.namespaceURI = parent.namespaceURI;
      this._next = null;
      this._parent = parent;
      this.__data__ = datum;
    }

    EnterNode.prototype = {
      constructor: EnterNode,
      appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
      insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
      querySelector: function(selector) { return this._parent.querySelector(selector); },
      querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
    };

    function constant$c(x) {
      return function() {
        return x;
      };
    }

    var keyPrefix$1 = "$"; // Protect against keys like “__proto__”.

    function bindIndex(parent, group, enter, update, exit, data) {
      var i = 0,
          node,
          groupLength = group.length,
          dataLength = data.length;

      // Put any non-null nodes that fit into update.
      // Put any null nodes into enter.
      // Put any remaining data into enter.
      for (; i < dataLength; ++i) {
        if (node = group[i]) {
          node.__data__ = data[i];
          update[i] = node;
        } else {
          enter[i] = new EnterNode(parent, data[i]);
        }
      }

      // Put any non-null nodes that don’t fit into exit.
      for (; i < groupLength; ++i) {
        if (node = group[i]) {
          exit[i] = node;
        }
      }
    }

    function bindKey(parent, group, enter, update, exit, data, key) {
      var i,
          node,
          nodeByKeyValue = {},
          groupLength = group.length,
          dataLength = data.length,
          keyValues = new Array(groupLength),
          keyValue;

      // Compute the key for each node.
      // If multiple nodes have the same key, the duplicates are added to exit.
      for (i = 0; i < groupLength; ++i) {
        if (node = group[i]) {
          keyValues[i] = keyValue = keyPrefix$1 + key.call(node, node.__data__, i, group);
          if (keyValue in nodeByKeyValue) {
            exit[i] = node;
          } else {
            nodeByKeyValue[keyValue] = node;
          }
        }
      }

      // Compute the key for each datum.
      // If there a node associated with this key, join and add it to update.
      // If there is not (or the key is a duplicate), add it to enter.
      for (i = 0; i < dataLength; ++i) {
        keyValue = keyPrefix$1 + key.call(parent, data[i], i, data);
        if (node = nodeByKeyValue[keyValue]) {
          update[i] = node;
          node.__data__ = data[i];
          nodeByKeyValue[keyValue] = null;
        } else {
          enter[i] = new EnterNode(parent, data[i]);
        }
      }

      // Add any remaining nodes that were not bound to data to exit.
      for (i = 0; i < groupLength; ++i) {
        if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
          exit[i] = node;
        }
      }
    }

    function selection_data(value, key) {
      if (!value) {
        data = new Array(this.size()), j = -1;
        this.each(function(d) { data[++j] = d; });
        return data;
      }

      var bind = key ? bindKey : bindIndex,
          parents = this._parents,
          groups = this._groups;

      if (typeof value !== "function") value = constant$c(value);

      for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
        var parent = parents[j],
            group = groups[j],
            groupLength = group.length,
            data = value.call(parent, parent && parent.__data__, j, parents),
            dataLength = data.length,
            enterGroup = enter[j] = new Array(dataLength),
            updateGroup = update[j] = new Array(dataLength),
            exitGroup = exit[j] = new Array(groupLength);

        bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

        // Now connect the enter nodes to their following update node, such that
        // appendChild can insert the materialized enter node before this node,
        // rather than at the end of the parent node.
        for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
          if (previous = enterGroup[i0]) {
            if (i0 >= i1) i1 = i0 + 1;
            while (!(next = updateGroup[i1]) && ++i1 < dataLength);
            previous._next = next || null;
          }
        }
      }

      update = new Selection$1(update, parents);
      update._enter = enter;
      update._exit = exit;
      return update;
    }

    function selection_exit() {
      return new Selection$1(this._exit || this._groups.map(sparse), this._parents);
    }

    function selection_join(onenter, onupdate, onexit) {
      var enter = this.enter(), update = this, exit = this.exit();
      enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
      if (onupdate != null) update = onupdate(update);
      if (onexit == null) exit.remove(); else onexit(exit);
      return enter && update ? enter.merge(update).order() : update;
    }

    function selection_merge(selection) {

      for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group0[i] || group1[i]) {
            merge[i] = node;
          }
        }
      }

      for (; j < m0; ++j) {
        merges[j] = groups0[j];
      }

      return new Selection$1(merges, this._parents);
    }

    function selection_order() {

      for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
        for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
          if (node = group[i]) {
            if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
            next = node;
          }
        }
      }

      return this;
    }

    function selection_sort(compare) {
      if (!compare) compare = ascending$2;

      function compareNode(a, b) {
        return a && b ? compare(a.__data__, b.__data__) : !a - !b;
      }

      for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            sortgroup[i] = node;
          }
        }
        sortgroup.sort(compareNode);
      }

      return new Selection$1(sortgroups, this._parents).order();
    }

    function ascending$2(a, b) {
      return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function selection_call() {
      var callback = arguments[0];
      arguments[0] = this;
      callback.apply(null, arguments);
      return this;
    }

    function selection_nodes() {
      var nodes = new Array(this.size()), i = -1;
      this.each(function() { nodes[++i] = this; });
      return nodes;
    }

    function selection_node() {

      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
          var node = group[i];
          if (node) return node;
        }
      }

      return null;
    }

    function selection_size() {
      var size = 0;
      this.each(function() { ++size; });
      return size;
    }

    function selection_empty() {
      return !this.node();
    }

    function selection_each(callback) {

      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
          if (node = group[i]) callback.call(node, node.__data__, i, group);
        }
      }

      return this;
    }

    function attrRemove$1(name) {
      return function() {
        this.removeAttribute(name);
      };
    }

    function attrRemoveNS$1(fullname) {
      return function() {
        this.removeAttributeNS(fullname.space, fullname.local);
      };
    }

    function attrConstant$1(name, value) {
      return function() {
        this.setAttribute(name, value);
      };
    }

    function attrConstantNS$1(fullname, value) {
      return function() {
        this.setAttributeNS(fullname.space, fullname.local, value);
      };
    }

    function attrFunction$1(name, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) this.removeAttribute(name);
        else this.setAttribute(name, v);
      };
    }

    function attrFunctionNS$1(fullname, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
        else this.setAttributeNS(fullname.space, fullname.local, v);
      };
    }

    function selection_attr(name, value) {
      var fullname = namespace(name);

      if (arguments.length < 2) {
        var node = this.node();
        return fullname.local
            ? node.getAttributeNS(fullname.space, fullname.local)
            : node.getAttribute(fullname);
      }

      return this.each((value == null
          ? (fullname.local ? attrRemoveNS$1 : attrRemove$1) : (typeof value === "function"
          ? (fullname.local ? attrFunctionNS$1 : attrFunction$1)
          : (fullname.local ? attrConstantNS$1 : attrConstant$1)))(fullname, value));
    }

    function defaultView(node) {
      return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
          || (node.document && node) // node is a Window
          || node.defaultView; // node is a Document
    }

    function styleRemove$1(name) {
      return function() {
        this.style.removeProperty(name);
      };
    }

    function styleConstant$1(name, value, priority) {
      return function() {
        this.style.setProperty(name, value, priority);
      };
    }

    function styleFunction$1(name, value, priority) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) this.style.removeProperty(name);
        else this.style.setProperty(name, v, priority);
      };
    }

    function selection_style(name, value, priority) {
      return arguments.length > 1
          ? this.each((value == null
                ? styleRemove$1 : typeof value === "function"
                ? styleFunction$1
                : styleConstant$1)(name, value, priority == null ? "" : priority))
          : styleValue(this.node(), name);
    }

    function styleValue(node, name) {
      return node.style.getPropertyValue(name)
          || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
    }

    function propertyRemove(name) {
      return function() {
        delete this[name];
      };
    }

    function propertyConstant(name, value) {
      return function() {
        this[name] = value;
      };
    }

    function propertyFunction(name, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) delete this[name];
        else this[name] = v;
      };
    }

    function selection_property(name, value) {
      return arguments.length > 1
          ? this.each((value == null
              ? propertyRemove : typeof value === "function"
              ? propertyFunction
              : propertyConstant)(name, value))
          : this.node()[name];
    }

    function classArray(string) {
      return string.trim().split(/^|\s+/);
    }

    function classList(node) {
      return node.classList || new ClassList(node);
    }

    function ClassList(node) {
      this._node = node;
      this._names = classArray(node.getAttribute("class") || "");
    }

    ClassList.prototype = {
      add: function(name) {
        var i = this._names.indexOf(name);
        if (i < 0) {
          this._names.push(name);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      remove: function(name) {
        var i = this._names.indexOf(name);
        if (i >= 0) {
          this._names.splice(i, 1);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      contains: function(name) {
        return this._names.indexOf(name) >= 0;
      }
    };

    function classedAdd(node, names) {
      var list = classList(node), i = -1, n = names.length;
      while (++i < n) list.add(names[i]);
    }

    function classedRemove(node, names) {
      var list = classList(node), i = -1, n = names.length;
      while (++i < n) list.remove(names[i]);
    }

    function classedTrue(names) {
      return function() {
        classedAdd(this, names);
      };
    }

    function classedFalse(names) {
      return function() {
        classedRemove(this, names);
      };
    }

    function classedFunction(names, value) {
      return function() {
        (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
      };
    }

    function selection_classed(name, value) {
      var names = classArray(name + "");

      if (arguments.length < 2) {
        var list = classList(this.node()), i = -1, n = names.length;
        while (++i < n) if (!list.contains(names[i])) return false;
        return true;
      }

      return this.each((typeof value === "function"
          ? classedFunction : value
          ? classedTrue
          : classedFalse)(names, value));
    }

    function textRemove() {
      this.textContent = "";
    }

    function textConstant$1(value) {
      return function() {
        this.textContent = value;
      };
    }

    function textFunction$1(value) {
      return function() {
        var v = value.apply(this, arguments);
        this.textContent = v == null ? "" : v;
      };
    }

    function selection_text(value) {
      return arguments.length
          ? this.each(value == null
              ? textRemove : (typeof value === "function"
              ? textFunction$1
              : textConstant$1)(value))
          : this.node().textContent;
    }

    function htmlRemove() {
      this.innerHTML = "";
    }

    function htmlConstant(value) {
      return function() {
        this.innerHTML = value;
      };
    }

    function htmlFunction(value) {
      return function() {
        var v = value.apply(this, arguments);
        this.innerHTML = v == null ? "" : v;
      };
    }

    function selection_html(value) {
      return arguments.length
          ? this.each(value == null
              ? htmlRemove : (typeof value === "function"
              ? htmlFunction
              : htmlConstant)(value))
          : this.node().innerHTML;
    }

    function raise() {
      if (this.nextSibling) this.parentNode.appendChild(this);
    }

    function selection_raise() {
      return this.each(raise);
    }

    function lower() {
      if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
    }

    function selection_lower() {
      return this.each(lower);
    }

    function selection_append(name) {
      var create = typeof name === "function" ? name : creator(name);
      return this.select(function() {
        return this.appendChild(create.apply(this, arguments));
      });
    }

    function constantNull() {
      return null;
    }

    function selection_insert(name, before) {
      var create = typeof name === "function" ? name : creator(name),
          select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
      return this.select(function() {
        return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
      });
    }

    function remove() {
      var parent = this.parentNode;
      if (parent) parent.removeChild(this);
    }

    function selection_remove() {
      return this.each(remove);
    }

    function selection_cloneShallow() {
      var clone = this.cloneNode(false), parent = this.parentNode;
      return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
    }

    function selection_cloneDeep() {
      var clone = this.cloneNode(true), parent = this.parentNode;
      return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
    }

    function selection_clone(deep) {
      return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
    }

    function selection_datum(value) {
      return arguments.length
          ? this.property("__data__", value)
          : this.node().__data__;
    }

    var filterEvents = {};

    var event = null;

    if (typeof document !== "undefined") {
      var element = document.documentElement;
      if (!("onmouseenter" in element)) {
        filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
      }
    }

    function filterContextListener(listener, index, group) {
      listener = contextListener(listener, index, group);
      return function(event) {
        var related = event.relatedTarget;
        if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
          listener.call(this, event);
        }
      };
    }

    function contextListener(listener, index, group) {
      return function(event1) {
        var event0 = event; // Events can be reentrant (e.g., focus).
        event = event1;
        try {
          listener.call(this, this.__data__, index, group);
        } finally {
          event = event0;
        }
      };
    }

    function parseTypenames(typenames) {
      return typenames.trim().split(/^|\s+/).map(function(t) {
        var name = "", i = t.indexOf(".");
        if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
        return {type: t, name: name};
      });
    }

    function onRemove(typename) {
      return function() {
        var on = this.__on;
        if (!on) return;
        for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
          if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
            this.removeEventListener(o.type, o.listener, o.capture);
          } else {
            on[++i] = o;
          }
        }
        if (++i) on.length = i;
        else delete this.__on;
      };
    }

    function onAdd(typename, value, capture) {
      var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
      return function(d, i, group) {
        var on = this.__on, o, listener = wrap(value, i, group);
        if (on) for (var j = 0, m = on.length; j < m; ++j) {
          if ((o = on[j]).type === typename.type && o.name === typename.name) {
            this.removeEventListener(o.type, o.listener, o.capture);
            this.addEventListener(o.type, o.listener = listener, o.capture = capture);
            o.value = value;
            return;
          }
        }
        this.addEventListener(typename.type, listener, capture);
        o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
        if (!on) this.__on = [o];
        else on.push(o);
      };
    }

    function selection_on(typename, value, capture) {
      var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

      if (arguments.length < 2) {
        var on = this.node().__on;
        if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
          for (i = 0, o = on[j]; i < n; ++i) {
            if ((t = typenames[i]).type === o.type && t.name === o.name) {
              return o.value;
            }
          }
        }
        return;
      }

      on = value ? onAdd : onRemove;
      if (capture == null) capture = false;
      for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
      return this;
    }

    function customEvent(event1, listener, that, args) {
      var event0 = event;
      event1.sourceEvent = event;
      event = event1;
      try {
        return listener.apply(that, args);
      } finally {
        event = event0;
      }
    }

    function dispatchEvent(node, type, params) {
      var window = defaultView(node),
          event = window.CustomEvent;

      if (typeof event === "function") {
        event = new event(type, params);
      } else {
        event = window.document.createEvent("Event");
        if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
        else event.initEvent(type, false, false);
      }

      node.dispatchEvent(event);
    }

    function dispatchConstant(type, params) {
      return function() {
        return dispatchEvent(this, type, params);
      };
    }

    function dispatchFunction(type, params) {
      return function() {
        return dispatchEvent(this, type, params.apply(this, arguments));
      };
    }

    function selection_dispatch(type, params) {
      return this.each((typeof params === "function"
          ? dispatchFunction
          : dispatchConstant)(type, params));
    }

    var root$1 = [null];

    function Selection$1(groups, parents) {
      this._groups = groups;
      this._parents = parents;
    }

    function selection() {
      return new Selection$1([[document.documentElement]], root$1);
    }

    Selection$1.prototype = selection.prototype = {
      constructor: Selection$1,
      select: selection_select,
      selectAll: selection_selectAll,
      filter: selection_filter,
      data: selection_data,
      enter: selection_enter,
      exit: selection_exit,
      join: selection_join,
      merge: selection_merge,
      order: selection_order,
      sort: selection_sort,
      call: selection_call,
      nodes: selection_nodes,
      node: selection_node,
      size: selection_size,
      empty: selection_empty,
      each: selection_each,
      attr: selection_attr,
      style: selection_style,
      property: selection_property,
      classed: selection_classed,
      text: selection_text,
      html: selection_html,
      raise: selection_raise,
      lower: selection_lower,
      append: selection_append,
      insert: selection_insert,
      remove: selection_remove,
      clone: selection_clone,
      datum: selection_datum,
      on: selection_on,
      dispatch: selection_dispatch
    };

    function select(selector) {
      return typeof selector === "string"
          ? new Selection$1([[document.querySelector(selector)]], [document.documentElement])
          : new Selection$1([[selector]], root$1);
    }

    function create$1(name) {
      return select(creator(name).call(document.documentElement));
    }

    var nextId = 0;

    function local$1() {
      return new Local;
    }

    function Local() {
      this._ = "@" + (++nextId).toString(36);
    }

    Local.prototype = local$1.prototype = {
      constructor: Local,
      get: function(node) {
        var id = this._;
        while (!(id in node)) if (!(node = node.parentNode)) return;
        return node[id];
      },
      set: function(node, value) {
        return node[this._] = value;
      },
      remove: function(node) {
        return this._ in node && delete node[this._];
      },
      toString: function() {
        return this._;
      }
    };

    function sourceEvent() {
      var current = event, source;
      while (source = current.sourceEvent) current = source;
      return current;
    }

    function point$5(node, event) {
      var svg = node.ownerSVGElement || node;

      if (svg.createSVGPoint) {
        var point = svg.createSVGPoint();
        point.x = event.clientX, point.y = event.clientY;
        point = point.matrixTransform(node.getScreenCTM().inverse());
        return [point.x, point.y];
      }

      var rect = node.getBoundingClientRect();
      return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
    }

    function mouse(node) {
      var event = sourceEvent();
      if (event.changedTouches) event = event.changedTouches[0];
      return point$5(node, event);
    }

    function selectAll(selector) {
      return typeof selector === "string"
          ? new Selection$1([document.querySelectorAll(selector)], [document.documentElement])
          : new Selection$1([selector == null ? [] : selector], root$1);
    }

    function touch(node, touches, identifier) {
      if (arguments.length < 3) identifier = touches, touches = sourceEvent().changedTouches;

      for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
        if ((touch = touches[i]).identifier === identifier) {
          return point$5(node, touch);
        }
      }

      return null;
    }

    function touches(node, touches) {
      if (touches == null) touches = sourceEvent().touches;

      for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {
        points[i] = point$5(node, touches[i]);
      }

      return points;
    }

    function nopropagation$2() {
      event.stopImmediatePropagation();
    }

    function noevent$2() {
      event.preventDefault();
      event.stopImmediatePropagation();
    }

    function dragDisable(view) {
      var root = view.document.documentElement,
          selection = select(view).on("dragstart.drag", noevent$2, true);
      if ("onselectstart" in root) {
        selection.on("selectstart.drag", noevent$2, true);
      } else {
        root.__noselect = root.style.MozUserSelect;
        root.style.MozUserSelect = "none";
      }
    }

    function yesdrag(view, noclick) {
      var root = view.document.documentElement,
          selection = select(view).on("dragstart.drag", null);
      if (noclick) {
        selection.on("click.drag", noevent$2, true);
        setTimeout(function() { selection.on("click.drag", null); }, 0);
      }
      if ("onselectstart" in root) {
        selection.on("selectstart.drag", null);
      } else {
        root.style.MozUserSelect = root.__noselect;
        delete root.__noselect;
      }
    }

    function constant$b(x) {
      return function() {
        return x;
      };
    }

    function DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch) {
      this.target = target;
      this.type = type;
      this.subject = subject;
      this.identifier = id;
      this.active = active;
      this.x = x;
      this.y = y;
      this.dx = dx;
      this.dy = dy;
      this._ = dispatch;
    }

    DragEvent.prototype.on = function() {
      var value = this._.on.apply(this._, arguments);
      return value === this._ ? this : value;
    };

    // Ignore right-click, since that should open the context menu.
    function defaultFilter$2() {
      return !event.ctrlKey && !event.button;
    }

    function defaultContainer() {
      return this.parentNode;
    }

    function defaultSubject(d) {
      return d == null ? {x: event.x, y: event.y} : d;
    }

    function defaultTouchable$2() {
      return navigator.maxTouchPoints || ("ontouchstart" in this);
    }

    function drag() {
      var filter = defaultFilter$2,
          container = defaultContainer,
          subject = defaultSubject,
          touchable = defaultTouchable$2,
          gestures = {},
          listeners = dispatch("start", "drag", "end"),
          active = 0,
          mousedownx,
          mousedowny,
          mousemoving,
          touchending,
          clickDistance2 = 0;

      function drag(selection) {
        selection
            .on("mousedown.drag", mousedowned)
          .filter(touchable)
            .on("touchstart.drag", touchstarted)
            .on("touchmove.drag", touchmoved)
            .on("touchend.drag touchcancel.drag", touchended)
            .style("touch-action", "none")
            .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
      }

      function mousedowned() {
        if (touchending || !filter.apply(this, arguments)) return;
        var gesture = beforestart("mouse", container.apply(this, arguments), mouse, this, arguments);
        if (!gesture) return;
        select(event.view).on("mousemove.drag", mousemoved, true).on("mouseup.drag", mouseupped, true);
        dragDisable(event.view);
        nopropagation$2();
        mousemoving = false;
        mousedownx = event.clientX;
        mousedowny = event.clientY;
        gesture("start");
      }

      function mousemoved() {
        noevent$2();
        if (!mousemoving) {
          var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
          mousemoving = dx * dx + dy * dy > clickDistance2;
        }
        gestures.mouse("drag");
      }

      function mouseupped() {
        select(event.view).on("mousemove.drag mouseup.drag", null);
        yesdrag(event.view, mousemoving);
        noevent$2();
        gestures.mouse("end");
      }

      function touchstarted() {
        if (!filter.apply(this, arguments)) return;
        var touches = event.changedTouches,
            c = container.apply(this, arguments),
            n = touches.length, i, gesture;

        for (i = 0; i < n; ++i) {
          if (gesture = beforestart(touches[i].identifier, c, touch, this, arguments)) {
            nopropagation$2();
            gesture("start");
          }
        }
      }

      function touchmoved() {
        var touches = event.changedTouches,
            n = touches.length, i, gesture;

        for (i = 0; i < n; ++i) {
          if (gesture = gestures[touches[i].identifier]) {
            noevent$2();
            gesture("drag");
          }
        }
      }

      function touchended() {
        var touches = event.changedTouches,
            n = touches.length, i, gesture;

        if (touchending) clearTimeout(touchending);
        touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
        for (i = 0; i < n; ++i) {
          if (gesture = gestures[touches[i].identifier]) {
            nopropagation$2();
            gesture("end");
          }
        }
      }

      function beforestart(id, container, point, that, args) {
        var p = point(container, id), s, dx, dy,
            sublisteners = listeners.copy();

        if (!customEvent(new DragEvent(drag, "beforestart", s, id, active, p[0], p[1], 0, 0, sublisteners), function() {
          if ((event.subject = s = subject.apply(that, args)) == null) return false;
          dx = s.x - p[0] || 0;
          dy = s.y - p[1] || 0;
          return true;
        })) return;

        return function gesture(type) {
          var p0 = p, n;
          switch (type) {
            case "start": gestures[id] = gesture, n = active++; break;
            case "end": delete gestures[id], --active; // nobreak
            case "drag": p = point(container, id), n = active; break;
          }
          customEvent(new DragEvent(drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]);
        };
      }

      drag.filter = function(_) {
        return arguments.length ? (filter = typeof _ === "function" ? _ : constant$b(!!_), drag) : filter;
      };

      drag.container = function(_) {
        return arguments.length ? (container = typeof _ === "function" ? _ : constant$b(_), drag) : container;
      };

      drag.subject = function(_) {
        return arguments.length ? (subject = typeof _ === "function" ? _ : constant$b(_), drag) : subject;
      };

      drag.touchable = function(_) {
        return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$b(!!_), drag) : touchable;
      };

      drag.on = function() {
        var value = listeners.on.apply(listeners, arguments);
        return value === listeners ? drag : value;
      };

      drag.clickDistance = function(_) {
        return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
      };

      return drag;
    }

    function define(constructor, factory, prototype) {
      constructor.prototype = factory.prototype = prototype;
      prototype.constructor = constructor;
    }

    function extend(parent, definition) {
      var prototype = Object.create(parent.prototype);
      for (var key in definition) prototype[key] = definition[key];
      return prototype;
    }

    function Color() {}

    var darker = 0.7;
    var brighter = 1 / darker;

    var reI = "\\s*([+-]?\\d+)\\s*",
        reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
        reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
        reHex = /^#([0-9a-f]{3,8})$/,
        reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
        reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
        reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
        reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
        reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
        reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

    var named = {
      aliceblue: 0xf0f8ff,
      antiquewhite: 0xfaebd7,
      aqua: 0x00ffff,
      aquamarine: 0x7fffd4,
      azure: 0xf0ffff,
      beige: 0xf5f5dc,
      bisque: 0xffe4c4,
      black: 0x000000,
      blanchedalmond: 0xffebcd,
      blue: 0x0000ff,
      blueviolet: 0x8a2be2,
      brown: 0xa52a2a,
      burlywood: 0xdeb887,
      cadetblue: 0x5f9ea0,
      chartreuse: 0x7fff00,
      chocolate: 0xd2691e,
      coral: 0xff7f50,
      cornflowerblue: 0x6495ed,
      cornsilk: 0xfff8dc,
      crimson: 0xdc143c,
      cyan: 0x00ffff,
      darkblue: 0x00008b,
      darkcyan: 0x008b8b,
      darkgoldenrod: 0xb8860b,
      darkgray: 0xa9a9a9,
      darkgreen: 0x006400,
      darkgrey: 0xa9a9a9,
      darkkhaki: 0xbdb76b,
      darkmagenta: 0x8b008b,
      darkolivegreen: 0x556b2f,
      darkorange: 0xff8c00,
      darkorchid: 0x9932cc,
      darkred: 0x8b0000,
      darksalmon: 0xe9967a,
      darkseagreen: 0x8fbc8f,
      darkslateblue: 0x483d8b,
      darkslategray: 0x2f4f4f,
      darkslategrey: 0x2f4f4f,
      darkturquoise: 0x00ced1,
      darkviolet: 0x9400d3,
      deeppink: 0xff1493,
      deepskyblue: 0x00bfff,
      dimgray: 0x696969,
      dimgrey: 0x696969,
      dodgerblue: 0x1e90ff,
      firebrick: 0xb22222,
      floralwhite: 0xfffaf0,
      forestgreen: 0x228b22,
      fuchsia: 0xff00ff,
      gainsboro: 0xdcdcdc,
      ghostwhite: 0xf8f8ff,
      gold: 0xffd700,
      goldenrod: 0xdaa520,
      gray: 0x808080,
      green: 0x008000,
      greenyellow: 0xadff2f,
      grey: 0x808080,
      honeydew: 0xf0fff0,
      hotpink: 0xff69b4,
      indianred: 0xcd5c5c,
      indigo: 0x4b0082,
      ivory: 0xfffff0,
      khaki: 0xf0e68c,
      lavender: 0xe6e6fa,
      lavenderblush: 0xfff0f5,
      lawngreen: 0x7cfc00,
      lemonchiffon: 0xfffacd,
      lightblue: 0xadd8e6,
      lightcoral: 0xf08080,
      lightcyan: 0xe0ffff,
      lightgoldenrodyellow: 0xfafad2,
      lightgray: 0xd3d3d3,
      lightgreen: 0x90ee90,
      lightgrey: 0xd3d3d3,
      lightpink: 0xffb6c1,
      lightsalmon: 0xffa07a,
      lightseagreen: 0x20b2aa,
      lightskyblue: 0x87cefa,
      lightslategray: 0x778899,
      lightslategrey: 0x778899,
      lightsteelblue: 0xb0c4de,
      lightyellow: 0xffffe0,
      lime: 0x00ff00,
      limegreen: 0x32cd32,
      linen: 0xfaf0e6,
      magenta: 0xff00ff,
      maroon: 0x800000,
      mediumaquamarine: 0x66cdaa,
      mediumblue: 0x0000cd,
      mediumorchid: 0xba55d3,
      mediumpurple: 0x9370db,
      mediumseagreen: 0x3cb371,
      mediumslateblue: 0x7b68ee,
      mediumspringgreen: 0x00fa9a,
      mediumturquoise: 0x48d1cc,
      mediumvioletred: 0xc71585,
      midnightblue: 0x191970,
      mintcream: 0xf5fffa,
      mistyrose: 0xffe4e1,
      moccasin: 0xffe4b5,
      navajowhite: 0xffdead,
      navy: 0x000080,
      oldlace: 0xfdf5e6,
      olive: 0x808000,
      olivedrab: 0x6b8e23,
      orange: 0xffa500,
      orangered: 0xff4500,
      orchid: 0xda70d6,
      palegoldenrod: 0xeee8aa,
      palegreen: 0x98fb98,
      paleturquoise: 0xafeeee,
      palevioletred: 0xdb7093,
      papayawhip: 0xffefd5,
      peachpuff: 0xffdab9,
      peru: 0xcd853f,
      pink: 0xffc0cb,
      plum: 0xdda0dd,
      powderblue: 0xb0e0e6,
      purple: 0x800080,
      rebeccapurple: 0x663399,
      red: 0xff0000,
      rosybrown: 0xbc8f8f,
      royalblue: 0x4169e1,
      saddlebrown: 0x8b4513,
      salmon: 0xfa8072,
      sandybrown: 0xf4a460,
      seagreen: 0x2e8b57,
      seashell: 0xfff5ee,
      sienna: 0xa0522d,
      silver: 0xc0c0c0,
      skyblue: 0x87ceeb,
      slateblue: 0x6a5acd,
      slategray: 0x708090,
      slategrey: 0x708090,
      snow: 0xfffafa,
      springgreen: 0x00ff7f,
      steelblue: 0x4682b4,
      tan: 0xd2b48c,
      teal: 0x008080,
      thistle: 0xd8bfd8,
      tomato: 0xff6347,
      turquoise: 0x40e0d0,
      violet: 0xee82ee,
      wheat: 0xf5deb3,
      white: 0xffffff,
      whitesmoke: 0xf5f5f5,
      yellow: 0xffff00,
      yellowgreen: 0x9acd32
    };

    define(Color, color, {
      copy: function(channels) {
        return Object.assign(new this.constructor, this, channels);
      },
      displayable: function() {
        return this.rgb().displayable();
      },
      hex: color_formatHex, // Deprecated! Use color.formatHex.
      formatHex: color_formatHex,
      formatHsl: color_formatHsl,
      formatRgb: color_formatRgb,
      toString: color_formatRgb
    });

    function color_formatHex() {
      return this.rgb().formatHex();
    }

    function color_formatHsl() {
      return hslConvert(this).formatHsl();
    }

    function color_formatRgb() {
      return this.rgb().formatRgb();
    }

    function color(format) {
      var m, l;
      format = (format + "").trim().toLowerCase();
      return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
          : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
          : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
          : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
          : null) // invalid hex
          : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
          : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
          : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
          : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
          : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
          : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
          : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
          : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
          : null;
    }

    function rgbn(n) {
      return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
    }

    function rgba(r, g, b, a) {
      if (a <= 0) r = g = b = NaN;
      return new Rgb(r, g, b, a);
    }

    function rgbConvert(o) {
      if (!(o instanceof Color)) o = color(o);
      if (!o) return new Rgb;
      o = o.rgb();
      return new Rgb(o.r, o.g, o.b, o.opacity);
    }

    function rgb(r, g, b, opacity) {
      return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
    }

    function Rgb(r, g, b, opacity) {
      this.r = +r;
      this.g = +g;
      this.b = +b;
      this.opacity = +opacity;
    }

    define(Rgb, rgb, extend(Color, {
      brighter: function(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      darker: function(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      rgb: function() {
        return this;
      },
      displayable: function() {
        return (-0.5 <= this.r && this.r < 255.5)
            && (-0.5 <= this.g && this.g < 255.5)
            && (-0.5 <= this.b && this.b < 255.5)
            && (0 <= this.opacity && this.opacity <= 1);
      },
      hex: rgb_formatHex, // Deprecated! Use color.formatHex.
      formatHex: rgb_formatHex,
      formatRgb: rgb_formatRgb,
      toString: rgb_formatRgb
    }));

    function rgb_formatHex() {
      return "#" + hex(this.r) + hex(this.g) + hex(this.b);
    }

    function rgb_formatRgb() {
      var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
      return (a === 1 ? "rgb(" : "rgba(")
          + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
          + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
          + Math.max(0, Math.min(255, Math.round(this.b) || 0))
          + (a === 1 ? ")" : ", " + a + ")");
    }

    function hex(value) {
      value = Math.max(0, Math.min(255, Math.round(value) || 0));
      return (value < 16 ? "0" : "") + value.toString(16);
    }

    function hsla(h, s, l, a) {
      if (a <= 0) h = s = l = NaN;
      else if (l <= 0 || l >= 1) h = s = NaN;
      else if (s <= 0) h = NaN;
      return new Hsl(h, s, l, a);
    }

    function hslConvert(o) {
      if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
      if (!(o instanceof Color)) o = color(o);
      if (!o) return new Hsl;
      if (o instanceof Hsl) return o;
      o = o.rgb();
      var r = o.r / 255,
          g = o.g / 255,
          b = o.b / 255,
          min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          h = NaN,
          s = max - min,
          l = (max + min) / 2;
      if (s) {
        if (r === max) h = (g - b) / s + (g < b) * 6;
        else if (g === max) h = (b - r) / s + 2;
        else h = (r - g) / s + 4;
        s /= l < 0.5 ? max + min : 2 - max - min;
        h *= 60;
      } else {
        s = l > 0 && l < 1 ? 0 : h;
      }
      return new Hsl(h, s, l, o.opacity);
    }

    function hsl$2(h, s, l, opacity) {
      return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
    }

    function Hsl(h, s, l, opacity) {
      this.h = +h;
      this.s = +s;
      this.l = +l;
      this.opacity = +opacity;
    }

    define(Hsl, hsl$2, extend(Color, {
      brighter: function(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      darker: function(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      rgb: function() {
        var h = this.h % 360 + (this.h < 0) * 360,
            s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
            l = this.l,
            m2 = l + (l < 0.5 ? l : 1 - l) * s,
            m1 = 2 * l - m2;
        return new Rgb(
          hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
          hsl2rgb(h, m1, m2),
          hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
          this.opacity
        );
      },
      displayable: function() {
        return (0 <= this.s && this.s <= 1 || isNaN(this.s))
            && (0 <= this.l && this.l <= 1)
            && (0 <= this.opacity && this.opacity <= 1);
      },
      formatHsl: function() {
        var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
        return (a === 1 ? "hsl(" : "hsla(")
            + (this.h || 0) + ", "
            + (this.s || 0) * 100 + "%, "
            + (this.l || 0) * 100 + "%"
            + (a === 1 ? ")" : ", " + a + ")");
      }
    }));

    /* From FvD 13.37, CSS Color Module Level 3 */
    function hsl2rgb(h, m1, m2) {
      return (h < 60 ? m1 + (m2 - m1) * h / 60
          : h < 180 ? m2
          : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
          : m1) * 255;
    }

    var deg2rad = Math.PI / 180;
    var rad2deg = 180 / Math.PI;

    // https://observablehq.com/@mbostock/lab-and-rgb
    var K = 18,
        Xn = 0.96422,
        Yn = 1,
        Zn = 0.82521,
        t0$1 = 4 / 29,
        t1$1 = 6 / 29,
        t2 = 3 * t1$1 * t1$1,
        t3 = t1$1 * t1$1 * t1$1;

    function labConvert(o) {
      if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
      if (o instanceof Hcl) return hcl2lab(o);
      if (!(o instanceof Rgb)) o = rgbConvert(o);
      var r = rgb2lrgb(o.r),
          g = rgb2lrgb(o.g),
          b = rgb2lrgb(o.b),
          y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
      if (r === g && g === b) x = z = y; else {
        x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
        z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
      }
      return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
    }

    function gray(l, opacity) {
      return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
    }

    function lab$1(l, a, b, opacity) {
      return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
    }

    function Lab(l, a, b, opacity) {
      this.l = +l;
      this.a = +a;
      this.b = +b;
      this.opacity = +opacity;
    }

    define(Lab, lab$1, extend(Color, {
      brighter: function(k) {
        return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
      },
      darker: function(k) {
        return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
      },
      rgb: function() {
        var y = (this.l + 16) / 116,
            x = isNaN(this.a) ? y : y + this.a / 500,
            z = isNaN(this.b) ? y : y - this.b / 200;
        x = Xn * lab2xyz(x);
        y = Yn * lab2xyz(y);
        z = Zn * lab2xyz(z);
        return new Rgb(
          lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
          lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
          lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
          this.opacity
        );
      }
    }));

    function xyz2lab(t) {
      return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0$1;
    }

    function lab2xyz(t) {
      return t > t1$1 ? t * t * t : t2 * (t - t0$1);
    }

    function lrgb2rgb(x) {
      return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
    }

    function rgb2lrgb(x) {
      return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
    }

    function hclConvert(o) {
      if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
      if (!(o instanceof Lab)) o = labConvert(o);
      if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
      var h = Math.atan2(o.b, o.a) * rad2deg;
      return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
    }

    function lch(l, c, h, opacity) {
      return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
    }

    function hcl$2(h, c, l, opacity) {
      return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
    }

    function Hcl(h, c, l, opacity) {
      this.h = +h;
      this.c = +c;
      this.l = +l;
      this.opacity = +opacity;
    }

    function hcl2lab(o) {
      if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
      var h = o.h * deg2rad;
      return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
    }

    define(Hcl, hcl$2, extend(Color, {
      brighter: function(k) {
        return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
      },
      darker: function(k) {
        return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
      },
      rgb: function() {
        return hcl2lab(this).rgb();
      }
    }));

    var A = -0.14861,
        B = +1.78277,
        C = -0.29227,
        D = -0.90649,
        E = +1.97294,
        ED = E * D,
        EB = E * B,
        BC_DA = B * C - D * A;

    function cubehelixConvert(o) {
      if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
      if (!(o instanceof Rgb)) o = rgbConvert(o);
      var r = o.r / 255,
          g = o.g / 255,
          b = o.b / 255,
          l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
          bl = b - l,
          k = (E * (g - l) - C * bl) / D,
          s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
          h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
      return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
    }

    function cubehelix$3(h, s, l, opacity) {
      return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
    }

    function Cubehelix(h, s, l, opacity) {
      this.h = +h;
      this.s = +s;
      this.l = +l;
      this.opacity = +opacity;
    }

    define(Cubehelix, cubehelix$3, extend(Color, {
      brighter: function(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
      },
      darker: function(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
      },
      rgb: function() {
        var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,
            l = +this.l,
            a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
            cosh = Math.cos(h),
            sinh = Math.sin(h);
        return new Rgb(
          255 * (l + a * (A * cosh + B * sinh)),
          255 * (l + a * (C * cosh + D * sinh)),
          255 * (l + a * (E * cosh)),
          this.opacity
        );
      }
    }));

    function basis$1(t1, v0, v1, v2, v3) {
      var t2 = t1 * t1, t3 = t2 * t1;
      return ((1 - 3 * t1 + 3 * t2 - t3) * v0
          + (4 - 6 * t2 + 3 * t3) * v1
          + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
          + t3 * v3) / 6;
    }

    function basis$2(values) {
      var n = values.length - 1;
      return function(t) {
        var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
            v1 = values[i],
            v2 = values[i + 1],
            v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
            v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
        return basis$1((t - i / n) * n, v0, v1, v2, v3);
      };
    }

    function basisClosed$1(values) {
      var n = values.length;
      return function(t) {
        var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
            v0 = values[(i + n - 1) % n],
            v1 = values[i % n],
            v2 = values[(i + 1) % n],
            v3 = values[(i + 2) % n];
        return basis$1((t - i / n) * n, v0, v1, v2, v3);
      };
    }

    function constant$a(x) {
      return function() {
        return x;
      };
    }

    function linear$2(a, d) {
      return function(t) {
        return a + t * d;
      };
    }

    function exponential$1(a, b, y) {
      return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
        return Math.pow(a + t * b, y);
      };
    }

    function hue$1(a, b) {
      var d = b - a;
      return d ? linear$2(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant$a(isNaN(a) ? b : a);
    }

    function gamma(y) {
      return (y = +y) === 1 ? nogamma : function(a, b) {
        return b - a ? exponential$1(a, b, y) : constant$a(isNaN(a) ? b : a);
      };
    }

    function nogamma(a, b) {
      var d = b - a;
      return d ? linear$2(a, d) : constant$a(isNaN(a) ? b : a);
    }

    var interpolateRgb = (function rgbGamma(y) {
      var color = gamma(y);

      function rgb$1(start, end) {
        var r = color((start = rgb(start)).r, (end = rgb(end)).r),
            g = color(start.g, end.g),
            b = color(start.b, end.b),
            opacity = nogamma(start.opacity, end.opacity);
        return function(t) {
          start.r = r(t);
          start.g = g(t);
          start.b = b(t);
          start.opacity = opacity(t);
          return start + "";
        };
      }

      rgb$1.gamma = rgbGamma;

      return rgb$1;
    })(1);

    function rgbSpline(spline) {
      return function(colors) {
        var n = colors.length,
            r = new Array(n),
            g = new Array(n),
            b = new Array(n),
            i, color;
        for (i = 0; i < n; ++i) {
          color = rgb(colors[i]);
          r[i] = color.r || 0;
          g[i] = color.g || 0;
          b[i] = color.b || 0;
        }
        r = spline(r);
        g = spline(g);
        b = spline(b);
        color.opacity = 1;
        return function(t) {
          color.r = r(t);
          color.g = g(t);
          color.b = b(t);
          return color + "";
        };
      };
    }

    var rgbBasis = rgbSpline(basis$2);
    var rgbBasisClosed = rgbSpline(basisClosed$1);

    function numberArray(a, b) {
      if (!b) b = [];
      var n = a ? Math.min(b.length, a.length) : 0,
          c = b.slice(),
          i;
      return function(t) {
        for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
        return c;
      };
    }

    function isNumberArray(x) {
      return ArrayBuffer.isView(x) && !(x instanceof DataView);
    }

    function array$2(a, b) {
      return (isNumberArray(b) ? numberArray : genericArray)(a, b);
    }

    function genericArray(a, b) {
      var nb = b ? b.length : 0,
          na = a ? Math.min(nb, a.length) : 0,
          x = new Array(na),
          c = new Array(nb),
          i;

      for (i = 0; i < na; ++i) x[i] = interpolateValue(a[i], b[i]);
      for (; i < nb; ++i) c[i] = b[i];

      return function(t) {
        for (i = 0; i < na; ++i) c[i] = x[i](t);
        return c;
      };
    }

    function date$1(a, b) {
      var d = new Date;
      return a = +a, b = +b, function(t) {
        return d.setTime(a * (1 - t) + b * t), d;
      };
    }

    function interpolateNumber(a, b) {
      return a = +a, b = +b, function(t) {
        return a * (1 - t) + b * t;
      };
    }

    function object$1(a, b) {
      var i = {},
          c = {},
          k;

      if (a === null || typeof a !== "object") a = {};
      if (b === null || typeof b !== "object") b = {};

      for (k in b) {
        if (k in a) {
          i[k] = interpolateValue(a[k], b[k]);
        } else {
          c[k] = b[k];
        }
      }

      return function(t) {
        for (k in i) c[k] = i[k](t);
        return c;
      };
    }

    var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
        reB = new RegExp(reA.source, "g");

    function zero(b) {
      return function() {
        return b;
      };
    }

    function one(b) {
      return function(t) {
        return b(t) + "";
      };
    }

    function interpolateString(a, b) {
      var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
          am, // current match in a
          bm, // current match in b
          bs, // string preceding current number in b, if any
          i = -1, // index in s
          s = [], // string constants and placeholders
          q = []; // number interpolators

      // Coerce inputs to strings.
      a = a + "", b = b + "";

      // Interpolate pairs of numbers in a & b.
      while ((am = reA.exec(a))
          && (bm = reB.exec(b))) {
        if ((bs = bm.index) > bi) { // a string precedes the next number in b
          bs = b.slice(bi, bs);
          if (s[i]) s[i] += bs; // coalesce with previous string
          else s[++i] = bs;
        }
        if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
          if (s[i]) s[i] += bm; // coalesce with previous string
          else s[++i] = bm;
        } else { // interpolate non-matching numbers
          s[++i] = null;
          q.push({i: i, x: interpolateNumber(am, bm)});
        }
        bi = reB.lastIndex;
      }

      // Add remains of b.
      if (bi < b.length) {
        bs = b.slice(bi);
        if (s[i]) s[i] += bs; // coalesce with previous string
        else s[++i] = bs;
      }

      // Special optimization for only a single match.
      // Otherwise, interpolate each of the numbers and rejoin the string.
      return s.length < 2 ? (q[0]
          ? one(q[0].x)
          : zero(b))
          : (b = q.length, function(t) {
              for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
              return s.join("");
            });
    }

    function interpolateValue(a, b) {
      var t = typeof b, c;
      return b == null || t === "boolean" ? constant$a(b)
          : (t === "number" ? interpolateNumber
          : t === "string" ? ((c = color(b)) ? (b = c, interpolateRgb) : interpolateString)
          : b instanceof color ? interpolateRgb
          : b instanceof Date ? date$1
          : isNumberArray(b) ? numberArray
          : Array.isArray(b) ? genericArray
          : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object$1
          : interpolateNumber)(a, b);
    }

    function discrete(range) {
      var n = range.length;
      return function(t) {
        return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
      };
    }

    function hue(a, b) {
      var i = hue$1(+a, +b);
      return function(t) {
        var x = i(t);
        return x - 360 * Math.floor(x / 360);
      };
    }

    function interpolateRound(a, b) {
      return a = +a, b = +b, function(t) {
        return Math.round(a * (1 - t) + b * t);
      };
    }

    var degrees$1 = 180 / Math.PI;

    var identity$7 = {
      translateX: 0,
      translateY: 0,
      rotate: 0,
      skewX: 0,
      scaleX: 1,
      scaleY: 1
    };

    function decompose(a, b, c, d, e, f) {
      var scaleX, scaleY, skewX;
      if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
      if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
      if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
      if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
      return {
        translateX: e,
        translateY: f,
        rotate: Math.atan2(b, a) * degrees$1,
        skewX: Math.atan(skewX) * degrees$1,
        scaleX: scaleX,
        scaleY: scaleY
      };
    }

    var cssNode,
        cssRoot,
        cssView,
        svgNode;

    function parseCss(value) {
      if (value === "none") return identity$7;
      if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
      cssNode.style.transform = value;
      value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
      cssRoot.removeChild(cssNode);
      value = value.slice(7, -1).split(",");
      return decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
    }

    function parseSvg(value) {
      if (value == null) return identity$7;
      if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
      svgNode.setAttribute("transform", value);
      if (!(value = svgNode.transform.baseVal.consolidate())) return identity$7;
      value = value.matrix;
      return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
    }

    function interpolateTransform(parse, pxComma, pxParen, degParen) {

      function pop(s) {
        return s.length ? s.pop() + " " : "";
      }

      function translate(xa, ya, xb, yb, s, q) {
        if (xa !== xb || ya !== yb) {
          var i = s.push("translate(", null, pxComma, null, pxParen);
          q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
        } else if (xb || yb) {
          s.push("translate(" + xb + pxComma + yb + pxParen);
        }
      }

      function rotate(a, b, s, q) {
        if (a !== b) {
          if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
          q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: interpolateNumber(a, b)});
        } else if (b) {
          s.push(pop(s) + "rotate(" + b + degParen);
        }
      }

      function skewX(a, b, s, q) {
        if (a !== b) {
          q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: interpolateNumber(a, b)});
        } else if (b) {
          s.push(pop(s) + "skewX(" + b + degParen);
        }
      }

      function scale(xa, ya, xb, yb, s, q) {
        if (xa !== xb || ya !== yb) {
          var i = s.push(pop(s) + "scale(", null, ",", null, ")");
          q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
        } else if (xb !== 1 || yb !== 1) {
          s.push(pop(s) + "scale(" + xb + "," + yb + ")");
        }
      }

      return function(a, b) {
        var s = [], // string constants and placeholders
            q = []; // number interpolators
        a = parse(a), b = parse(b);
        translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
        rotate(a.rotate, b.rotate, s, q);
        skewX(a.skewX, b.skewX, s, q);
        scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
        a = b = null; // gc
        return function(t) {
          var i = -1, n = q.length, o;
          while (++i < n) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        };
      };
    }

    var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
    var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

    var rho = Math.SQRT2,
        rho2 = 2,
        rho4 = 4,
        epsilon2$2 = 1e-12;

    function cosh(x) {
      return ((x = Math.exp(x)) + 1 / x) / 2;
    }

    function sinh(x) {
      return ((x = Math.exp(x)) - 1 / x) / 2;
    }

    function tanh(x) {
      return ((x = Math.exp(2 * x)) - 1) / (x + 1);
    }

    // p0 = [ux0, uy0, w0]
    // p1 = [ux1, uy1, w1]
    function interpolateZoom(p0, p1) {
      var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
          ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
          dx = ux1 - ux0,
          dy = uy1 - uy0,
          d2 = dx * dx + dy * dy,
          i,
          S;

      // Special case for u0 ≅ u1.
      if (d2 < epsilon2$2) {
        S = Math.log(w1 / w0) / rho;
        i = function(t) {
          return [
            ux0 + t * dx,
            uy0 + t * dy,
            w0 * Math.exp(rho * t * S)
          ];
        };
      }

      // General case.
      else {
        var d1 = Math.sqrt(d2),
            b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
            b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
            r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
            r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
        S = (r1 - r0) / rho;
        i = function(t) {
          var s = t * S,
              coshr0 = cosh(r0),
              u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
          return [
            ux0 + u * dx,
            uy0 + u * dy,
            w0 * coshr0 / cosh(rho * s + r0)
          ];
        };
      }

      i.duration = S * 1000;

      return i;
    }

    function hsl(hue) {
      return function(start, end) {
        var h = hue((start = hsl$2(start)).h, (end = hsl$2(end)).h),
            s = nogamma(start.s, end.s),
            l = nogamma(start.l, end.l),
            opacity = nogamma(start.opacity, end.opacity);
        return function(t) {
          start.h = h(t);
          start.s = s(t);
          start.l = l(t);
          start.opacity = opacity(t);
          return start + "";
        };
      }
    }

    var hsl$1 = hsl(hue$1);
    var hslLong = hsl(nogamma);

    function lab(start, end) {
      var l = nogamma((start = lab$1(start)).l, (end = lab$1(end)).l),
          a = nogamma(start.a, end.a),
          b = nogamma(start.b, end.b),
          opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.l = l(t);
        start.a = a(t);
        start.b = b(t);
        start.opacity = opacity(t);
        return start + "";
      };
    }

    function hcl(hue) {
      return function(start, end) {
        var h = hue((start = hcl$2(start)).h, (end = hcl$2(end)).h),
            c = nogamma(start.c, end.c),
            l = nogamma(start.l, end.l),
            opacity = nogamma(start.opacity, end.opacity);
        return function(t) {
          start.h = h(t);
          start.c = c(t);
          start.l = l(t);
          start.opacity = opacity(t);
          return start + "";
        };
      }
    }

    var hcl$1 = hcl(hue$1);
    var hclLong = hcl(nogamma);

    function cubehelix$1(hue) {
      return (function cubehelixGamma(y) {
        y = +y;

        function cubehelix(start, end) {
          var h = hue((start = cubehelix$3(start)).h, (end = cubehelix$3(end)).h),
              s = nogamma(start.s, end.s),
              l = nogamma(start.l, end.l),
              opacity = nogamma(start.opacity, end.opacity);
          return function(t) {
            start.h = h(t);
            start.s = s(t);
            start.l = l(Math.pow(t, y));
            start.opacity = opacity(t);
            return start + "";
          };
        }

        cubehelix.gamma = cubehelixGamma;

        return cubehelix;
      })(1);
    }

    var cubehelix$2 = cubehelix$1(hue$1);
    var cubehelixLong = cubehelix$1(nogamma);

    function piecewise(interpolate, values) {
      var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
      while (i < n) I[i] = interpolate(v, v = values[++i]);
      return function(t) {
        var i = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
        return I[i](t - i);
      };
    }

    function quantize$1(interpolator, n) {
      var samples = new Array(n);
      for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
      return samples;
    }

    var frame = 0, // is an animation frame pending?
        timeout$1 = 0, // is a timeout pending?
        interval$1 = 0, // are any timers active?
        pokeDelay = 1000, // how frequently we check for clock skew
        taskHead,
        taskTail,
        clockLast = 0,
        clockNow = 0,
        clockSkew = 0,
        clock = typeof performance === "object" && performance.now ? performance : Date,
        setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

    function now() {
      return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
    }

    function clearNow() {
      clockNow = 0;
    }

    function Timer() {
      this._call =
      this._time =
      this._next = null;
    }

    Timer.prototype = timer.prototype = {
      constructor: Timer,
      restart: function(callback, delay, time) {
        if (typeof callback !== "function") throw new TypeError("callback is not a function");
        time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
        if (!this._next && taskTail !== this) {
          if (taskTail) taskTail._next = this;
          else taskHead = this;
          taskTail = this;
        }
        this._call = callback;
        this._time = time;
        sleep();
      },
      stop: function() {
        if (this._call) {
          this._call = null;
          this._time = Infinity;
          sleep();
        }
      }
    };

    function timer(callback, delay, time) {
      var t = new Timer;
      t.restart(callback, delay, time);
      return t;
    }

    function timerFlush() {
      now(); // Get the current time, if not already set.
      ++frame; // Pretend we’ve set an alarm, if we haven’t already.
      var t = taskHead, e;
      while (t) {
        if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
        t = t._next;
      }
      --frame;
    }

    function wake() {
      clockNow = (clockLast = clock.now()) + clockSkew;
      frame = timeout$1 = 0;
      try {
        timerFlush();
      } finally {
        frame = 0;
        nap();
        clockNow = 0;
      }
    }

    function poke() {
      var now = clock.now(), delay = now - clockLast;
      if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
    }

    function nap() {
      var t0, t1 = taskHead, t2, time = Infinity;
      while (t1) {
        if (t1._call) {
          if (time > t1._time) time = t1._time;
          t0 = t1, t1 = t1._next;
        } else {
          t2 = t1._next, t1._next = null;
          t1 = t0 ? t0._next = t2 : taskHead = t2;
        }
      }
      taskTail = t0;
      sleep(time);
    }

    function sleep(time) {
      if (frame) return; // Soonest alarm already set, or will be.
      if (timeout$1) timeout$1 = clearTimeout(timeout$1);
      var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
      if (delay > 24) {
        if (time < Infinity) timeout$1 = setTimeout(wake, time - clock.now() - clockSkew);
        if (interval$1) interval$1 = clearInterval(interval$1);
      } else {
        if (!interval$1) clockLast = clock.now(), interval$1 = setInterval(poke, pokeDelay);
        frame = 1, setFrame(wake);
      }
    }

    function timeout(callback, delay, time) {
      var t = new Timer;
      delay = delay == null ? 0 : +delay;
      t.restart(function(elapsed) {
        t.stop();
        callback(elapsed + delay);
      }, delay, time);
      return t;
    }

    function interval(callback, delay, time) {
      var t = new Timer, total = delay;
      if (delay == null) return t.restart(callback, delay, time), t;
      delay = +delay, time = time == null ? now() : +time;
      t.restart(function tick(elapsed) {
        elapsed += total;
        t.restart(tick, total += delay, time);
        callback(elapsed);
      }, delay, time);
      return t;
    }

    var emptyOn = dispatch("start", "end", "cancel", "interrupt");
    var emptyTween = [];

    var CREATED = 0;
    var SCHEDULED = 1;
    var STARTING = 2;
    var STARTED = 3;
    var RUNNING = 4;
    var ENDING = 5;
    var ENDED = 6;

    function schedule(node, name, id, index, group, timing) {
      var schedules = node.__transition;
      if (!schedules) node.__transition = {};
      else if (id in schedules) return;
      create(node, id, {
        name: name,
        index: index, // For context during callback.
        group: group, // For context during callback.
        on: emptyOn,
        tween: emptyTween,
        time: timing.time,
        delay: timing.delay,
        duration: timing.duration,
        ease: timing.ease,
        timer: null,
        state: CREATED
      });
    }

    function init(node, id) {
      var schedule = get(node, id);
      if (schedule.state > CREATED) throw new Error("too late; already scheduled");
      return schedule;
    }

    function set$1(node, id) {
      var schedule = get(node, id);
      if (schedule.state > STARTED) throw new Error("too late; already running");
      return schedule;
    }

    function get(node, id) {
      var schedule = node.__transition;
      if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
      return schedule;
    }

    function create(node, id, self) {
      var schedules = node.__transition,
          tween;

      // Initialize the self timer when the transition is created.
      // Note the actual delay is not known until the first callback!
      schedules[id] = self;
      self.timer = timer(schedule, 0, self.time);

      function schedule(elapsed) {
        self.state = SCHEDULED;
        self.timer.restart(start, self.delay, self.time);

        // If the elapsed delay is less than our first sleep, start immediately.
        if (self.delay <= elapsed) start(elapsed - self.delay);
      }

      function start(elapsed) {
        var i, j, n, o;

        // If the state is not SCHEDULED, then we previously errored on start.
        if (self.state !== SCHEDULED) return stop();

        for (i in schedules) {
          o = schedules[i];
          if (o.name !== self.name) continue;

          // While this element already has a starting transition during this frame,
          // defer starting an interrupting transition until that transition has a
          // chance to tick (and possibly end); see d3/d3-transition#54!
          if (o.state === STARTED) return timeout(start);

          // Interrupt the active transition, if any.
          if (o.state === RUNNING) {
            o.state = ENDED;
            o.timer.stop();
            o.on.call("interrupt", node, node.__data__, o.index, o.group);
            delete schedules[i];
          }

          // Cancel any pre-empted transitions.
          else if (+i < id) {
            o.state = ENDED;
            o.timer.stop();
            o.on.call("cancel", node, node.__data__, o.index, o.group);
            delete schedules[i];
          }
        }

        // Defer the first tick to end of the current frame; see d3/d3#1576.
        // Note the transition may be canceled after start and before the first tick!
        // Note this must be scheduled before the start event; see d3/d3-transition#16!
        // Assuming this is successful, subsequent callbacks go straight to tick.
        timeout(function() {
          if (self.state === STARTED) {
            self.state = RUNNING;
            self.timer.restart(tick, self.delay, self.time);
            tick(elapsed);
          }
        });

        // Dispatch the start event.
        // Note this must be done before the tween are initialized.
        self.state = STARTING;
        self.on.call("start", node, node.__data__, self.index, self.group);
        if (self.state !== STARTING) return; // interrupted
        self.state = STARTED;

        // Initialize the tween, deleting null tween.
        tween = new Array(n = self.tween.length);
        for (i = 0, j = -1; i < n; ++i) {
          if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
            tween[++j] = o;
          }
        }
        tween.length = j + 1;
      }

      function tick(elapsed) {
        var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
            i = -1,
            n = tween.length;

        while (++i < n) {
          tween[i].call(node, t);
        }

        // Dispatch the end event.
        if (self.state === ENDING) {
          self.on.call("end", node, node.__data__, self.index, self.group);
          stop();
        }
      }

      function stop() {
        self.state = ENDED;
        self.timer.stop();
        delete schedules[id];
        for (var i in schedules) return; // eslint-disable-line no-unused-vars
        delete node.__transition;
      }
    }

    function interrupt(node, name) {
      var schedules = node.__transition,
          schedule,
          active,
          empty = true,
          i;

      if (!schedules) return;

      name = name == null ? null : name + "";

      for (i in schedules) {
        if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
        active = schedule.state > STARTING && schedule.state < ENDING;
        schedule.state = ENDED;
        schedule.timer.stop();
        schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
        delete schedules[i];
      }

      if (empty) delete node.__transition;
    }

    function selection_interrupt(name) {
      return this.each(function() {
        interrupt(this, name);
      });
    }

    function tweenRemove(id, name) {
      var tween0, tween1;
      return function() {
        var schedule = set$1(this, id),
            tween = schedule.tween;

        // If this node shared tween with the previous node,
        // just assign the updated shared tween and we’re done!
        // Otherwise, copy-on-write.
        if (tween !== tween0) {
          tween1 = tween0 = tween;
          for (var i = 0, n = tween1.length; i < n; ++i) {
            if (tween1[i].name === name) {
              tween1 = tween1.slice();
              tween1.splice(i, 1);
              break;
            }
          }
        }

        schedule.tween = tween1;
      };
    }

    function tweenFunction(id, name, value) {
      var tween0, tween1;
      if (typeof value !== "function") throw new Error;
      return function() {
        var schedule = set$1(this, id),
            tween = schedule.tween;

        // If this node shared tween with the previous node,
        // just assign the updated shared tween and we’re done!
        // Otherwise, copy-on-write.
        if (tween !== tween0) {
          tween1 = (tween0 = tween).slice();
          for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
            if (tween1[i].name === name) {
              tween1[i] = t;
              break;
            }
          }
          if (i === n) tween1.push(t);
        }

        schedule.tween = tween1;
      };
    }

    function transition_tween(name, value) {
      var id = this._id;

      name += "";

      if (arguments.length < 2) {
        var tween = get(this.node(), id).tween;
        for (var i = 0, n = tween.length, t; i < n; ++i) {
          if ((t = tween[i]).name === name) {
            return t.value;
          }
        }
        return null;
      }

      return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
    }

    function tweenValue(transition, name, value) {
      var id = transition._id;

      transition.each(function() {
        var schedule = set$1(this, id);
        (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
      });

      return function(node) {
        return get(node, id).value[name];
      };
    }

    function interpolate$1(a, b) {
      var c;
      return (typeof b === "number" ? interpolateNumber
          : b instanceof color ? interpolateRgb
          : (c = color(b)) ? (b = c, interpolateRgb)
          : interpolateString)(a, b);
    }

    function attrRemove(name) {
      return function() {
        this.removeAttribute(name);
      };
    }

    function attrRemoveNS(fullname) {
      return function() {
        this.removeAttributeNS(fullname.space, fullname.local);
      };
    }

    function attrConstant(name, interpolate, value1) {
      var string00,
          string1 = value1 + "",
          interpolate0;
      return function() {
        var string0 = this.getAttribute(name);
        return string0 === string1 ? null
            : string0 === string00 ? interpolate0
            : interpolate0 = interpolate(string00 = string0, value1);
      };
    }

    function attrConstantNS(fullname, interpolate, value1) {
      var string00,
          string1 = value1 + "",
          interpolate0;
      return function() {
        var string0 = this.getAttributeNS(fullname.space, fullname.local);
        return string0 === string1 ? null
            : string0 === string00 ? interpolate0
            : interpolate0 = interpolate(string00 = string0, value1);
      };
    }

    function attrFunction(name, interpolate, value) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0, value1 = value(this), string1;
        if (value1 == null) return void this.removeAttribute(name);
        string0 = this.getAttribute(name);
        string1 = value1 + "";
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
      };
    }

    function attrFunctionNS(fullname, interpolate, value) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0, value1 = value(this), string1;
        if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
        string0 = this.getAttributeNS(fullname.space, fullname.local);
        string1 = value1 + "";
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
      };
    }

    function transition_attr(name, value) {
      var fullname = namespace(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate$1;
      return this.attrTween(name, typeof value === "function"
          ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, tweenValue(this, "attr." + name, value))
          : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)
          : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
    }

    function attrInterpolate(name, i) {
      return function(t) {
        this.setAttribute(name, i.call(this, t));
      };
    }

    function attrInterpolateNS(fullname, i) {
      return function(t) {
        this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
      };
    }

    function attrTweenNS(fullname, value) {
      var t0, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
        return t0;
      }
      tween._value = value;
      return tween;
    }

    function attrTween(name, value) {
      var t0, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
        return t0;
      }
      tween._value = value;
      return tween;
    }

    function transition_attrTween(name, value) {
      var key = "attr." + name;
      if (arguments.length < 2) return (key = this.tween(key)) && key._value;
      if (value == null) return this.tween(key, null);
      if (typeof value !== "function") throw new Error;
      var fullname = namespace(name);
      return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
    }

    function delayFunction(id, value) {
      return function() {
        init(this, id).delay = +value.apply(this, arguments);
      };
    }

    function delayConstant(id, value) {
      return value = +value, function() {
        init(this, id).delay = value;
      };
    }

    function transition_delay(value) {
      var id = this._id;

      return arguments.length
          ? this.each((typeof value === "function"
              ? delayFunction
              : delayConstant)(id, value))
          : get(this.node(), id).delay;
    }

    function durationFunction(id, value) {
      return function() {
        set$1(this, id).duration = +value.apply(this, arguments);
      };
    }

    function durationConstant(id, value) {
      return value = +value, function() {
        set$1(this, id).duration = value;
      };
    }

    function transition_duration(value) {
      var id = this._id;

      return arguments.length
          ? this.each((typeof value === "function"
              ? durationFunction
              : durationConstant)(id, value))
          : get(this.node(), id).duration;
    }

    function easeConstant(id, value) {
      if (typeof value !== "function") throw new Error;
      return function() {
        set$1(this, id).ease = value;
      };
    }

    function transition_ease(value) {
      var id = this._id;

      return arguments.length
          ? this.each(easeConstant(id, value))
          : get(this.node(), id).ease;
    }

    function transition_filter(match) {
      if (typeof match !== "function") match = matcher(match);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
          if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
            subgroup.push(node);
          }
        }
      }

      return new Transition(subgroups, this._parents, this._name, this._id);
    }

    function transition_merge(transition) {
      if (transition._id !== this._id) throw new Error;

      for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group0[i] || group1[i]) {
            merge[i] = node;
          }
        }
      }

      for (; j < m0; ++j) {
        merges[j] = groups0[j];
      }

      return new Transition(merges, this._parents, this._name, this._id);
    }

    function start(name) {
      return (name + "").trim().split(/^|\s+/).every(function(t) {
        var i = t.indexOf(".");
        if (i >= 0) t = t.slice(0, i);
        return !t || t === "start";
      });
    }

    function onFunction(id, name, listener) {
      var on0, on1, sit = start(name) ? init : set$1;
      return function() {
        var schedule = sit(this, id),
            on = schedule.on;

        // If this node shared a dispatch with the previous node,
        // just assign the updated shared dispatch and we’re done!
        // Otherwise, copy-on-write.
        if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

        schedule.on = on1;
      };
    }

    function transition_on(name, listener) {
      var id = this._id;

      return arguments.length < 2
          ? get(this.node(), id).on.on(name)
          : this.each(onFunction(id, name, listener));
    }

    function removeFunction(id) {
      return function() {
        var parent = this.parentNode;
        for (var i in this.__transition) if (+i !== id) return;
        if (parent) parent.removeChild(this);
      };
    }

    function transition_remove() {
      return this.on("end.remove", removeFunction(this._id));
    }

    function transition_select(select) {
      var name = this._name,
          id = this._id;

      if (typeof select !== "function") select = selector(select);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
          if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
            if ("__data__" in node) subnode.__data__ = node.__data__;
            subgroup[i] = subnode;
            schedule(subgroup[i], name, id, i, subgroup, get(node, id));
          }
        }
      }

      return new Transition(subgroups, this._parents, name, id);
    }

    function transition_selectAll(select) {
      var name = this._name,
          id = this._id;

      if (typeof select !== "function") select = selectorAll(select);

      for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            for (var children = select.call(node, node.__data__, i, group), child, inherit = get(node, id), k = 0, l = children.length; k < l; ++k) {
              if (child = children[k]) {
                schedule(child, name, id, k, children, inherit);
              }
            }
            subgroups.push(children);
            parents.push(node);
          }
        }
      }

      return new Transition(subgroups, parents, name, id);
    }

    var Selection = selection.prototype.constructor;

    function transition_selection() {
      return new Selection(this._groups, this._parents);
    }

    function styleNull(name, interpolate) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0 = styleValue(this, name),
            string1 = (this.style.removeProperty(name), styleValue(this, name));
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : interpolate0 = interpolate(string00 = string0, string10 = string1);
      };
    }

    function styleRemove(name) {
      return function() {
        this.style.removeProperty(name);
      };
    }

    function styleConstant(name, interpolate, value1) {
      var string00,
          string1 = value1 + "",
          interpolate0;
      return function() {
        var string0 = styleValue(this, name);
        return string0 === string1 ? null
            : string0 === string00 ? interpolate0
            : interpolate0 = interpolate(string00 = string0, value1);
      };
    }

    function styleFunction(name, interpolate, value) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0 = styleValue(this, name),
            value1 = value(this),
            string1 = value1 + "";
        if (value1 == null) string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
      };
    }

    function styleMaybeRemove(id, name) {
      var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
      return function() {
        var schedule = set$1(this, id),
            on = schedule.on,
            listener = schedule.value[key] == null ? remove || (remove = styleRemove(name)) : undefined;

        // If this node shared a dispatch with the previous node,
        // just assign the updated shared dispatch and we’re done!
        // Otherwise, copy-on-write.
        if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);

        schedule.on = on1;
      };
    }

    function transition_style(name, value, priority) {
      var i = (name += "") === "transform" ? interpolateTransformCss : interpolate$1;
      return value == null ? this
          .styleTween(name, styleNull(name, i))
          .on("end.style." + name, styleRemove(name))
        : typeof value === "function" ? this
          .styleTween(name, styleFunction(name, i, tweenValue(this, "style." + name, value)))
          .each(styleMaybeRemove(this._id, name))
        : this
          .styleTween(name, styleConstant(name, i, value), priority)
          .on("end.style." + name, null);
    }

    function styleInterpolate(name, i, priority) {
      return function(t) {
        this.style.setProperty(name, i.call(this, t), priority);
      };
    }

    function styleTween(name, value, priority) {
      var t, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
        return t;
      }
      tween._value = value;
      return tween;
    }

    function transition_styleTween(name, value, priority) {
      var key = "style." + (name += "");
      if (arguments.length < 2) return (key = this.tween(key)) && key._value;
      if (value == null) return this.tween(key, null);
      if (typeof value !== "function") throw new Error;
      return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
    }

    function textConstant(value) {
      return function() {
        this.textContent = value;
      };
    }

    function textFunction(value) {
      return function() {
        var value1 = value(this);
        this.textContent = value1 == null ? "" : value1;
      };
    }

    function transition_text(value) {
      return this.tween("text", typeof value === "function"
          ? textFunction(tweenValue(this, "text", value))
          : textConstant(value == null ? "" : value + ""));
    }

    function textInterpolate(i) {
      return function(t) {
        this.textContent = i.call(this, t);
      };
    }

    function textTween(value) {
      var t0, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
        return t0;
      }
      tween._value = value;
      return tween;
    }

    function transition_textTween(value) {
      var key = "text";
      if (arguments.length < 1) return (key = this.tween(key)) && key._value;
      if (value == null) return this.tween(key, null);
      if (typeof value !== "function") throw new Error;
      return this.tween(key, textTween(value));
    }

    function transition_transition() {
      var name = this._name,
          id0 = this._id,
          id1 = newId();

      for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            var inherit = get(node, id0);
            schedule(node, name, id1, i, group, {
              time: inherit.time + inherit.delay + inherit.duration,
              delay: 0,
              duration: inherit.duration,
              ease: inherit.ease
            });
          }
        }
      }

      return new Transition(groups, this._parents, name, id1);
    }

    function transition_end() {
      var on0, on1, that = this, id = that._id, size = that.size();
      return new Promise(function(resolve, reject) {
        var cancel = {value: reject},
            end = {value: function() { if (--size === 0) resolve(); }};

        that.each(function() {
          var schedule = set$1(this, id),
              on = schedule.on;

          // If this node shared a dispatch with the previous node,
          // just assign the updated shared dispatch and we’re done!
          // Otherwise, copy-on-write.
          if (on !== on0) {
            on1 = (on0 = on).copy();
            on1._.cancel.push(cancel);
            on1._.interrupt.push(cancel);
            on1._.end.push(end);
          }

          schedule.on = on1;
        });
      });
    }

    var id = 0;

    function Transition(groups, parents, name, id) {
      this._groups = groups;
      this._parents = parents;
      this._name = name;
      this._id = id;
    }

    function transition(name) {
      return selection().transition(name);
    }

    function newId() {
      return ++id;
    }

    var selection_prototype = selection.prototype;

    Transition.prototype = transition.prototype = {
      constructor: Transition,
      select: transition_select,
      selectAll: transition_selectAll,
      filter: transition_filter,
      merge: transition_merge,
      selection: transition_selection,
      transition: transition_transition,
      call: selection_prototype.call,
      nodes: selection_prototype.nodes,
      node: selection_prototype.node,
      size: selection_prototype.size,
      empty: selection_prototype.empty,
      each: selection_prototype.each,
      on: transition_on,
      attr: transition_attr,
      attrTween: transition_attrTween,
      style: transition_style,
      styleTween: transition_styleTween,
      text: transition_text,
      textTween: transition_textTween,
      remove: transition_remove,
      tween: transition_tween,
      delay: transition_delay,
      duration: transition_duration,
      ease: transition_ease,
      end: transition_end
    };

    function linear$1(t) {
      return +t;
    }

    function quadIn(t) {
      return t * t;
    }

    function quadOut(t) {
      return t * (2 - t);
    }

    function quadInOut(t) {
      return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
    }

    function cubicIn(t) {
      return t * t * t;
    }

    function cubicOut(t) {
      return --t * t * t + 1;
    }

    function cubicInOut(t) {
      return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
    }

    var exponent$1 = 3;

    var polyIn = (function custom(e) {
      e = +e;

      function polyIn(t) {
        return Math.pow(t, e);
      }

      polyIn.exponent = custom;

      return polyIn;
    })(exponent$1);

    var polyOut = (function custom(e) {
      e = +e;

      function polyOut(t) {
        return 1 - Math.pow(1 - t, e);
      }

      polyOut.exponent = custom;

      return polyOut;
    })(exponent$1);

    var polyInOut = (function custom(e) {
      e = +e;

      function polyInOut(t) {
        return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
      }

      polyInOut.exponent = custom;

      return polyInOut;
    })(exponent$1);

    var pi$4 = Math.PI,
        halfPi$3 = pi$4 / 2;

    function sinIn(t) {
      return (+t === 1) ? 1 : 1 - Math.cos(t * halfPi$3);
    }

    function sinOut(t) {
      return Math.sin(t * halfPi$3);
    }

    function sinInOut(t) {
      return (1 - Math.cos(pi$4 * t)) / 2;
    }

    // tpmt is two power minus ten times t scaled to [0,1]
    function tpmt(x) {
      return (Math.pow(2, -10 * x) - 0.0009765625) * 1.0009775171065494;
    }

    function expIn(t) {
      return tpmt(1 - +t);
    }

    function expOut(t) {
      return 1 - tpmt(t);
    }

    function expInOut(t) {
      return ((t *= 2) <= 1 ? tpmt(1 - t) : 2 - tpmt(t - 1)) / 2;
    }

    function circleIn(t) {
      return 1 - Math.sqrt(1 - t * t);
    }

    function circleOut(t) {
      return Math.sqrt(1 - --t * t);
    }

    function circleInOut(t) {
      return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
    }

    var b1 = 4 / 11,
        b2 = 6 / 11,
        b3 = 8 / 11,
        b4 = 3 / 4,
        b5 = 9 / 11,
        b6 = 10 / 11,
        b7 = 15 / 16,
        b8 = 21 / 22,
        b9 = 63 / 64,
        b0 = 1 / b1 / b1;

    function bounceIn(t) {
      return 1 - bounceOut(1 - t);
    }

    function bounceOut(t) {
      return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
    }

    function bounceInOut(t) {
      return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
    }

    var overshoot = 1.70158;

    var backIn = (function custom(s) {
      s = +s;

      function backIn(t) {
        return (t = +t) * t * (s * (t - 1) + t);
      }

      backIn.overshoot = custom;

      return backIn;
    })(overshoot);

    var backOut = (function custom(s) {
      s = +s;

      function backOut(t) {
        return --t * t * ((t + 1) * s + t) + 1;
      }

      backOut.overshoot = custom;

      return backOut;
    })(overshoot);

    var backInOut = (function custom(s) {
      s = +s;

      function backInOut(t) {
        return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
      }

      backInOut.overshoot = custom;

      return backInOut;
    })(overshoot);

    var tau$4 = 2 * Math.PI,
        amplitude = 1,
        period = 0.3;

    var elasticIn = (function custom(a, p) {
      var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau$4);

      function elasticIn(t) {
        return a * tpmt(-(--t)) * Math.sin((s - t) / p);
      }

      elasticIn.amplitude = function(a) { return custom(a, p * tau$4); };
      elasticIn.period = function(p) { return custom(a, p); };

      return elasticIn;
    })(amplitude, period);

    var elasticOut = (function custom(a, p) {
      var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau$4);

      function elasticOut(t) {
        return 1 - a * tpmt(t = +t) * Math.sin((t + s) / p);
      }

      elasticOut.amplitude = function(a) { return custom(a, p * tau$4); };
      elasticOut.period = function(p) { return custom(a, p); };

      return elasticOut;
    })(amplitude, period);

    var elasticInOut = (function custom(a, p) {
      var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau$4);

      function elasticInOut(t) {
        return ((t = t * 2 - 1) < 0
            ? a * tpmt(-t) * Math.sin((s - t) / p)
            : 2 - a * tpmt(t) * Math.sin((s + t) / p)) / 2;
      }

      elasticInOut.amplitude = function(a) { return custom(a, p * tau$4); };
      elasticInOut.period = function(p) { return custom(a, p); };

      return elasticInOut;
    })(amplitude, period);

    var defaultTiming = {
      time: null, // Set on use.
      delay: 0,
      duration: 250,
      ease: cubicInOut
    };

    function inherit(node, id) {
      var timing;
      while (!(timing = node.__transition) || !(timing = timing[id])) {
        if (!(node = node.parentNode)) {
          return defaultTiming.time = now(), defaultTiming;
        }
      }
      return timing;
    }

    function selection_transition(name) {
      var id,
          timing;

      if (name instanceof Transition) {
        id = name._id, name = name._name;
      } else {
        id = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
      }

      for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            schedule(node, name, id, i, group, timing || inherit(node, id));
          }
        }
      }

      return new Transition(groups, this._parents, name, id);
    }

    selection.prototype.interrupt = selection_interrupt;
    selection.prototype.transition = selection_transition;

    var root = [null];

    function active(node, name) {
      var schedules = node.__transition,
          schedule,
          i;

      if (schedules) {
        name = name == null ? null : name + "";
        for (i in schedules) {
          if ((schedule = schedules[i]).state > SCHEDULED && schedule.name === name) {
            return new Transition([[node]], root, name, +i);
          }
        }
      }

      return null;
    }

    function constant$9(x) {
      return function() {
        return x;
      };
    }

    function BrushEvent(target, type, selection) {
      this.target = target;
      this.type = type;
      this.selection = selection;
    }

    function nopropagation$1() {
      event.stopImmediatePropagation();
    }

    function noevent$1() {
      event.preventDefault();
      event.stopImmediatePropagation();
    }

    var MODE_DRAG = {name: "drag"},
        MODE_SPACE = {name: "space"},
        MODE_HANDLE = {name: "handle"},
        MODE_CENTER = {name: "center"};

    function number1(e) {
      return [+e[0], +e[1]];
    }

    function number2(e) {
      return [number1(e[0]), number1(e[1])];
    }

    function toucher(identifier) {
      return function(target) {
        return touch(target, event.touches, identifier);
      };
    }

    var X = {
      name: "x",
      handles: ["w", "e"].map(type),
      input: function(x, e) { return x == null ? null : [[+x[0], e[0][1]], [+x[1], e[1][1]]]; },
      output: function(xy) { return xy && [xy[0][0], xy[1][0]]; }
    };

    var Y = {
      name: "y",
      handles: ["n", "s"].map(type),
      input: function(y, e) { return y == null ? null : [[e[0][0], +y[0]], [e[1][0], +y[1]]]; },
      output: function(xy) { return xy && [xy[0][1], xy[1][1]]; }
    };

    var XY = {
      name: "xy",
      handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(type),
      input: function(xy) { return xy == null ? null : number2(xy); },
      output: function(xy) { return xy; }
    };

    var cursors = {
      overlay: "crosshair",
      selection: "move",
      n: "ns-resize",
      e: "ew-resize",
      s: "ns-resize",
      w: "ew-resize",
      nw: "nwse-resize",
      ne: "nesw-resize",
      se: "nwse-resize",
      sw: "nesw-resize"
    };

    var flipX = {
      e: "w",
      w: "e",
      nw: "ne",
      ne: "nw",
      se: "sw",
      sw: "se"
    };

    var flipY = {
      n: "s",
      s: "n",
      nw: "sw",
      ne: "se",
      se: "ne",
      sw: "nw"
    };

    var signsX = {
      overlay: +1,
      selection: +1,
      n: null,
      e: +1,
      s: null,
      w: -1,
      nw: -1,
      ne: +1,
      se: +1,
      sw: -1
    };

    var signsY = {
      overlay: +1,
      selection: +1,
      n: -1,
      e: null,
      s: +1,
      w: null,
      nw: -1,
      ne: -1,
      se: +1,
      sw: +1
    };

    function type(t) {
      return {type: t};
    }

    // Ignore right-click, since that should open the context menu.
    function defaultFilter$1() {
      return !event.ctrlKey && !event.button;
    }

    function defaultExtent$1() {
      var svg = this.ownerSVGElement || this;
      if (svg.hasAttribute("viewBox")) {
        svg = svg.viewBox.baseVal;
        return [[svg.x, svg.y], [svg.x + svg.width, svg.y + svg.height]];
      }
      return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
    }

    function defaultTouchable$1() {
      return navigator.maxTouchPoints || ("ontouchstart" in this);
    }

    // Like d3.local, but with the name “__brush” rather than auto-generated.
    function local(node) {
      while (!node.__brush) if (!(node = node.parentNode)) return;
      return node.__brush;
    }

    function empty(extent) {
      return extent[0][0] === extent[1][0]
          || extent[0][1] === extent[1][1];
    }

    function brushSelection(node) {
      var state = node.__brush;
      return state ? state.dim.output(state.selection) : null;
    }

    function brushX() {
      return brush$1(X);
    }

    function brushY() {
      return brush$1(Y);
    }

    function brush() {
      return brush$1(XY);
    }

    function brush$1(dim) {
      var extent = defaultExtent$1,
          filter = defaultFilter$1,
          touchable = defaultTouchable$1,
          keys = true,
          listeners = dispatch("start", "brush", "end"),
          handleSize = 6,
          touchending;

      function brush(group) {
        var overlay = group
            .property("__brush", initialize)
          .selectAll(".overlay")
          .data([type("overlay")]);

        overlay.enter().append("rect")
            .attr("class", "overlay")
            .attr("pointer-events", "all")
            .attr("cursor", cursors.overlay)
          .merge(overlay)
            .each(function() {
              var extent = local(this).extent;
              select(this)
                  .attr("x", extent[0][0])
                  .attr("y", extent[0][1])
                  .attr("width", extent[1][0] - extent[0][0])
                  .attr("height", extent[1][1] - extent[0][1]);
            });

        group.selectAll(".selection")
          .data([type("selection")])
          .enter().append("rect")
            .attr("class", "selection")
            .attr("cursor", cursors.selection)
            .attr("fill", "#777")
            .attr("fill-opacity", 0.3)
            .attr("stroke", "#fff")
            .attr("shape-rendering", "crispEdges");

        var handle = group.selectAll(".handle")
          .data(dim.handles, function(d) { return d.type; });

        handle.exit().remove();

        handle.enter().append("rect")
            .attr("class", function(d) { return "handle handle--" + d.type; })
            .attr("cursor", function(d) { return cursors[d.type]; });

        group
            .each(redraw)
            .attr("fill", "none")
            .attr("pointer-events", "all")
            .on("mousedown.brush", started)
          .filter(touchable)
            .on("touchstart.brush", started)
            .on("touchmove.brush", touchmoved)
            .on("touchend.brush touchcancel.brush", touchended)
            .style("touch-action", "none")
            .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
      }

      brush.move = function(group, selection) {
        if (group.selection) {
          group
              .on("start.brush", function() { emitter(this, arguments).beforestart().start(); })
              .on("interrupt.brush end.brush", function() { emitter(this, arguments).end(); })
              .tween("brush", function() {
                var that = this,
                    state = that.__brush,
                    emit = emitter(that, arguments),
                    selection0 = state.selection,
                    selection1 = dim.input(typeof selection === "function" ? selection.apply(this, arguments) : selection, state.extent),
                    i = interpolateValue(selection0, selection1);

                function tween(t) {
                  state.selection = t === 1 && selection1 === null ? null : i(t);
                  redraw.call(that);
                  emit.brush();
                }

                return selection0 !== null && selection1 !== null ? tween : tween(1);
              });
        } else {
          group
              .each(function() {
                var that = this,
                    args = arguments,
                    state = that.__brush,
                    selection1 = dim.input(typeof selection === "function" ? selection.apply(that, args) : selection, state.extent),
                    emit = emitter(that, args).beforestart();

                interrupt(that);
                state.selection = selection1 === null ? null : selection1;
                redraw.call(that);
                emit.start().brush().end();
              });
        }
      };

      brush.clear = function(group) {
        brush.move(group, null);
      };

      function redraw() {
        var group = select(this),
            selection = local(this).selection;

        if (selection) {
          group.selectAll(".selection")
              .style("display", null)
              .attr("x", selection[0][0])
              .attr("y", selection[0][1])
              .attr("width", selection[1][0] - selection[0][0])
              .attr("height", selection[1][1] - selection[0][1]);

          group.selectAll(".handle")
              .style("display", null)
              .attr("x", function(d) { return d.type[d.type.length - 1] === "e" ? selection[1][0] - handleSize / 2 : selection[0][0] - handleSize / 2; })
              .attr("y", function(d) { return d.type[0] === "s" ? selection[1][1] - handleSize / 2 : selection[0][1] - handleSize / 2; })
              .attr("width", function(d) { return d.type === "n" || d.type === "s" ? selection[1][0] - selection[0][0] + handleSize : handleSize; })
              .attr("height", function(d) { return d.type === "e" || d.type === "w" ? selection[1][1] - selection[0][1] + handleSize : handleSize; });
        }

        else {
          group.selectAll(".selection,.handle")
              .style("display", "none")
              .attr("x", null)
              .attr("y", null)
              .attr("width", null)
              .attr("height", null);
        }
      }

      function emitter(that, args, clean) {
        var emit = that.__brush.emitter;
        return emit && (!clean || !emit.clean) ? emit : new Emitter(that, args, clean);
      }

      function Emitter(that, args, clean) {
        this.that = that;
        this.args = args;
        this.state = that.__brush;
        this.active = 0;
        this.clean = clean;
      }

      Emitter.prototype = {
        beforestart: function() {
          if (++this.active === 1) this.state.emitter = this, this.starting = true;
          return this;
        },
        start: function() {
          if (this.starting) this.starting = false, this.emit("start");
          else this.emit("brush");
          return this;
        },
        brush: function() {
          this.emit("brush");
          return this;
        },
        end: function() {
          if (--this.active === 0) delete this.state.emitter, this.emit("end");
          return this;
        },
        emit: function(type) {
          customEvent(new BrushEvent(brush, type, dim.output(this.state.selection)), listeners.apply, listeners, [type, this.that, this.args]);
        }
      };

      function started() {
        if (touchending && !event.touches) return;
        if (!filter.apply(this, arguments)) return;

        var that = this,
            type = event.target.__data__.type,
            mode = (keys && event.metaKey ? type = "overlay" : type) === "selection" ? MODE_DRAG : (keys && event.altKey ? MODE_CENTER : MODE_HANDLE),
            signX = dim === Y ? null : signsX[type],
            signY = dim === X ? null : signsY[type],
            state = local(that),
            extent = state.extent,
            selection = state.selection,
            W = extent[0][0], w0, w1,
            N = extent[0][1], n0, n1,
            E = extent[1][0], e0, e1,
            S = extent[1][1], s0, s1,
            dx = 0,
            dy = 0,
            moving,
            shifting = signX && signY && keys && event.shiftKey,
            lockX,
            lockY,
            pointer = event.touches ? toucher(event.changedTouches[0].identifier) : mouse,
            point0 = pointer(that),
            point = point0,
            emit = emitter(that, arguments, true).beforestart();

        if (type === "overlay") {
          if (selection) moving = true;
          state.selection = selection = [
            [w0 = dim === Y ? W : point0[0], n0 = dim === X ? N : point0[1]],
            [e0 = dim === Y ? E : w0, s0 = dim === X ? S : n0]
          ];
        } else {
          w0 = selection[0][0];
          n0 = selection[0][1];
          e0 = selection[1][0];
          s0 = selection[1][1];
        }

        w1 = w0;
        n1 = n0;
        e1 = e0;
        s1 = s0;

        var group = select(that)
            .attr("pointer-events", "none");

        var overlay = group.selectAll(".overlay")
            .attr("cursor", cursors[type]);

        if (event.touches) {
          emit.moved = moved;
          emit.ended = ended;
        } else {
          var view = select(event.view)
              .on("mousemove.brush", moved, true)
              .on("mouseup.brush", ended, true);
          if (keys) view
              .on("keydown.brush", keydowned, true)
              .on("keyup.brush", keyupped, true);

          dragDisable(event.view);
        }

        nopropagation$1();
        interrupt(that);
        redraw.call(that);
        emit.start();

        function moved() {
          var point1 = pointer(that);
          if (shifting && !lockX && !lockY) {
            if (Math.abs(point1[0] - point[0]) > Math.abs(point1[1] - point[1])) lockY = true;
            else lockX = true;
          }
          point = point1;
          moving = true;
          noevent$1();
          move();
        }

        function move() {
          var t;

          dx = point[0] - point0[0];
          dy = point[1] - point0[1];

          switch (mode) {
            case MODE_SPACE:
            case MODE_DRAG: {
              if (signX) dx = Math.max(W - w0, Math.min(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
              if (signY) dy = Math.max(N - n0, Math.min(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
              break;
            }
            case MODE_HANDLE: {
              if (signX < 0) dx = Math.max(W - w0, Math.min(E - w0, dx)), w1 = w0 + dx, e1 = e0;
              else if (signX > 0) dx = Math.max(W - e0, Math.min(E - e0, dx)), w1 = w0, e1 = e0 + dx;
              if (signY < 0) dy = Math.max(N - n0, Math.min(S - n0, dy)), n1 = n0 + dy, s1 = s0;
              else if (signY > 0) dy = Math.max(N - s0, Math.min(S - s0, dy)), n1 = n0, s1 = s0 + dy;
              break;
            }
            case MODE_CENTER: {
              if (signX) w1 = Math.max(W, Math.min(E, w0 - dx * signX)), e1 = Math.max(W, Math.min(E, e0 + dx * signX));
              if (signY) n1 = Math.max(N, Math.min(S, n0 - dy * signY)), s1 = Math.max(N, Math.min(S, s0 + dy * signY));
              break;
            }
          }

          if (e1 < w1) {
            signX *= -1;
            t = w0, w0 = e0, e0 = t;
            t = w1, w1 = e1, e1 = t;
            if (type in flipX) overlay.attr("cursor", cursors[type = flipX[type]]);
          }

          if (s1 < n1) {
            signY *= -1;
            t = n0, n0 = s0, s0 = t;
            t = n1, n1 = s1, s1 = t;
            if (type in flipY) overlay.attr("cursor", cursors[type = flipY[type]]);
          }

          if (state.selection) selection = state.selection; // May be set by brush.move!
          if (lockX) w1 = selection[0][0], e1 = selection[1][0];
          if (lockY) n1 = selection[0][1], s1 = selection[1][1];

          if (selection[0][0] !== w1
              || selection[0][1] !== n1
              || selection[1][0] !== e1
              || selection[1][1] !== s1) {
            state.selection = [[w1, n1], [e1, s1]];
            redraw.call(that);
            emit.brush();
          }
        }

        function ended() {
          nopropagation$1();
          if (event.touches) {
            if (event.touches.length) return;
            if (touchending) clearTimeout(touchending);
            touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
          } else {
            yesdrag(event.view, moving);
            view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
          }
          group.attr("pointer-events", "all");
          overlay.attr("cursor", cursors.overlay);
          if (state.selection) selection = state.selection; // May be set by brush.move (on start)!
          if (empty(selection)) state.selection = null, redraw.call(that);
          emit.end();
        }

        function keydowned() {
          switch (event.keyCode) {
            case 16: { // SHIFT
              shifting = signX && signY;
              break;
            }
            case 18: { // ALT
              if (mode === MODE_HANDLE) {
                if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
                if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
                mode = MODE_CENTER;
                move();
              }
              break;
            }
            case 32: { // SPACE; takes priority over ALT
              if (mode === MODE_HANDLE || mode === MODE_CENTER) {
                if (signX < 0) e0 = e1 - dx; else if (signX > 0) w0 = w1 - dx;
                if (signY < 0) s0 = s1 - dy; else if (signY > 0) n0 = n1 - dy;
                mode = MODE_SPACE;
                overlay.attr("cursor", cursors.selection);
                move();
              }
              break;
            }
            default: return;
          }
          noevent$1();
        }

        function keyupped() {
          switch (event.keyCode) {
            case 16: { // SHIFT
              if (shifting) {
                lockX = lockY = shifting = false;
                move();
              }
              break;
            }
            case 18: { // ALT
              if (mode === MODE_CENTER) {
                if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
                if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
                mode = MODE_HANDLE;
                move();
              }
              break;
            }
            case 32: { // SPACE
              if (mode === MODE_SPACE) {
                if (event.altKey) {
                  if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
                  if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
                  mode = MODE_CENTER;
                } else {
                  if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
                  if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
                  mode = MODE_HANDLE;
                }
                overlay.attr("cursor", cursors[type]);
                move();
              }
              break;
            }
            default: return;
          }
          noevent$1();
        }
      }

      function touchmoved() {
        emitter(this, arguments).moved();
      }

      function touchended() {
        emitter(this, arguments).ended();
      }

      function initialize() {
        var state = this.__brush || {selection: null};
        state.extent = number2(extent.apply(this, arguments));
        state.dim = dim;
        return state;
      }

      brush.extent = function(_) {
        return arguments.length ? (extent = typeof _ === "function" ? _ : constant$9(number2(_)), brush) : extent;
      };

      brush.filter = function(_) {
        return arguments.length ? (filter = typeof _ === "function" ? _ : constant$9(!!_), brush) : filter;
      };

      brush.touchable = function(_) {
        return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$9(!!_), brush) : touchable;
      };

      brush.handleSize = function(_) {
        return arguments.length ? (handleSize = +_, brush) : handleSize;
      };

      brush.keyModifiers = function(_) {
        return arguments.length ? (keys = !!_, brush) : keys;
      };

      brush.on = function() {
        var value = listeners.on.apply(listeners, arguments);
        return value === listeners ? brush : value;
      };

      return brush;
    }

    var cos$2 = Math.cos;
    var sin$2 = Math.sin;
    var pi$3 = Math.PI;
    var halfPi$2 = pi$3 / 2;
    var tau$3 = pi$3 * 2;
    var max$1 = Math.max;

    function compareValue(compare) {
      return function(a, b) {
        return compare(
          a.source.value + a.target.value,
          b.source.value + b.target.value
        );
      };
    }

    function chord() {
      var padAngle = 0,
          sortGroups = null,
          sortSubgroups = null,
          sortChords = null;

      function chord(matrix) {
        var n = matrix.length,
            groupSums = [],
            groupIndex = sequence(n),
            subgroupIndex = [],
            chords = [],
            groups = chords.groups = new Array(n),
            subgroups = new Array(n * n),
            k,
            x,
            x0,
            dx,
            i,
            j;

        // Compute the sum.
        k = 0, i = -1; while (++i < n) {
          x = 0, j = -1; while (++j < n) {
            x += matrix[i][j];
          }
          groupSums.push(x);
          subgroupIndex.push(sequence(n));
          k += x;
        }

        // Sort groups…
        if (sortGroups) groupIndex.sort(function(a, b) {
          return sortGroups(groupSums[a], groupSums[b]);
        });

        // Sort subgroups…
        if (sortSubgroups) subgroupIndex.forEach(function(d, i) {
          d.sort(function(a, b) {
            return sortSubgroups(matrix[i][a], matrix[i][b]);
          });
        });

        // Convert the sum to scaling factor for [0, 2pi].
        // TODO Allow start and end angle to be specified?
        // TODO Allow padding to be specified as percentage?
        k = max$1(0, tau$3 - padAngle * n) / k;
        dx = k ? padAngle : tau$3 / n;

        // Compute the start and end angle for each group and subgroup.
        // Note: Opera has a bug reordering object literal properties!
        x = 0, i = -1; while (++i < n) {
          x0 = x, j = -1; while (++j < n) {
            var di = groupIndex[i],
                dj = subgroupIndex[di][j],
                v = matrix[di][dj],
                a0 = x,
                a1 = x += v * k;
            subgroups[dj * n + di] = {
              index: di,
              subindex: dj,
              startAngle: a0,
              endAngle: a1,
              value: v
            };
          }
          groups[di] = {
            index: di,
            startAngle: x0,
            endAngle: x,
            value: groupSums[di]
          };
          x += dx;
        }

        // Generate chords for each (non-empty) subgroup-subgroup link.
        i = -1; while (++i < n) {
          j = i - 1; while (++j < n) {
            var source = subgroups[j * n + i],
                target = subgroups[i * n + j];
            if (source.value || target.value) {
              chords.push(source.value < target.value
                  ? {source: target, target: source}
                  : {source: source, target: target});
            }
          }
        }

        return sortChords ? chords.sort(sortChords) : chords;
      }

      chord.padAngle = function(_) {
        return arguments.length ? (padAngle = max$1(0, _), chord) : padAngle;
      };

      chord.sortGroups = function(_) {
        return arguments.length ? (sortGroups = _, chord) : sortGroups;
      };

      chord.sortSubgroups = function(_) {
        return arguments.length ? (sortSubgroups = _, chord) : sortSubgroups;
      };

      chord.sortChords = function(_) {
        return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord) : sortChords && sortChords._;
      };

      return chord;
    }

    var slice$4 = Array.prototype.slice;

    function constant$8(x) {
      return function() {
        return x;
      };
    }

    var pi$2 = Math.PI,
        tau$2 = 2 * pi$2,
        epsilon$3 = 1e-6,
        tauEpsilon = tau$2 - epsilon$3;

    function Path() {
      this._x0 = this._y0 = // start of current subpath
      this._x1 = this._y1 = null; // end of current subpath
      this._ = "";
    }

    function path() {
      return new Path;
    }

    Path.prototype = path.prototype = {
      constructor: Path,
      moveTo: function(x, y) {
        this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
      },
      closePath: function() {
        if (this._x1 !== null) {
          this._x1 = this._x0, this._y1 = this._y0;
          this._ += "Z";
        }
      },
      lineTo: function(x, y) {
        this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
      },
      quadraticCurveTo: function(x1, y1, x, y) {
        this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
      },
      bezierCurveTo: function(x1, y1, x2, y2, x, y) {
        this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
      },
      arcTo: function(x1, y1, x2, y2, r) {
        x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
        var x0 = this._x1,
            y0 = this._y1,
            x21 = x2 - x1,
            y21 = y2 - y1,
            x01 = x0 - x1,
            y01 = y0 - y1,
            l01_2 = x01 * x01 + y01 * y01;

        // Is the radius negative? Error.
        if (r < 0) throw new Error("negative radius: " + r);

        // Is this path empty? Move to (x1,y1).
        if (this._x1 === null) {
          this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
        }

        // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
        else if (!(l01_2 > epsilon$3));

        // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
        // Equivalently, is (x1,y1) coincident with (x2,y2)?
        // Or, is the radius zero? Line to (x1,y1).
        else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon$3) || !r) {
          this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
        }

        // Otherwise, draw an arc!
        else {
          var x20 = x2 - x0,
              y20 = y2 - y0,
              l21_2 = x21 * x21 + y21 * y21,
              l20_2 = x20 * x20 + y20 * y20,
              l21 = Math.sqrt(l21_2),
              l01 = Math.sqrt(l01_2),
              l = r * Math.tan((pi$2 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
              t01 = l / l01,
              t21 = l / l21;

          // If the start tangent is not coincident with (x0,y0), line to.
          if (Math.abs(t01 - 1) > epsilon$3) {
            this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
          }

          this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
        }
      },
      arc: function(x, y, r, a0, a1, ccw) {
        x = +x, y = +y, r = +r, ccw = !!ccw;
        var dx = r * Math.cos(a0),
            dy = r * Math.sin(a0),
            x0 = x + dx,
            y0 = y + dy,
            cw = 1 ^ ccw,
            da = ccw ? a0 - a1 : a1 - a0;

        // Is the radius negative? Error.
        if (r < 0) throw new Error("negative radius: " + r);

        // Is this path empty? Move to (x0,y0).
        if (this._x1 === null) {
          this._ += "M" + x0 + "," + y0;
        }

        // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
        else if (Math.abs(this._x1 - x0) > epsilon$3 || Math.abs(this._y1 - y0) > epsilon$3) {
          this._ += "L" + x0 + "," + y0;
        }

        // Is this arc empty? We’re done.
        if (!r) return;

        // Does the angle go the wrong way? Flip the direction.
        if (da < 0) da = da % tau$2 + tau$2;

        // Is this a complete circle? Draw two arcs to complete the circle.
        if (da > tauEpsilon) {
          this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
        }

        // Is this arc non-empty? Draw an arc!
        else if (da > epsilon$3) {
          this._ += "A" + r + "," + r + ",0," + (+(da >= pi$2)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
        }
      },
      rect: function(x, y, w, h) {
        this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
      },
      toString: function() {
        return this._;
      }
    };

    function defaultSource$1(d) {
      return d.source;
    }

    function defaultTarget(d) {
      return d.target;
    }

    function defaultRadius$1(d) {
      return d.radius;
    }

    function defaultStartAngle(d) {
      return d.startAngle;
    }

    function defaultEndAngle(d) {
      return d.endAngle;
    }

    function ribbon() {
      var source = defaultSource$1,
          target = defaultTarget,
          radius = defaultRadius$1,
          startAngle = defaultStartAngle,
          endAngle = defaultEndAngle,
          context = null;

      function ribbon() {
        var buffer,
            argv = slice$4.call(arguments),
            s = source.apply(this, argv),
            t = target.apply(this, argv),
            sr = +radius.apply(this, (argv[0] = s, argv)),
            sa0 = startAngle.apply(this, argv) - halfPi$2,
            sa1 = endAngle.apply(this, argv) - halfPi$2,
            sx0 = sr * cos$2(sa0),
            sy0 = sr * sin$2(sa0),
            tr = +radius.apply(this, (argv[0] = t, argv)),
            ta0 = startAngle.apply(this, argv) - halfPi$2,
            ta1 = endAngle.apply(this, argv) - halfPi$2;

        if (!context) context = buffer = path();

        context.moveTo(sx0, sy0);
        context.arc(0, 0, sr, sa0, sa1);
        if (sa0 !== ta0 || sa1 !== ta1) { // TODO sr !== tr?
          context.quadraticCurveTo(0, 0, tr * cos$2(ta0), tr * sin$2(ta0));
          context.arc(0, 0, tr, ta0, ta1);
        }
        context.quadraticCurveTo(0, 0, sx0, sy0);
        context.closePath();

        if (buffer) return context = null, buffer + "" || null;
      }

      ribbon.radius = function(_) {
        return arguments.length ? (radius = typeof _ === "function" ? _ : constant$8(+_), ribbon) : radius;
      };

      ribbon.startAngle = function(_) {
        return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$8(+_), ribbon) : startAngle;
      };

      ribbon.endAngle = function(_) {
        return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$8(+_), ribbon) : endAngle;
      };

      ribbon.source = function(_) {
        return arguments.length ? (source = _, ribbon) : source;
      };

      ribbon.target = function(_) {
        return arguments.length ? (target = _, ribbon) : target;
      };

      ribbon.context = function(_) {
        return arguments.length ? ((context = _ == null ? null : _), ribbon) : context;
      };

      return ribbon;
    }

    var prefix = "$";

    function Map$1() {}

    Map$1.prototype = map$2.prototype = {
      constructor: Map$1,
      has: function(key) {
        return (prefix + key) in this;
      },
      get: function(key) {
        return this[prefix + key];
      },
      set: function(key, value) {
        this[prefix + key] = value;
        return this;
      },
      remove: function(key) {
        var property = prefix + key;
        return property in this && delete this[property];
      },
      clear: function() {
        for (var property in this) if (property[0] === prefix) delete this[property];
      },
      keys: function() {
        var keys = [];
        for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));
        return keys;
      },
      values: function() {
        var values = [];
        for (var property in this) if (property[0] === prefix) values.push(this[property]);
        return values;
      },
      entries: function() {
        var entries = [];
        for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});
        return entries;
      },
      size: function() {
        var size = 0;
        for (var property in this) if (property[0] === prefix) ++size;
        return size;
      },
      empty: function() {
        for (var property in this) if (property[0] === prefix) return false;
        return true;
      },
      each: function(f) {
        for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
      }
    };

    function map$2(object, f) {
      var map = new Map$1;

      // Copy constructor.
      if (object instanceof Map$1) object.each(function(value, key) { map.set(key, value); });

      // Index array by numeric index or specified key function.
      else if (Array.isArray(object)) {
        var i = -1,
            n = object.length,
            o;

        if (f == null) while (++i < n) map.set(i, object[i]);
        else while (++i < n) map.set(f(o = object[i], i, object), o);
      }

      // Convert object to map.
      else if (object) for (var key in object) map.set(key, object[key]);

      return map;
    }

    function nest() {
      var keys = [],
          sortKeys = [],
          sortValues,
          rollup,
          nest;

      function apply(array, depth, createResult, setResult) {
        if (depth >= keys.length) {
          if (sortValues != null) array.sort(sortValues);
          return rollup != null ? rollup(array) : array;
        }

        var i = -1,
            n = array.length,
            key = keys[depth++],
            keyValue,
            value,
            valuesByKey = map$2(),
            values,
            result = createResult();

        while (++i < n) {
          if (values = valuesByKey.get(keyValue = key(value = array[i]) + "")) {
            values.push(value);
          } else {
            valuesByKey.set(keyValue, [value]);
          }
        }

        valuesByKey.each(function(values, key) {
          setResult(result, key, apply(values, depth, createResult, setResult));
        });

        return result;
      }

      function entries(map, depth) {
        if (++depth > keys.length) return map;
        var array, sortKey = sortKeys[depth - 1];
        if (rollup != null && depth >= keys.length) array = map.entries();
        else array = [], map.each(function(v, k) { array.push({key: k, values: entries(v, depth)}); });
        return sortKey != null ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array;
      }

      return nest = {
        object: function(array) { return apply(array, 0, createObject, setObject); },
        map: function(array) { return apply(array, 0, createMap, setMap); },
        entries: function(array) { return entries(apply(array, 0, createMap, setMap), 0); },
        key: function(d) { keys.push(d); return nest; },
        sortKeys: function(order) { sortKeys[keys.length - 1] = order; return nest; },
        sortValues: function(order) { sortValues = order; return nest; },
        rollup: function(f) { rollup = f; return nest; }
      };
    }

    function createObject() {
      return {};
    }

    function setObject(object, key, value) {
      object[key] = value;
    }

    function createMap() {
      return map$2();
    }

    function setMap(map, key, value) {
      map.set(key, value);
    }

    function Set$1() {}

    var proto = map$2.prototype;

    Set$1.prototype = set.prototype = {
      constructor: Set$1,
      has: proto.has,
      add: function(value) {
        value += "";
        this[prefix + value] = value;
        return this;
      },
      remove: proto.remove,
      clear: proto.clear,
      values: proto.keys,
      size: proto.size,
      empty: proto.empty,
      each: proto.each
    };

    function set(object, f) {
      var set = new Set$1;

      // Copy constructor.
      if (object instanceof Set$1) object.each(function(value) { set.add(value); });

      // Otherwise, assume it’s an array.
      else if (object) {
        var i = -1, n = object.length;
        if (f == null) while (++i < n) set.add(object[i]);
        else while (++i < n) set.add(f(object[i], i, object));
      }

      return set;
    }

    function keys(map) {
      var keys = [];
      for (var key in map) keys.push(key);
      return keys;
    }

    function values(map) {
      var values = [];
      for (var key in map) values.push(map[key]);
      return values;
    }

    function entries(map) {
      var entries = [];
      for (var key in map) entries.push({key: key, value: map[key]});
      return entries;
    }

    var array$1 = Array.prototype;

    var slice$3 = array$1.slice;

    function ascending$1(a, b) {
      return a - b;
    }

    function area$3(ring) {
      var i = 0, n = ring.length, area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
      while (++i < n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
      return area;
    }

    function constant$7(x) {
      return function() {
        return x;
      };
    }

    function contains$2(ring, hole) {
      var i = -1, n = hole.length, c;
      while (++i < n) if (c = ringContains(ring, hole[i])) return c;
      return 0;
    }

    function ringContains(ring, point) {
      var x = point[0], y = point[1], contains = -1;
      for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
        var pi = ring[i], xi = pi[0], yi = pi[1], pj = ring[j], xj = pj[0], yj = pj[1];
        if (segmentContains(pi, pj, point)) return 0;
        if (((yi > y) !== (yj > y)) && ((x < (xj - xi) * (y - yi) / (yj - yi) + xi))) contains = -contains;
      }
      return contains;
    }

    function segmentContains(a, b, c) {
      var i; return collinear(a, b, c) && within(a[i = +(a[0] === b[0])], c[i], b[i]);
    }

    function collinear(a, b, c) {
      return (b[0] - a[0]) * (c[1] - a[1]) === (c[0] - a[0]) * (b[1] - a[1]);
    }

    function within(p, q, r) {
      return p <= q && q <= r || r <= q && q <= p;
    }

    function noop$2() {}

    var cases = [
      [],
      [[[1.0, 1.5], [0.5, 1.0]]],
      [[[1.5, 1.0], [1.0, 1.5]]],
      [[[1.5, 1.0], [0.5, 1.0]]],
      [[[1.0, 0.5], [1.5, 1.0]]],
      [[[1.0, 1.5], [0.5, 1.0]], [[1.0, 0.5], [1.5, 1.0]]],
      [[[1.0, 0.5], [1.0, 1.5]]],
      [[[1.0, 0.5], [0.5, 1.0]]],
      [[[0.5, 1.0], [1.0, 0.5]]],
      [[[1.0, 1.5], [1.0, 0.5]]],
      [[[0.5, 1.0], [1.0, 0.5]], [[1.5, 1.0], [1.0, 1.5]]],
      [[[1.5, 1.0], [1.0, 0.5]]],
      [[[0.5, 1.0], [1.5, 1.0]]],
      [[[1.0, 1.5], [1.5, 1.0]]],
      [[[0.5, 1.0], [1.0, 1.5]]],
      []
    ];

    function contours() {
      var dx = 1,
          dy = 1,
          threshold = thresholdSturges,
          smooth = smoothLinear;

      function contours(values) {
        var tz = threshold(values);

        // Convert number of thresholds into uniform thresholds.
        if (!Array.isArray(tz)) {
          var domain = extent$1(values), start = domain[0], stop = domain[1];
          tz = tickStep(start, stop, tz);
          tz = sequence(Math.floor(start / tz) * tz, Math.floor(stop / tz) * tz, tz);
        } else {
          tz = tz.slice().sort(ascending$1);
        }

        return tz.map(function(value) {
          return contour(values, value);
        });
      }

      // Accumulate, smooth contour rings, assign holes to exterior rings.
      // Based on https://github.com/mbostock/shapefile/blob/v0.6.2/shp/polygon.js
      function contour(values, value) {
        var polygons = [],
            holes = [];

        isorings(values, value, function(ring) {
          smooth(ring, values, value);
          if (area$3(ring) > 0) polygons.push([ring]);
          else holes.push(ring);
        });

        holes.forEach(function(hole) {
          for (var i = 0, n = polygons.length, polygon; i < n; ++i) {
            if (contains$2((polygon = polygons[i])[0], hole) !== -1) {
              polygon.push(hole);
              return;
            }
          }
        });

        return {
          type: "MultiPolygon",
          value: value,
          coordinates: polygons
        };
      }

      // Marching squares with isolines stitched into rings.
      // Based on https://github.com/topojson/topojson-client/blob/v3.0.0/src/stitch.js
      function isorings(values, value, callback) {
        var fragmentByStart = new Array,
            fragmentByEnd = new Array,
            x, y, t0, t1, t2, t3;

        // Special case for the first row (y = -1, t2 = t3 = 0).
        x = y = -1;
        t1 = values[0] >= value;
        cases[t1 << 1].forEach(stitch);
        while (++x < dx - 1) {
          t0 = t1, t1 = values[x + 1] >= value;
          cases[t0 | t1 << 1].forEach(stitch);
        }
        cases[t1 << 0].forEach(stitch);

        // General case for the intermediate rows.
        while (++y < dy - 1) {
          x = -1;
          t1 = values[y * dx + dx] >= value;
          t2 = values[y * dx] >= value;
          cases[t1 << 1 | t2 << 2].forEach(stitch);
          while (++x < dx - 1) {
            t0 = t1, t1 = values[y * dx + dx + x + 1] >= value;
            t3 = t2, t2 = values[y * dx + x + 1] >= value;
            cases[t0 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);
          }
          cases[t1 | t2 << 3].forEach(stitch);
        }

        // Special case for the last row (y = dy - 1, t0 = t1 = 0).
        x = -1;
        t2 = values[y * dx] >= value;
        cases[t2 << 2].forEach(stitch);
        while (++x < dx - 1) {
          t3 = t2, t2 = values[y * dx + x + 1] >= value;
          cases[t2 << 2 | t3 << 3].forEach(stitch);
        }
        cases[t2 << 3].forEach(stitch);

        function stitch(line) {
          var start = [line[0][0] + x, line[0][1] + y],
              end = [line[1][0] + x, line[1][1] + y],
              startIndex = index(start),
              endIndex = index(end),
              f, g;
          if (f = fragmentByEnd[startIndex]) {
            if (g = fragmentByStart[endIndex]) {
              delete fragmentByEnd[f.end];
              delete fragmentByStart[g.start];
              if (f === g) {
                f.ring.push(end);
                callback(f.ring);
              } else {
                fragmentByStart[f.start] = fragmentByEnd[g.end] = {start: f.start, end: g.end, ring: f.ring.concat(g.ring)};
              }
            } else {
              delete fragmentByEnd[f.end];
              f.ring.push(end);
              fragmentByEnd[f.end = endIndex] = f;
            }
          } else if (f = fragmentByStart[endIndex]) {
            if (g = fragmentByEnd[startIndex]) {
              delete fragmentByStart[f.start];
              delete fragmentByEnd[g.end];
              if (f === g) {
                f.ring.push(end);
                callback(f.ring);
              } else {
                fragmentByStart[g.start] = fragmentByEnd[f.end] = {start: g.start, end: f.end, ring: g.ring.concat(f.ring)};
              }
            } else {
              delete fragmentByStart[f.start];
              f.ring.unshift(start);
              fragmentByStart[f.start = startIndex] = f;
            }
          } else {
            fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {start: startIndex, end: endIndex, ring: [start, end]};
          }
        }
      }

      function index(point) {
        return point[0] * 2 + point[1] * (dx + 1) * 4;
      }

      function smoothLinear(ring, values, value) {
        ring.forEach(function(point) {
          var x = point[0],
              y = point[1],
              xt = x | 0,
              yt = y | 0,
              v0,
              v1 = values[yt * dx + xt];
          if (x > 0 && x < dx && xt === x) {
            v0 = values[yt * dx + xt - 1];
            point[0] = x + (value - v0) / (v1 - v0) - 0.5;
          }
          if (y > 0 && y < dy && yt === y) {
            v0 = values[(yt - 1) * dx + xt];
            point[1] = y + (value - v0) / (v1 - v0) - 0.5;
          }
        });
      }

      contours.contour = contour;

      contours.size = function(_) {
        if (!arguments.length) return [dx, dy];
        var _0 = Math.ceil(_[0]), _1 = Math.ceil(_[1]);
        if (!(_0 > 0) || !(_1 > 0)) throw new Error("invalid size");
        return dx = _0, dy = _1, contours;
      };

      contours.thresholds = function(_) {
        return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant$7(slice$3.call(_)) : constant$7(_), contours) : threshold;
      };

      contours.smooth = function(_) {
        return arguments.length ? (smooth = _ ? smoothLinear : noop$2, contours) : smooth === smoothLinear;
      };

      return contours;
    }

    // TODO Optimize edge cases.
    // TODO Optimize index calculation.
    // TODO Optimize arguments.
    function blurX(source, target, r) {
      var n = source.width,
          m = source.height,
          w = (r << 1) + 1;
      for (var j = 0; j < m; ++j) {
        for (var i = 0, sr = 0; i < n + r; ++i) {
          if (i < n) {
            sr += source.data[i + j * n];
          }
          if (i >= r) {
            if (i >= w) {
              sr -= source.data[i - w + j * n];
            }
            target.data[i - r + j * n] = sr / Math.min(i + 1, n - 1 + w - i, w);
          }
        }
      }
    }

    // TODO Optimize edge cases.
    // TODO Optimize index calculation.
    // TODO Optimize arguments.
    function blurY(source, target, r) {
      var n = source.width,
          m = source.height,
          w = (r << 1) + 1;
      for (var i = 0; i < n; ++i) {
        for (var j = 0, sr = 0; j < m + r; ++j) {
          if (j < m) {
            sr += source.data[i + j * n];
          }
          if (j >= r) {
            if (j >= w) {
              sr -= source.data[i + (j - w) * n];
            }
            target.data[i + (j - r) * n] = sr / Math.min(j + 1, m - 1 + w - j, w);
          }
        }
      }
    }

    function defaultX$1(d) {
      return d[0];
    }

    function defaultY$1(d) {
      return d[1];
    }

    function defaultWeight() {
      return 1;
    }

    function density() {
      var x = defaultX$1,
          y = defaultY$1,
          weight = defaultWeight,
          dx = 960,
          dy = 500,
          r = 20, // blur radius
          k = 2, // log2(grid cell size)
          o = r * 3, // grid offset, to pad for blur
          n = (dx + o * 2) >> k, // grid width
          m = (dy + o * 2) >> k, // grid height
          threshold = constant$7(20);

      function density(data) {
        var values0 = new Float32Array(n * m),
            values1 = new Float32Array(n * m);

        data.forEach(function(d, i, data) {
          var xi = (+x(d, i, data) + o) >> k,
              yi = (+y(d, i, data) + o) >> k,
              wi = +weight(d, i, data);
          if (xi >= 0 && xi < n && yi >= 0 && yi < m) {
            values0[xi + yi * n] += wi;
          }
        });

        // TODO Optimize.
        blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
        blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);
        blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
        blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);
        blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
        blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);

        var tz = threshold(values0);

        // Convert number of thresholds into uniform thresholds.
        if (!Array.isArray(tz)) {
          var stop = max$2(values0);
          tz = tickStep(0, stop, tz);
          tz = sequence(0, Math.floor(stop / tz) * tz, tz);
          tz.shift();
        }

        return contours()
            .thresholds(tz)
            .size([n, m])
          (values0)
            .map(transform);
      }

      function transform(geometry) {
        geometry.value *= Math.pow(2, -2 * k); // Density in points per square pixel.
        geometry.coordinates.forEach(transformPolygon);
        return geometry;
      }

      function transformPolygon(coordinates) {
        coordinates.forEach(transformRing);
      }

      function transformRing(coordinates) {
        coordinates.forEach(transformPoint);
      }

      // TODO Optimize.
      function transformPoint(coordinates) {
        coordinates[0] = coordinates[0] * Math.pow(2, k) - o;
        coordinates[1] = coordinates[1] * Math.pow(2, k) - o;
      }

      function resize() {
        o = r * 3;
        n = (dx + o * 2) >> k;
        m = (dy + o * 2) >> k;
        return density;
      }

      density.x = function(_) {
        return arguments.length ? (x = typeof _ === "function" ? _ : constant$7(+_), density) : x;
      };

      density.y = function(_) {
        return arguments.length ? (y = typeof _ === "function" ? _ : constant$7(+_), density) : y;
      };

      density.weight = function(_) {
        return arguments.length ? (weight = typeof _ === "function" ? _ : constant$7(+_), density) : weight;
      };

      density.size = function(_) {
        if (!arguments.length) return [dx, dy];
        var _0 = Math.ceil(_[0]), _1 = Math.ceil(_[1]);
        if (!(_0 >= 0) && !(_0 >= 0)) throw new Error("invalid size");
        return dx = _0, dy = _1, resize();
      };

      density.cellSize = function(_) {
        if (!arguments.length) return 1 << k;
        if (!((_ = +_) >= 1)) throw new Error("invalid cell size");
        return k = Math.floor(Math.log(_) / Math.LN2), resize();
      };

      density.thresholds = function(_) {
        return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant$7(slice$3.call(_)) : constant$7(_), density) : threshold;
      };

      density.bandwidth = function(_) {
        if (!arguments.length) return Math.sqrt(r * (r + 1));
        if (!((_ = +_) >= 0)) throw new Error("invalid bandwidth");
        return r = Math.round((Math.sqrt(4 * _ * _ + 1) - 1) / 2), resize();
      };

      return density;
    }

    var EOL = {},
        EOF = {},
        QUOTE = 34,
        NEWLINE = 10,
        RETURN = 13;

    function objectConverter(columns) {
      return new Function("d", "return {" + columns.map(function(name, i) {
        return JSON.stringify(name) + ": d[" + i + "] || \"\"";
      }).join(",") + "}");
    }

    function customConverter(columns, f) {
      var object = objectConverter(columns);
      return function(row, i) {
        return f(object(row), i, columns);
      };
    }

    // Compute unique columns in order of discovery.
    function inferColumns(rows) {
      var columnSet = Object.create(null),
          columns = [];

      rows.forEach(function(row) {
        for (var column in row) {
          if (!(column in columnSet)) {
            columns.push(columnSet[column] = column);
          }
        }
      });

      return columns;
    }

    function pad$1(value, width) {
      var s = value + "", length = s.length;
      return length < width ? new Array(width - length + 1).join(0) + s : s;
    }

    function formatYear$1(year) {
      return year < 0 ? "-" + pad$1(-year, 6)
        : year > 9999 ? "+" + pad$1(year, 6)
        : pad$1(year, 4);
    }

    function formatDate(date) {
      var hours = date.getUTCHours(),
          minutes = date.getUTCMinutes(),
          seconds = date.getUTCSeconds(),
          milliseconds = date.getUTCMilliseconds();
      return isNaN(date) ? "Invalid Date"
          : formatYear$1(date.getUTCFullYear()) + "-" + pad$1(date.getUTCMonth() + 1, 2) + "-" + pad$1(date.getUTCDate(), 2)
          + (milliseconds ? "T" + pad$1(hours, 2) + ":" + pad$1(minutes, 2) + ":" + pad$1(seconds, 2) + "." + pad$1(milliseconds, 3) + "Z"
          : seconds ? "T" + pad$1(hours, 2) + ":" + pad$1(minutes, 2) + ":" + pad$1(seconds, 2) + "Z"
          : minutes || hours ? "T" + pad$1(hours, 2) + ":" + pad$1(minutes, 2) + "Z"
          : "");
    }

    function dsvFormat(delimiter) {
      var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
          DELIMITER = delimiter.charCodeAt(0);

      function parse(text, f) {
        var convert, columns, rows = parseRows(text, function(row, i) {
          if (convert) return convert(row, i - 1);
          columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
        });
        rows.columns = columns || [];
        return rows;
      }

      function parseRows(text, f) {
        var rows = [], // output rows
            N = text.length,
            I = 0, // current character index
            n = 0, // current line number
            t, // current token
            eof = N <= 0, // current token followed by EOF?
            eol = false; // current token followed by EOL?

        // Strip the trailing newline.
        if (text.charCodeAt(N - 1) === NEWLINE) --N;
        if (text.charCodeAt(N - 1) === RETURN) --N;

        function token() {
          if (eof) return EOF;
          if (eol) return eol = false, EOL;

          // Unescape quotes.
          var i, j = I, c;
          if (text.charCodeAt(j) === QUOTE) {
            while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);
            if ((i = I) >= N) eof = true;
            else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;
            else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
            return text.slice(j + 1, i - 1).replace(/""/g, "\"");
          }

          // Find next delimiter or newline.
          while (I < N) {
            if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;
            else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
            else if (c !== DELIMITER) continue;
            return text.slice(j, i);
          }

          // Return last token before EOF.
          return eof = true, text.slice(j, N);
        }

        while ((t = token()) !== EOF) {
          var row = [];
          while (t !== EOL && t !== EOF) row.push(t), t = token();
          if (f && (row = f(row, n++)) == null) continue;
          rows.push(row);
        }

        return rows;
      }

      function preformatBody(rows, columns) {
        return rows.map(function(row) {
          return columns.map(function(column) {
            return formatValue(row[column]);
          }).join(delimiter);
        });
      }

      function format(rows, columns) {
        if (columns == null) columns = inferColumns(rows);
        return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
      }

      function formatBody(rows, columns) {
        if (columns == null) columns = inferColumns(rows);
        return preformatBody(rows, columns).join("\n");
      }

      function formatRows(rows) {
        return rows.map(formatRow).join("\n");
      }

      function formatRow(row) {
        return row.map(formatValue).join(delimiter);
      }

      function formatValue(value) {
        return value == null ? ""
            : value instanceof Date ? formatDate(value)
            : reFormat.test(value += "") ? "\"" + value.replace(/"/g, "\"\"") + "\""
            : value;
      }

      return {
        parse: parse,
        parseRows: parseRows,
        format: format,
        formatBody: formatBody,
        formatRows: formatRows,
        formatRow: formatRow,
        formatValue: formatValue
      };
    }

    var csv$1 = dsvFormat(",");

    var csvParse = csv$1.parse;
    var csvParseRows = csv$1.parseRows;
    var csvFormat = csv$1.format;
    var csvFormatBody = csv$1.formatBody;
    var csvFormatRows = csv$1.formatRows;
    var csvFormatRow = csv$1.formatRow;
    var csvFormatValue = csv$1.formatValue;

    var tsv$1 = dsvFormat("\t");

    var tsvParse = tsv$1.parse;
    var tsvParseRows = tsv$1.parseRows;
    var tsvFormat = tsv$1.format;
    var tsvFormatBody = tsv$1.formatBody;
    var tsvFormatRows = tsv$1.formatRows;
    var tsvFormatRow = tsv$1.formatRow;
    var tsvFormatValue = tsv$1.formatValue;

    function autoType(object) {
      for (var key in object) {
        var value = object[key].trim(), number, m;
        if (!value) value = null;
        else if (value === "true") value = true;
        else if (value === "false") value = false;
        else if (value === "NaN") value = NaN;
        else if (!isNaN(number = +value)) value = number;
        else if (m = value.match(/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/)) {
          if (fixtz && !!m[4] && !m[7]) value = value.replace(/-/g, "/").replace(/T/, " ");
          value = new Date(value);
        }
        else continue;
        object[key] = value;
      }
      return object;
    }

    // https://github.com/d3/d3-dsv/issues/45
    var fixtz = new Date("2019-01-01T00:00").getHours() || new Date("2019-07-01T00:00").getHours();

    function responseBlob(response) {
      if (!response.ok) throw new Error(response.status + " " + response.statusText);
      return response.blob();
    }

    function blob(input, init) {
      return fetch(input, init).then(responseBlob);
    }

    function responseArrayBuffer(response) {
      if (!response.ok) throw new Error(response.status + " " + response.statusText);
      return response.arrayBuffer();
    }

    function buffer(input, init) {
      return fetch(input, init).then(responseArrayBuffer);
    }

    function responseText(response) {
      if (!response.ok) throw new Error(response.status + " " + response.statusText);
      return response.text();
    }

    function text(input, init) {
      return fetch(input, init).then(responseText);
    }

    function dsvParse(parse) {
      return function(input, init, row) {
        if (arguments.length === 2 && typeof init === "function") row = init, init = undefined;
        return text(input, init).then(function(response) {
          return parse(response, row);
        });
      };
    }

    function dsv(delimiter, input, init, row) {
      if (arguments.length === 3 && typeof init === "function") row = init, init = undefined;
      var format = dsvFormat(delimiter);
      return text(input, init).then(function(response) {
        return format.parse(response, row);
      });
    }

    var csv = dsvParse(csvParse);
    var tsv = dsvParse(tsvParse);

    function image(input, init) {
      return new Promise(function(resolve, reject) {
        var image = new Image;
        for (var key in init) image[key] = init[key];
        image.onerror = reject;
        image.onload = function() { resolve(image); };
        image.src = input;
      });
    }

    function responseJson(response) {
      if (!response.ok) throw new Error(response.status + " " + response.statusText);
      if (response.status === 204 || response.status === 205) return;
      return response.json();
    }

    function json(input, init) {
      return fetch(input, init).then(responseJson);
    }

    function parser(type) {
      return function(input, init)  {
        return text(input, init).then(function(text) {
          return (new DOMParser).parseFromString(text, type);
        });
      };
    }

    var xml = parser("application/xml");

    var html = parser("text/html");

    var svg = parser("image/svg+xml");

    function center(x, y) {
      var nodes;

      if (x == null) x = 0;
      if (y == null) y = 0;

      function force() {
        var i,
            n = nodes.length,
            node,
            sx = 0,
            sy = 0;

        for (i = 0; i < n; ++i) {
          node = nodes[i], sx += node.x, sy += node.y;
        }

        for (sx = sx / n - x, sy = sy / n - y, i = 0; i < n; ++i) {
          node = nodes[i], node.x -= sx, node.y -= sy;
        }
      }

      force.initialize = function(_) {
        nodes = _;
      };

      force.x = function(_) {
        return arguments.length ? (x = +_, force) : x;
      };

      force.y = function(_) {
        return arguments.length ? (y = +_, force) : y;
      };

      return force;
    }

    function constant$6(x) {
      return function() {
        return x;
      };
    }

    function jiggle() {
      return (Math.random() - 0.5) * 1e-6;
    }

    function tree_add(d) {
      var x = +this._x.call(null, d),
          y = +this._y.call(null, d);
      return add$1(this.cover(x, y), x, y, d);
    }

    function add$1(tree, x, y, d) {
      if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

      var parent,
          node = tree._root,
          leaf = {data: d},
          x0 = tree._x0,
          y0 = tree._y0,
          x1 = tree._x1,
          y1 = tree._y1,
          xm,
          ym,
          xp,
          yp,
          right,
          bottom,
          i,
          j;

      // If the tree is empty, initialize the root as a leaf.
      if (!node) return tree._root = leaf, tree;

      // Find the existing leaf for the new point, or add it.
      while (node.length) {
        if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
        if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
        if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
      }

      // Is the new point is exactly coincident with the existing point?
      xp = +tree._x.call(null, node.data);
      yp = +tree._y.call(null, node.data);
      if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

      // Otherwise, split the leaf node until the old and new point are separated.
      do {
        parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
        if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
        if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
      } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
      return parent[j] = node, parent[i] = leaf, tree;
    }

    function addAll(data) {
      var d, i, n = data.length,
          x,
          y,
          xz = new Array(n),
          yz = new Array(n),
          x0 = Infinity,
          y0 = Infinity,
          x1 = -Infinity,
          y1 = -Infinity;

      // Compute the points and their extent.
      for (i = 0; i < n; ++i) {
        if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
        xz[i] = x;
        yz[i] = y;
        if (x < x0) x0 = x;
        if (x > x1) x1 = x;
        if (y < y0) y0 = y;
        if (y > y1) y1 = y;
      }

      // If there were no (valid) points, abort.
      if (x0 > x1 || y0 > y1) return this;

      // Expand the tree to cover the new points.
      this.cover(x0, y0).cover(x1, y1);

      // Add the new points.
      for (i = 0; i < n; ++i) {
        add$1(this, xz[i], yz[i], data[i]);
      }

      return this;
    }

    function tree_cover(x, y) {
      if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

      var x0 = this._x0,
          y0 = this._y0,
          x1 = this._x1,
          y1 = this._y1;

      // If the quadtree has no extent, initialize them.
      // Integer extent are necessary so that if we later double the extent,
      // the existing quadrant boundaries don’t change due to floating point error!
      if (isNaN(x0)) {
        x1 = (x0 = Math.floor(x)) + 1;
        y1 = (y0 = Math.floor(y)) + 1;
      }

      // Otherwise, double repeatedly to cover.
      else {
        var z = x1 - x0,
            node = this._root,
            parent,
            i;

        while (x0 > x || x >= x1 || y0 > y || y >= y1) {
          i = (y < y0) << 1 | (x < x0);
          parent = new Array(4), parent[i] = node, node = parent, z *= 2;
          switch (i) {
            case 0: x1 = x0 + z, y1 = y0 + z; break;
            case 1: x0 = x1 - z, y1 = y0 + z; break;
            case 2: x1 = x0 + z, y0 = y1 - z; break;
            case 3: x0 = x1 - z, y0 = y1 - z; break;
          }
        }

        if (this._root && this._root.length) this._root = node;
      }

      this._x0 = x0;
      this._y0 = y0;
      this._x1 = x1;
      this._y1 = y1;
      return this;
    }

    function tree_data() {
      var data = [];
      this.visit(function(node) {
        if (!node.length) do data.push(node.data); while (node = node.next)
      });
      return data;
    }

    function tree_extent(_) {
      return arguments.length
          ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
          : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
    }

    function Quad(node, x0, y0, x1, y1) {
      this.node = node;
      this.x0 = x0;
      this.y0 = y0;
      this.x1 = x1;
      this.y1 = y1;
    }

    function tree_find(x, y, radius) {
      var data,
          x0 = this._x0,
          y0 = this._y0,
          x1,
          y1,
          x2,
          y2,
          x3 = this._x1,
          y3 = this._y1,
          quads = [],
          node = this._root,
          q,
          i;

      if (node) quads.push(new Quad(node, x0, y0, x3, y3));
      if (radius == null) radius = Infinity;
      else {
        x0 = x - radius, y0 = y - radius;
        x3 = x + radius, y3 = y + radius;
        radius *= radius;
      }

      while (q = quads.pop()) {

        // Stop searching if this quadrant can’t contain a closer node.
        if (!(node = q.node)
            || (x1 = q.x0) > x3
            || (y1 = q.y0) > y3
            || (x2 = q.x1) < x0
            || (y2 = q.y1) < y0) continue;

        // Bisect the current quadrant.
        if (node.length) {
          var xm = (x1 + x2) / 2,
              ym = (y1 + y2) / 2;

          quads.push(
            new Quad(node[3], xm, ym, x2, y2),
            new Quad(node[2], x1, ym, xm, y2),
            new Quad(node[1], xm, y1, x2, ym),
            new Quad(node[0], x1, y1, xm, ym)
          );

          // Visit the closest quadrant first.
          if (i = (y >= ym) << 1 | (x >= xm)) {
            q = quads[quads.length - 1];
            quads[quads.length - 1] = quads[quads.length - 1 - i];
            quads[quads.length - 1 - i] = q;
          }
        }

        // Visit this point. (Visiting coincident points isn’t necessary!)
        else {
          var dx = x - +this._x.call(null, node.data),
              dy = y - +this._y.call(null, node.data),
              d2 = dx * dx + dy * dy;
          if (d2 < radius) {
            var d = Math.sqrt(radius = d2);
            x0 = x - d, y0 = y - d;
            x3 = x + d, y3 = y + d;
            data = node.data;
          }
        }
      }

      return data;
    }

    function tree_remove(d) {
      if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

      var parent,
          node = this._root,
          retainer,
          previous,
          next,
          x0 = this._x0,
          y0 = this._y0,
          x1 = this._x1,
          y1 = this._y1,
          x,
          y,
          xm,
          ym,
          right,
          bottom,
          i,
          j;

      // If the tree is empty, initialize the root as a leaf.
      if (!node) return this;

      // Find the leaf node for the point.
      // While descending, also retain the deepest parent with a non-removed sibling.
      if (node.length) while (true) {
        if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
        if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
        if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
        if (!node.length) break;
        if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;
      }

      // Find the point to remove.
      while (node.data !== d) if (!(previous = node, node = node.next)) return this;
      if (next = node.next) delete node.next;

      // If there are multiple coincident points, remove just the point.
      if (previous) return (next ? previous.next = next : delete previous.next), this;

      // If this is the root point, remove it.
      if (!parent) return this._root = next, this;

      // Remove this leaf.
      next ? parent[i] = next : delete parent[i];

      // If the parent now contains exactly one leaf, collapse superfluous parents.
      if ((node = parent[0] || parent[1] || parent[2] || parent[3])
          && node === (parent[3] || parent[2] || parent[1] || parent[0])
          && !node.length) {
        if (retainer) retainer[j] = node;
        else this._root = node;
      }

      return this;
    }

    function removeAll(data) {
      for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
      return this;
    }

    function tree_root() {
      return this._root;
    }

    function tree_size() {
      var size = 0;
      this.visit(function(node) {
        if (!node.length) do ++size; while (node = node.next)
      });
      return size;
    }

    function tree_visit(callback) {
      var quads = [], q, node = this._root, child, x0, y0, x1, y1;
      if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));
      while (q = quads.pop()) {
        if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
          var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
          if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
          if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
          if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
          if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
        }
      }
      return this;
    }

    function tree_visitAfter(callback) {
      var quads = [], next = [], q;
      if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));
      while (q = quads.pop()) {
        var node = q.node;
        if (node.length) {
          var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
          if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
          if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
          if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
          if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
        }
        next.push(q);
      }
      while (q = next.pop()) {
        callback(q.node, q.x0, q.y0, q.x1, q.y1);
      }
      return this;
    }

    function defaultX(d) {
      return d[0];
    }

    function tree_x(_) {
      return arguments.length ? (this._x = _, this) : this._x;
    }

    function defaultY(d) {
      return d[1];
    }

    function tree_y(_) {
      return arguments.length ? (this._y = _, this) : this._y;
    }

    function quadtree(nodes, x, y) {
      var tree = new Quadtree(x == null ? defaultX : x, y == null ? defaultY : y, NaN, NaN, NaN, NaN);
      return nodes == null ? tree : tree.addAll(nodes);
    }

    function Quadtree(x, y, x0, y0, x1, y1) {
      this._x = x;
      this._y = y;
      this._x0 = x0;
      this._y0 = y0;
      this._x1 = x1;
      this._y1 = y1;
      this._root = undefined;
    }

    function leaf_copy(leaf) {
      var copy = {data: leaf.data}, next = copy;
      while (leaf = leaf.next) next = next.next = {data: leaf.data};
      return copy;
    }

    var treeProto = quadtree.prototype = Quadtree.prototype;

    treeProto.copy = function() {
      var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
          node = this._root,
          nodes,
          child;

      if (!node) return copy;

      if (!node.length) return copy._root = leaf_copy(node), copy;

      nodes = [{source: node, target: copy._root = new Array(4)}];
      while (node = nodes.pop()) {
        for (var i = 0; i < 4; ++i) {
          if (child = node.source[i]) {
            if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});
            else node.target[i] = leaf_copy(child);
          }
        }
      }

      return copy;
    };

    treeProto.add = tree_add;
    treeProto.addAll = addAll;
    treeProto.cover = tree_cover;
    treeProto.data = tree_data;
    treeProto.extent = tree_extent;
    treeProto.find = tree_find;
    treeProto.remove = tree_remove;
    treeProto.removeAll = removeAll;
    treeProto.root = tree_root;
    treeProto.size = tree_size;
    treeProto.visit = tree_visit;
    treeProto.visitAfter = tree_visitAfter;
    treeProto.x = tree_x;
    treeProto.y = tree_y;

    function x$4(d) {
      return d.x + d.vx;
    }

    function y$4(d) {
      return d.y + d.vy;
    }

    function collide(radius) {
      var nodes,
          radii,
          strength = 1,
          iterations = 1;

      if (typeof radius !== "function") radius = constant$6(radius == null ? 1 : +radius);

      function force() {
        var i, n = nodes.length,
            tree,
            node,
            xi,
            yi,
            ri,
            ri2;

        for (var k = 0; k < iterations; ++k) {
          tree = quadtree(nodes, x$4, y$4).visitAfter(prepare);
          for (i = 0; i < n; ++i) {
            node = nodes[i];
            ri = radii[node.index], ri2 = ri * ri;
            xi = node.x + node.vx;
            yi = node.y + node.vy;
            tree.visit(apply);
          }
        }

        function apply(quad, x0, y0, x1, y1) {
          var data = quad.data, rj = quad.r, r = ri + rj;
          if (data) {
            if (data.index > node.index) {
              var x = xi - data.x - data.vx,
                  y = yi - data.y - data.vy,
                  l = x * x + y * y;
              if (l < r * r) {
                if (x === 0) x = jiggle(), l += x * x;
                if (y === 0) y = jiggle(), l += y * y;
                l = (r - (l = Math.sqrt(l))) / l * strength;
                node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
                node.vy += (y *= l) * r;
                data.vx -= x * (r = 1 - r);
                data.vy -= y * r;
              }
            }
            return;
          }
          return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
        }
      }

      function prepare(quad) {
        if (quad.data) return quad.r = radii[quad.data.index];
        for (var i = quad.r = 0; i < 4; ++i) {
          if (quad[i] && quad[i].r > quad.r) {
            quad.r = quad[i].r;
          }
        }
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length, node;
        radii = new Array(n);
        for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);
      }

      force.initialize = function(_) {
        nodes = _;
        initialize();
      };

      force.iterations = function(_) {
        return arguments.length ? (iterations = +_, force) : iterations;
      };

      force.strength = function(_) {
        return arguments.length ? (strength = +_, force) : strength;
      };

      force.radius = function(_) {
        return arguments.length ? (radius = typeof _ === "function" ? _ : constant$6(+_), initialize(), force) : radius;
      };

      return force;
    }

    function index$3(d) {
      return d.index;
    }

    function find(nodeById, nodeId) {
      var node = nodeById.get(nodeId);
      if (!node) throw new Error("missing: " + nodeId);
      return node;
    }

    function link$2(links) {
      var id = index$3,
          strength = defaultStrength,
          strengths,
          distance = constant$6(30),
          distances,
          nodes,
          count,
          bias,
          iterations = 1;

      if (links == null) links = [];

      function defaultStrength(link) {
        return 1 / Math.min(count[link.source.index], count[link.target.index]);
      }

      function force(alpha) {
        for (var k = 0, n = links.length; k < iterations; ++k) {
          for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {
            link = links[i], source = link.source, target = link.target;
            x = target.x + target.vx - source.x - source.vx || jiggle();
            y = target.y + target.vy - source.y - source.vy || jiggle();
            l = Math.sqrt(x * x + y * y);
            l = (l - distances[i]) / l * alpha * strengths[i];
            x *= l, y *= l;
            target.vx -= x * (b = bias[i]);
            target.vy -= y * b;
            source.vx += x * (b = 1 - b);
            source.vy += y * b;
          }
        }
      }

      function initialize() {
        if (!nodes) return;

        var i,
            n = nodes.length,
            m = links.length,
            nodeById = map$2(nodes, id),
            link;

        for (i = 0, count = new Array(n); i < m; ++i) {
          link = links[i], link.index = i;
          if (typeof link.source !== "object") link.source = find(nodeById, link.source);
          if (typeof link.target !== "object") link.target = find(nodeById, link.target);
          count[link.source.index] = (count[link.source.index] || 0) + 1;
          count[link.target.index] = (count[link.target.index] || 0) + 1;
        }

        for (i = 0, bias = new Array(m); i < m; ++i) {
          link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
        }

        strengths = new Array(m), initializeStrength();
        distances = new Array(m), initializeDistance();
      }

      function initializeStrength() {
        if (!nodes) return;

        for (var i = 0, n = links.length; i < n; ++i) {
          strengths[i] = +strength(links[i], i, links);
        }
      }

      function initializeDistance() {
        if (!nodes) return;

        for (var i = 0, n = links.length; i < n; ++i) {
          distances[i] = +distance(links[i], i, links);
        }
      }

      force.initialize = function(_) {
        nodes = _;
        initialize();
      };

      force.links = function(_) {
        return arguments.length ? (links = _, initialize(), force) : links;
      };

      force.id = function(_) {
        return arguments.length ? (id = _, force) : id;
      };

      force.iterations = function(_) {
        return arguments.length ? (iterations = +_, force) : iterations;
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$6(+_), initializeStrength(), force) : strength;
      };

      force.distance = function(_) {
        return arguments.length ? (distance = typeof _ === "function" ? _ : constant$6(+_), initializeDistance(), force) : distance;
      };

      return force;
    }

    function x$3(d) {
      return d.x;
    }

    function y$3(d) {
      return d.y;
    }

    var initialRadius = 10,
        initialAngle = Math.PI * (3 - Math.sqrt(5));

    function simulation(nodes) {
      var simulation,
          alpha = 1,
          alphaMin = 0.001,
          alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),
          alphaTarget = 0,
          velocityDecay = 0.6,
          forces = map$2(),
          stepper = timer(step),
          event = dispatch("tick", "end");

      if (nodes == null) nodes = [];

      function step() {
        tick();
        event.call("tick", simulation);
        if (alpha < alphaMin) {
          stepper.stop();
          event.call("end", simulation);
        }
      }

      function tick(iterations) {
        var i, n = nodes.length, node;

        if (iterations === undefined) iterations = 1;

        for (var k = 0; k < iterations; ++k) {
          alpha += (alphaTarget - alpha) * alphaDecay;

          forces.each(function (force) {
            force(alpha);
          });

          for (i = 0; i < n; ++i) {
            node = nodes[i];
            if (node.fx == null) node.x += node.vx *= velocityDecay;
            else node.x = node.fx, node.vx = 0;
            if (node.fy == null) node.y += node.vy *= velocityDecay;
            else node.y = node.fy, node.vy = 0;
          }
        }

        return simulation;
      }

      function initializeNodes() {
        for (var i = 0, n = nodes.length, node; i < n; ++i) {
          node = nodes[i], node.index = i;
          if (node.fx != null) node.x = node.fx;
          if (node.fy != null) node.y = node.fy;
          if (isNaN(node.x) || isNaN(node.y)) {
            var radius = initialRadius * Math.sqrt(i), angle = i * initialAngle;
            node.x = radius * Math.cos(angle);
            node.y = radius * Math.sin(angle);
          }
          if (isNaN(node.vx) || isNaN(node.vy)) {
            node.vx = node.vy = 0;
          }
        }
      }

      function initializeForce(force) {
        if (force.initialize) force.initialize(nodes);
        return force;
      }

      initializeNodes();

      return simulation = {
        tick: tick,

        restart: function() {
          return stepper.restart(step), simulation;
        },

        stop: function() {
          return stepper.stop(), simulation;
        },

        nodes: function(_) {
          return arguments.length ? (nodes = _, initializeNodes(), forces.each(initializeForce), simulation) : nodes;
        },

        alpha: function(_) {
          return arguments.length ? (alpha = +_, simulation) : alpha;
        },

        alphaMin: function(_) {
          return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
        },

        alphaDecay: function(_) {
          return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
        },

        alphaTarget: function(_) {
          return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
        },

        velocityDecay: function(_) {
          return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
        },

        force: function(name, _) {
          return arguments.length > 1 ? ((_ == null ? forces.remove(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);
        },

        find: function(x, y, radius) {
          var i = 0,
              n = nodes.length,
              dx,
              dy,
              d2,
              node,
              closest;

          if (radius == null) radius = Infinity;
          else radius *= radius;

          for (i = 0; i < n; ++i) {
            node = nodes[i];
            dx = x - node.x;
            dy = y - node.y;
            d2 = dx * dx + dy * dy;
            if (d2 < radius) closest = node, radius = d2;
          }

          return closest;
        },

        on: function(name, _) {
          return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
        }
      };
    }

    function manyBody() {
      var nodes,
          node,
          alpha,
          strength = constant$6(-30),
          strengths,
          distanceMin2 = 1,
          distanceMax2 = Infinity,
          theta2 = 0.81;

      function force(_) {
        var i, n = nodes.length, tree = quadtree(nodes, x$3, y$3).visitAfter(accumulate);
        for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length, node;
        strengths = new Array(n);
        for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);
      }

      function accumulate(quad) {
        var strength = 0, q, c, weight = 0, x, y, i;

        // For internal nodes, accumulate forces from child quadrants.
        if (quad.length) {
          for (x = y = i = 0; i < 4; ++i) {
            if ((q = quad[i]) && (c = Math.abs(q.value))) {
              strength += q.value, weight += c, x += c * q.x, y += c * q.y;
            }
          }
          quad.x = x / weight;
          quad.y = y / weight;
        }

        // For leaf nodes, accumulate forces from coincident quadrants.
        else {
          q = quad;
          q.x = q.data.x;
          q.y = q.data.y;
          do strength += strengths[q.data.index];
          while (q = q.next);
        }

        quad.value = strength;
      }

      function apply(quad, x1, _, x2) {
        if (!quad.value) return true;

        var x = quad.x - node.x,
            y = quad.y - node.y,
            w = x2 - x1,
            l = x * x + y * y;

        // Apply the Barnes-Hut approximation if possible.
        // Limit forces for very close nodes; randomize direction if coincident.
        if (w * w / theta2 < l) {
          if (l < distanceMax2) {
            if (x === 0) x = jiggle(), l += x * x;
            if (y === 0) y = jiggle(), l += y * y;
            if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
            node.vx += x * quad.value * alpha / l;
            node.vy += y * quad.value * alpha / l;
          }
          return true;
        }

        // Otherwise, process points directly.
        else if (quad.length || l >= distanceMax2) return;

        // Limit forces for very close nodes; randomize direction if coincident.
        if (quad.data !== node || quad.next) {
          if (x === 0) x = jiggle(), l += x * x;
          if (y === 0) y = jiggle(), l += y * y;
          if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
        }

        do if (quad.data !== node) {
          w = strengths[quad.data.index] * alpha / l;
          node.vx += x * w;
          node.vy += y * w;
        } while (quad = quad.next);
      }

      force.initialize = function(_) {
        nodes = _;
        initialize();
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$6(+_), initialize(), force) : strength;
      };

      force.distanceMin = function(_) {
        return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
      };

      force.distanceMax = function(_) {
        return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
      };

      force.theta = function(_) {
        return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
      };

      return force;
    }

    function radial(radius, x, y) {
      var nodes,
          strength = constant$6(0.1),
          strengths,
          radiuses;

      if (typeof radius !== "function") radius = constant$6(+radius);
      if (x == null) x = 0;
      if (y == null) y = 0;

      function force(alpha) {
        for (var i = 0, n = nodes.length; i < n; ++i) {
          var node = nodes[i],
              dx = node.x - x || 1e-6,
              dy = node.y - y || 1e-6,
              r = Math.sqrt(dx * dx + dy * dy),
              k = (radiuses[i] - r) * strengths[i] * alpha / r;
          node.vx += dx * k;
          node.vy += dy * k;
        }
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length;
        strengths = new Array(n);
        radiuses = new Array(n);
        for (i = 0; i < n; ++i) {
          radiuses[i] = +radius(nodes[i], i, nodes);
          strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);
        }
      }

      force.initialize = function(_) {
        nodes = _, initialize();
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$6(+_), initialize(), force) : strength;
      };

      force.radius = function(_) {
        return arguments.length ? (radius = typeof _ === "function" ? _ : constant$6(+_), initialize(), force) : radius;
      };

      force.x = function(_) {
        return arguments.length ? (x = +_, force) : x;
      };

      force.y = function(_) {
        return arguments.length ? (y = +_, force) : y;
      };

      return force;
    }

    function x$2(x) {
      var strength = constant$6(0.1),
          nodes,
          strengths,
          xz;

      if (typeof x !== "function") x = constant$6(x == null ? 0 : +x);

      function force(alpha) {
        for (var i = 0, n = nodes.length, node; i < n; ++i) {
          node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
        }
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length;
        strengths = new Array(n);
        xz = new Array(n);
        for (i = 0; i < n; ++i) {
          strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
        }
      }

      force.initialize = function(_) {
        nodes = _;
        initialize();
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$6(+_), initialize(), force) : strength;
      };

      force.x = function(_) {
        return arguments.length ? (x = typeof _ === "function" ? _ : constant$6(+_), initialize(), force) : x;
      };

      return force;
    }

    function y$2(y) {
      var strength = constant$6(0.1),
          nodes,
          strengths,
          yz;

      if (typeof y !== "function") y = constant$6(y == null ? 0 : +y);

      function force(alpha) {
        for (var i = 0, n = nodes.length, node; i < n; ++i) {
          node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
        }
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length;
        strengths = new Array(n);
        yz = new Array(n);
        for (i = 0; i < n; ++i) {
          strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
        }
      }

      force.initialize = function(_) {
        nodes = _;
        initialize();
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$6(+_), initialize(), force) : strength;
      };

      force.y = function(_) {
        return arguments.length ? (y = typeof _ === "function" ? _ : constant$6(+_), initialize(), force) : y;
      };

      return force;
    }

    function formatDecimal(x) {
      return Math.abs(x = Math.round(x)) >= 1e21
          ? x.toLocaleString("en").replace(/,/g, "")
          : x.toString(10);
    }

    // Computes the decimal coefficient and exponent of the specified number x with
    // significant digits p, where x is positive and p is in [1, 21] or undefined.
    // For example, formatDecimalParts(1.23) returns ["123", 0].
    function formatDecimalParts(x, p) {
      if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
      var i, coefficient = x.slice(0, i);

      // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
      // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
      return [
        coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
        +x.slice(i + 1)
      ];
    }

    function exponent(x) {
      return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
    }

    function formatGroup(grouping, thousands) {
      return function(value, width) {
        var i = value.length,
            t = [],
            j = 0,
            g = grouping[0],
            length = 0;

        while (i > 0 && g > 0) {
          if (length + g + 1 > width) g = Math.max(1, width - length);
          t.push(value.substring(i -= g, i + g));
          if ((length += g + 1) > width) break;
          g = grouping[j = (j + 1) % grouping.length];
        }

        return t.reverse().join(thousands);
      };
    }

    function formatNumerals(numerals) {
      return function(value) {
        return value.replace(/[0-9]/g, function(i) {
          return numerals[+i];
        });
      };
    }

    // [[fill]align][sign][symbol][0][width][,][.precision][~][type]
    var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

    function formatSpecifier(specifier) {
      if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
      var match;
      return new FormatSpecifier({
        fill: match[1],
        align: match[2],
        sign: match[3],
        symbol: match[4],
        zero: match[5],
        width: match[6],
        comma: match[7],
        precision: match[8] && match[8].slice(1),
        trim: match[9],
        type: match[10]
      });
    }

    formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

    function FormatSpecifier(specifier) {
      this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
      this.align = specifier.align === undefined ? ">" : specifier.align + "";
      this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
      this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
      this.zero = !!specifier.zero;
      this.width = specifier.width === undefined ? undefined : +specifier.width;
      this.comma = !!specifier.comma;
      this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
      this.trim = !!specifier.trim;
      this.type = specifier.type === undefined ? "" : specifier.type + "";
    }

    FormatSpecifier.prototype.toString = function() {
      return this.fill
          + this.align
          + this.sign
          + this.symbol
          + (this.zero ? "0" : "")
          + (this.width === undefined ? "" : Math.max(1, this.width | 0))
          + (this.comma ? "," : "")
          + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
          + (this.trim ? "~" : "")
          + this.type;
    };

    // Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
    function formatTrim(s) {
      out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
        switch (s[i]) {
          case ".": i0 = i1 = i; break;
          case "0": if (i0 === 0) i0 = i; i1 = i; break;
          default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
        }
      }
      return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
    }

    var prefixExponent;

    function formatPrefixAuto(x, p) {
      var d = formatDecimalParts(x, p);
      if (!d) return x + "";
      var coefficient = d[0],
          exponent = d[1],
          i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
          n = coefficient.length;
      return i === n ? coefficient
          : i > n ? coefficient + new Array(i - n + 1).join("0")
          : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
          : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0]; // less than 1y!
    }

    function formatRounded(x, p) {
      var d = formatDecimalParts(x, p);
      if (!d) return x + "";
      var coefficient = d[0],
          exponent = d[1];
      return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
          : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
          : coefficient + new Array(exponent - coefficient.length + 2).join("0");
    }

    var formatTypes = {
      "%": function(x, p) { return (x * 100).toFixed(p); },
      "b": function(x) { return Math.round(x).toString(2); },
      "c": function(x) { return x + ""; },
      "d": formatDecimal,
      "e": function(x, p) { return x.toExponential(p); },
      "f": function(x, p) { return x.toFixed(p); },
      "g": function(x, p) { return x.toPrecision(p); },
      "o": function(x) { return Math.round(x).toString(8); },
      "p": function(x, p) { return formatRounded(x * 100, p); },
      "r": formatRounded,
      "s": formatPrefixAuto,
      "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
      "x": function(x) { return Math.round(x).toString(16); }
    };

    function identity$6(x) {
      return x;
    }

    var map$1 = Array.prototype.map,
        prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

    function formatLocale$1(locale) {
      var group = locale.grouping === undefined || locale.thousands === undefined ? identity$6 : formatGroup(map$1.call(locale.grouping, Number), locale.thousands + ""),
          currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
          currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
          decimal = locale.decimal === undefined ? "." : locale.decimal + "",
          numerals = locale.numerals === undefined ? identity$6 : formatNumerals(map$1.call(locale.numerals, String)),
          percent = locale.percent === undefined ? "%" : locale.percent + "",
          minus = locale.minus === undefined ? "-" : locale.minus + "",
          nan = locale.nan === undefined ? "NaN" : locale.nan + "";

      function newFormat(specifier) {
        specifier = formatSpecifier(specifier);

        var fill = specifier.fill,
            align = specifier.align,
            sign = specifier.sign,
            symbol = specifier.symbol,
            zero = specifier.zero,
            width = specifier.width,
            comma = specifier.comma,
            precision = specifier.precision,
            trim = specifier.trim,
            type = specifier.type;

        // The "n" type is an alias for ",g".
        if (type === "n") comma = true, type = "g";

        // The "" type, and any invalid type, is an alias for ".12~g".
        else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = "g";

        // If zero fill is specified, padding goes after sign and before digits.
        if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

        // Compute the prefix and suffix.
        // For SI-prefix, the suffix is lazily computed.
        var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
            suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

        // What format function should we use?
        // Is this an integer type?
        // Can this type generate exponential notation?
        var formatType = formatTypes[type],
            maybeSuffix = /[defgprs%]/.test(type);

        // Set the default precision if not specified,
        // or clamp the specified precision to the supported range.
        // For significant precision, it must be in [1, 21].
        // For fixed precision, it must be in [0, 20].
        precision = precision === undefined ? 6
            : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
            : Math.max(0, Math.min(20, precision));

        function format(value) {
          var valuePrefix = prefix,
              valueSuffix = suffix,
              i, n, c;

          if (type === "c") {
            valueSuffix = formatType(value) + valueSuffix;
            value = "";
          } else {
            value = +value;

            // Determine the sign. -0 is not less than 0, but 1 / -0 is!
            var valueNegative = value < 0 || 1 / value < 0;

            // Perform the initial formatting.
            value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

            // Trim insignificant zeros.
            if (trim) value = formatTrim(value);

            // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
            if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;

            // Compute the prefix and suffix.
            valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
            valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

            // Break the formatted value into the integer “value” part that can be
            // grouped, and fractional or exponential “suffix” part that is not.
            if (maybeSuffix) {
              i = -1, n = value.length;
              while (++i < n) {
                if (c = value.charCodeAt(i), 48 > c || c > 57) {
                  valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                  value = value.slice(0, i);
                  break;
                }
              }
            }
          }

          // If the fill character is not "0", grouping is applied before padding.
          if (comma && !zero) value = group(value, Infinity);

          // Compute the padding.
          var length = valuePrefix.length + value.length + valueSuffix.length,
              padding = length < width ? new Array(width - length + 1).join(fill) : "";

          // If the fill character is "0", grouping is applied after padding.
          if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

          // Reconstruct the final output based on the desired alignment.
          switch (align) {
            case "<": value = valuePrefix + value + valueSuffix + padding; break;
            case "=": value = valuePrefix + padding + value + valueSuffix; break;
            case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
            default: value = padding + valuePrefix + value + valueSuffix; break;
          }

          return numerals(value);
        }

        format.toString = function() {
          return specifier + "";
        };

        return format;
      }

      function formatPrefix(specifier, value) {
        var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
            e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
            k = Math.pow(10, -e),
            prefix = prefixes[8 + e / 3];
        return function(value) {
          return f(k * value) + prefix;
        };
      }

      return {
        format: newFormat,
        formatPrefix: formatPrefix
      };
    }

    var locale$1;
    var format;
    var formatPrefix;

    defaultLocale$1({
      decimal: ".",
      thousands: ",",
      grouping: [3],
      currency: ["$", ""],
      minus: "-"
    });

    function defaultLocale$1(definition) {
      locale$1 = formatLocale$1(definition);
      format = locale$1.format;
      formatPrefix = locale$1.formatPrefix;
      return locale$1;
    }

    function precisionFixed(step) {
      return Math.max(0, -exponent(Math.abs(step)));
    }

    function precisionPrefix(step, value) {
      return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
    }

    function precisionRound(step, max) {
      step = Math.abs(step), max = Math.abs(max) - step;
      return Math.max(0, exponent(max) - exponent(step)) + 1;
    }

    // Adds floating point numbers with twice the normal precision.
    // Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and
    // Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)
    // 305–363 (1997).
    // Code adapted from GeographicLib by Charles F. F. Karney,
    // http://geographiclib.sourceforge.net/

    function adder() {
      return new Adder;
    }

    function Adder() {
      this.reset();
    }

    Adder.prototype = {
      constructor: Adder,
      reset: function() {
        this.s = // rounded value
        this.t = 0; // exact error
      },
      add: function(y) {
        add(temp, y, this.t);
        add(this, temp.s, this.s);
        if (this.s) this.t += temp.t;
        else this.s = temp.t;
      },
      valueOf: function() {
        return this.s;
      }
    };

    var temp = new Adder;

    function add(adder, a, b) {
      var x = adder.s = a + b,
          bv = x - a,
          av = x - bv;
      adder.t = (a - av) + (b - bv);
    }

    var epsilon$2 = 1e-6;
    var epsilon2$1 = 1e-12;
    var pi$1 = Math.PI;
    var halfPi$1 = pi$1 / 2;
    var quarterPi = pi$1 / 4;
    var tau$1 = pi$1 * 2;

    var degrees = 180 / pi$1;
    var radians = pi$1 / 180;

    var abs$1 = Math.abs;
    var atan = Math.atan;
    var atan2$1 = Math.atan2;
    var cos$1 = Math.cos;
    var ceil = Math.ceil;
    var exp = Math.exp;
    var log$1 = Math.log;
    var pow$1 = Math.pow;
    var sin$1 = Math.sin;
    var sign$1 = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };
    var sqrt$2 = Math.sqrt;
    var tan = Math.tan;

    function acos$1(x) {
      return x > 1 ? 0 : x < -1 ? pi$1 : Math.acos(x);
    }

    function asin$1(x) {
      return x > 1 ? halfPi$1 : x < -1 ? -halfPi$1 : Math.asin(x);
    }

    function haversin(x) {
      return (x = sin$1(x / 2)) * x;
    }

    function noop$1() {}

    function streamGeometry(geometry, stream) {
      if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
        streamGeometryType[geometry.type](geometry, stream);
      }
    }

    var streamObjectType = {
      Feature: function(object, stream) {
        streamGeometry(object.geometry, stream);
      },
      FeatureCollection: function(object, stream) {
        var features = object.features, i = -1, n = features.length;
        while (++i < n) streamGeometry(features[i].geometry, stream);
      }
    };

    var streamGeometryType = {
      Sphere: function(object, stream) {
        stream.sphere();
      },
      Point: function(object, stream) {
        object = object.coordinates;
        stream.point(object[0], object[1], object[2]);
      },
      MultiPoint: function(object, stream) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
      },
      LineString: function(object, stream) {
        streamLine(object.coordinates, stream, 0);
      },
      MultiLineString: function(object, stream) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) streamLine(coordinates[i], stream, 0);
      },
      Polygon: function(object, stream) {
        streamPolygon(object.coordinates, stream);
      },
      MultiPolygon: function(object, stream) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) streamPolygon(coordinates[i], stream);
      },
      GeometryCollection: function(object, stream) {
        var geometries = object.geometries, i = -1, n = geometries.length;
        while (++i < n) streamGeometry(geometries[i], stream);
      }
    };

    function streamLine(coordinates, stream, closed) {
      var i = -1, n = coordinates.length - closed, coordinate;
      stream.lineStart();
      while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
      stream.lineEnd();
    }

    function streamPolygon(coordinates, stream) {
      var i = -1, n = coordinates.length;
      stream.polygonStart();
      while (++i < n) streamLine(coordinates[i], stream, 1);
      stream.polygonEnd();
    }

    function geoStream(object, stream) {
      if (object && streamObjectType.hasOwnProperty(object.type)) {
        streamObjectType[object.type](object, stream);
      } else {
        streamGeometry(object, stream);
      }
    }

    var areaRingSum$1 = adder();

    var areaSum$1 = adder(),
        lambda00$2,
        phi00$2,
        lambda0$2,
        cosPhi0$1,
        sinPhi0$1;

    var areaStream$1 = {
      point: noop$1,
      lineStart: noop$1,
      lineEnd: noop$1,
      polygonStart: function() {
        areaRingSum$1.reset();
        areaStream$1.lineStart = areaRingStart$1;
        areaStream$1.lineEnd = areaRingEnd$1;
      },
      polygonEnd: function() {
        var areaRing = +areaRingSum$1;
        areaSum$1.add(areaRing < 0 ? tau$1 + areaRing : areaRing);
        this.lineStart = this.lineEnd = this.point = noop$1;
      },
      sphere: function() {
        areaSum$1.add(tau$1);
      }
    };

    function areaRingStart$1() {
      areaStream$1.point = areaPointFirst$1;
    }

    function areaRingEnd$1() {
      areaPoint$1(lambda00$2, phi00$2);
    }

    function areaPointFirst$1(lambda, phi) {
      areaStream$1.point = areaPoint$1;
      lambda00$2 = lambda, phi00$2 = phi;
      lambda *= radians, phi *= radians;
      lambda0$2 = lambda, cosPhi0$1 = cos$1(phi = phi / 2 + quarterPi), sinPhi0$1 = sin$1(phi);
    }

    function areaPoint$1(lambda, phi) {
      lambda *= radians, phi *= radians;
      phi = phi / 2 + quarterPi; // half the angular distance from south pole

      // Spherical excess E for a spherical triangle with vertices: south pole,
      // previous point, current point.  Uses a formula derived from Cagnoli’s
      // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).
      var dLambda = lambda - lambda0$2,
          sdLambda = dLambda >= 0 ? 1 : -1,
          adLambda = sdLambda * dLambda,
          cosPhi = cos$1(phi),
          sinPhi = sin$1(phi),
          k = sinPhi0$1 * sinPhi,
          u = cosPhi0$1 * cosPhi + k * cos$1(adLambda),
          v = k * sdLambda * sin$1(adLambda);
      areaRingSum$1.add(atan2$1(v, u));

      // Advance the previous points.
      lambda0$2 = lambda, cosPhi0$1 = cosPhi, sinPhi0$1 = sinPhi;
    }

    function area$2(object) {
      areaSum$1.reset();
      geoStream(object, areaStream$1);
      return areaSum$1 * 2;
    }

    function spherical(cartesian) {
      return [atan2$1(cartesian[1], cartesian[0]), asin$1(cartesian[2])];
    }

    function cartesian(spherical) {
      var lambda = spherical[0], phi = spherical[1], cosPhi = cos$1(phi);
      return [cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi)];
    }

    function cartesianDot(a, b) {
      return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    }

    function cartesianCross(a, b) {
      return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
    }

    // TODO return a
    function cartesianAddInPlace(a, b) {
      a[0] += b[0], a[1] += b[1], a[2] += b[2];
    }

    function cartesianScale(vector, k) {
      return [vector[0] * k, vector[1] * k, vector[2] * k];
    }

    // TODO return d
    function cartesianNormalizeInPlace(d) {
      var l = sqrt$2(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
      d[0] /= l, d[1] /= l, d[2] /= l;
    }

    var lambda0$1, phi0, lambda1, phi1, // bounds
        lambda2, // previous lambda-coordinate
        lambda00$1, phi00$1, // first point
        p0, // previous 3D point
        deltaSum = adder(),
        ranges,
        range;

    var boundsStream$2 = {
      point: boundsPoint$1,
      lineStart: boundsLineStart,
      lineEnd: boundsLineEnd,
      polygonStart: function() {
        boundsStream$2.point = boundsRingPoint;
        boundsStream$2.lineStart = boundsRingStart;
        boundsStream$2.lineEnd = boundsRingEnd;
        deltaSum.reset();
        areaStream$1.polygonStart();
      },
      polygonEnd: function() {
        areaStream$1.polygonEnd();
        boundsStream$2.point = boundsPoint$1;
        boundsStream$2.lineStart = boundsLineStart;
        boundsStream$2.lineEnd = boundsLineEnd;
        if (areaRingSum$1 < 0) lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
        else if (deltaSum > epsilon$2) phi1 = 90;
        else if (deltaSum < -epsilon$2) phi0 = -90;
        range[0] = lambda0$1, range[1] = lambda1;
      },
      sphere: function() {
        lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
      }
    };

    function boundsPoint$1(lambda, phi) {
      ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
      if (phi < phi0) phi0 = phi;
      if (phi > phi1) phi1 = phi;
    }

    function linePoint(lambda, phi) {
      var p = cartesian([lambda * radians, phi * radians]);
      if (p0) {
        var normal = cartesianCross(p0, p),
            equatorial = [normal[1], -normal[0], 0],
            inflection = cartesianCross(equatorial, normal);
        cartesianNormalizeInPlace(inflection);
        inflection = spherical(inflection);
        var delta = lambda - lambda2,
            sign = delta > 0 ? 1 : -1,
            lambdai = inflection[0] * degrees * sign,
            phii,
            antimeridian = abs$1(delta) > 180;
        if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
          phii = inflection[1] * degrees;
          if (phii > phi1) phi1 = phii;
        } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
          phii = -inflection[1] * degrees;
          if (phii < phi0) phi0 = phii;
        } else {
          if (phi < phi0) phi0 = phi;
          if (phi > phi1) phi1 = phi;
        }
        if (antimeridian) {
          if (lambda < lambda2) {
            if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
          } else {
            if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
          }
        } else {
          if (lambda1 >= lambda0$1) {
            if (lambda < lambda0$1) lambda0$1 = lambda;
            if (lambda > lambda1) lambda1 = lambda;
          } else {
            if (lambda > lambda2) {
              if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
            } else {
              if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
            }
          }
        }
      } else {
        ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
      }
      if (phi < phi0) phi0 = phi;
      if (phi > phi1) phi1 = phi;
      p0 = p, lambda2 = lambda;
    }

    function boundsLineStart() {
      boundsStream$2.point = linePoint;
    }

    function boundsLineEnd() {
      range[0] = lambda0$1, range[1] = lambda1;
      boundsStream$2.point = boundsPoint$1;
      p0 = null;
    }

    function boundsRingPoint(lambda, phi) {
      if (p0) {
        var delta = lambda - lambda2;
        deltaSum.add(abs$1(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
      } else {
        lambda00$1 = lambda, phi00$1 = phi;
      }
      areaStream$1.point(lambda, phi);
      linePoint(lambda, phi);
    }

    function boundsRingStart() {
      areaStream$1.lineStart();
    }

    function boundsRingEnd() {
      boundsRingPoint(lambda00$1, phi00$1);
      areaStream$1.lineEnd();
      if (abs$1(deltaSum) > epsilon$2) lambda0$1 = -(lambda1 = 180);
      range[0] = lambda0$1, range[1] = lambda1;
      p0 = null;
    }

    // Finds the left-right distance between two longitudes.
    // This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want
    // the distance between ±180° to be 360°.
    function angle(lambda0, lambda1) {
      return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;
    }

    function rangeCompare(a, b) {
      return a[0] - b[0];
    }

    function rangeContains(range, x) {
      return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
    }

    function bounds(feature) {
      var i, n, a, b, merged, deltaMax, delta;

      phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);
      ranges = [];
      geoStream(feature, boundsStream$2);

      // First, sort ranges by their minimum longitudes.
      if (n = ranges.length) {
        ranges.sort(rangeCompare);

        // Then, merge any ranges that overlap.
        for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
          b = ranges[i];
          if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
            if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
            if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
          } else {
            merged.push(a = b);
          }
        }

        // Finally, find the largest gap between the merged ranges.
        // The final bounding box will be the inverse of this gap.
        for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
          b = merged[i];
          if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0$1 = b[0], lambda1 = a[1];
        }
      }

      ranges = range = null;

      return lambda0$1 === Infinity || phi0 === Infinity
          ? [[NaN, NaN], [NaN, NaN]]
          : [[lambda0$1, phi0], [lambda1, phi1]];
    }

    var W0, W1,
        X0$1, Y0$1, Z0$1,
        X1$1, Y1$1, Z1$1,
        X2$1, Y2$1, Z2$1,
        lambda00, phi00, // first point
        x0$4, y0$4, z0; // previous point

    var centroidStream$1 = {
      sphere: noop$1,
      point: centroidPoint$1,
      lineStart: centroidLineStart$1,
      lineEnd: centroidLineEnd$1,
      polygonStart: function() {
        centroidStream$1.lineStart = centroidRingStart$1;
        centroidStream$1.lineEnd = centroidRingEnd$1;
      },
      polygonEnd: function() {
        centroidStream$1.lineStart = centroidLineStart$1;
        centroidStream$1.lineEnd = centroidLineEnd$1;
      }
    };

    // Arithmetic mean of Cartesian vectors.
    function centroidPoint$1(lambda, phi) {
      lambda *= radians, phi *= radians;
      var cosPhi = cos$1(phi);
      centroidPointCartesian(cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi));
    }

    function centroidPointCartesian(x, y, z) {
      ++W0;
      X0$1 += (x - X0$1) / W0;
      Y0$1 += (y - Y0$1) / W0;
      Z0$1 += (z - Z0$1) / W0;
    }

    function centroidLineStart$1() {
      centroidStream$1.point = centroidLinePointFirst;
    }

    function centroidLinePointFirst(lambda, phi) {
      lambda *= radians, phi *= radians;
      var cosPhi = cos$1(phi);
      x0$4 = cosPhi * cos$1(lambda);
      y0$4 = cosPhi * sin$1(lambda);
      z0 = sin$1(phi);
      centroidStream$1.point = centroidLinePoint;
      centroidPointCartesian(x0$4, y0$4, z0);
    }

    function centroidLinePoint(lambda, phi) {
      lambda *= radians, phi *= radians;
      var cosPhi = cos$1(phi),
          x = cosPhi * cos$1(lambda),
          y = cosPhi * sin$1(lambda),
          z = sin$1(phi),
          w = atan2$1(sqrt$2((w = y0$4 * z - z0 * y) * w + (w = z0 * x - x0$4 * z) * w + (w = x0$4 * y - y0$4 * x) * w), x0$4 * x + y0$4 * y + z0 * z);
      W1 += w;
      X1$1 += w * (x0$4 + (x0$4 = x));
      Y1$1 += w * (y0$4 + (y0$4 = y));
      Z1$1 += w * (z0 + (z0 = z));
      centroidPointCartesian(x0$4, y0$4, z0);
    }

    function centroidLineEnd$1() {
      centroidStream$1.point = centroidPoint$1;
    }

    // See J. E. Brock, The Inertia Tensor for a Spherical Triangle,
    // J. Applied Mechanics 42, 239 (1975).
    function centroidRingStart$1() {
      centroidStream$1.point = centroidRingPointFirst;
    }

    function centroidRingEnd$1() {
      centroidRingPoint(lambda00, phi00);
      centroidStream$1.point = centroidPoint$1;
    }

    function centroidRingPointFirst(lambda, phi) {
      lambda00 = lambda, phi00 = phi;
      lambda *= radians, phi *= radians;
      centroidStream$1.point = centroidRingPoint;
      var cosPhi = cos$1(phi);
      x0$4 = cosPhi * cos$1(lambda);
      y0$4 = cosPhi * sin$1(lambda);
      z0 = sin$1(phi);
      centroidPointCartesian(x0$4, y0$4, z0);
    }

    function centroidRingPoint(lambda, phi) {
      lambda *= radians, phi *= radians;
      var cosPhi = cos$1(phi),
          x = cosPhi * cos$1(lambda),
          y = cosPhi * sin$1(lambda),
          z = sin$1(phi),
          cx = y0$4 * z - z0 * y,
          cy = z0 * x - x0$4 * z,
          cz = x0$4 * y - y0$4 * x,
          m = sqrt$2(cx * cx + cy * cy + cz * cz),
          w = asin$1(m), // line weight = angle
          v = m && -w / m; // area weight multiplier
      X2$1 += v * cx;
      Y2$1 += v * cy;
      Z2$1 += v * cz;
      W1 += w;
      X1$1 += w * (x0$4 + (x0$4 = x));
      Y1$1 += w * (y0$4 + (y0$4 = y));
      Z1$1 += w * (z0 + (z0 = z));
      centroidPointCartesian(x0$4, y0$4, z0);
    }

    function centroid$1(object) {
      W0 = W1 =
      X0$1 = Y0$1 = Z0$1 =
      X1$1 = Y1$1 = Z1$1 =
      X2$1 = Y2$1 = Z2$1 = 0;
      geoStream(object, centroidStream$1);

      var x = X2$1,
          y = Y2$1,
          z = Z2$1,
          m = x * x + y * y + z * z;

      // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.
      if (m < epsilon2$1) {
        x = X1$1, y = Y1$1, z = Z1$1;
        // If the feature has zero length, fall back to arithmetic mean of point vectors.
        if (W1 < epsilon$2) x = X0$1, y = Y0$1, z = Z0$1;
        m = x * x + y * y + z * z;
        // If the feature still has an undefined ccentroid, then return.
        if (m < epsilon2$1) return [NaN, NaN];
      }

      return [atan2$1(y, x) * degrees, asin$1(z / sqrt$2(m)) * degrees];
    }

    function constant$5(x) {
      return function() {
        return x;
      };
    }

    function compose(a, b) {

      function compose(x, y) {
        return x = a(x, y), b(x[0], x[1]);
      }

      if (a.invert && b.invert) compose.invert = function(x, y) {
        return x = b.invert(x, y), x && a.invert(x[0], x[1]);
      };

      return compose;
    }

    function rotationIdentity(lambda, phi) {
      return [abs$1(lambda) > pi$1 ? lambda + Math.round(-lambda / tau$1) * tau$1 : lambda, phi];
    }

    rotationIdentity.invert = rotationIdentity;

    function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
      return (deltaLambda %= tau$1) ? (deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))
        : rotationLambda(deltaLambda))
        : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)
        : rotationIdentity);
    }

    function forwardRotationLambda(deltaLambda) {
      return function(lambda, phi) {
        return lambda += deltaLambda, [lambda > pi$1 ? lambda - tau$1 : lambda < -pi$1 ? lambda + tau$1 : lambda, phi];
      };
    }

    function rotationLambda(deltaLambda) {
      var rotation = forwardRotationLambda(deltaLambda);
      rotation.invert = forwardRotationLambda(-deltaLambda);
      return rotation;
    }

    function rotationPhiGamma(deltaPhi, deltaGamma) {
      var cosDeltaPhi = cos$1(deltaPhi),
          sinDeltaPhi = sin$1(deltaPhi),
          cosDeltaGamma = cos$1(deltaGamma),
          sinDeltaGamma = sin$1(deltaGamma);

      function rotation(lambda, phi) {
        var cosPhi = cos$1(phi),
            x = cos$1(lambda) * cosPhi,
            y = sin$1(lambda) * cosPhi,
            z = sin$1(phi),
            k = z * cosDeltaPhi + x * sinDeltaPhi;
        return [
          atan2$1(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
          asin$1(k * cosDeltaGamma + y * sinDeltaGamma)
        ];
      }

      rotation.invert = function(lambda, phi) {
        var cosPhi = cos$1(phi),
            x = cos$1(lambda) * cosPhi,
            y = sin$1(lambda) * cosPhi,
            z = sin$1(phi),
            k = z * cosDeltaGamma - y * sinDeltaGamma;
        return [
          atan2$1(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
          asin$1(k * cosDeltaPhi - x * sinDeltaPhi)
        ];
      };

      return rotation;
    }

    function rotation(rotate) {
      rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);

      function forward(coordinates) {
        coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);
        return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
      }

      forward.invert = function(coordinates) {
        coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);
        return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
      };

      return forward;
    }

    // Generates a circle centered at [0°, 0°], with a given radius and precision.
    function circleStream(stream, radius, delta, direction, t0, t1) {
      if (!delta) return;
      var cosRadius = cos$1(radius),
          sinRadius = sin$1(radius),
          step = direction * delta;
      if (t0 == null) {
        t0 = radius + direction * tau$1;
        t1 = radius - step / 2;
      } else {
        t0 = circleRadius(cosRadius, t0);
        t1 = circleRadius(cosRadius, t1);
        if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau$1;
      }
      for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
        point = spherical([cosRadius, -sinRadius * cos$1(t), -sinRadius * sin$1(t)]);
        stream.point(point[0], point[1]);
      }
    }

    // Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].
    function circleRadius(cosRadius, point) {
      point = cartesian(point), point[0] -= cosRadius;
      cartesianNormalizeInPlace(point);
      var radius = acos$1(-point[1]);
      return ((-point[2] < 0 ? -radius : radius) + tau$1 - epsilon$2) % tau$1;
    }

    function circle$2() {
      var center = constant$5([0, 0]),
          radius = constant$5(90),
          precision = constant$5(6),
          ring,
          rotate,
          stream = {point: point};

      function point(x, y) {
        ring.push(x = rotate(x, y));
        x[0] *= degrees, x[1] *= degrees;
      }

      function circle() {
        var c = center.apply(this, arguments),
            r = radius.apply(this, arguments) * radians,
            p = precision.apply(this, arguments) * radians;
        ring = [];
        rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;
        circleStream(stream, r, p, 1);
        c = {type: "Polygon", coordinates: [ring]};
        ring = rotate = null;
        return c;
      }

      circle.center = function(_) {
        return arguments.length ? (center = typeof _ === "function" ? _ : constant$5([+_[0], +_[1]]), circle) : center;
      };

      circle.radius = function(_) {
        return arguments.length ? (radius = typeof _ === "function" ? _ : constant$5(+_), circle) : radius;
      };

      circle.precision = function(_) {
        return arguments.length ? (precision = typeof _ === "function" ? _ : constant$5(+_), circle) : precision;
      };

      return circle;
    }

    function clipBuffer() {
      var lines = [],
          line;
      return {
        point: function(x, y, m) {
          line.push([x, y, m]);
        },
        lineStart: function() {
          lines.push(line = []);
        },
        lineEnd: noop$1,
        rejoin: function() {
          if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
        },
        result: function() {
          var result = lines;
          lines = [];
          line = null;
          return result;
        }
      };
    }

    function pointEqual(a, b) {
      return abs$1(a[0] - b[0]) < epsilon$2 && abs$1(a[1] - b[1]) < epsilon$2;
    }

    function Intersection(point, points, other, entry) {
      this.x = point;
      this.z = points;
      this.o = other; // another intersection
      this.e = entry; // is an entry?
      this.v = false; // visited
      this.n = this.p = null; // next & previous
    }

    // A generalized polygon clipping algorithm: given a polygon that has been cut
    // into its visible line segments, and rejoins the segments by interpolating
    // along the clip edge.
    function clipRejoin(segments, compareIntersection, startInside, interpolate, stream) {
      var subject = [],
          clip = [],
          i,
          n;

      segments.forEach(function(segment) {
        if ((n = segment.length - 1) <= 0) return;
        var n, p0 = segment[0], p1 = segment[n], x;

        if (pointEqual(p0, p1)) {
          if (!p0[2] && !p1[2]) {
            stream.lineStart();
            for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);
            stream.lineEnd();
            return;
          }
          // handle degenerate cases by moving the point
          p1[0] += 2 * epsilon$2;
        }

        subject.push(x = new Intersection(p0, segment, null, true));
        clip.push(x.o = new Intersection(p0, null, x, false));
        subject.push(x = new Intersection(p1, segment, null, false));
        clip.push(x.o = new Intersection(p1, null, x, true));
      });

      if (!subject.length) return;

      clip.sort(compareIntersection);
      link$1(subject);
      link$1(clip);

      for (i = 0, n = clip.length; i < n; ++i) {
        clip[i].e = startInside = !startInside;
      }

      var start = subject[0],
          points,
          point;

      while (1) {
        // Find first unvisited intersection.
        var current = start,
            isSubject = true;
        while (current.v) if ((current = current.n) === start) return;
        points = current.z;
        stream.lineStart();
        do {
          current.v = current.o.v = true;
          if (current.e) {
            if (isSubject) {
              for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
            } else {
              interpolate(current.x, current.n.x, 1, stream);
            }
            current = current.n;
          } else {
            if (isSubject) {
              points = current.p.z;
              for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
            } else {
              interpolate(current.x, current.p.x, -1, stream);
            }
            current = current.p;
          }
          current = current.o;
          points = current.z;
          isSubject = !isSubject;
        } while (!current.v);
        stream.lineEnd();
      }
    }

    function link$1(array) {
      if (!(n = array.length)) return;
      var n,
          i = 0,
          a = array[0],
          b;
      while (++i < n) {
        a.n = b = array[i];
        b.p = a;
        a = b;
      }
      a.n = b = array[0];
      b.p = a;
    }

    var sum$1 = adder();

    function longitude(point) {
      if (abs$1(point[0]) <= pi$1)
        return point[0];
      else
        return sign$1(point[0]) * ((abs$1(point[0]) + pi$1) % tau$1 - pi$1);
    }

    function polygonContains(polygon, point) {
      var lambda = longitude(point),
          phi = point[1],
          sinPhi = sin$1(phi),
          normal = [sin$1(lambda), -cos$1(lambda), 0],
          angle = 0,
          winding = 0;

      sum$1.reset();

      if (sinPhi === 1) phi = halfPi$1 + epsilon$2;
      else if (sinPhi === -1) phi = -halfPi$1 - epsilon$2;

      for (var i = 0, n = polygon.length; i < n; ++i) {
        if (!(m = (ring = polygon[i]).length)) continue;
        var ring,
            m,
            point0 = ring[m - 1],
            lambda0 = longitude(point0),
            phi0 = point0[1] / 2 + quarterPi,
            sinPhi0 = sin$1(phi0),
            cosPhi0 = cos$1(phi0);

        for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
          var point1 = ring[j],
              lambda1 = longitude(point1),
              phi1 = point1[1] / 2 + quarterPi,
              sinPhi1 = sin$1(phi1),
              cosPhi1 = cos$1(phi1),
              delta = lambda1 - lambda0,
              sign = delta >= 0 ? 1 : -1,
              absDelta = sign * delta,
              antimeridian = absDelta > pi$1,
              k = sinPhi0 * sinPhi1;

          sum$1.add(atan2$1(k * sign * sin$1(absDelta), cosPhi0 * cosPhi1 + k * cos$1(absDelta)));
          angle += antimeridian ? delta + sign * tau$1 : delta;

          // Are the longitudes either side of the point’s meridian (lambda),
          // and are the latitudes smaller than the parallel (phi)?
          if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
            var arc = cartesianCross(cartesian(point0), cartesian(point1));
            cartesianNormalizeInPlace(arc);
            var intersection = cartesianCross(normal, arc);
            cartesianNormalizeInPlace(intersection);
            var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin$1(intersection[2]);
            if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
              winding += antimeridian ^ delta >= 0 ? 1 : -1;
            }
          }
        }
      }

      // First, determine whether the South pole is inside or outside:
      //
      // It is inside if:
      // * the polygon winds around it in a clockwise direction.
      // * the polygon does not (cumulatively) wind around it, but has a negative
      //   (counter-clockwise) area.
      //
      // Second, count the (signed) number of times a segment crosses a lambda
      // from the point to the South pole.  If it is zero, then the point is the
      // same side as the South pole.

      return (angle < -epsilon$2 || angle < epsilon$2 && sum$1 < -epsilon$2) ^ (winding & 1);
    }

    function clip(pointVisible, clipLine, interpolate, start) {
      return function(sink) {
        var line = clipLine(sink),
            ringBuffer = clipBuffer(),
            ringSink = clipLine(ringBuffer),
            polygonStarted = false,
            polygon,
            segments,
            ring;

        var clip = {
          point: point,
          lineStart: lineStart,
          lineEnd: lineEnd,
          polygonStart: function() {
            clip.point = pointRing;
            clip.lineStart = ringStart;
            clip.lineEnd = ringEnd;
            segments = [];
            polygon = [];
          },
          polygonEnd: function() {
            clip.point = point;
            clip.lineStart = lineStart;
            clip.lineEnd = lineEnd;
            segments = merge(segments);
            var startInside = polygonContains(polygon, start);
            if (segments.length) {
              if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
              clipRejoin(segments, compareIntersection, startInside, interpolate, sink);
            } else if (startInside) {
              if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
              sink.lineStart();
              interpolate(null, null, 1, sink);
              sink.lineEnd();
            }
            if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
            segments = polygon = null;
          },
          sphere: function() {
            sink.polygonStart();
            sink.lineStart();
            interpolate(null, null, 1, sink);
            sink.lineEnd();
            sink.polygonEnd();
          }
        };

        function point(lambda, phi) {
          if (pointVisible(lambda, phi)) sink.point(lambda, phi);
        }

        function pointLine(lambda, phi) {
          line.point(lambda, phi);
        }

        function lineStart() {
          clip.point = pointLine;
          line.lineStart();
        }

        function lineEnd() {
          clip.point = point;
          line.lineEnd();
        }

        function pointRing(lambda, phi) {
          ring.push([lambda, phi]);
          ringSink.point(lambda, phi);
        }

        function ringStart() {
          ringSink.lineStart();
          ring = [];
        }

        function ringEnd() {
          pointRing(ring[0][0], ring[0][1]);
          ringSink.lineEnd();

          var clean = ringSink.clean(),
              ringSegments = ringBuffer.result(),
              i, n = ringSegments.length, m,
              segment,
              point;

          ring.pop();
          polygon.push(ring);
          ring = null;

          if (!n) return;

          // No intersections.
          if (clean & 1) {
            segment = ringSegments[0];
            if ((m = segment.length - 1) > 0) {
              if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
              sink.lineStart();
              for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);
              sink.lineEnd();
            }
            return;
          }

          // Rejoin connected segments.
          // TODO reuse ringBuffer.rejoin()?
          if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));

          segments.push(ringSegments.filter(validSegment));
        }

        return clip;
      };
    }

    function validSegment(segment) {
      return segment.length > 1;
    }

    // Intersections are sorted along the clip edge. For both antimeridian cutting
    // and circle clipping, the same comparison is used.
    function compareIntersection(a, b) {
      return ((a = a.x)[0] < 0 ? a[1] - halfPi$1 - epsilon$2 : halfPi$1 - a[1])
           - ((b = b.x)[0] < 0 ? b[1] - halfPi$1 - epsilon$2 : halfPi$1 - b[1]);
    }

    var clipAntimeridian = clip(
      function() { return true; },
      clipAntimeridianLine,
      clipAntimeridianInterpolate,
      [-pi$1, -halfPi$1]
    );

    // Takes a line and cuts into visible segments. Return values: 0 - there were
    // intersections or the line was empty; 1 - no intersections; 2 - there were
    // intersections, and the first and last segments should be rejoined.
    function clipAntimeridianLine(stream) {
      var lambda0 = NaN,
          phi0 = NaN,
          sign0 = NaN,
          clean; // no intersections

      return {
        lineStart: function() {
          stream.lineStart();
          clean = 1;
        },
        point: function(lambda1, phi1) {
          var sign1 = lambda1 > 0 ? pi$1 : -pi$1,
              delta = abs$1(lambda1 - lambda0);
          if (abs$1(delta - pi$1) < epsilon$2) { // line crosses a pole
            stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi$1 : -halfPi$1);
            stream.point(sign0, phi0);
            stream.lineEnd();
            stream.lineStart();
            stream.point(sign1, phi0);
            stream.point(lambda1, phi0);
            clean = 0;
          } else if (sign0 !== sign1 && delta >= pi$1) { // line crosses antimeridian
            if (abs$1(lambda0 - sign0) < epsilon$2) lambda0 -= sign0 * epsilon$2; // handle degeneracies
            if (abs$1(lambda1 - sign1) < epsilon$2) lambda1 -= sign1 * epsilon$2;
            phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
            stream.point(sign0, phi0);
            stream.lineEnd();
            stream.lineStart();
            stream.point(sign1, phi0);
            clean = 0;
          }
          stream.point(lambda0 = lambda1, phi0 = phi1);
          sign0 = sign1;
        },
        lineEnd: function() {
          stream.lineEnd();
          lambda0 = phi0 = NaN;
        },
        clean: function() {
          return 2 - clean; // if intersections, rejoin first and last segments
        }
      };
    }

    function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
      var cosPhi0,
          cosPhi1,
          sinLambda0Lambda1 = sin$1(lambda0 - lambda1);
      return abs$1(sinLambda0Lambda1) > epsilon$2
          ? atan((sin$1(phi0) * (cosPhi1 = cos$1(phi1)) * sin$1(lambda1)
              - sin$1(phi1) * (cosPhi0 = cos$1(phi0)) * sin$1(lambda0))
              / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))
          : (phi0 + phi1) / 2;
    }

    function clipAntimeridianInterpolate(from, to, direction, stream) {
      var phi;
      if (from == null) {
        phi = direction * halfPi$1;
        stream.point(-pi$1, phi);
        stream.point(0, phi);
        stream.point(pi$1, phi);
        stream.point(pi$1, 0);
        stream.point(pi$1, -phi);
        stream.point(0, -phi);
        stream.point(-pi$1, -phi);
        stream.point(-pi$1, 0);
        stream.point(-pi$1, phi);
      } else if (abs$1(from[0] - to[0]) > epsilon$2) {
        var lambda = from[0] < to[0] ? pi$1 : -pi$1;
        phi = direction * lambda / 2;
        stream.point(-lambda, phi);
        stream.point(0, phi);
        stream.point(lambda, phi);
      } else {
        stream.point(to[0], to[1]);
      }
    }

    function clipCircle(radius) {
      var cr = cos$1(radius),
          delta = 6 * radians,
          smallRadius = cr > 0,
          notHemisphere = abs$1(cr) > epsilon$2; // TODO optimise for this common case

      function interpolate(from, to, direction, stream) {
        circleStream(stream, radius, delta, direction, from, to);
      }

      function visible(lambda, phi) {
        return cos$1(lambda) * cos$1(phi) > cr;
      }

      // Takes a line and cuts into visible segments. Return values used for polygon
      // clipping: 0 - there were intersections or the line was empty; 1 - no
      // intersections 2 - there were intersections, and the first and last segments
      // should be rejoined.
      function clipLine(stream) {
        var point0, // previous point
            c0, // code for previous point
            v0, // visibility of previous point
            v00, // visibility of first point
            clean; // no intersections
        return {
          lineStart: function() {
            v00 = v0 = false;
            clean = 1;
          },
          point: function(lambda, phi) {
            var point1 = [lambda, phi],
                point2,
                v = visible(lambda, phi),
                c = smallRadius
                  ? v ? 0 : code(lambda, phi)
                  : v ? code(lambda + (lambda < 0 ? pi$1 : -pi$1), phi) : 0;
            if (!point0 && (v00 = v0 = v)) stream.lineStart();
            if (v !== v0) {
              point2 = intersect(point0, point1);
              if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2))
                point1[2] = 1;
            }
            if (v !== v0) {
              clean = 0;
              if (v) {
                // outside going in
                stream.lineStart();
                point2 = intersect(point1, point0);
                stream.point(point2[0], point2[1]);
              } else {
                // inside going out
                point2 = intersect(point0, point1);
                stream.point(point2[0], point2[1], 2);
                stream.lineEnd();
              }
              point0 = point2;
            } else if (notHemisphere && point0 && smallRadius ^ v) {
              var t;
              // If the codes for two points are different, or are both zero,
              // and there this segment intersects with the small circle.
              if (!(c & c0) && (t = intersect(point1, point0, true))) {
                clean = 0;
                if (smallRadius) {
                  stream.lineStart();
                  stream.point(t[0][0], t[0][1]);
                  stream.point(t[1][0], t[1][1]);
                  stream.lineEnd();
                } else {
                  stream.point(t[1][0], t[1][1]);
                  stream.lineEnd();
                  stream.lineStart();
                  stream.point(t[0][0], t[0][1], 3);
                }
              }
            }
            if (v && (!point0 || !pointEqual(point0, point1))) {
              stream.point(point1[0], point1[1]);
            }
            point0 = point1, v0 = v, c0 = c;
          },
          lineEnd: function() {
            if (v0) stream.lineEnd();
            point0 = null;
          },
          // Rejoin first and last segments if there were intersections and the first
          // and last points were visible.
          clean: function() {
            return clean | ((v00 && v0) << 1);
          }
        };
      }

      // Intersects the great circle between a and b with the clip circle.
      function intersect(a, b, two) {
        var pa = cartesian(a),
            pb = cartesian(b);

        // We have two planes, n1.p = d1 and n2.p = d2.
        // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).
        var n1 = [1, 0, 0], // normal
            n2 = cartesianCross(pa, pb),
            n2n2 = cartesianDot(n2, n2),
            n1n2 = n2[0], // cartesianDot(n1, n2),
            determinant = n2n2 - n1n2 * n1n2;

        // Two polar points.
        if (!determinant) return !two && a;

        var c1 =  cr * n2n2 / determinant,
            c2 = -cr * n1n2 / determinant,
            n1xn2 = cartesianCross(n1, n2),
            A = cartesianScale(n1, c1),
            B = cartesianScale(n2, c2);
        cartesianAddInPlace(A, B);

        // Solve |p(t)|^2 = 1.
        var u = n1xn2,
            w = cartesianDot(A, u),
            uu = cartesianDot(u, u),
            t2 = w * w - uu * (cartesianDot(A, A) - 1);

        if (t2 < 0) return;

        var t = sqrt$2(t2),
            q = cartesianScale(u, (-w - t) / uu);
        cartesianAddInPlace(q, A);
        q = spherical(q);

        if (!two) return q;

        // Two intersection points.
        var lambda0 = a[0],
            lambda1 = b[0],
            phi0 = a[1],
            phi1 = b[1],
            z;

        if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;

        var delta = lambda1 - lambda0,
            polar = abs$1(delta - pi$1) < epsilon$2,
            meridian = polar || delta < epsilon$2;

        if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;

        // Check that the first point is between a and b.
        if (meridian
            ? polar
              ? phi0 + phi1 > 0 ^ q[1] < (abs$1(q[0] - lambda0) < epsilon$2 ? phi0 : phi1)
              : phi0 <= q[1] && q[1] <= phi1
            : delta > pi$1 ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
          var q1 = cartesianScale(u, (-w + t) / uu);
          cartesianAddInPlace(q1, A);
          return [q, spherical(q1)];
        }
      }

      // Generates a 4-bit vector representing the location of a point relative to
      // the small circle's bounding box.
      function code(lambda, phi) {
        var r = smallRadius ? radius : pi$1 - radius,
            code = 0;
        if (lambda < -r) code |= 1; // left
        else if (lambda > r) code |= 2; // right
        if (phi < -r) code |= 4; // below
        else if (phi > r) code |= 8; // above
        return code;
      }

      return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi$1, radius - pi$1]);
    }

    function clipLine(a, b, x0, y0, x1, y1) {
      var ax = a[0],
          ay = a[1],
          bx = b[0],
          by = b[1],
          t0 = 0,
          t1 = 1,
          dx = bx - ax,
          dy = by - ay,
          r;

      r = x0 - ax;
      if (!dx && r > 0) return;
      r /= dx;
      if (dx < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dx > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }

      r = x1 - ax;
      if (!dx && r < 0) return;
      r /= dx;
      if (dx < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dx > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }

      r = y0 - ay;
      if (!dy && r > 0) return;
      r /= dy;
      if (dy < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dy > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }

      r = y1 - ay;
      if (!dy && r < 0) return;
      r /= dy;
      if (dy < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dy > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }

      if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
      if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
      return true;
    }

    var clipMax = 1e9, clipMin = -clipMax;

    // TODO Use d3-polygon’s polygonContains here for the ring check?
    // TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

    function clipRectangle(x0, y0, x1, y1) {

      function visible(x, y) {
        return x0 <= x && x <= x1 && y0 <= y && y <= y1;
      }

      function interpolate(from, to, direction, stream) {
        var a = 0, a1 = 0;
        if (from == null
            || (a = corner(from, direction)) !== (a1 = corner(to, direction))
            || comparePoint(from, to) < 0 ^ direction > 0) {
          do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
          while ((a = (a + direction + 4) % 4) !== a1);
        } else {
          stream.point(to[0], to[1]);
        }
      }

      function corner(p, direction) {
        return abs$1(p[0] - x0) < epsilon$2 ? direction > 0 ? 0 : 3
            : abs$1(p[0] - x1) < epsilon$2 ? direction > 0 ? 2 : 1
            : abs$1(p[1] - y0) < epsilon$2 ? direction > 0 ? 1 : 0
            : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
      }

      function compareIntersection(a, b) {
        return comparePoint(a.x, b.x);
      }

      function comparePoint(a, b) {
        var ca = corner(a, 1),
            cb = corner(b, 1);
        return ca !== cb ? ca - cb
            : ca === 0 ? b[1] - a[1]
            : ca === 1 ? a[0] - b[0]
            : ca === 2 ? a[1] - b[1]
            : b[0] - a[0];
      }

      return function(stream) {
        var activeStream = stream,
            bufferStream = clipBuffer(),
            segments,
            polygon,
            ring,
            x__, y__, v__, // first point
            x_, y_, v_, // previous point
            first,
            clean;

        var clipStream = {
          point: point,
          lineStart: lineStart,
          lineEnd: lineEnd,
          polygonStart: polygonStart,
          polygonEnd: polygonEnd
        };

        function point(x, y) {
          if (visible(x, y)) activeStream.point(x, y);
        }

        function polygonInside() {
          var winding = 0;

          for (var i = 0, n = polygon.length; i < n; ++i) {
            for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
              a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];
              if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }
              else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }
            }
          }

          return winding;
        }

        // Buffer geometry within a polygon and then clip it en masse.
        function polygonStart() {
          activeStream = bufferStream, segments = [], polygon = [], clean = true;
        }

        function polygonEnd() {
          var startInside = polygonInside(),
              cleanInside = clean && startInside,
              visible = (segments = merge(segments)).length;
          if (cleanInside || visible) {
            stream.polygonStart();
            if (cleanInside) {
              stream.lineStart();
              interpolate(null, null, 1, stream);
              stream.lineEnd();
            }
            if (visible) {
              clipRejoin(segments, compareIntersection, startInside, interpolate, stream);
            }
            stream.polygonEnd();
          }
          activeStream = stream, segments = polygon = ring = null;
        }

        function lineStart() {
          clipStream.point = linePoint;
          if (polygon) polygon.push(ring = []);
          first = true;
          v_ = false;
          x_ = y_ = NaN;
        }

        // TODO rather than special-case polygons, simply handle them separately.
        // Ideally, coincident intersection points should be jittered to avoid
        // clipping issues.
        function lineEnd() {
          if (segments) {
            linePoint(x__, y__);
            if (v__ && v_) bufferStream.rejoin();
            segments.push(bufferStream.result());
          }
          clipStream.point = point;
          if (v_) activeStream.lineEnd();
        }

        function linePoint(x, y) {
          var v = visible(x, y);
          if (polygon) ring.push([x, y]);
          if (first) {
            x__ = x, y__ = y, v__ = v;
            first = false;
            if (v) {
              activeStream.lineStart();
              activeStream.point(x, y);
            }
          } else {
            if (v && v_) activeStream.point(x, y);
            else {
              var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
                  b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
              if (clipLine(a, b, x0, y0, x1, y1)) {
                if (!v_) {
                  activeStream.lineStart();
                  activeStream.point(a[0], a[1]);
                }
                activeStream.point(b[0], b[1]);
                if (!v) activeStream.lineEnd();
                clean = false;
              } else if (v) {
                activeStream.lineStart();
                activeStream.point(x, y);
                clean = false;
              }
            }
          }
          x_ = x, y_ = y, v_ = v;
        }

        return clipStream;
      };
    }

    function extent() {
      var x0 = 0,
          y0 = 0,
          x1 = 960,
          y1 = 500,
          cache,
          cacheStream,
          clip;

      return clip = {
        stream: function(stream) {
          return cache && cacheStream === stream ? cache : cache = clipRectangle(x0, y0, x1, y1)(cacheStream = stream);
        },
        extent: function(_) {
          return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];
        }
      };
    }

    var lengthSum$1 = adder(),
        lambda0,
        sinPhi0,
        cosPhi0;

    var lengthStream$1 = {
      sphere: noop$1,
      point: noop$1,
      lineStart: lengthLineStart,
      lineEnd: noop$1,
      polygonStart: noop$1,
      polygonEnd: noop$1
    };

    function lengthLineStart() {
      lengthStream$1.point = lengthPointFirst$1;
      lengthStream$1.lineEnd = lengthLineEnd;
    }

    function lengthLineEnd() {
      lengthStream$1.point = lengthStream$1.lineEnd = noop$1;
    }

    function lengthPointFirst$1(lambda, phi) {
      lambda *= radians, phi *= radians;
      lambda0 = lambda, sinPhi0 = sin$1(phi), cosPhi0 = cos$1(phi);
      lengthStream$1.point = lengthPoint$1;
    }

    function lengthPoint$1(lambda, phi) {
      lambda *= radians, phi *= radians;
      var sinPhi = sin$1(phi),
          cosPhi = cos$1(phi),
          delta = abs$1(lambda - lambda0),
          cosDelta = cos$1(delta),
          sinDelta = sin$1(delta),
          x = cosPhi * sinDelta,
          y = cosPhi0 * sinPhi - sinPhi0 * cosPhi * cosDelta,
          z = sinPhi0 * sinPhi + cosPhi0 * cosPhi * cosDelta;
      lengthSum$1.add(atan2$1(sqrt$2(x * x + y * y), z));
      lambda0 = lambda, sinPhi0 = sinPhi, cosPhi0 = cosPhi;
    }

    function length$1(object) {
      lengthSum$1.reset();
      geoStream(object, lengthStream$1);
      return +lengthSum$1;
    }

    var coordinates = [null, null],
        object = {type: "LineString", coordinates: coordinates};

    function distance(a, b) {
      coordinates[0] = a;
      coordinates[1] = b;
      return length$1(object);
    }

    var containsObjectType = {
      Feature: function(object, point) {
        return containsGeometry(object.geometry, point);
      },
      FeatureCollection: function(object, point) {
        var features = object.features, i = -1, n = features.length;
        while (++i < n) if (containsGeometry(features[i].geometry, point)) return true;
        return false;
      }
    };

    var containsGeometryType = {
      Sphere: function() {
        return true;
      },
      Point: function(object, point) {
        return containsPoint(object.coordinates, point);
      },
      MultiPoint: function(object, point) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) if (containsPoint(coordinates[i], point)) return true;
        return false;
      },
      LineString: function(object, point) {
        return containsLine(object.coordinates, point);
      },
      MultiLineString: function(object, point) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) if (containsLine(coordinates[i], point)) return true;
        return false;
      },
      Polygon: function(object, point) {
        return containsPolygon(object.coordinates, point);
      },
      MultiPolygon: function(object, point) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) if (containsPolygon(coordinates[i], point)) return true;
        return false;
      },
      GeometryCollection: function(object, point) {
        var geometries = object.geometries, i = -1, n = geometries.length;
        while (++i < n) if (containsGeometry(geometries[i], point)) return true;
        return false;
      }
    };

    function containsGeometry(geometry, point) {
      return geometry && containsGeometryType.hasOwnProperty(geometry.type)
          ? containsGeometryType[geometry.type](geometry, point)
          : false;
    }

    function containsPoint(coordinates, point) {
      return distance(coordinates, point) === 0;
    }

    function containsLine(coordinates, point) {
      var ao, bo, ab;
      for (var i = 0, n = coordinates.length; i < n; i++) {
        bo = distance(coordinates[i], point);
        if (bo === 0) return true;
        if (i > 0) {
          ab = distance(coordinates[i], coordinates[i - 1]);
          if (
            ab > 0 &&
            ao <= ab &&
            bo <= ab &&
            (ao + bo - ab) * (1 - Math.pow((ao - bo) / ab, 2)) < epsilon2$1 * ab
          )
            return true;
        }
        ao = bo;
      }
      return false;
    }

    function containsPolygon(coordinates, point) {
      return !!polygonContains(coordinates.map(ringRadians), pointRadians(point));
    }

    function ringRadians(ring) {
      return ring = ring.map(pointRadians), ring.pop(), ring;
    }

    function pointRadians(point) {
      return [point[0] * radians, point[1] * radians];
    }

    function contains$1(object, point) {
      return (object && containsObjectType.hasOwnProperty(object.type)
          ? containsObjectType[object.type]
          : containsGeometry)(object, point);
    }

    function graticuleX(y0, y1, dy) {
      var y = sequence(y0, y1 - epsilon$2, dy).concat(y1);
      return function(x) { return y.map(function(y) { return [x, y]; }); };
    }

    function graticuleY(x0, x1, dx) {
      var x = sequence(x0, x1 - epsilon$2, dx).concat(x1);
      return function(y) { return x.map(function(x) { return [x, y]; }); };
    }

    function graticule() {
      var x1, x0, X1, X0,
          y1, y0, Y1, Y0,
          dx = 10, dy = dx, DX = 90, DY = 360,
          x, y, X, Y,
          precision = 2.5;

      function graticule() {
        return {type: "MultiLineString", coordinates: lines()};
      }

      function lines() {
        return sequence(ceil(X0 / DX) * DX, X1, DX).map(X)
            .concat(sequence(ceil(Y0 / DY) * DY, Y1, DY).map(Y))
            .concat(sequence(ceil(x0 / dx) * dx, x1, dx).filter(function(x) { return abs$1(x % DX) > epsilon$2; }).map(x))
            .concat(sequence(ceil(y0 / dy) * dy, y1, dy).filter(function(y) { return abs$1(y % DY) > epsilon$2; }).map(y));
      }

      graticule.lines = function() {
        return lines().map(function(coordinates) { return {type: "LineString", coordinates: coordinates}; });
      };

      graticule.outline = function() {
        return {
          type: "Polygon",
          coordinates: [
            X(X0).concat(
            Y(Y1).slice(1),
            X(X1).reverse().slice(1),
            Y(Y0).reverse().slice(1))
          ]
        };
      };

      graticule.extent = function(_) {
        if (!arguments.length) return graticule.extentMinor();
        return graticule.extentMajor(_).extentMinor(_);
      };

      graticule.extentMajor = function(_) {
        if (!arguments.length) return [[X0, Y0], [X1, Y1]];
        X0 = +_[0][0], X1 = +_[1][0];
        Y0 = +_[0][1], Y1 = +_[1][1];
        if (X0 > X1) _ = X0, X0 = X1, X1 = _;
        if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
        return graticule.precision(precision);
      };

      graticule.extentMinor = function(_) {
        if (!arguments.length) return [[x0, y0], [x1, y1]];
        x0 = +_[0][0], x1 = +_[1][0];
        y0 = +_[0][1], y1 = +_[1][1];
        if (x0 > x1) _ = x0, x0 = x1, x1 = _;
        if (y0 > y1) _ = y0, y0 = y1, y1 = _;
        return graticule.precision(precision);
      };

      graticule.step = function(_) {
        if (!arguments.length) return graticule.stepMinor();
        return graticule.stepMajor(_).stepMinor(_);
      };

      graticule.stepMajor = function(_) {
        if (!arguments.length) return [DX, DY];
        DX = +_[0], DY = +_[1];
        return graticule;
      };

      graticule.stepMinor = function(_) {
        if (!arguments.length) return [dx, dy];
        dx = +_[0], dy = +_[1];
        return graticule;
      };

      graticule.precision = function(_) {
        if (!arguments.length) return precision;
        precision = +_;
        x = graticuleX(y0, y1, 90);
        y = graticuleY(x0, x1, precision);
        X = graticuleX(Y0, Y1, 90);
        Y = graticuleY(X0, X1, precision);
        return graticule;
      };

      return graticule
          .extentMajor([[-180, -90 + epsilon$2], [180, 90 - epsilon$2]])
          .extentMinor([[-180, -80 - epsilon$2], [180, 80 + epsilon$2]]);
    }

    function graticule10() {
      return graticule()();
    }

    function interpolate(a, b) {
      var x0 = a[0] * radians,
          y0 = a[1] * radians,
          x1 = b[0] * radians,
          y1 = b[1] * radians,
          cy0 = cos$1(y0),
          sy0 = sin$1(y0),
          cy1 = cos$1(y1),
          sy1 = sin$1(y1),
          kx0 = cy0 * cos$1(x0),
          ky0 = cy0 * sin$1(x0),
          kx1 = cy1 * cos$1(x1),
          ky1 = cy1 * sin$1(x1),
          d = 2 * asin$1(sqrt$2(haversin(y1 - y0) + cy0 * cy1 * haversin(x1 - x0))),
          k = sin$1(d);

      var interpolate = d ? function(t) {
        var B = sin$1(t *= d) / k,
            A = sin$1(d - t) / k,
            x = A * kx0 + B * kx1,
            y = A * ky0 + B * ky1,
            z = A * sy0 + B * sy1;
        return [
          atan2$1(y, x) * degrees,
          atan2$1(z, sqrt$2(x * x + y * y)) * degrees
        ];
      } : function() {
        return [x0 * degrees, y0 * degrees];
      };

      interpolate.distance = d;

      return interpolate;
    }

    function identity$5(x) {
      return x;
    }

    var areaSum = adder(),
        areaRingSum = adder(),
        x00$2,
        y00$2,
        x0$3,
        y0$3;

    var areaStream = {
      point: noop$1,
      lineStart: noop$1,
      lineEnd: noop$1,
      polygonStart: function() {
        areaStream.lineStart = areaRingStart;
        areaStream.lineEnd = areaRingEnd;
      },
      polygonEnd: function() {
        areaStream.lineStart = areaStream.lineEnd = areaStream.point = noop$1;
        areaSum.add(abs$1(areaRingSum));
        areaRingSum.reset();
      },
      result: function() {
        var area = areaSum / 2;
        areaSum.reset();
        return area;
      }
    };

    function areaRingStart() {
      areaStream.point = areaPointFirst;
    }

    function areaPointFirst(x, y) {
      areaStream.point = areaPoint;
      x00$2 = x0$3 = x, y00$2 = y0$3 = y;
    }

    function areaPoint(x, y) {
      areaRingSum.add(y0$3 * x - x0$3 * y);
      x0$3 = x, y0$3 = y;
    }

    function areaRingEnd() {
      areaPoint(x00$2, y00$2);
    }

    var pathArea = areaStream;

    var x0$2 = Infinity,
        y0$2 = x0$2,
        x1 = -x0$2,
        y1 = x1;

    var boundsStream = {
      point: boundsPoint,
      lineStart: noop$1,
      lineEnd: noop$1,
      polygonStart: noop$1,
      polygonEnd: noop$1,
      result: function() {
        var bounds = [[x0$2, y0$2], [x1, y1]];
        x1 = y1 = -(y0$2 = x0$2 = Infinity);
        return bounds;
      }
    };

    function boundsPoint(x, y) {
      if (x < x0$2) x0$2 = x;
      if (x > x1) x1 = x;
      if (y < y0$2) y0$2 = y;
      if (y > y1) y1 = y;
    }

    var boundsStream$1 = boundsStream;

    // TODO Enforce positive area for exterior, negative area for interior?

    var X0 = 0,
        Y0 = 0,
        Z0 = 0,
        X1 = 0,
        Y1 = 0,
        Z1 = 0,
        X2 = 0,
        Y2 = 0,
        Z2 = 0,
        x00$1,
        y00$1,
        x0$1,
        y0$1;

    var centroidStream = {
      point: centroidPoint,
      lineStart: centroidLineStart,
      lineEnd: centroidLineEnd,
      polygonStart: function() {
        centroidStream.lineStart = centroidRingStart;
        centroidStream.lineEnd = centroidRingEnd;
      },
      polygonEnd: function() {
        centroidStream.point = centroidPoint;
        centroidStream.lineStart = centroidLineStart;
        centroidStream.lineEnd = centroidLineEnd;
      },
      result: function() {
        var centroid = Z2 ? [X2 / Z2, Y2 / Z2]
            : Z1 ? [X1 / Z1, Y1 / Z1]
            : Z0 ? [X0 / Z0, Y0 / Z0]
            : [NaN, NaN];
        X0 = Y0 = Z0 =
        X1 = Y1 = Z1 =
        X2 = Y2 = Z2 = 0;
        return centroid;
      }
    };

    function centroidPoint(x, y) {
      X0 += x;
      Y0 += y;
      ++Z0;
    }

    function centroidLineStart() {
      centroidStream.point = centroidPointFirstLine;
    }

    function centroidPointFirstLine(x, y) {
      centroidStream.point = centroidPointLine;
      centroidPoint(x0$1 = x, y0$1 = y);
    }

    function centroidPointLine(x, y) {
      var dx = x - x0$1, dy = y - y0$1, z = sqrt$2(dx * dx + dy * dy);
      X1 += z * (x0$1 + x) / 2;
      Y1 += z * (y0$1 + y) / 2;
      Z1 += z;
      centroidPoint(x0$1 = x, y0$1 = y);
    }

    function centroidLineEnd() {
      centroidStream.point = centroidPoint;
    }

    function centroidRingStart() {
      centroidStream.point = centroidPointFirstRing;
    }

    function centroidRingEnd() {
      centroidPointRing(x00$1, y00$1);
    }

    function centroidPointFirstRing(x, y) {
      centroidStream.point = centroidPointRing;
      centroidPoint(x00$1 = x0$1 = x, y00$1 = y0$1 = y);
    }

    function centroidPointRing(x, y) {
      var dx = x - x0$1,
          dy = y - y0$1,
          z = sqrt$2(dx * dx + dy * dy);

      X1 += z * (x0$1 + x) / 2;
      Y1 += z * (y0$1 + y) / 2;
      Z1 += z;

      z = y0$1 * x - x0$1 * y;
      X2 += z * (x0$1 + x);
      Y2 += z * (y0$1 + y);
      Z2 += z * 3;
      centroidPoint(x0$1 = x, y0$1 = y);
    }

    var pathCentroid = centroidStream;

    function PathContext(context) {
      this._context = context;
    }

    PathContext.prototype = {
      _radius: 4.5,
      pointRadius: function(_) {
        return this._radius = _, this;
      },
      polygonStart: function() {
        this._line = 0;
      },
      polygonEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line === 0) this._context.closePath();
        this._point = NaN;
      },
      point: function(x, y) {
        switch (this._point) {
          case 0: {
            this._context.moveTo(x, y);
            this._point = 1;
            break;
          }
          case 1: {
            this._context.lineTo(x, y);
            break;
          }
          default: {
            this._context.moveTo(x + this._radius, y);
            this._context.arc(x, y, this._radius, 0, tau$1);
            break;
          }
        }
      },
      result: noop$1
    };

    var lengthSum = adder(),
        lengthRing,
        x00,
        y00,
        x0,
        y0;

    var lengthStream = {
      point: noop$1,
      lineStart: function() {
        lengthStream.point = lengthPointFirst;
      },
      lineEnd: function() {
        if (lengthRing) lengthPoint(x00, y00);
        lengthStream.point = noop$1;
      },
      polygonStart: function() {
        lengthRing = true;
      },
      polygonEnd: function() {
        lengthRing = null;
      },
      result: function() {
        var length = +lengthSum;
        lengthSum.reset();
        return length;
      }
    };

    function lengthPointFirst(x, y) {
      lengthStream.point = lengthPoint;
      x00 = x0 = x, y00 = y0 = y;
    }

    function lengthPoint(x, y) {
      x0 -= x, y0 -= y;
      lengthSum.add(sqrt$2(x0 * x0 + y0 * y0));
      x0 = x, y0 = y;
    }

    var pathMeasure = lengthStream;

    function PathString() {
      this._string = [];
    }

    PathString.prototype = {
      _radius: 4.5,
      _circle: circle$1(4.5),
      pointRadius: function(_) {
        if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;
        return this;
      },
      polygonStart: function() {
        this._line = 0;
      },
      polygonEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line === 0) this._string.push("Z");
        this._point = NaN;
      },
      point: function(x, y) {
        switch (this._point) {
          case 0: {
            this._string.push("M", x, ",", y);
            this._point = 1;
            break;
          }
          case 1: {
            this._string.push("L", x, ",", y);
            break;
          }
          default: {
            if (this._circle == null) this._circle = circle$1(this._radius);
            this._string.push("M", x, ",", y, this._circle);
            break;
          }
        }
      },
      result: function() {
        if (this._string.length) {
          var result = this._string.join("");
          this._string = [];
          return result;
        } else {
          return null;
        }
      }
    };

    function circle$1(radius) {
      return "m0," + radius
          + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius
          + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius
          + "z";
    }

    function index$2(projection, context) {
      var pointRadius = 4.5,
          projectionStream,
          contextStream;

      function path(object) {
        if (object) {
          if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
          geoStream(object, projectionStream(contextStream));
        }
        return contextStream.result();
      }

      path.area = function(object) {
        geoStream(object, projectionStream(pathArea));
        return pathArea.result();
      };

      path.measure = function(object) {
        geoStream(object, projectionStream(pathMeasure));
        return pathMeasure.result();
      };

      path.bounds = function(object) {
        geoStream(object, projectionStream(boundsStream$1));
        return boundsStream$1.result();
      };

      path.centroid = function(object) {
        geoStream(object, projectionStream(pathCentroid));
        return pathCentroid.result();
      };

      path.projection = function(_) {
        return arguments.length ? (projectionStream = _ == null ? (projection = null, identity$5) : (projection = _).stream, path) : projection;
      };

      path.context = function(_) {
        if (!arguments.length) return context;
        contextStream = _ == null ? (context = null, new PathString) : new PathContext(context = _);
        if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
        return path;
      };

      path.pointRadius = function(_) {
        if (!arguments.length) return pointRadius;
        pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
        return path;
      };

      return path.projection(projection).context(context);
    }

    function transform$1(methods) {
      return {
        stream: transformer$3(methods)
      };
    }

    function transformer$3(methods) {
      return function(stream) {
        var s = new TransformStream;
        for (var key in methods) s[key] = methods[key];
        s.stream = stream;
        return s;
      };
    }

    function TransformStream() {}

    TransformStream.prototype = {
      constructor: TransformStream,
      point: function(x, y) { this.stream.point(x, y); },
      sphere: function() { this.stream.sphere(); },
      lineStart: function() { this.stream.lineStart(); },
      lineEnd: function() { this.stream.lineEnd(); },
      polygonStart: function() { this.stream.polygonStart(); },
      polygonEnd: function() { this.stream.polygonEnd(); }
    };

    function fit(projection, fitBounds, object) {
      var clip = projection.clipExtent && projection.clipExtent();
      projection.scale(150).translate([0, 0]);
      if (clip != null) projection.clipExtent(null);
      geoStream(object, projection.stream(boundsStream$1));
      fitBounds(boundsStream$1.result());
      if (clip != null) projection.clipExtent(clip);
      return projection;
    }

    function fitExtent(projection, extent, object) {
      return fit(projection, function(b) {
        var w = extent[1][0] - extent[0][0],
            h = extent[1][1] - extent[0][1],
            k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
            x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
            y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
        projection.scale(150 * k).translate([x, y]);
      }, object);
    }

    function fitSize(projection, size, object) {
      return fitExtent(projection, [[0, 0], size], object);
    }

    function fitWidth(projection, width, object) {
      return fit(projection, function(b) {
        var w = +width,
            k = w / (b[1][0] - b[0][0]),
            x = (w - k * (b[1][0] + b[0][0])) / 2,
            y = -k * b[0][1];
        projection.scale(150 * k).translate([x, y]);
      }, object);
    }

    function fitHeight(projection, height, object) {
      return fit(projection, function(b) {
        var h = +height,
            k = h / (b[1][1] - b[0][1]),
            x = -k * b[0][0],
            y = (h - k * (b[1][1] + b[0][1])) / 2;
        projection.scale(150 * k).translate([x, y]);
      }, object);
    }

    var maxDepth = 16, // maximum depth of subdivision
        cosMinDistance = cos$1(30 * radians); // cos(minimum angular distance)

    function resample(project, delta2) {
      return +delta2 ? resample$1(project, delta2) : resampleNone(project);
    }

    function resampleNone(project) {
      return transformer$3({
        point: function(x, y) {
          x = project(x, y);
          this.stream.point(x[0], x[1]);
        }
      });
    }

    function resample$1(project, delta2) {

      function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
        var dx = x1 - x0,
            dy = y1 - y0,
            d2 = dx * dx + dy * dy;
        if (d2 > 4 * delta2 && depth--) {
          var a = a0 + a1,
              b = b0 + b1,
              c = c0 + c1,
              m = sqrt$2(a * a + b * b + c * c),
              phi2 = asin$1(c /= m),
              lambda2 = abs$1(abs$1(c) - 1) < epsilon$2 || abs$1(lambda0 - lambda1) < epsilon$2 ? (lambda0 + lambda1) / 2 : atan2$1(b, a),
              p = project(lambda2, phi2),
              x2 = p[0],
              y2 = p[1],
              dx2 = x2 - x0,
              dy2 = y2 - y0,
              dz = dy * dx2 - dx * dy2;
          if (dz * dz / d2 > delta2 // perpendicular projected distance
              || abs$1((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
              || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance
            resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
            stream.point(x2, y2);
            resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
          }
        }
      }
      return function(stream) {
        var lambda00, x00, y00, a00, b00, c00, // first point
            lambda0, x0, y0, a0, b0, c0; // previous point

        var resampleStream = {
          point: point,
          lineStart: lineStart,
          lineEnd: lineEnd,
          polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },
          polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }
        };

        function point(x, y) {
          x = project(x, y);
          stream.point(x[0], x[1]);
        }

        function lineStart() {
          x0 = NaN;
          resampleStream.point = linePoint;
          stream.lineStart();
        }

        function linePoint(lambda, phi) {
          var c = cartesian([lambda, phi]), p = project(lambda, phi);
          resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
          stream.point(x0, y0);
        }

        function lineEnd() {
          resampleStream.point = point;
          stream.lineEnd();
        }

        function ringStart() {
          lineStart();
          resampleStream.point = ringPoint;
          resampleStream.lineEnd = ringEnd;
        }

        function ringPoint(lambda, phi) {
          linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
          resampleStream.point = linePoint;
        }

        function ringEnd() {
          resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
          resampleStream.lineEnd = lineEnd;
          lineEnd();
        }

        return resampleStream;
      };
    }

    var transformRadians = transformer$3({
      point: function(x, y) {
        this.stream.point(x * radians, y * radians);
      }
    });

    function transformRotate(rotate) {
      return transformer$3({
        point: function(x, y) {
          var r = rotate(x, y);
          return this.stream.point(r[0], r[1]);
        }
      });
    }

    function scaleTranslate(k, dx, dy, sx, sy) {
      function transform(x, y) {
        x *= sx; y *= sy;
        return [dx + k * x, dy - k * y];
      }
      transform.invert = function(x, y) {
        return [(x - dx) / k * sx, (dy - y) / k * sy];
      };
      return transform;
    }

    function scaleTranslateRotate(k, dx, dy, sx, sy, alpha) {
      var cosAlpha = cos$1(alpha),
          sinAlpha = sin$1(alpha),
          a = cosAlpha * k,
          b = sinAlpha * k,
          ai = cosAlpha / k,
          bi = sinAlpha / k,
          ci = (sinAlpha * dy - cosAlpha * dx) / k,
          fi = (sinAlpha * dx + cosAlpha * dy) / k;
      function transform(x, y) {
        x *= sx; y *= sy;
        return [a * x - b * y + dx, dy - b * x - a * y];
      }
      transform.invert = function(x, y) {
        return [sx * (ai * x - bi * y + ci), sy * (fi - bi * x - ai * y)];
      };
      return transform;
    }

    function projection(project) {
      return projectionMutator(function() { return project; })();
    }

    function projectionMutator(projectAt) {
      var project,
          k = 150, // scale
          x = 480, y = 250, // translate
          lambda = 0, phi = 0, // center
          deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, // pre-rotate
          alpha = 0, // post-rotate angle
          sx = 1, // reflectX
          sy = 1, // reflectX
          theta = null, preclip = clipAntimeridian, // pre-clip angle
          x0 = null, y0, x1, y1, postclip = identity$5, // post-clip extent
          delta2 = 0.5, // precision
          projectResample,
          projectTransform,
          projectRotateTransform,
          cache,
          cacheStream;

      function projection(point) {
        return projectRotateTransform(point[0] * radians, point[1] * radians);
      }

      function invert(point) {
        point = projectRotateTransform.invert(point[0], point[1]);
        return point && [point[0] * degrees, point[1] * degrees];
      }

      projection.stream = function(stream) {
        return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
      };

      projection.preclip = function(_) {
        return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;
      };

      projection.postclip = function(_) {
        return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
      };

      projection.clipAngle = function(_) {
        return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees;
      };

      projection.clipExtent = function(_) {
        return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$5) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
      };

      projection.scale = function(_) {
        return arguments.length ? (k = +_, recenter()) : k;
      };

      projection.translate = function(_) {
        return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
      };

      projection.center = function(_) {
        return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];
      };

      projection.rotate = function(_) {
        return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
      };

      projection.angle = function(_) {
        return arguments.length ? (alpha = _ % 360 * radians, recenter()) : alpha * degrees;
      };

      projection.reflectX = function(_) {
        return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;
      };

      projection.reflectY = function(_) {
        return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;
      };

      projection.precision = function(_) {
        return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt$2(delta2);
      };

      projection.fitExtent = function(extent, object) {
        return fitExtent(projection, extent, object);
      };

      projection.fitSize = function(size, object) {
        return fitSize(projection, size, object);
      };

      projection.fitWidth = function(width, object) {
        return fitWidth(projection, width, object);
      };

      projection.fitHeight = function(height, object) {
        return fitHeight(projection, height, object);
      };

      function recenter() {
        var center = scaleTranslateRotate(k, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi)),
            transform = (alpha ? scaleTranslateRotate : scaleTranslate)(k, x - center[0], y - center[1], sx, sy, alpha);
        rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
        projectTransform = compose(project, transform);
        projectRotateTransform = compose(rotate, projectTransform);
        projectResample = resample(projectTransform, delta2);
        return reset();
      }

      function reset() {
        cache = cacheStream = null;
        return projection;
      }

      return function() {
        project = projectAt.apply(this, arguments);
        projection.invert = project.invert && invert;
        return recenter();
      };
    }

    function conicProjection(projectAt) {
      var phi0 = 0,
          phi1 = pi$1 / 3,
          m = projectionMutator(projectAt),
          p = m(phi0, phi1);

      p.parallels = function(_) {
        return arguments.length ? m(phi0 = _[0] * radians, phi1 = _[1] * radians) : [phi0 * degrees, phi1 * degrees];
      };

      return p;
    }

    function cylindricalEqualAreaRaw(phi0) {
      var cosPhi0 = cos$1(phi0);

      function forward(lambda, phi) {
        return [lambda * cosPhi0, sin$1(phi) / cosPhi0];
      }

      forward.invert = function(x, y) {
        return [x / cosPhi0, asin$1(y * cosPhi0)];
      };

      return forward;
    }

    function conicEqualAreaRaw(y0, y1) {
      var sy0 = sin$1(y0), n = (sy0 + sin$1(y1)) / 2;

      // Are the parallels symmetrical around the Equator?
      if (abs$1(n) < epsilon$2) return cylindricalEqualAreaRaw(y0);

      var c = 1 + sy0 * (2 * n - sy0), r0 = sqrt$2(c) / n;

      function project(x, y) {
        var r = sqrt$2(c - 2 * n * sin$1(y)) / n;
        return [r * sin$1(x *= n), r0 - r * cos$1(x)];
      }

      project.invert = function(x, y) {
        var r0y = r0 - y,
            l = atan2$1(x, abs$1(r0y)) * sign$1(r0y);
        if (r0y * n < 0)
          l -= pi$1 * sign$1(x) * sign$1(r0y);
        return [l / n, asin$1((c - (x * x + r0y * r0y) * n * n) / (2 * n))];
      };

      return project;
    }

    function conicEqualArea() {
      return conicProjection(conicEqualAreaRaw)
          .scale(155.424)
          .center([0, 33.6442]);
    }

    function albers() {
      return conicEqualArea()
          .parallels([29.5, 45.5])
          .scale(1070)
          .translate([480, 250])
          .rotate([96, 0])
          .center([-0.6, 38.7]);
    }

    // The projections must have mutually exclusive clip regions on the sphere,
    // as this will avoid emitting interleaving lines and polygons.
    function multiplex(streams) {
      var n = streams.length;
      return {
        point: function(x, y) { var i = -1; while (++i < n) streams[i].point(x, y); },
        sphere: function() { var i = -1; while (++i < n) streams[i].sphere(); },
        lineStart: function() { var i = -1; while (++i < n) streams[i].lineStart(); },
        lineEnd: function() { var i = -1; while (++i < n) streams[i].lineEnd(); },
        polygonStart: function() { var i = -1; while (++i < n) streams[i].polygonStart(); },
        polygonEnd: function() { var i = -1; while (++i < n) streams[i].polygonEnd(); }
      };
    }

    // A composite projection for the United States, configured by default for
    // 960×500. The projection also works quite well at 960×600 if you change the
    // scale to 1285 and adjust the translate accordingly. The set of standard
    // parallels for each region comes from USGS, which is published here:
    // http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers
    function albersUsa() {
      var cache,
          cacheStream,
          lower48 = albers(), lower48Point,
          alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, // EPSG:3338
          hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, // ESRI:102007
          point, pointStream = {point: function(x, y) { point = [x, y]; }};

      function albersUsa(coordinates) {
        var x = coordinates[0], y = coordinates[1];
        return point = null,
            (lower48Point.point(x, y), point)
            || (alaskaPoint.point(x, y), point)
            || (hawaiiPoint.point(x, y), point);
      }

      albersUsa.invert = function(coordinates) {
        var k = lower48.scale(),
            t = lower48.translate(),
            x = (coordinates[0] - t[0]) / k,
            y = (coordinates[1] - t[1]) / k;
        return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska
            : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii
            : lower48).invert(coordinates);
      };

      albersUsa.stream = function(stream) {
        return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
      };

      albersUsa.precision = function(_) {
        if (!arguments.length) return lower48.precision();
        lower48.precision(_), alaska.precision(_), hawaii.precision(_);
        return reset();
      };

      albersUsa.scale = function(_) {
        if (!arguments.length) return lower48.scale();
        lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
        return albersUsa.translate(lower48.translate());
      };

      albersUsa.translate = function(_) {
        if (!arguments.length) return lower48.translate();
        var k = lower48.scale(), x = +_[0], y = +_[1];

        lower48Point = lower48
            .translate(_)
            .clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]])
            .stream(pointStream);

        alaskaPoint = alaska
            .translate([x - 0.307 * k, y + 0.201 * k])
            .clipExtent([[x - 0.425 * k + epsilon$2, y + 0.120 * k + epsilon$2], [x - 0.214 * k - epsilon$2, y + 0.234 * k - epsilon$2]])
            .stream(pointStream);

        hawaiiPoint = hawaii
            .translate([x - 0.205 * k, y + 0.212 * k])
            .clipExtent([[x - 0.214 * k + epsilon$2, y + 0.166 * k + epsilon$2], [x - 0.115 * k - epsilon$2, y + 0.234 * k - epsilon$2]])
            .stream(pointStream);

        return reset();
      };

      albersUsa.fitExtent = function(extent, object) {
        return fitExtent(albersUsa, extent, object);
      };

      albersUsa.fitSize = function(size, object) {
        return fitSize(albersUsa, size, object);
      };

      albersUsa.fitWidth = function(width, object) {
        return fitWidth(albersUsa, width, object);
      };

      albersUsa.fitHeight = function(height, object) {
        return fitHeight(albersUsa, height, object);
      };

      function reset() {
        cache = cacheStream = null;
        return albersUsa;
      }

      return albersUsa.scale(1070);
    }

    function azimuthalRaw(scale) {
      return function(x, y) {
        var cx = cos$1(x),
            cy = cos$1(y),
            k = scale(cx * cy);
        return [
          k * cy * sin$1(x),
          k * sin$1(y)
        ];
      }
    }

    function azimuthalInvert(angle) {
      return function(x, y) {
        var z = sqrt$2(x * x + y * y),
            c = angle(z),
            sc = sin$1(c),
            cc = cos$1(c);
        return [
          atan2$1(x * sc, z * cc),
          asin$1(z && y * sc / z)
        ];
      }
    }

    var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
      return sqrt$2(2 / (1 + cxcy));
    });

    azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
      return 2 * asin$1(z / 2);
    });

    function azimuthalEqualArea() {
      return projection(azimuthalEqualAreaRaw)
          .scale(124.75)
          .clipAngle(180 - 1e-3);
    }

    var azimuthalEquidistantRaw = azimuthalRaw(function(c) {
      return (c = acos$1(c)) && c / sin$1(c);
    });

    azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
      return z;
    });

    function azimuthalEquidistant() {
      return projection(azimuthalEquidistantRaw)
          .scale(79.4188)
          .clipAngle(180 - 1e-3);
    }

    function mercatorRaw(lambda, phi) {
      return [lambda, log$1(tan((halfPi$1 + phi) / 2))];
    }

    mercatorRaw.invert = function(x, y) {
      return [x, 2 * atan(exp(y)) - halfPi$1];
    };

    function mercator() {
      return mercatorProjection(mercatorRaw)
          .scale(961 / tau$1);
    }

    function mercatorProjection(project) {
      var m = projection(project),
          center = m.center,
          scale = m.scale,
          translate = m.translate,
          clipExtent = m.clipExtent,
          x0 = null, y0, x1, y1; // clip extent

      m.scale = function(_) {
        return arguments.length ? (scale(_), reclip()) : scale();
      };

      m.translate = function(_) {
        return arguments.length ? (translate(_), reclip()) : translate();
      };

      m.center = function(_) {
        return arguments.length ? (center(_), reclip()) : center();
      };

      m.clipExtent = function(_) {
        return arguments.length ? ((_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1])), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];
      };

      function reclip() {
        var k = pi$1 * scale(),
            t = m(rotation(m.rotate()).invert([0, 0]));
        return clipExtent(x0 == null
            ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw
            ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]]
            : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);
      }

      return reclip();
    }

    function tany(y) {
      return tan((halfPi$1 + y) / 2);
    }

    function conicConformalRaw(y0, y1) {
      var cy0 = cos$1(y0),
          n = y0 === y1 ? sin$1(y0) : log$1(cy0 / cos$1(y1)) / log$1(tany(y1) / tany(y0)),
          f = cy0 * pow$1(tany(y0), n) / n;

      if (!n) return mercatorRaw;

      function project(x, y) {
        if (f > 0) { if (y < -halfPi$1 + epsilon$2) y = -halfPi$1 + epsilon$2; }
        else { if (y > halfPi$1 - epsilon$2) y = halfPi$1 - epsilon$2; }
        var r = f / pow$1(tany(y), n);
        return [r * sin$1(n * x), f - r * cos$1(n * x)];
      }

      project.invert = function(x, y) {
        var fy = f - y, r = sign$1(n) * sqrt$2(x * x + fy * fy),
          l = atan2$1(x, abs$1(fy)) * sign$1(fy);
        if (fy * n < 0)
          l -= pi$1 * sign$1(x) * sign$1(fy);
        return [l / n, 2 * atan(pow$1(f / r, 1 / n)) - halfPi$1];
      };

      return project;
    }

    function conicConformal() {
      return conicProjection(conicConformalRaw)
          .scale(109.5)
          .parallels([30, 30]);
    }

    function equirectangularRaw(lambda, phi) {
      return [lambda, phi];
    }

    equirectangularRaw.invert = equirectangularRaw;

    function equirectangular() {
      return projection(equirectangularRaw)
          .scale(152.63);
    }

    function conicEquidistantRaw(y0, y1) {
      var cy0 = cos$1(y0),
          n = y0 === y1 ? sin$1(y0) : (cy0 - cos$1(y1)) / (y1 - y0),
          g = cy0 / n + y0;

      if (abs$1(n) < epsilon$2) return equirectangularRaw;

      function project(x, y) {
        var gy = g - y, nx = n * x;
        return [gy * sin$1(nx), g - gy * cos$1(nx)];
      }

      project.invert = function(x, y) {
        var gy = g - y,
            l = atan2$1(x, abs$1(gy)) * sign$1(gy);
        if (gy * n < 0)
          l -= pi$1 * sign$1(x) * sign$1(gy);
        return [l / n, g - sign$1(n) * sqrt$2(x * x + gy * gy)];
      };

      return project;
    }

    function conicEquidistant() {
      return conicProjection(conicEquidistantRaw)
          .scale(131.154)
          .center([0, 13.9389]);
    }

    var A1 = 1.340264,
        A2 = -0.081106,
        A3 = 0.000893,
        A4 = 0.003796,
        M = sqrt$2(3) / 2,
        iterations = 12;

    function equalEarthRaw(lambda, phi) {
      var l = asin$1(M * sin$1(phi)), l2 = l * l, l6 = l2 * l2 * l2;
      return [
        lambda * cos$1(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),
        l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))
      ];
    }

    equalEarthRaw.invert = function(x, y) {
      var l = y, l2 = l * l, l6 = l2 * l2 * l2;
      for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
        fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y;
        fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);
        l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
        if (abs$1(delta) < epsilon2$1) break;
      }
      return [
        M * x * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos$1(l),
        asin$1(sin$1(l) / M)
      ];
    };

    function equalEarth() {
      return projection(equalEarthRaw)
          .scale(177.158);
    }

    function gnomonicRaw(x, y) {
      var cy = cos$1(y), k = cos$1(x) * cy;
      return [cy * sin$1(x) / k, sin$1(y) / k];
    }

    gnomonicRaw.invert = azimuthalInvert(atan);

    function gnomonic() {
      return projection(gnomonicRaw)
          .scale(144.049)
          .clipAngle(60);
    }

    function identity$4() {
      var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, // scale, translate and reflect
          alpha = 0, ca, sa, // angle
          x0 = null, y0, x1, y1, // clip extent
          kx = 1, ky = 1,
          transform = transformer$3({
            point: function(x, y) {
              var p = projection([x, y]);
              this.stream.point(p[0], p[1]);
            }
          }),
          postclip = identity$5,
          cache,
          cacheStream;

      function reset() {
        kx = k * sx;
        ky = k * sy;
        cache = cacheStream = null;
        return projection;
      }

      function projection (p) {
        var x = p[0] * kx, y = p[1] * ky;
        if (alpha) {
          var t = y * ca - x * sa;
          x = x * ca + y * sa;
          y = t;
        }    
        return [x + tx, y + ty];
      }
      projection.invert = function(p) {
        var x = p[0] - tx, y = p[1] - ty;
        if (alpha) {
          var t = y * ca + x * sa;
          x = x * ca - y * sa;
          y = t;
        }
        return [x / kx, y / ky];
      };
      projection.stream = function(stream) {
        return cache && cacheStream === stream ? cache : cache = transform(postclip(cacheStream = stream));
      };
      projection.postclip = function(_) {
        return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
      };
      projection.clipExtent = function(_) {
        return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$5) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
      };
      projection.scale = function(_) {
        return arguments.length ? (k = +_, reset()) : k;
      };
      projection.translate = function(_) {
        return arguments.length ? (tx = +_[0], ty = +_[1], reset()) : [tx, ty];
      };
      projection.angle = function(_) {
        return arguments.length ? (alpha = _ % 360 * radians, sa = sin$1(alpha), ca = cos$1(alpha), reset()) : alpha * degrees;
      };
      projection.reflectX = function(_) {
        return arguments.length ? (sx = _ ? -1 : 1, reset()) : sx < 0;
      };
      projection.reflectY = function(_) {
        return arguments.length ? (sy = _ ? -1 : 1, reset()) : sy < 0;
      };
      projection.fitExtent = function(extent, object) {
        return fitExtent(projection, extent, object);
      };
      projection.fitSize = function(size, object) {
        return fitSize(projection, size, object);
      };
      projection.fitWidth = function(width, object) {
        return fitWidth(projection, width, object);
      };
      projection.fitHeight = function(height, object) {
        return fitHeight(projection, height, object);
      };

      return projection;
    }

    function naturalEarth1Raw(lambda, phi) {
      var phi2 = phi * phi, phi4 = phi2 * phi2;
      return [
        lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))),
        phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))
      ];
    }

    naturalEarth1Raw.invert = function(x, y) {
      var phi = y, i = 25, delta;
      do {
        var phi2 = phi * phi, phi4 = phi2 * phi2;
        phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) /
            (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 0.005916 * 11 * phi4)));
      } while (abs$1(delta) > epsilon$2 && --i > 0);
      return [
        x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))),
        phi
      ];
    };

    function naturalEarth1() {
      return projection(naturalEarth1Raw)
          .scale(175.295);
    }

    function orthographicRaw(x, y) {
      return [cos$1(y) * sin$1(x), sin$1(y)];
    }

    orthographicRaw.invert = azimuthalInvert(asin$1);

    function orthographic() {
      return projection(orthographicRaw)
          .scale(249.5)
          .clipAngle(90 + epsilon$2);
    }

    function stereographicRaw(x, y) {
      var cy = cos$1(y), k = 1 + cos$1(x) * cy;
      return [cy * sin$1(x) / k, sin$1(y) / k];
    }

    stereographicRaw.invert = azimuthalInvert(function(z) {
      return 2 * atan(z);
    });

    function stereographic() {
      return projection(stereographicRaw)
          .scale(250)
          .clipAngle(142);
    }

    function transverseMercatorRaw(lambda, phi) {
      return [log$1(tan((halfPi$1 + phi) / 2)), -lambda];
    }

    transverseMercatorRaw.invert = function(x, y) {
      return [-y, 2 * atan(exp(x)) - halfPi$1];
    };

    function transverseMercator() {
      var m = mercatorProjection(transverseMercatorRaw),
          center = m.center,
          rotate = m.rotate;

      m.center = function(_) {
        return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
      };

      m.rotate = function(_) {
        return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
      };

      return rotate([0, 0, 90])
          .scale(159.155);
    }

    function defaultSeparation$1(a, b) {
      return a.parent === b.parent ? 1 : 2;
    }

    function meanX(children) {
      return children.reduce(meanXReduce, 0) / children.length;
    }

    function meanXReduce(x, c) {
      return x + c.x;
    }

    function maxY(children) {
      return 1 + children.reduce(maxYReduce, 0);
    }

    function maxYReduce(y, c) {
      return Math.max(y, c.y);
    }

    function leafLeft(node) {
      var children;
      while (children = node.children) node = children[0];
      return node;
    }

    function leafRight(node) {
      var children;
      while (children = node.children) node = children[children.length - 1];
      return node;
    }

    function cluster() {
      var separation = defaultSeparation$1,
          dx = 1,
          dy = 1,
          nodeSize = false;

      function cluster(root) {
        var previousNode,
            x = 0;

        // First walk, computing the initial x & y values.
        root.eachAfter(function(node) {
          var children = node.children;
          if (children) {
            node.x = meanX(children);
            node.y = maxY(children);
          } else {
            node.x = previousNode ? x += separation(node, previousNode) : 0;
            node.y = 0;
            previousNode = node;
          }
        });

        var left = leafLeft(root),
            right = leafRight(root),
            x0 = left.x - separation(left, right) / 2,
            x1 = right.x + separation(right, left) / 2;

        // Second walk, normalizing x & y to the desired size.
        return root.eachAfter(nodeSize ? function(node) {
          node.x = (node.x - root.x) * dx;
          node.y = (root.y - node.y) * dy;
        } : function(node) {
          node.x = (node.x - x0) / (x1 - x0) * dx;
          node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;
        });
      }

      cluster.separation = function(x) {
        return arguments.length ? (separation = x, cluster) : separation;
      };

      cluster.size = function(x) {
        return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? null : [dx, dy]);
      };

      cluster.nodeSize = function(x) {
        return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? [dx, dy] : null);
      };

      return cluster;
    }

    function count(node) {
      var sum = 0,
          children = node.children,
          i = children && children.length;
      if (!i) sum = 1;
      else while (--i >= 0) sum += children[i].value;
      node.value = sum;
    }

    function node_count() {
      return this.eachAfter(count);
    }

    function node_each(callback) {
      var node = this, current, next = [node], children, i, n;
      do {
        current = next.reverse(), next = [];
        while (node = current.pop()) {
          callback(node), children = node.children;
          if (children) for (i = 0, n = children.length; i < n; ++i) {
            next.push(children[i]);
          }
        }
      } while (next.length);
      return this;
    }

    function node_eachBefore(callback) {
      var node = this, nodes = [node], children, i;
      while (node = nodes.pop()) {
        callback(node), children = node.children;
        if (children) for (i = children.length - 1; i >= 0; --i) {
          nodes.push(children[i]);
        }
      }
      return this;
    }

    function node_eachAfter(callback) {
      var node = this, nodes = [node], next = [], children, i, n;
      while (node = nodes.pop()) {
        next.push(node), children = node.children;
        if (children) for (i = 0, n = children.length; i < n; ++i) {
          nodes.push(children[i]);
        }
      }
      while (node = next.pop()) {
        callback(node);
      }
      return this;
    }

    function node_sum(value) {
      return this.eachAfter(function(node) {
        var sum = +value(node.data) || 0,
            children = node.children,
            i = children && children.length;
        while (--i >= 0) sum += children[i].value;
        node.value = sum;
      });
    }

    function node_sort(compare) {
      return this.eachBefore(function(node) {
        if (node.children) {
          node.children.sort(compare);
        }
      });
    }

    function node_path(end) {
      var start = this,
          ancestor = leastCommonAncestor(start, end),
          nodes = [start];
      while (start !== ancestor) {
        start = start.parent;
        nodes.push(start);
      }
      var k = nodes.length;
      while (end !== ancestor) {
        nodes.splice(k, 0, end);
        end = end.parent;
      }
      return nodes;
    }

    function leastCommonAncestor(a, b) {
      if (a === b) return a;
      var aNodes = a.ancestors(),
          bNodes = b.ancestors(),
          c = null;
      a = aNodes.pop();
      b = bNodes.pop();
      while (a === b) {
        c = a;
        a = aNodes.pop();
        b = bNodes.pop();
      }
      return c;
    }

    function node_ancestors() {
      var node = this, nodes = [node];
      while (node = node.parent) {
        nodes.push(node);
      }
      return nodes;
    }

    function node_descendants() {
      var nodes = [];
      this.each(function(node) {
        nodes.push(node);
      });
      return nodes;
    }

    function node_leaves() {
      var leaves = [];
      this.eachBefore(function(node) {
        if (!node.children) {
          leaves.push(node);
        }
      });
      return leaves;
    }

    function node_links() {
      var root = this, links = [];
      root.each(function(node) {
        if (node !== root) { // Don’t include the root’s parent, if any.
          links.push({source: node.parent, target: node});
        }
      });
      return links;
    }

    function hierarchy(data, children) {
      var root = new Node$1(data),
          valued = +data.value && (root.value = data.value),
          node,
          nodes = [root],
          child,
          childs,
          i,
          n;

      if (children == null) children = defaultChildren;

      while (node = nodes.pop()) {
        if (valued) node.value = +node.data.value;
        if ((childs = children(node.data)) && (n = childs.length)) {
          node.children = new Array(n);
          for (i = n - 1; i >= 0; --i) {
            nodes.push(child = node.children[i] = new Node$1(childs[i]));
            child.parent = node;
            child.depth = node.depth + 1;
          }
        }
      }

      return root.eachBefore(computeHeight);
    }

    function node_copy() {
      return hierarchy(this).eachBefore(copyData);
    }

    function defaultChildren(d) {
      return d.children;
    }

    function copyData(node) {
      node.data = node.data.data;
    }

    function computeHeight(node) {
      var height = 0;
      do node.height = height;
      while ((node = node.parent) && (node.height < ++height));
    }

    function Node$1(data) {
      this.data = data;
      this.depth =
      this.height = 0;
      this.parent = null;
    }

    Node$1.prototype = hierarchy.prototype = {
      constructor: Node$1,
      count: node_count,
      each: node_each,
      eachAfter: node_eachAfter,
      eachBefore: node_eachBefore,
      sum: node_sum,
      sort: node_sort,
      path: node_path,
      ancestors: node_ancestors,
      descendants: node_descendants,
      leaves: node_leaves,
      links: node_links,
      copy: node_copy
    };

    var slice$2 = Array.prototype.slice;

    function shuffle(array) {
      var m = array.length,
          t,
          i;

      while (m) {
        i = Math.random() * m-- | 0;
        t = array[m];
        array[m] = array[i];
        array[i] = t;
      }

      return array;
    }

    function enclose(circles) {
      var i = 0, n = (circles = shuffle(slice$2.call(circles))).length, B = [], p, e;

      while (i < n) {
        p = circles[i];
        if (e && enclosesWeak(e, p)) ++i;
        else e = encloseBasis(B = extendBasis(B, p)), i = 0;
      }

      return e;
    }

    function extendBasis(B, p) {
      var i, j;

      if (enclosesWeakAll(p, B)) return [p];

      // If we get here then B must have at least one element.
      for (i = 0; i < B.length; ++i) {
        if (enclosesNot(p, B[i])
            && enclosesWeakAll(encloseBasis2(B[i], p), B)) {
          return [B[i], p];
        }
      }

      // If we get here then B must have at least two elements.
      for (i = 0; i < B.length - 1; ++i) {
        for (j = i + 1; j < B.length; ++j) {
          if (enclosesNot(encloseBasis2(B[i], B[j]), p)
              && enclosesNot(encloseBasis2(B[i], p), B[j])
              && enclosesNot(encloseBasis2(B[j], p), B[i])
              && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {
            return [B[i], B[j], p];
          }
        }
      }

      // If we get here then something is very wrong.
      throw new Error;
    }

    function enclosesNot(a, b) {
      var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;
      return dr < 0 || dr * dr < dx * dx + dy * dy;
    }

    function enclosesWeak(a, b) {
      var dr = a.r - b.r + 1e-6, dx = b.x - a.x, dy = b.y - a.y;
      return dr > 0 && dr * dr > dx * dx + dy * dy;
    }

    function enclosesWeakAll(a, B) {
      for (var i = 0; i < B.length; ++i) {
        if (!enclosesWeak(a, B[i])) {
          return false;
        }
      }
      return true;
    }

    function encloseBasis(B) {
      switch (B.length) {
        case 1: return encloseBasis1(B[0]);
        case 2: return encloseBasis2(B[0], B[1]);
        case 3: return encloseBasis3(B[0], B[1], B[2]);
      }
    }

    function encloseBasis1(a) {
      return {
        x: a.x,
        y: a.y,
        r: a.r
      };
    }

    function encloseBasis2(a, b) {
      var x1 = a.x, y1 = a.y, r1 = a.r,
          x2 = b.x, y2 = b.y, r2 = b.r,
          x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1,
          l = Math.sqrt(x21 * x21 + y21 * y21);
      return {
        x: (x1 + x2 + x21 / l * r21) / 2,
        y: (y1 + y2 + y21 / l * r21) / 2,
        r: (l + r1 + r2) / 2
      };
    }

    function encloseBasis3(a, b, c) {
      var x1 = a.x, y1 = a.y, r1 = a.r,
          x2 = b.x, y2 = b.y, r2 = b.r,
          x3 = c.x, y3 = c.y, r3 = c.r,
          a2 = x1 - x2,
          a3 = x1 - x3,
          b2 = y1 - y2,
          b3 = y1 - y3,
          c2 = r2 - r1,
          c3 = r3 - r1,
          d1 = x1 * x1 + y1 * y1 - r1 * r1,
          d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2,
          d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3,
          ab = a3 * b2 - a2 * b3,
          xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1,
          xb = (b3 * c2 - b2 * c3) / ab,
          ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1,
          yb = (a2 * c3 - a3 * c2) / ab,
          A = xb * xb + yb * yb - 1,
          B = 2 * (r1 + xa * xb + ya * yb),
          C = xa * xa + ya * ya - r1 * r1,
          r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
      return {
        x: x1 + xa + xb * r,
        y: y1 + ya + yb * r,
        r: r
      };
    }

    function place(b, a, c) {
      var dx = b.x - a.x, x, a2,
          dy = b.y - a.y, y, b2,
          d2 = dx * dx + dy * dy;
      if (d2) {
        a2 = a.r + c.r, a2 *= a2;
        b2 = b.r + c.r, b2 *= b2;
        if (a2 > b2) {
          x = (d2 + b2 - a2) / (2 * d2);
          y = Math.sqrt(Math.max(0, b2 / d2 - x * x));
          c.x = b.x - x * dx - y * dy;
          c.y = b.y - x * dy + y * dx;
        } else {
          x = (d2 + a2 - b2) / (2 * d2);
          y = Math.sqrt(Math.max(0, a2 / d2 - x * x));
          c.x = a.x + x * dx - y * dy;
          c.y = a.y + x * dy + y * dx;
        }
      } else {
        c.x = a.x + c.r;
        c.y = a.y;
      }
    }

    function intersects(a, b) {
      var dr = a.r + b.r - 1e-6, dx = b.x - a.x, dy = b.y - a.y;
      return dr > 0 && dr * dr > dx * dx + dy * dy;
    }

    function score(node) {
      var a = node._,
          b = node.next._,
          ab = a.r + b.r,
          dx = (a.x * b.r + b.x * a.r) / ab,
          dy = (a.y * b.r + b.y * a.r) / ab;
      return dx * dx + dy * dy;
    }

    function Node(circle) {
      this._ = circle;
      this.next = null;
      this.previous = null;
    }

    function packEnclose(circles) {
      if (!(n = circles.length)) return 0;

      var a, b, c, n, aa, ca, i, j, k, sj, sk;

      // Place the first circle.
      a = circles[0], a.x = 0, a.y = 0;
      if (!(n > 1)) return a.r;

      // Place the second circle.
      b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
      if (!(n > 2)) return a.r + b.r;

      // Place the third circle.
      place(b, a, c = circles[2]);

      // Initialize the front-chain using the first three circles a, b and c.
      a = new Node(a), b = new Node(b), c = new Node(c);
      a.next = c.previous = b;
      b.next = a.previous = c;
      c.next = b.previous = a;

      // Attempt to place each remaining circle…
      pack: for (i = 3; i < n; ++i) {
        place(a._, b._, c = circles[i]), c = new Node(c);

        // Find the closest intersecting circle on the front-chain, if any.
        // “Closeness” is determined by linear distance along the front-chain.
        // “Ahead” or “behind” is likewise determined by linear distance.
        j = b.next, k = a.previous, sj = b._.r, sk = a._.r;
        do {
          if (sj <= sk) {
            if (intersects(j._, c._)) {
              b = j, a.next = b, b.previous = a, --i;
              continue pack;
            }
            sj += j._.r, j = j.next;
          } else {
            if (intersects(k._, c._)) {
              a = k, a.next = b, b.previous = a, --i;
              continue pack;
            }
            sk += k._.r, k = k.previous;
          }
        } while (j !== k.next);

        // Success! Insert the new circle c between a and b.
        c.previous = a, c.next = b, a.next = b.previous = b = c;

        // Compute the new closest circle pair to the centroid.
        aa = score(a);
        while ((c = c.next) !== b) {
          if ((ca = score(c)) < aa) {
            a = c, aa = ca;
          }
        }
        b = a.next;
      }

      // Compute the enclosing circle of the front chain.
      a = [b._], c = b; while ((c = c.next) !== b) a.push(c._); c = enclose(a);

      // Translate the circles to put the enclosing circle around the origin.
      for (i = 0; i < n; ++i) a = circles[i], a.x -= c.x, a.y -= c.y;

      return c.r;
    }

    function siblings(circles) {
      packEnclose(circles);
      return circles;
    }

    function optional(f) {
      return f == null ? null : required(f);
    }

    function required(f) {
      if (typeof f !== "function") throw new Error;
      return f;
    }

    function constantZero() {
      return 0;
    }

    function constant$4(x) {
      return function() {
        return x;
      };
    }

    function defaultRadius(d) {
      return Math.sqrt(d.value);
    }

    function index$1() {
      var radius = null,
          dx = 1,
          dy = 1,
          padding = constantZero;

      function pack(root) {
        root.x = dx / 2, root.y = dy / 2;
        if (radius) {
          root.eachBefore(radiusLeaf(radius))
              .eachAfter(packChildren(padding, 0.5))
              .eachBefore(translateChild(1));
        } else {
          root.eachBefore(radiusLeaf(defaultRadius))
              .eachAfter(packChildren(constantZero, 1))
              .eachAfter(packChildren(padding, root.r / Math.min(dx, dy)))
              .eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
        }
        return root;
      }

      pack.radius = function(x) {
        return arguments.length ? (radius = optional(x), pack) : radius;
      };

      pack.size = function(x) {
        return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];
      };

      pack.padding = function(x) {
        return arguments.length ? (padding = typeof x === "function" ? x : constant$4(+x), pack) : padding;
      };

      return pack;
    }

    function radiusLeaf(radius) {
      return function(node) {
        if (!node.children) {
          node.r = Math.max(0, +radius(node) || 0);
        }
      };
    }

    function packChildren(padding, k) {
      return function(node) {
        if (children = node.children) {
          var children,
              i,
              n = children.length,
              r = padding(node) * k || 0,
              e;

          if (r) for (i = 0; i < n; ++i) children[i].r += r;
          e = packEnclose(children);
          if (r) for (i = 0; i < n; ++i) children[i].r -= r;
          node.r = e + r;
        }
      };
    }

    function translateChild(k) {
      return function(node) {
        var parent = node.parent;
        node.r *= k;
        if (parent) {
          node.x = parent.x + k * node.x;
          node.y = parent.y + k * node.y;
        }
      };
    }

    function roundNode(node) {
      node.x0 = Math.round(node.x0);
      node.y0 = Math.round(node.y0);
      node.x1 = Math.round(node.x1);
      node.y1 = Math.round(node.y1);
    }

    function treemapDice(parent, x0, y0, x1, y1) {
      var nodes = parent.children,
          node,
          i = -1,
          n = nodes.length,
          k = parent.value && (x1 - x0) / parent.value;

      while (++i < n) {
        node = nodes[i], node.y0 = y0, node.y1 = y1;
        node.x0 = x0, node.x1 = x0 += node.value * k;
      }
    }

    function partition() {
      var dx = 1,
          dy = 1,
          padding = 0,
          round = false;

      function partition(root) {
        var n = root.height + 1;
        root.x0 =
        root.y0 = padding;
        root.x1 = dx;
        root.y1 = dy / n;
        root.eachBefore(positionNode(dy, n));
        if (round) root.eachBefore(roundNode);
        return root;
      }

      function positionNode(dy, n) {
        return function(node) {
          if (node.children) {
            treemapDice(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);
          }
          var x0 = node.x0,
              y0 = node.y0,
              x1 = node.x1 - padding,
              y1 = node.y1 - padding;
          if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
          if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
          node.x0 = x0;
          node.y0 = y0;
          node.x1 = x1;
          node.y1 = y1;
        };
      }

      partition.round = function(x) {
        return arguments.length ? (round = !!x, partition) : round;
      };

      partition.size = function(x) {
        return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];
      };

      partition.padding = function(x) {
        return arguments.length ? (padding = +x, partition) : padding;
      };

      return partition;
    }

    var keyPrefix = "$", // Protect against keys like “__proto__”.
        preroot = {depth: -1},
        ambiguous = {};

    function defaultId(d) {
      return d.id;
    }

    function defaultParentId(d) {
      return d.parentId;
    }

    function stratify() {
      var id = defaultId,
          parentId = defaultParentId;

      function stratify(data) {
        var d,
            i,
            n = data.length,
            root,
            parent,
            node,
            nodes = new Array(n),
            nodeId,
            nodeKey,
            nodeByKey = {};

        for (i = 0; i < n; ++i) {
          d = data[i], node = nodes[i] = new Node$1(d);
          if ((nodeId = id(d, i, data)) != null && (nodeId += "")) {
            nodeKey = keyPrefix + (node.id = nodeId);
            nodeByKey[nodeKey] = nodeKey in nodeByKey ? ambiguous : node;
          }
        }

        for (i = 0; i < n; ++i) {
          node = nodes[i], nodeId = parentId(data[i], i, data);
          if (nodeId == null || !(nodeId += "")) {
            if (root) throw new Error("multiple roots");
            root = node;
          } else {
            parent = nodeByKey[keyPrefix + nodeId];
            if (!parent) throw new Error("missing: " + nodeId);
            if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
            if (parent.children) parent.children.push(node);
            else parent.children = [node];
            node.parent = parent;
          }
        }

        if (!root) throw new Error("no root");
        root.parent = preroot;
        root.eachBefore(function(node) { node.depth = node.parent.depth + 1; --n; }).eachBefore(computeHeight);
        root.parent = null;
        if (n > 0) throw new Error("cycle");

        return root;
      }

      stratify.id = function(x) {
        return arguments.length ? (id = required(x), stratify) : id;
      };

      stratify.parentId = function(x) {
        return arguments.length ? (parentId = required(x), stratify) : parentId;
      };

      return stratify;
    }

    function defaultSeparation(a, b) {
      return a.parent === b.parent ? 1 : 2;
    }

    // function radialSeparation(a, b) {
    //   return (a.parent === b.parent ? 1 : 2) / a.depth;
    // }

    // This function is used to traverse the left contour of a subtree (or
    // subforest). It returns the successor of v on this contour. This successor is
    // either given by the leftmost child of v or by the thread of v. The function
    // returns null if and only if v is on the highest level of its subtree.
    function nextLeft(v) {
      var children = v.children;
      return children ? children[0] : v.t;
    }

    // This function works analogously to nextLeft.
    function nextRight(v) {
      var children = v.children;
      return children ? children[children.length - 1] : v.t;
    }

    // Shifts the current subtree rooted at w+. This is done by increasing
    // prelim(w+) and mod(w+) by shift.
    function moveSubtree(wm, wp, shift) {
      var change = shift / (wp.i - wm.i);
      wp.c -= change;
      wp.s += shift;
      wm.c += change;
      wp.z += shift;
      wp.m += shift;
    }

    // All other shifts, applied to the smaller subtrees between w- and w+, are
    // performed by this function. To prepare the shifts, we have to adjust
    // change(w+), shift(w+), and change(w-).
    function executeShifts(v) {
      var shift = 0,
          change = 0,
          children = v.children,
          i = children.length,
          w;
      while (--i >= 0) {
        w = children[i];
        w.z += shift;
        w.m += shift;
        shift += w.s + (change += w.c);
      }
    }

    // If vi-’s ancestor is a sibling of v, returns vi-’s ancestor. Otherwise,
    // returns the specified (default) ancestor.
    function nextAncestor(vim, v, ancestor) {
      return vim.a.parent === v.parent ? vim.a : ancestor;
    }

    function TreeNode(node, i) {
      this._ = node;
      this.parent = null;
      this.children = null;
      this.A = null; // default ancestor
      this.a = this; // ancestor
      this.z = 0; // prelim
      this.m = 0; // mod
      this.c = 0; // change
      this.s = 0; // shift
      this.t = null; // thread
      this.i = i; // number
    }

    TreeNode.prototype = Object.create(Node$1.prototype);

    function treeRoot(root) {
      var tree = new TreeNode(root, 0),
          node,
          nodes = [tree],
          child,
          children,
          i,
          n;

      while (node = nodes.pop()) {
        if (children = node._.children) {
          node.children = new Array(n = children.length);
          for (i = n - 1; i >= 0; --i) {
            nodes.push(child = node.children[i] = new TreeNode(children[i], i));
            child.parent = node;
          }
        }
      }

      (tree.parent = new TreeNode(null, 0)).children = [tree];
      return tree;
    }

    // Node-link tree diagram using the Reingold-Tilford "tidy" algorithm
    function tree() {
      var separation = defaultSeparation,
          dx = 1,
          dy = 1,
          nodeSize = null;

      function tree(root) {
        var t = treeRoot(root);

        // Compute the layout using Buchheim et al.’s algorithm.
        t.eachAfter(firstWalk), t.parent.m = -t.z;
        t.eachBefore(secondWalk);

        // If a fixed node size is specified, scale x and y.
        if (nodeSize) root.eachBefore(sizeNode);

        // If a fixed tree size is specified, scale x and y based on the extent.
        // Compute the left-most, right-most, and depth-most nodes for extents.
        else {
          var left = root,
              right = root,
              bottom = root;
          root.eachBefore(function(node) {
            if (node.x < left.x) left = node;
            if (node.x > right.x) right = node;
            if (node.depth > bottom.depth) bottom = node;
          });
          var s = left === right ? 1 : separation(left, right) / 2,
              tx = s - left.x,
              kx = dx / (right.x + s + tx),
              ky = dy / (bottom.depth || 1);
          root.eachBefore(function(node) {
            node.x = (node.x + tx) * kx;
            node.y = node.depth * ky;
          });
        }

        return root;
      }

      // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is
      // applied recursively to the children of v, as well as the function
      // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the
      // node v is placed to the midpoint of its outermost children.
      function firstWalk(v) {
        var children = v.children,
            siblings = v.parent.children,
            w = v.i ? siblings[v.i - 1] : null;
        if (children) {
          executeShifts(v);
          var midpoint = (children[0].z + children[children.length - 1].z) / 2;
          if (w) {
            v.z = w.z + separation(v._, w._);
            v.m = v.z - midpoint;
          } else {
            v.z = midpoint;
          }
        } else if (w) {
          v.z = w.z + separation(v._, w._);
        }
        v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
      }

      // Computes all real x-coordinates by summing up the modifiers recursively.
      function secondWalk(v) {
        v._.x = v.z + v.parent.m;
        v.m += v.parent.m;
      }

      // The core of the algorithm. Here, a new subtree is combined with the
      // previous subtrees. Threads are used to traverse the inside and outside
      // contours of the left and right subtree up to the highest common level. The
      // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the
      // superscript o means outside and i means inside, the subscript - means left
      // subtree and + means right subtree. For summing up the modifiers along the
      // contour, we use respective variables si+, si-, so-, and so+. Whenever two
      // nodes of the inside contours conflict, we compute the left one of the
      // greatest uncommon ancestors using the function ANCESTOR and call MOVE
      // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.
      // Finally, we add a new thread (if necessary).
      function apportion(v, w, ancestor) {
        if (w) {
          var vip = v,
              vop = v,
              vim = w,
              vom = vip.parent.children[0],
              sip = vip.m,
              sop = vop.m,
              sim = vim.m,
              som = vom.m,
              shift;
          while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
            vom = nextLeft(vom);
            vop = nextRight(vop);
            vop.a = v;
            shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
            if (shift > 0) {
              moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
              sip += shift;
              sop += shift;
            }
            sim += vim.m;
            sip += vip.m;
            som += vom.m;
            sop += vop.m;
          }
          if (vim && !nextRight(vop)) {
            vop.t = vim;
            vop.m += sim - sop;
          }
          if (vip && !nextLeft(vom)) {
            vom.t = vip;
            vom.m += sip - som;
            ancestor = v;
          }
        }
        return ancestor;
      }

      function sizeNode(node) {
        node.x *= dx;
        node.y = node.depth * dy;
      }

      tree.separation = function(x) {
        return arguments.length ? (separation = x, tree) : separation;
      };

      tree.size = function(x) {
        return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);
      };

      tree.nodeSize = function(x) {
        return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);
      };

      return tree;
    }

    function treemapSlice(parent, x0, y0, x1, y1) {
      var nodes = parent.children,
          node,
          i = -1,
          n = nodes.length,
          k = parent.value && (y1 - y0) / parent.value;

      while (++i < n) {
        node = nodes[i], node.x0 = x0, node.x1 = x1;
        node.y0 = y0, node.y1 = y0 += node.value * k;
      }
    }

    var phi = (1 + Math.sqrt(5)) / 2;

    function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
      var rows = [],
          nodes = parent.children,
          row,
          nodeValue,
          i0 = 0,
          i1 = 0,
          n = nodes.length,
          dx, dy,
          value = parent.value,
          sumValue,
          minValue,
          maxValue,
          newRatio,
          minRatio,
          alpha,
          beta;

      while (i0 < n) {
        dx = x1 - x0, dy = y1 - y0;

        // Find the next non-empty node.
        do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);
        minValue = maxValue = sumValue;
        alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
        beta = sumValue * sumValue * alpha;
        minRatio = Math.max(maxValue / beta, beta / minValue);

        // Keep adding nodes while the aspect ratio maintains or improves.
        for (; i1 < n; ++i1) {
          sumValue += nodeValue = nodes[i1].value;
          if (nodeValue < minValue) minValue = nodeValue;
          if (nodeValue > maxValue) maxValue = nodeValue;
          beta = sumValue * sumValue * alpha;
          newRatio = Math.max(maxValue / beta, beta / minValue);
          if (newRatio > minRatio) { sumValue -= nodeValue; break; }
          minRatio = newRatio;
        }

        // Position and record the row orientation.
        rows.push(row = {value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1)});
        if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);
        else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
        value -= sumValue, i0 = i1;
      }

      return rows;
    }

    var squarify = (function custom(ratio) {

      function squarify(parent, x0, y0, x1, y1) {
        squarifyRatio(ratio, parent, x0, y0, x1, y1);
      }

      squarify.ratio = function(x) {
        return custom((x = +x) > 1 ? x : 1);
      };

      return squarify;
    })(phi);

    function index() {
      var tile = squarify,
          round = false,
          dx = 1,
          dy = 1,
          paddingStack = [0],
          paddingInner = constantZero,
          paddingTop = constantZero,
          paddingRight = constantZero,
          paddingBottom = constantZero,
          paddingLeft = constantZero;

      function treemap(root) {
        root.x0 =
        root.y0 = 0;
        root.x1 = dx;
        root.y1 = dy;
        root.eachBefore(positionNode);
        paddingStack = [0];
        if (round) root.eachBefore(roundNode);
        return root;
      }

      function positionNode(node) {
        var p = paddingStack[node.depth],
            x0 = node.x0 + p,
            y0 = node.y0 + p,
            x1 = node.x1 - p,
            y1 = node.y1 - p;
        if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
        if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
        node.x0 = x0;
        node.y0 = y0;
        node.x1 = x1;
        node.y1 = y1;
        if (node.children) {
          p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
          x0 += paddingLeft(node) - p;
          y0 += paddingTop(node) - p;
          x1 -= paddingRight(node) - p;
          y1 -= paddingBottom(node) - p;
          if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
          if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
          tile(node, x0, y0, x1, y1);
        }
      }

      treemap.round = function(x) {
        return arguments.length ? (round = !!x, treemap) : round;
      };

      treemap.size = function(x) {
        return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];
      };

      treemap.tile = function(x) {
        return arguments.length ? (tile = required(x), treemap) : tile;
      };

      treemap.padding = function(x) {
        return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();
      };

      treemap.paddingInner = function(x) {
        return arguments.length ? (paddingInner = typeof x === "function" ? x : constant$4(+x), treemap) : paddingInner;
      };

      treemap.paddingOuter = function(x) {
        return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();
      };

      treemap.paddingTop = function(x) {
        return arguments.length ? (paddingTop = typeof x === "function" ? x : constant$4(+x), treemap) : paddingTop;
      };

      treemap.paddingRight = function(x) {
        return arguments.length ? (paddingRight = typeof x === "function" ? x : constant$4(+x), treemap) : paddingRight;
      };

      treemap.paddingBottom = function(x) {
        return arguments.length ? (paddingBottom = typeof x === "function" ? x : constant$4(+x), treemap) : paddingBottom;
      };

      treemap.paddingLeft = function(x) {
        return arguments.length ? (paddingLeft = typeof x === "function" ? x : constant$4(+x), treemap) : paddingLeft;
      };

      return treemap;
    }

    function binary(parent, x0, y0, x1, y1) {
      var nodes = parent.children,
          i, n = nodes.length,
          sum, sums = new Array(n + 1);

      for (sums[0] = sum = i = 0; i < n; ++i) {
        sums[i + 1] = sum += nodes[i].value;
      }

      partition(0, n, parent.value, x0, y0, x1, y1);

      function partition(i, j, value, x0, y0, x1, y1) {
        if (i >= j - 1) {
          var node = nodes[i];
          node.x0 = x0, node.y0 = y0;
          node.x1 = x1, node.y1 = y1;
          return;
        }

        var valueOffset = sums[i],
            valueTarget = (value / 2) + valueOffset,
            k = i + 1,
            hi = j - 1;

        while (k < hi) {
          var mid = k + hi >>> 1;
          if (sums[mid] < valueTarget) k = mid + 1;
          else hi = mid;
        }

        if ((valueTarget - sums[k - 1]) < (sums[k] - valueTarget) && i + 1 < k) --k;

        var valueLeft = sums[k] - valueOffset,
            valueRight = value - valueLeft;

        if ((x1 - x0) > (y1 - y0)) {
          var xk = (x0 * valueRight + x1 * valueLeft) / value;
          partition(i, k, valueLeft, x0, y0, xk, y1);
          partition(k, j, valueRight, xk, y0, x1, y1);
        } else {
          var yk = (y0 * valueRight + y1 * valueLeft) / value;
          partition(i, k, valueLeft, x0, y0, x1, yk);
          partition(k, j, valueRight, x0, yk, x1, y1);
        }
      }
    }

    function sliceDice(parent, x0, y0, x1, y1) {
      (parent.depth & 1 ? treemapSlice : treemapDice)(parent, x0, y0, x1, y1);
    }

    var resquarify = (function custom(ratio) {

      function resquarify(parent, x0, y0, x1, y1) {
        if ((rows = parent._squarify) && (rows.ratio === ratio)) {
          var rows,
              row,
              nodes,
              i,
              j = -1,
              n,
              m = rows.length,
              value = parent.value;

          while (++j < m) {
            row = rows[j], nodes = row.children;
            for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;
            if (row.dice) treemapDice(row, x0, y0, x1, y0 += (y1 - y0) * row.value / value);
            else treemapSlice(row, x0, y0, x0 += (x1 - x0) * row.value / value, y1);
            value -= row.value;
          }
        } else {
          parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);
          rows.ratio = ratio;
        }
      }

      resquarify.ratio = function(x) {
        return custom((x = +x) > 1 ? x : 1);
      };

      return resquarify;
    })(phi);

    function area$1(polygon) {
      var i = -1,
          n = polygon.length,
          a,
          b = polygon[n - 1],
          area = 0;

      while (++i < n) {
        a = b;
        b = polygon[i];
        area += a[1] * b[0] - a[0] * b[1];
      }

      return area / 2;
    }

    function centroid(polygon) {
      var i = -1,
          n = polygon.length,
          x = 0,
          y = 0,
          a,
          b = polygon[n - 1],
          c,
          k = 0;

      while (++i < n) {
        a = b;
        b = polygon[i];
        k += c = a[0] * b[1] - b[0] * a[1];
        x += (a[0] + b[0]) * c;
        y += (a[1] + b[1]) * c;
      }

      return k *= 3, [x / k, y / k];
    }

    // Returns the 2D cross product of AB and AC vectors, i.e., the z-component of
    // the 3D cross product in a quadrant I Cartesian coordinate system (+x is
    // right, +y is up). Returns a positive value if ABC is counter-clockwise,
    // negative if clockwise, and zero if the points are collinear.
    function cross$1(a, b, c) {
      return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
    }

    function lexicographicOrder(a, b) {
      return a[0] - b[0] || a[1] - b[1];
    }

    // Computes the upper convex hull per the monotone chain algorithm.
    // Assumes points.length >= 3, is sorted by x, unique in y.
    // Returns an array of indices into points in left-to-right order.
    function computeUpperHullIndexes(points) {
      var n = points.length,
          indexes = [0, 1],
          size = 2;

      for (var i = 2; i < n; ++i) {
        while (size > 1 && cross$1(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) <= 0) --size;
        indexes[size++] = i;
      }

      return indexes.slice(0, size); // remove popped points
    }

    function hull(points) {
      if ((n = points.length) < 3) return null;

      var i,
          n,
          sortedPoints = new Array(n),
          flippedPoints = new Array(n);

      for (i = 0; i < n; ++i) sortedPoints[i] = [+points[i][0], +points[i][1], i];
      sortedPoints.sort(lexicographicOrder);
      for (i = 0; i < n; ++i) flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];

      var upperIndexes = computeUpperHullIndexes(sortedPoints),
          lowerIndexes = computeUpperHullIndexes(flippedPoints);

      // Construct the hull polygon, removing possible duplicate endpoints.
      var skipLeft = lowerIndexes[0] === upperIndexes[0],
          skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1],
          hull = [];

      // Add upper hull in right-to-l order.
      // Then add lower hull in left-to-right order.
      for (i = upperIndexes.length - 1; i >= 0; --i) hull.push(points[sortedPoints[upperIndexes[i]][2]]);
      for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i) hull.push(points[sortedPoints[lowerIndexes[i]][2]]);

      return hull;
    }

    function contains(polygon, point) {
      var n = polygon.length,
          p = polygon[n - 1],
          x = point[0], y = point[1],
          x0 = p[0], y0 = p[1],
          x1, y1,
          inside = false;

      for (var i = 0; i < n; ++i) {
        p = polygon[i], x1 = p[0], y1 = p[1];
        if (((y1 > y) !== (y0 > y)) && (x < (x0 - x1) * (y - y1) / (y0 - y1) + x1)) inside = !inside;
        x0 = x1, y0 = y1;
      }

      return inside;
    }

    function length(polygon) {
      var i = -1,
          n = polygon.length,
          b = polygon[n - 1],
          xa,
          ya,
          xb = b[0],
          yb = b[1],
          perimeter = 0;

      while (++i < n) {
        xa = xb;
        ya = yb;
        b = polygon[i];
        xb = b[0];
        yb = b[1];
        xa -= xb;
        ya -= yb;
        perimeter += Math.sqrt(xa * xa + ya * ya);
      }

      return perimeter;
    }

    function defaultSource() {
      return Math.random();
    }

    var uniform = (function sourceRandomUniform(source) {
      function randomUniform(min, max) {
        min = min == null ? 0 : +min;
        max = max == null ? 1 : +max;
        if (arguments.length === 1) max = min, min = 0;
        else max -= min;
        return function() {
          return source() * max + min;
        };
      }

      randomUniform.source = sourceRandomUniform;

      return randomUniform;
    })(defaultSource);

    var normal = (function sourceRandomNormal(source) {
      function randomNormal(mu, sigma) {
        var x, r;
        mu = mu == null ? 0 : +mu;
        sigma = sigma == null ? 1 : +sigma;
        return function() {
          var y;

          // If available, use the second previously-generated uniform random.
          if (x != null) y = x, x = null;

          // Otherwise, generate a new x and y.
          else do {
            x = source() * 2 - 1;
            y = source() * 2 - 1;
            r = x * x + y * y;
          } while (!r || r > 1);

          return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);
        };
      }

      randomNormal.source = sourceRandomNormal;

      return randomNormal;
    })(defaultSource);

    var logNormal = (function sourceRandomLogNormal(source) {
      function randomLogNormal() {
        var randomNormal = normal.source(source).apply(this, arguments);
        return function() {
          return Math.exp(randomNormal());
        };
      }

      randomLogNormal.source = sourceRandomLogNormal;

      return randomLogNormal;
    })(defaultSource);

    var irwinHall = (function sourceRandomIrwinHall(source) {
      function randomIrwinHall(n) {
        return function() {
          for (var sum = 0, i = 0; i < n; ++i) sum += source();
          return sum;
        };
      }

      randomIrwinHall.source = sourceRandomIrwinHall;

      return randomIrwinHall;
    })(defaultSource);

    var bates = (function sourceRandomBates(source) {
      function randomBates(n) {
        var randomIrwinHall = irwinHall.source(source)(n);
        return function() {
          return randomIrwinHall() / n;
        };
      }

      randomBates.source = sourceRandomBates;

      return randomBates;
    })(defaultSource);

    var exponential = (function sourceRandomExponential(source) {
      function randomExponential(lambda) {
        return function() {
          return -Math.log(1 - source()) / lambda;
        };
      }

      randomExponential.source = sourceRandomExponential;

      return randomExponential;
    })(defaultSource);

    function initRange(domain, range) {
      switch (arguments.length) {
        case 0: break;
        case 1: this.range(domain); break;
        default: this.range(range).domain(domain); break;
      }
      return this;
    }

    function initInterpolator(domain, interpolator) {
      switch (arguments.length) {
        case 0: break;
        case 1: this.interpolator(domain); break;
        default: this.interpolator(interpolator).domain(domain); break;
      }
      return this;
    }

    var array = Array.prototype;

    var map = array.map;
    var slice$1 = array.slice;

    var implicit = {name: "implicit"};

    function ordinal() {
      var index = map$2(),
          domain = [],
          range = [],
          unknown = implicit;

      function scale(d) {
        var key = d + "", i = index.get(key);
        if (!i) {
          if (unknown !== implicit) return unknown;
          index.set(key, i = domain.push(d));
        }
        return range[(i - 1) % range.length];
      }

      scale.domain = function(_) {
        if (!arguments.length) return domain.slice();
        domain = [], index = map$2();
        var i = -1, n = _.length, d, key;
        while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));
        return scale;
      };

      scale.range = function(_) {
        return arguments.length ? (range = slice$1.call(_), scale) : range.slice();
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.copy = function() {
        return ordinal(domain, range).unknown(unknown);
      };

      initRange.apply(scale, arguments);

      return scale;
    }

    function band() {
      var scale = ordinal().unknown(undefined),
          domain = scale.domain,
          ordinalRange = scale.range,
          range = [0, 1],
          step,
          bandwidth,
          round = false,
          paddingInner = 0,
          paddingOuter = 0,
          align = 0.5;

      delete scale.unknown;

      function rescale() {
        var n = domain().length,
            reverse = range[1] < range[0],
            start = range[reverse - 0],
            stop = range[1 - reverse];
        step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
        if (round) step = Math.floor(step);
        start += (stop - start - step * (n - paddingInner)) * align;
        bandwidth = step * (1 - paddingInner);
        if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
        var values = sequence(n).map(function(i) { return start + step * i; });
        return ordinalRange(reverse ? values.reverse() : values);
      }

      scale.domain = function(_) {
        return arguments.length ? (domain(_), rescale()) : domain();
      };

      scale.range = function(_) {
        return arguments.length ? (range = [+_[0], +_[1]], rescale()) : range.slice();
      };

      scale.rangeRound = function(_) {
        return range = [+_[0], +_[1]], round = true, rescale();
      };

      scale.bandwidth = function() {
        return bandwidth;
      };

      scale.step = function() {
        return step;
      };

      scale.round = function(_) {
        return arguments.length ? (round = !!_, rescale()) : round;
      };

      scale.padding = function(_) {
        return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
      };

      scale.paddingInner = function(_) {
        return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
      };

      scale.paddingOuter = function(_) {
        return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
      };

      scale.align = function(_) {
        return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
      };

      scale.copy = function() {
        return band(domain(), range)
            .round(round)
            .paddingInner(paddingInner)
            .paddingOuter(paddingOuter)
            .align(align);
      };

      return initRange.apply(rescale(), arguments);
    }

    function pointish(scale) {
      var copy = scale.copy;

      scale.padding = scale.paddingOuter;
      delete scale.paddingInner;
      delete scale.paddingOuter;

      scale.copy = function() {
        return pointish(copy());
      };

      return scale;
    }

    function point$4() {
      return pointish(band.apply(null, arguments).paddingInner(1));
    }

    function constant$3(x) {
      return function() {
        return x;
      };
    }

    function number$1(x) {
      return +x;
    }

    var unit = [0, 1];

    function identity$3(x) {
      return x;
    }

    function normalize(a, b) {
      return (b -= (a = +a))
          ? function(x) { return (x - a) / b; }
          : constant$3(isNaN(b) ? NaN : 0.5);
    }

    function clamper(domain) {
      var a = domain[0], b = domain[domain.length - 1], t;
      if (a > b) t = a, a = b, b = t;
      return function(x) { return Math.max(a, Math.min(b, x)); };
    }

    // normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
    // interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
    function bimap(domain, range, interpolate) {
      var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
      if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
      else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
      return function(x) { return r0(d0(x)); };
    }

    function polymap(domain, range, interpolate) {
      var j = Math.min(domain.length, range.length) - 1,
          d = new Array(j),
          r = new Array(j),
          i = -1;

      // Reverse descending domains.
      if (domain[j] < domain[0]) {
        domain = domain.slice().reverse();
        range = range.slice().reverse();
      }

      while (++i < j) {
        d[i] = normalize(domain[i], domain[i + 1]);
        r[i] = interpolate(range[i], range[i + 1]);
      }

      return function(x) {
        var i = bisectRight(domain, x, 1, j) - 1;
        return r[i](d[i](x));
      };
    }

    function copy$1(source, target) {
      return target
          .domain(source.domain())
          .range(source.range())
          .interpolate(source.interpolate())
          .clamp(source.clamp())
          .unknown(source.unknown());
    }

    function transformer$2() {
      var domain = unit,
          range = unit,
          interpolate = interpolateValue,
          transform,
          untransform,
          unknown,
          clamp = identity$3,
          piecewise,
          output,
          input;

      function rescale() {
        piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;
        output = input = null;
        return scale;
      }

      function scale(x) {
        return isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
      }

      scale.invert = function(y) {
        return clamp(untransform((input || (input = piecewise(range, domain.map(transform), interpolateNumber)))(y)));
      };

      scale.domain = function(_) {
        return arguments.length ? (domain = map.call(_, number$1), clamp === identity$3 || (clamp = clamper(domain)), rescale()) : domain.slice();
      };

      scale.range = function(_) {
        return arguments.length ? (range = slice$1.call(_), rescale()) : range.slice();
      };

      scale.rangeRound = function(_) {
        return range = slice$1.call(_), interpolate = interpolateRound, rescale();
      };

      scale.clamp = function(_) {
        return arguments.length ? (clamp = _ ? clamper(domain) : identity$3, scale) : clamp !== identity$3;
      };

      scale.interpolate = function(_) {
        return arguments.length ? (interpolate = _, rescale()) : interpolate;
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      return function(t, u) {
        transform = t, untransform = u;
        return rescale();
      };
    }

    function continuous(transform, untransform) {
      return transformer$2()(transform, untransform);
    }

    function tickFormat(start, stop, count, specifier) {
      var step = tickStep(start, stop, count),
          precision;
      specifier = formatSpecifier(specifier == null ? ",f" : specifier);
      switch (specifier.type) {
        case "s": {
          var value = Math.max(Math.abs(start), Math.abs(stop));
          if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
          return formatPrefix(specifier, value);
        }
        case "":
        case "e":
        case "g":
        case "p":
        case "r": {
          if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
          break;
        }
        case "f":
        case "%": {
          if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
          break;
        }
      }
      return format(specifier);
    }

    function linearish(scale) {
      var domain = scale.domain;

      scale.ticks = function(count) {
        var d = domain();
        return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
      };

      scale.tickFormat = function(count, specifier) {
        var d = domain();
        return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
      };

      scale.nice = function(count) {
        if (count == null) count = 10;

        var d = domain(),
            i0 = 0,
            i1 = d.length - 1,
            start = d[i0],
            stop = d[i1],
            step;

        if (stop < start) {
          step = start, start = stop, stop = step;
          step = i0, i0 = i1, i1 = step;
        }

        step = tickIncrement(start, stop, count);

        if (step > 0) {
          start = Math.floor(start / step) * step;
          stop = Math.ceil(stop / step) * step;
          step = tickIncrement(start, stop, count);
        } else if (step < 0) {
          start = Math.ceil(start * step) / step;
          stop = Math.floor(stop * step) / step;
          step = tickIncrement(start, stop, count);
        }

        if (step > 0) {
          d[i0] = Math.floor(start / step) * step;
          d[i1] = Math.ceil(stop / step) * step;
          domain(d);
        } else if (step < 0) {
          d[i0] = Math.ceil(start * step) / step;
          d[i1] = Math.floor(stop * step) / step;
          domain(d);
        }

        return scale;
      };

      return scale;
    }

    function linear() {
      var scale = continuous(identity$3, identity$3);

      scale.copy = function() {
        return copy$1(scale, linear());
      };

      initRange.apply(scale, arguments);

      return linearish(scale);
    }

    function identity$2(domain) {
      var unknown;

      function scale(x) {
        return isNaN(x = +x) ? unknown : x;
      }

      scale.invert = scale;

      scale.domain = scale.range = function(_) {
        return arguments.length ? (domain = map.call(_, number$1), scale) : domain.slice();
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.copy = function() {
        return identity$2(domain).unknown(unknown);
      };

      domain = arguments.length ? map.call(domain, number$1) : [0, 1];

      return linearish(scale);
    }

    function nice(domain, interval) {
      domain = domain.slice();

      var i0 = 0,
          i1 = domain.length - 1,
          x0 = domain[i0],
          x1 = domain[i1],
          t;

      if (x1 < x0) {
        t = i0, i0 = i1, i1 = t;
        t = x0, x0 = x1, x1 = t;
      }

      domain[i0] = interval.floor(x0);
      domain[i1] = interval.ceil(x1);
      return domain;
    }

    function transformLog(x) {
      return Math.log(x);
    }

    function transformExp(x) {
      return Math.exp(x);
    }

    function transformLogn(x) {
      return -Math.log(-x);
    }

    function transformExpn(x) {
      return -Math.exp(-x);
    }

    function pow10(x) {
      return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
    }

    function powp(base) {
      return base === 10 ? pow10
          : base === Math.E ? Math.exp
          : function(x) { return Math.pow(base, x); };
    }

    function logp(base) {
      return base === Math.E ? Math.log
          : base === 10 && Math.log10
          || base === 2 && Math.log2
          || (base = Math.log(base), function(x) { return Math.log(x) / base; });
    }

    function reflect(f) {
      return function(x) {
        return -f(-x);
      };
    }

    function loggish(transform) {
      var scale = transform(transformLog, transformExp),
          domain = scale.domain,
          base = 10,
          logs,
          pows;

      function rescale() {
        logs = logp(base), pows = powp(base);
        if (domain()[0] < 0) {
          logs = reflect(logs), pows = reflect(pows);
          transform(transformLogn, transformExpn);
        } else {
          transform(transformLog, transformExp);
        }
        return scale;
      }

      scale.base = function(_) {
        return arguments.length ? (base = +_, rescale()) : base;
      };

      scale.domain = function(_) {
        return arguments.length ? (domain(_), rescale()) : domain();
      };

      scale.ticks = function(count) {
        var d = domain(),
            u = d[0],
            v = d[d.length - 1],
            r;

        if (r = v < u) i = u, u = v, v = i;

        var i = logs(u),
            j = logs(v),
            p,
            k,
            t,
            n = count == null ? 10 : +count,
            z = [];

        if (!(base % 1) && j - i < n) {
          i = Math.round(i) - 1, j = Math.round(j) + 1;
          if (u > 0) for (; i < j; ++i) {
            for (k = 1, p = pows(i); k < base; ++k) {
              t = p * k;
              if (t < u) continue;
              if (t > v) break;
              z.push(t);
            }
          } else for (; i < j; ++i) {
            for (k = base - 1, p = pows(i); k >= 1; --k) {
              t = p * k;
              if (t < u) continue;
              if (t > v) break;
              z.push(t);
            }
          }
        } else {
          z = ticks(i, j, Math.min(j - i, n)).map(pows);
        }

        return r ? z.reverse() : z;
      };

      scale.tickFormat = function(count, specifier) {
        if (specifier == null) specifier = base === 10 ? ".0e" : ",";
        if (typeof specifier !== "function") specifier = format(specifier);
        if (count === Infinity) return specifier;
        if (count == null) count = 10;
        var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
        return function(d) {
          var i = d / pows(Math.round(logs(d)));
          if (i * base < base - 0.5) i *= base;
          return i <= k ? specifier(d) : "";
        };
      };

      scale.nice = function() {
        return domain(nice(domain(), {
          floor: function(x) { return pows(Math.floor(logs(x))); },
          ceil: function(x) { return pows(Math.ceil(logs(x))); }
        }));
      };

      return scale;
    }

    function log() {
      var scale = loggish(transformer$2()).domain([1, 10]);

      scale.copy = function() {
        return copy$1(scale, log()).base(scale.base());
      };

      initRange.apply(scale, arguments);

      return scale;
    }

    function transformSymlog(c) {
      return function(x) {
        return Math.sign(x) * Math.log1p(Math.abs(x / c));
      };
    }

    function transformSymexp(c) {
      return function(x) {
        return Math.sign(x) * Math.expm1(Math.abs(x)) * c;
      };
    }

    function symlogish(transform) {
      var c = 1, scale = transform(transformSymlog(c), transformSymexp(c));

      scale.constant = function(_) {
        return arguments.length ? transform(transformSymlog(c = +_), transformSymexp(c)) : c;
      };

      return linearish(scale);
    }

    function symlog() {
      var scale = symlogish(transformer$2());

      scale.copy = function() {
        return copy$1(scale, symlog()).constant(scale.constant());
      };

      return initRange.apply(scale, arguments);
    }

    function transformPow(exponent) {
      return function(x) {
        return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
      };
    }

    function transformSqrt(x) {
      return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
    }

    function transformSquare(x) {
      return x < 0 ? -x * x : x * x;
    }

    function powish(transform) {
      var scale = transform(identity$3, identity$3),
          exponent = 1;

      function rescale() {
        return exponent === 1 ? transform(identity$3, identity$3)
            : exponent === 0.5 ? transform(transformSqrt, transformSquare)
            : transform(transformPow(exponent), transformPow(1 / exponent));
      }

      scale.exponent = function(_) {
        return arguments.length ? (exponent = +_, rescale()) : exponent;
      };

      return linearish(scale);
    }

    function pow() {
      var scale = powish(transformer$2());

      scale.copy = function() {
        return copy$1(scale, pow()).exponent(scale.exponent());
      };

      initRange.apply(scale, arguments);

      return scale;
    }

    function sqrt$1() {
      return pow.apply(null, arguments).exponent(0.5);
    }

    function quantile() {
      var domain = [],
          range = [],
          thresholds = [],
          unknown;

      function rescale() {
        var i = 0, n = Math.max(1, range.length);
        thresholds = new Array(n - 1);
        while (++i < n) thresholds[i - 1] = threshold$1(domain, i / n);
        return scale;
      }

      function scale(x) {
        return isNaN(x = +x) ? unknown : range[bisectRight(thresholds, x)];
      }

      scale.invertExtent = function(y) {
        var i = range.indexOf(y);
        return i < 0 ? [NaN, NaN] : [
          i > 0 ? thresholds[i - 1] : domain[0],
          i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
        ];
      };

      scale.domain = function(_) {
        if (!arguments.length) return domain.slice();
        domain = [];
        for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);
        domain.sort(ascending$3);
        return rescale();
      };

      scale.range = function(_) {
        return arguments.length ? (range = slice$1.call(_), rescale()) : range.slice();
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.quantiles = function() {
        return thresholds.slice();
      };

      scale.copy = function() {
        return quantile()
            .domain(domain)
            .range(range)
            .unknown(unknown);
      };

      return initRange.apply(scale, arguments);
    }

    function quantize() {
      var x0 = 0,
          x1 = 1,
          n = 1,
          domain = [0.5],
          range = [0, 1],
          unknown;

      function scale(x) {
        return x <= x ? range[bisectRight(domain, x, 0, n)] : unknown;
      }

      function rescale() {
        var i = -1;
        domain = new Array(n);
        while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
        return scale;
      }

      scale.domain = function(_) {
        return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];
      };

      scale.range = function(_) {
        return arguments.length ? (n = (range = slice$1.call(_)).length - 1, rescale()) : range.slice();
      };

      scale.invertExtent = function(y) {
        var i = range.indexOf(y);
        return i < 0 ? [NaN, NaN]
            : i < 1 ? [x0, domain[0]]
            : i >= n ? [domain[n - 1], x1]
            : [domain[i - 1], domain[i]];
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : scale;
      };

      scale.thresholds = function() {
        return domain.slice();
      };

      scale.copy = function() {
        return quantize()
            .domain([x0, x1])
            .range(range)
            .unknown(unknown);
      };

      return initRange.apply(linearish(scale), arguments);
    }

    function threshold() {
      var domain = [0.5],
          range = [0, 1],
          unknown,
          n = 1;

      function scale(x) {
        return x <= x ? range[bisectRight(domain, x, 0, n)] : unknown;
      }

      scale.domain = function(_) {
        return arguments.length ? (domain = slice$1.call(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
      };

      scale.range = function(_) {
        return arguments.length ? (range = slice$1.call(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
      };

      scale.invertExtent = function(y) {
        var i = range.indexOf(y);
        return [domain[i - 1], domain[i]];
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.copy = function() {
        return threshold()
            .domain(domain)
            .range(range)
            .unknown(unknown);
      };

      return initRange.apply(scale, arguments);
    }

    var t0 = new Date,
        t1 = new Date;

    function newInterval(floori, offseti, count, field) {

      function interval(date) {
        return floori(date = arguments.length === 0 ? new Date : new Date(+date)), date;
      }

      interval.floor = function(date) {
        return floori(date = new Date(+date)), date;
      };

      interval.ceil = function(date) {
        return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
      };

      interval.round = function(date) {
        var d0 = interval(date),
            d1 = interval.ceil(date);
        return date - d0 < d1 - date ? d0 : d1;
      };

      interval.offset = function(date, step) {
        return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
      };

      interval.range = function(start, stop, step) {
        var range = [], previous;
        start = interval.ceil(start);
        step = step == null ? 1 : Math.floor(step);
        if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
        do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
        while (previous < start && start < stop);
        return range;
      };

      interval.filter = function(test) {
        return newInterval(function(date) {
          if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
        }, function(date, step) {
          if (date >= date) {
            if (step < 0) while (++step <= 0) {
              while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
            } else while (--step >= 0) {
              while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
            }
          }
        });
      };

      if (count) {
        interval.count = function(start, end) {
          t0.setTime(+start), t1.setTime(+end);
          floori(t0), floori(t1);
          return Math.floor(count(t0, t1));
        };

        interval.every = function(step) {
          step = Math.floor(step);
          return !isFinite(step) || !(step > 0) ? null
              : !(step > 1) ? interval
              : interval.filter(field
                  ? function(d) { return field(d) % step === 0; }
                  : function(d) { return interval.count(0, d) % step === 0; });
        };
      }

      return interval;
    }

    var millisecond = newInterval(function() {
      // noop
    }, function(date, step) {
      date.setTime(+date + step);
    }, function(start, end) {
      return end - start;
    });

    // An optimized implementation for this simple case.
    millisecond.every = function(k) {
      k = Math.floor(k);
      if (!isFinite(k) || !(k > 0)) return null;
      if (!(k > 1)) return millisecond;
      return newInterval(function(date) {
        date.setTime(Math.floor(date / k) * k);
      }, function(date, step) {
        date.setTime(+date + step * k);
      }, function(start, end) {
        return (end - start) / k;
      });
    };

    var utcMillisecond = millisecond;
    var milliseconds = millisecond.range;

    var durationSecond$1 = 1e3;
    var durationMinute$1 = 6e4;
    var durationHour$1 = 36e5;
    var durationDay$1 = 864e5;
    var durationWeek$1 = 6048e5;

    var second = newInterval(function(date) {
      date.setTime(date - date.getMilliseconds());
    }, function(date, step) {
      date.setTime(+date + step * durationSecond$1);
    }, function(start, end) {
      return (end - start) / durationSecond$1;
    }, function(date) {
      return date.getUTCSeconds();
    });

    var utcSecond = second;
    var seconds = second.range;

    var minute = newInterval(function(date) {
      date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond$1);
    }, function(date, step) {
      date.setTime(+date + step * durationMinute$1);
    }, function(start, end) {
      return (end - start) / durationMinute$1;
    }, function(date) {
      return date.getMinutes();
    });

    var timeMinute = minute;
    var minutes = minute.range;

    var hour = newInterval(function(date) {
      date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond$1 - date.getMinutes() * durationMinute$1);
    }, function(date, step) {
      date.setTime(+date + step * durationHour$1);
    }, function(start, end) {
      return (end - start) / durationHour$1;
    }, function(date) {
      return date.getHours();
    });

    var timeHour = hour;
    var hours = hour.range;

    var day = newInterval(function(date) {
      date.setHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setDate(date.getDate() + step);
    }, function(start, end) {
      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute$1) / durationDay$1;
    }, function(date) {
      return date.getDate() - 1;
    });

    var timeDay = day;
    var days = day.range;

    function weekday(i) {
      return newInterval(function(date) {
        date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
        date.setHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setDate(date.getDate() + step * 7);
      }, function(start, end) {
        return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute$1) / durationWeek$1;
      });
    }

    var sunday = weekday(0);
    var monday = weekday(1);
    var tuesday = weekday(2);
    var wednesday = weekday(3);
    var thursday = weekday(4);
    var friday = weekday(5);
    var saturday = weekday(6);

    var sundays = sunday.range;
    var mondays = monday.range;
    var tuesdays = tuesday.range;
    var wednesdays = wednesday.range;
    var thursdays = thursday.range;
    var fridays = friday.range;
    var saturdays = saturday.range;

    var month = newInterval(function(date) {
      date.setDate(1);
      date.setHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setMonth(date.getMonth() + step);
    }, function(start, end) {
      return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
    }, function(date) {
      return date.getMonth();
    });

    var timeMonth = month;
    var months = month.range;

    var year = newInterval(function(date) {
      date.setMonth(0, 1);
      date.setHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setFullYear(date.getFullYear() + step);
    }, function(start, end) {
      return end.getFullYear() - start.getFullYear();
    }, function(date) {
      return date.getFullYear();
    });

    // An optimized implementation for this simple case.
    year.every = function(k) {
      return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
        date.setFullYear(Math.floor(date.getFullYear() / k) * k);
        date.setMonth(0, 1);
        date.setHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setFullYear(date.getFullYear() + step * k);
      });
    };

    var timeYear = year;
    var years = year.range;

    var utcMinute = newInterval(function(date) {
      date.setUTCSeconds(0, 0);
    }, function(date, step) {
      date.setTime(+date + step * durationMinute$1);
    }, function(start, end) {
      return (end - start) / durationMinute$1;
    }, function(date) {
      return date.getUTCMinutes();
    });

    var utcMinute$1 = utcMinute;
    var utcMinutes = utcMinute.range;

    var utcHour = newInterval(function(date) {
      date.setUTCMinutes(0, 0, 0);
    }, function(date, step) {
      date.setTime(+date + step * durationHour$1);
    }, function(start, end) {
      return (end - start) / durationHour$1;
    }, function(date) {
      return date.getUTCHours();
    });

    var utcHour$1 = utcHour;
    var utcHours = utcHour.range;

    var utcDay = newInterval(function(date) {
      date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setUTCDate(date.getUTCDate() + step);
    }, function(start, end) {
      return (end - start) / durationDay$1;
    }, function(date) {
      return date.getUTCDate() - 1;
    });

    var utcDay$1 = utcDay;
    var utcDays = utcDay.range;

    function utcWeekday(i) {
      return newInterval(function(date) {
        date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
        date.setUTCHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setUTCDate(date.getUTCDate() + step * 7);
      }, function(start, end) {
        return (end - start) / durationWeek$1;
      });
    }

    var utcSunday = utcWeekday(0);
    var utcMonday = utcWeekday(1);
    var utcTuesday = utcWeekday(2);
    var utcWednesday = utcWeekday(3);
    var utcThursday = utcWeekday(4);
    var utcFriday = utcWeekday(5);
    var utcSaturday = utcWeekday(6);

    var utcSundays = utcSunday.range;
    var utcMondays = utcMonday.range;
    var utcTuesdays = utcTuesday.range;
    var utcWednesdays = utcWednesday.range;
    var utcThursdays = utcThursday.range;
    var utcFridays = utcFriday.range;
    var utcSaturdays = utcSaturday.range;

    var utcMonth = newInterval(function(date) {
      date.setUTCDate(1);
      date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setUTCMonth(date.getUTCMonth() + step);
    }, function(start, end) {
      return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
    }, function(date) {
      return date.getUTCMonth();
    });

    var utcMonth$1 = utcMonth;
    var utcMonths = utcMonth.range;

    var utcYear = newInterval(function(date) {
      date.setUTCMonth(0, 1);
      date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setUTCFullYear(date.getUTCFullYear() + step);
    }, function(start, end) {
      return end.getUTCFullYear() - start.getUTCFullYear();
    }, function(date) {
      return date.getUTCFullYear();
    });

    // An optimized implementation for this simple case.
    utcYear.every = function(k) {
      return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
        date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
        date.setUTCMonth(0, 1);
        date.setUTCHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setUTCFullYear(date.getUTCFullYear() + step * k);
      });
    };

    var utcYear$1 = utcYear;
    var utcYears = utcYear.range;

    function localDate(d) {
      if (0 <= d.y && d.y < 100) {
        var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
        date.setFullYear(d.y);
        return date;
      }
      return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
    }

    function utcDate(d) {
      if (0 <= d.y && d.y < 100) {
        var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
        date.setUTCFullYear(d.y);
        return date;
      }
      return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
    }

    function newDate(y, m, d) {
      return {y: y, m: m, d: d, H: 0, M: 0, S: 0, L: 0};
    }

    function formatLocale(locale) {
      var locale_dateTime = locale.dateTime,
          locale_date = locale.date,
          locale_time = locale.time,
          locale_periods = locale.periods,
          locale_weekdays = locale.days,
          locale_shortWeekdays = locale.shortDays,
          locale_months = locale.months,
          locale_shortMonths = locale.shortMonths;

      var periodRe = formatRe(locale_periods),
          periodLookup = formatLookup(locale_periods),
          weekdayRe = formatRe(locale_weekdays),
          weekdayLookup = formatLookup(locale_weekdays),
          shortWeekdayRe = formatRe(locale_shortWeekdays),
          shortWeekdayLookup = formatLookup(locale_shortWeekdays),
          monthRe = formatRe(locale_months),
          monthLookup = formatLookup(locale_months),
          shortMonthRe = formatRe(locale_shortMonths),
          shortMonthLookup = formatLookup(locale_shortMonths);

      var formats = {
        "a": formatShortWeekday,
        "A": formatWeekday,
        "b": formatShortMonth,
        "B": formatMonth,
        "c": null,
        "d": formatDayOfMonth,
        "e": formatDayOfMonth,
        "f": formatMicroseconds,
        "g": formatYearISO,
        "G": formatFullYearISO,
        "H": formatHour24,
        "I": formatHour12,
        "j": formatDayOfYear,
        "L": formatMilliseconds,
        "m": formatMonthNumber,
        "M": formatMinutes,
        "p": formatPeriod,
        "q": formatQuarter,
        "Q": formatUnixTimestamp,
        "s": formatUnixTimestampSeconds,
        "S": formatSeconds,
        "u": formatWeekdayNumberMonday,
        "U": formatWeekNumberSunday,
        "V": formatWeekNumberISO,
        "w": formatWeekdayNumberSunday,
        "W": formatWeekNumberMonday,
        "x": null,
        "X": null,
        "y": formatYear,
        "Y": formatFullYear,
        "Z": formatZone,
        "%": formatLiteralPercent
      };

      var utcFormats = {
        "a": formatUTCShortWeekday,
        "A": formatUTCWeekday,
        "b": formatUTCShortMonth,
        "B": formatUTCMonth,
        "c": null,
        "d": formatUTCDayOfMonth,
        "e": formatUTCDayOfMonth,
        "f": formatUTCMicroseconds,
        "g": formatUTCYearISO,
        "G": formatUTCFullYearISO,
        "H": formatUTCHour24,
        "I": formatUTCHour12,
        "j": formatUTCDayOfYear,
        "L": formatUTCMilliseconds,
        "m": formatUTCMonthNumber,
        "M": formatUTCMinutes,
        "p": formatUTCPeriod,
        "q": formatUTCQuarter,
        "Q": formatUnixTimestamp,
        "s": formatUnixTimestampSeconds,
        "S": formatUTCSeconds,
        "u": formatUTCWeekdayNumberMonday,
        "U": formatUTCWeekNumberSunday,
        "V": formatUTCWeekNumberISO,
        "w": formatUTCWeekdayNumberSunday,
        "W": formatUTCWeekNumberMonday,
        "x": null,
        "X": null,
        "y": formatUTCYear,
        "Y": formatUTCFullYear,
        "Z": formatUTCZone,
        "%": formatLiteralPercent
      };

      var parses = {
        "a": parseShortWeekday,
        "A": parseWeekday,
        "b": parseShortMonth,
        "B": parseMonth,
        "c": parseLocaleDateTime,
        "d": parseDayOfMonth,
        "e": parseDayOfMonth,
        "f": parseMicroseconds,
        "g": parseYear,
        "G": parseFullYear,
        "H": parseHour24,
        "I": parseHour24,
        "j": parseDayOfYear,
        "L": parseMilliseconds,
        "m": parseMonthNumber,
        "M": parseMinutes,
        "p": parsePeriod,
        "q": parseQuarter,
        "Q": parseUnixTimestamp,
        "s": parseUnixTimestampSeconds,
        "S": parseSeconds,
        "u": parseWeekdayNumberMonday,
        "U": parseWeekNumberSunday,
        "V": parseWeekNumberISO,
        "w": parseWeekdayNumberSunday,
        "W": parseWeekNumberMonday,
        "x": parseLocaleDate,
        "X": parseLocaleTime,
        "y": parseYear,
        "Y": parseFullYear,
        "Z": parseZone,
        "%": parseLiteralPercent
      };

      // These recursive directive definitions must be deferred.
      formats.x = newFormat(locale_date, formats);
      formats.X = newFormat(locale_time, formats);
      formats.c = newFormat(locale_dateTime, formats);
      utcFormats.x = newFormat(locale_date, utcFormats);
      utcFormats.X = newFormat(locale_time, utcFormats);
      utcFormats.c = newFormat(locale_dateTime, utcFormats);

      function newFormat(specifier, formats) {
        return function(date) {
          var string = [],
              i = -1,
              j = 0,
              n = specifier.length,
              c,
              pad,
              format;

          if (!(date instanceof Date)) date = new Date(+date);

          while (++i < n) {
            if (specifier.charCodeAt(i) === 37) {
              string.push(specifier.slice(j, i));
              if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
              else pad = c === "e" ? " " : "0";
              if (format = formats[c]) c = format(date, pad);
              string.push(c);
              j = i + 1;
            }
          }

          string.push(specifier.slice(j, i));
          return string.join("");
        };
      }

      function newParse(specifier, Z) {
        return function(string) {
          var d = newDate(1900, undefined, 1),
              i = parseSpecifier(d, specifier, string += "", 0),
              week, day;
          if (i != string.length) return null;

          // If a UNIX timestamp is specified, return it.
          if ("Q" in d) return new Date(d.Q);
          if ("s" in d) return new Date(d.s * 1000 + ("L" in d ? d.L : 0));

          // If this is utcParse, never use the local timezone.
          if (Z && !("Z" in d)) d.Z = 0;

          // The am-pm flag is 0 for AM, and 1 for PM.
          if ("p" in d) d.H = d.H % 12 + d.p * 12;

          // If the month was not specified, inherit from the quarter.
          if (d.m === undefined) d.m = "q" in d ? d.q : 0;

          // Convert day-of-week and week-of-year to day-of-year.
          if ("V" in d) {
            if (d.V < 1 || d.V > 53) return null;
            if (!("w" in d)) d.w = 1;
            if ("Z" in d) {
              week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
              week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
              week = utcDay$1.offset(week, (d.V - 1) * 7);
              d.y = week.getUTCFullYear();
              d.m = week.getUTCMonth();
              d.d = week.getUTCDate() + (d.w + 6) % 7;
            } else {
              week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
              week = day > 4 || day === 0 ? monday.ceil(week) : monday(week);
              week = timeDay.offset(week, (d.V - 1) * 7);
              d.y = week.getFullYear();
              d.m = week.getMonth();
              d.d = week.getDate() + (d.w + 6) % 7;
            }
          } else if ("W" in d || "U" in d) {
            if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
            day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
            d.m = 0;
            d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
          }

          // If a time zone is specified, all fields are interpreted as UTC and then
          // offset according to the specified time zone.
          if ("Z" in d) {
            d.H += d.Z / 100 | 0;
            d.M += d.Z % 100;
            return utcDate(d);
          }

          // Otherwise, all fields are in local time.
          return localDate(d);
        };
      }

      function parseSpecifier(d, specifier, string, j) {
        var i = 0,
            n = specifier.length,
            m = string.length,
            c,
            parse;

        while (i < n) {
          if (j >= m) return -1;
          c = specifier.charCodeAt(i++);
          if (c === 37) {
            c = specifier.charAt(i++);
            parse = parses[c in pads ? specifier.charAt(i++) : c];
            if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
          } else if (c != string.charCodeAt(j++)) {
            return -1;
          }
        }

        return j;
      }

      function parsePeriod(d, string, i) {
        var n = periodRe.exec(string.slice(i));
        return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
      }

      function parseShortWeekday(d, string, i) {
        var n = shortWeekdayRe.exec(string.slice(i));
        return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
      }

      function parseWeekday(d, string, i) {
        var n = weekdayRe.exec(string.slice(i));
        return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
      }

      function parseShortMonth(d, string, i) {
        var n = shortMonthRe.exec(string.slice(i));
        return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
      }

      function parseMonth(d, string, i) {
        var n = monthRe.exec(string.slice(i));
        return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
      }

      function parseLocaleDateTime(d, string, i) {
        return parseSpecifier(d, locale_dateTime, string, i);
      }

      function parseLocaleDate(d, string, i) {
        return parseSpecifier(d, locale_date, string, i);
      }

      function parseLocaleTime(d, string, i) {
        return parseSpecifier(d, locale_time, string, i);
      }

      function formatShortWeekday(d) {
        return locale_shortWeekdays[d.getDay()];
      }

      function formatWeekday(d) {
        return locale_weekdays[d.getDay()];
      }

      function formatShortMonth(d) {
        return locale_shortMonths[d.getMonth()];
      }

      function formatMonth(d) {
        return locale_months[d.getMonth()];
      }

      function formatPeriod(d) {
        return locale_periods[+(d.getHours() >= 12)];
      }

      function formatQuarter(d) {
        return 1 + ~~(d.getMonth() / 3);
      }

      function formatUTCShortWeekday(d) {
        return locale_shortWeekdays[d.getUTCDay()];
      }

      function formatUTCWeekday(d) {
        return locale_weekdays[d.getUTCDay()];
      }

      function formatUTCShortMonth(d) {
        return locale_shortMonths[d.getUTCMonth()];
      }

      function formatUTCMonth(d) {
        return locale_months[d.getUTCMonth()];
      }

      function formatUTCPeriod(d) {
        return locale_periods[+(d.getUTCHours() >= 12)];
      }

      function formatUTCQuarter(d) {
        return 1 + ~~(d.getUTCMonth() / 3);
      }

      return {
        format: function(specifier) {
          var f = newFormat(specifier += "", formats);
          f.toString = function() { return specifier; };
          return f;
        },
        parse: function(specifier) {
          var p = newParse(specifier += "", false);
          p.toString = function() { return specifier; };
          return p;
        },
        utcFormat: function(specifier) {
          var f = newFormat(specifier += "", utcFormats);
          f.toString = function() { return specifier; };
          return f;
        },
        utcParse: function(specifier) {
          var p = newParse(specifier += "", true);
          p.toString = function() { return specifier; };
          return p;
        }
      };
    }

    var pads = {"-": "", "_": " ", "0": "0"},
        numberRe = /^\s*\d+/, // note: ignores next directive
        percentRe = /^%/,
        requoteRe = /[\\^$*+?|[\]().{}]/g;

    function pad(value, fill, width) {
      var sign = value < 0 ? "-" : "",
          string = (sign ? -value : value) + "",
          length = string.length;
      return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
    }

    function requote(s) {
      return s.replace(requoteRe, "\\$&");
    }

    function formatRe(names) {
      return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
    }

    function formatLookup(names) {
      var map = {}, i = -1, n = names.length;
      while (++i < n) map[names[i].toLowerCase()] = i;
      return map;
    }

    function parseWeekdayNumberSunday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.w = +n[0], i + n[0].length) : -1;
    }

    function parseWeekdayNumberMonday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.u = +n[0], i + n[0].length) : -1;
    }

    function parseWeekNumberSunday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.U = +n[0], i + n[0].length) : -1;
    }

    function parseWeekNumberISO(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.V = +n[0], i + n[0].length) : -1;
    }

    function parseWeekNumberMonday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.W = +n[0], i + n[0].length) : -1;
    }

    function parseFullYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 4));
      return n ? (d.y = +n[0], i + n[0].length) : -1;
    }

    function parseYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
    }

    function parseZone(d, string, i) {
      var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
      return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
    }

    function parseQuarter(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
    }

    function parseMonthNumber(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
    }

    function parseDayOfMonth(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.d = +n[0], i + n[0].length) : -1;
    }

    function parseDayOfYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 3));
      return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
    }

    function parseHour24(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.H = +n[0], i + n[0].length) : -1;
    }

    function parseMinutes(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.M = +n[0], i + n[0].length) : -1;
    }

    function parseSeconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.S = +n[0], i + n[0].length) : -1;
    }

    function parseMilliseconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 3));
      return n ? (d.L = +n[0], i + n[0].length) : -1;
    }

    function parseMicroseconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 6));
      return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
    }

    function parseLiteralPercent(d, string, i) {
      var n = percentRe.exec(string.slice(i, i + 1));
      return n ? i + n[0].length : -1;
    }

    function parseUnixTimestamp(d, string, i) {
      var n = numberRe.exec(string.slice(i));
      return n ? (d.Q = +n[0], i + n[0].length) : -1;
    }

    function parseUnixTimestampSeconds(d, string, i) {
      var n = numberRe.exec(string.slice(i));
      return n ? (d.s = +n[0], i + n[0].length) : -1;
    }

    function formatDayOfMonth(d, p) {
      return pad(d.getDate(), p, 2);
    }

    function formatHour24(d, p) {
      return pad(d.getHours(), p, 2);
    }

    function formatHour12(d, p) {
      return pad(d.getHours() % 12 || 12, p, 2);
    }

    function formatDayOfYear(d, p) {
      return pad(1 + timeDay.count(timeYear(d), d), p, 3);
    }

    function formatMilliseconds(d, p) {
      return pad(d.getMilliseconds(), p, 3);
    }

    function formatMicroseconds(d, p) {
      return formatMilliseconds(d, p) + "000";
    }

    function formatMonthNumber(d, p) {
      return pad(d.getMonth() + 1, p, 2);
    }

    function formatMinutes(d, p) {
      return pad(d.getMinutes(), p, 2);
    }

    function formatSeconds(d, p) {
      return pad(d.getSeconds(), p, 2);
    }

    function formatWeekdayNumberMonday(d) {
      var day = d.getDay();
      return day === 0 ? 7 : day;
    }

    function formatWeekNumberSunday(d, p) {
      return pad(sunday.count(timeYear(d) - 1, d), p, 2);
    }

    function dISO(d) {
      var day = d.getDay();
      return (day >= 4 || day === 0) ? thursday(d) : thursday.ceil(d);
    }

    function formatWeekNumberISO(d, p) {
      d = dISO(d);
      return pad(thursday.count(timeYear(d), d) + (timeYear(d).getDay() === 4), p, 2);
    }

    function formatWeekdayNumberSunday(d) {
      return d.getDay();
    }

    function formatWeekNumberMonday(d, p) {
      return pad(monday.count(timeYear(d) - 1, d), p, 2);
    }

    function formatYear(d, p) {
      return pad(d.getFullYear() % 100, p, 2);
    }

    function formatYearISO(d, p) {
      d = dISO(d);
      return pad(d.getFullYear() % 100, p, 2);
    }

    function formatFullYear(d, p) {
      return pad(d.getFullYear() % 10000, p, 4);
    }

    function formatFullYearISO(d, p) {
      var day = d.getDay();
      d = (day >= 4 || day === 0) ? thursday(d) : thursday.ceil(d);
      return pad(d.getFullYear() % 10000, p, 4);
    }

    function formatZone(d) {
      var z = d.getTimezoneOffset();
      return (z > 0 ? "-" : (z *= -1, "+"))
          + pad(z / 60 | 0, "0", 2)
          + pad(z % 60, "0", 2);
    }

    function formatUTCDayOfMonth(d, p) {
      return pad(d.getUTCDate(), p, 2);
    }

    function formatUTCHour24(d, p) {
      return pad(d.getUTCHours(), p, 2);
    }

    function formatUTCHour12(d, p) {
      return pad(d.getUTCHours() % 12 || 12, p, 2);
    }

    function formatUTCDayOfYear(d, p) {
      return pad(1 + utcDay$1.count(utcYear$1(d), d), p, 3);
    }

    function formatUTCMilliseconds(d, p) {
      return pad(d.getUTCMilliseconds(), p, 3);
    }

    function formatUTCMicroseconds(d, p) {
      return formatUTCMilliseconds(d, p) + "000";
    }

    function formatUTCMonthNumber(d, p) {
      return pad(d.getUTCMonth() + 1, p, 2);
    }

    function formatUTCMinutes(d, p) {
      return pad(d.getUTCMinutes(), p, 2);
    }

    function formatUTCSeconds(d, p) {
      return pad(d.getUTCSeconds(), p, 2);
    }

    function formatUTCWeekdayNumberMonday(d) {
      var dow = d.getUTCDay();
      return dow === 0 ? 7 : dow;
    }

    function formatUTCWeekNumberSunday(d, p) {
      return pad(utcSunday.count(utcYear$1(d) - 1, d), p, 2);
    }

    function UTCdISO(d) {
      var day = d.getUTCDay();
      return (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
    }

    function formatUTCWeekNumberISO(d, p) {
      d = UTCdISO(d);
      return pad(utcThursday.count(utcYear$1(d), d) + (utcYear$1(d).getUTCDay() === 4), p, 2);
    }

    function formatUTCWeekdayNumberSunday(d) {
      return d.getUTCDay();
    }

    function formatUTCWeekNumberMonday(d, p) {
      return pad(utcMonday.count(utcYear$1(d) - 1, d), p, 2);
    }

    function formatUTCYear(d, p) {
      return pad(d.getUTCFullYear() % 100, p, 2);
    }

    function formatUTCYearISO(d, p) {
      d = UTCdISO(d);
      return pad(d.getUTCFullYear() % 100, p, 2);
    }

    function formatUTCFullYear(d, p) {
      return pad(d.getUTCFullYear() % 10000, p, 4);
    }

    function formatUTCFullYearISO(d, p) {
      var day = d.getUTCDay();
      d = (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
      return pad(d.getUTCFullYear() % 10000, p, 4);
    }

    function formatUTCZone() {
      return "+0000";
    }

    function formatLiteralPercent() {
      return "%";
    }

    function formatUnixTimestamp(d) {
      return +d;
    }

    function formatUnixTimestampSeconds(d) {
      return Math.floor(+d / 1000);
    }

    var locale;
    var timeFormat;
    var timeParse;
    var utcFormat;
    var utcParse;

    defaultLocale({
      dateTime: "%x, %X",
      date: "%-m/%-d/%Y",
      time: "%-I:%M:%S %p",
      periods: ["AM", "PM"],
      days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
      shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
      shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
    });

    function defaultLocale(definition) {
      locale = formatLocale(definition);
      timeFormat = locale.format;
      timeParse = locale.parse;
      utcFormat = locale.utcFormat;
      utcParse = locale.utcParse;
      return locale;
    }

    var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

    function formatIsoNative(date) {
      return date.toISOString();
    }

    var formatIso = Date.prototype.toISOString
        ? formatIsoNative
        : utcFormat(isoSpecifier);

    var formatIso$1 = formatIso;

    function parseIsoNative(string) {
      var date = new Date(string);
      return isNaN(date) ? null : date;
    }

    var parseIso = +new Date("2000-01-01T00:00:00.000Z")
        ? parseIsoNative
        : utcParse(isoSpecifier);

    var parseIso$1 = parseIso;

    var durationSecond = 1000,
        durationMinute = durationSecond * 60,
        durationHour = durationMinute * 60,
        durationDay = durationHour * 24,
        durationWeek = durationDay * 7,
        durationMonth = durationDay * 30,
        durationYear = durationDay * 365;

    function date(t) {
      return new Date(t);
    }

    function number(t) {
      return t instanceof Date ? +t : +new Date(+t);
    }

    function calendar(year, month, week, day, hour, minute, second, millisecond, format) {
      var scale = continuous(identity$3, identity$3),
          invert = scale.invert,
          domain = scale.domain;

      var formatMillisecond = format(".%L"),
          formatSecond = format(":%S"),
          formatMinute = format("%I:%M"),
          formatHour = format("%I %p"),
          formatDay = format("%a %d"),
          formatWeek = format("%b %d"),
          formatMonth = format("%B"),
          formatYear = format("%Y");

      var tickIntervals = [
        [second,  1,      durationSecond],
        [second,  5,  5 * durationSecond],
        [second, 15, 15 * durationSecond],
        [second, 30, 30 * durationSecond],
        [minute,  1,      durationMinute],
        [minute,  5,  5 * durationMinute],
        [minute, 15, 15 * durationMinute],
        [minute, 30, 30 * durationMinute],
        [  hour,  1,      durationHour  ],
        [  hour,  3,  3 * durationHour  ],
        [  hour,  6,  6 * durationHour  ],
        [  hour, 12, 12 * durationHour  ],
        [   day,  1,      durationDay   ],
        [   day,  2,  2 * durationDay   ],
        [  week,  1,      durationWeek  ],
        [ month,  1,      durationMonth ],
        [ month,  3,  3 * durationMonth ],
        [  year,  1,      durationYear  ]
      ];

      function tickFormat(date) {
        return (second(date) < date ? formatMillisecond
            : minute(date) < date ? formatSecond
            : hour(date) < date ? formatMinute
            : day(date) < date ? formatHour
            : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
            : year(date) < date ? formatMonth
            : formatYear)(date);
      }

      function tickInterval(interval, start, stop, step) {
        if (interval == null) interval = 10;

        // If a desired tick count is specified, pick a reasonable tick interval
        // based on the extent of the domain and a rough estimate of tick size.
        // Otherwise, assume interval is already a time interval and use it.
        if (typeof interval === "number") {
          var target = Math.abs(stop - start) / interval,
              i = bisector(function(i) { return i[2]; }).right(tickIntervals, target);
          if (i === tickIntervals.length) {
            step = tickStep(start / durationYear, stop / durationYear, interval);
            interval = year;
          } else if (i) {
            i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
            step = i[1];
            interval = i[0];
          } else {
            step = Math.max(tickStep(start, stop, interval), 1);
            interval = millisecond;
          }
        }

        return step == null ? interval : interval.every(step);
      }

      scale.invert = function(y) {
        return new Date(invert(y));
      };

      scale.domain = function(_) {
        return arguments.length ? domain(map.call(_, number)) : domain().map(date);
      };

      scale.ticks = function(interval, step) {
        var d = domain(),
            t0 = d[0],
            t1 = d[d.length - 1],
            r = t1 < t0,
            t;
        if (r) t = t0, t0 = t1, t1 = t;
        t = tickInterval(interval, t0, t1, step);
        t = t ? t.range(t0, t1 + 1) : []; // inclusive stop
        return r ? t.reverse() : t;
      };

      scale.tickFormat = function(count, specifier) {
        return specifier == null ? tickFormat : format(specifier);
      };

      scale.nice = function(interval, step) {
        var d = domain();
        return (interval = tickInterval(interval, d[0], d[d.length - 1], step))
            ? domain(nice(d, interval))
            : scale;
      };

      scale.copy = function() {
        return copy$1(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format));
      };

      return scale;
    }

    function time() {
      return initRange.apply(calendar(timeYear, timeMonth, sunday, timeDay, timeHour, timeMinute, utcSecond, utcMillisecond, timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]), arguments);
    }

    function utcTime() {
      return initRange.apply(calendar(utcYear$1, utcMonth$1, utcSunday, utcDay$1, utcHour$1, utcMinute$1, utcSecond, utcMillisecond, utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]), arguments);
    }

    function transformer$1() {
      var x0 = 0,
          x1 = 1,
          t0,
          t1,
          k10,
          transform,
          interpolator = identity$3,
          clamp = false,
          unknown;

      function scale(x) {
        return isNaN(x = +x) ? unknown : interpolator(k10 === 0 ? 0.5 : (x = (transform(x) - t0) * k10, clamp ? Math.max(0, Math.min(1, x)) : x));
      }

      scale.domain = function(_) {
        return arguments.length ? (t0 = transform(x0 = +_[0]), t1 = transform(x1 = +_[1]), k10 = t0 === t1 ? 0 : 1 / (t1 - t0), scale) : [x0, x1];
      };

      scale.clamp = function(_) {
        return arguments.length ? (clamp = !!_, scale) : clamp;
      };

      scale.interpolator = function(_) {
        return arguments.length ? (interpolator = _, scale) : interpolator;
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      return function(t) {
        transform = t, t0 = t(x0), t1 = t(x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0);
        return scale;
      };
    }

    function copy(source, target) {
      return target
          .domain(source.domain())
          .interpolator(source.interpolator())
          .clamp(source.clamp())
          .unknown(source.unknown());
    }

    function sequential() {
      var scale = linearish(transformer$1()(identity$3));

      scale.copy = function() {
        return copy(scale, sequential());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function sequentialLog() {
      var scale = loggish(transformer$1()).domain([1, 10]);

      scale.copy = function() {
        return copy(scale, sequentialLog()).base(scale.base());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function sequentialSymlog() {
      var scale = symlogish(transformer$1());

      scale.copy = function() {
        return copy(scale, sequentialSymlog()).constant(scale.constant());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function sequentialPow() {
      var scale = powish(transformer$1());

      scale.copy = function() {
        return copy(scale, sequentialPow()).exponent(scale.exponent());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function sequentialSqrt() {
      return sequentialPow.apply(null, arguments).exponent(0.5);
    }

    function sequentialQuantile() {
      var domain = [],
          interpolator = identity$3;

      function scale(x) {
        if (!isNaN(x = +x)) return interpolator((bisectRight(domain, x) - 1) / (domain.length - 1));
      }

      scale.domain = function(_) {
        if (!arguments.length) return domain.slice();
        domain = [];
        for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);
        domain.sort(ascending$3);
        return scale;
      };

      scale.interpolator = function(_) {
        return arguments.length ? (interpolator = _, scale) : interpolator;
      };

      scale.copy = function() {
        return sequentialQuantile(interpolator).domain(domain);
      };

      return initInterpolator.apply(scale, arguments);
    }

    function transformer() {
      var x0 = 0,
          x1 = 0.5,
          x2 = 1,
          t0,
          t1,
          t2,
          k10,
          k21,
          interpolator = identity$3,
          transform,
          clamp = false,
          unknown;

      function scale(x) {
        return isNaN(x = +x) ? unknown : (x = 0.5 + ((x = +transform(x)) - t1) * (x < t1 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x)) : x));
      }

      scale.domain = function(_) {
        return arguments.length ? (t0 = transform(x0 = +_[0]), t1 = transform(x1 = +_[1]), t2 = transform(x2 = +_[2]), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), scale) : [x0, x1, x2];
      };

      scale.clamp = function(_) {
        return arguments.length ? (clamp = !!_, scale) : clamp;
      };

      scale.interpolator = function(_) {
        return arguments.length ? (interpolator = _, scale) : interpolator;
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      return function(t) {
        transform = t, t0 = t(x0), t1 = t(x1), t2 = t(x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1);
        return scale;
      };
    }

    function diverging$1() {
      var scale = linearish(transformer()(identity$3));

      scale.copy = function() {
        return copy(scale, diverging$1());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function divergingLog() {
      var scale = loggish(transformer()).domain([0.1, 1, 10]);

      scale.copy = function() {
        return copy(scale, divergingLog()).base(scale.base());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function divergingSymlog() {
      var scale = symlogish(transformer());

      scale.copy = function() {
        return copy(scale, divergingSymlog()).constant(scale.constant());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function divergingPow() {
      var scale = powish(transformer());

      scale.copy = function() {
        return copy(scale, divergingPow()).exponent(scale.exponent());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function divergingSqrt() {
      return divergingPow.apply(null, arguments).exponent(0.5);
    }

    function colors(specifier) {
      var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
      while (i < n) colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
      return colors;
    }

    var category10 = colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

    var Accent = colors("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");

    var Dark2 = colors("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");

    var Paired = colors("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");

    var Pastel1 = colors("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");

    var Pastel2 = colors("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");

    var Set1 = colors("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");

    var Set2 = colors("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");

    var Set3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");

    var Tableau10 = colors("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");

    function ramp$1(scheme) {
      return rgbBasis(scheme[scheme.length - 1]);
    }

    var scheme$q = new Array(3).concat(
      "d8b365f5f5f55ab4ac",
      "a6611adfc27d80cdc1018571",
      "a6611adfc27df5f5f580cdc1018571",
      "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
      "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
      "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
      "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
      "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
      "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
    ).map(colors);

    var BrBG = ramp$1(scheme$q);

    var scheme$p = new Array(3).concat(
      "af8dc3f7f7f77fbf7b",
      "7b3294c2a5cfa6dba0008837",
      "7b3294c2a5cff7f7f7a6dba0008837",
      "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
      "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
      "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
      "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
      "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
      "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
    ).map(colors);

    var PRGn = ramp$1(scheme$p);

    var scheme$o = new Array(3).concat(
      "e9a3c9f7f7f7a1d76a",
      "d01c8bf1b6dab8e1864dac26",
      "d01c8bf1b6daf7f7f7b8e1864dac26",
      "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
      "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
      "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
      "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
      "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
      "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
    ).map(colors);

    var PiYG = ramp$1(scheme$o);

    var scheme$n = new Array(3).concat(
      "998ec3f7f7f7f1a340",
      "5e3c99b2abd2fdb863e66101",
      "5e3c99b2abd2f7f7f7fdb863e66101",
      "542788998ec3d8daebfee0b6f1a340b35806",
      "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
      "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
      "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
      "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
      "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
    ).map(colors);

    var PuOr = ramp$1(scheme$n);

    var scheme$m = new Array(3).concat(
      "ef8a62f7f7f767a9cf",
      "ca0020f4a58292c5de0571b0",
      "ca0020f4a582f7f7f792c5de0571b0",
      "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
      "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
      "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
      "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
      "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
      "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
    ).map(colors);

    var RdBu = ramp$1(scheme$m);

    var scheme$l = new Array(3).concat(
      "ef8a62ffffff999999",
      "ca0020f4a582bababa404040",
      "ca0020f4a582ffffffbababa404040",
      "b2182bef8a62fddbc7e0e0e09999994d4d4d",
      "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
      "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
      "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
      "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
      "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
    ).map(colors);

    var RdGy = ramp$1(scheme$l);

    var scheme$k = new Array(3).concat(
      "fc8d59ffffbf91bfdb",
      "d7191cfdae61abd9e92c7bb6",
      "d7191cfdae61ffffbfabd9e92c7bb6",
      "d73027fc8d59fee090e0f3f891bfdb4575b4",
      "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
      "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
      "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
      "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
      "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
    ).map(colors);

    var RdYlBu = ramp$1(scheme$k);

    var scheme$j = new Array(3).concat(
      "fc8d59ffffbf91cf60",
      "d7191cfdae61a6d96a1a9641",
      "d7191cfdae61ffffbfa6d96a1a9641",
      "d73027fc8d59fee08bd9ef8b91cf601a9850",
      "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
      "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
      "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
      "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
      "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
    ).map(colors);

    var RdYlGn = ramp$1(scheme$j);

    var scheme$i = new Array(3).concat(
      "fc8d59ffffbf99d594",
      "d7191cfdae61abdda42b83ba",
      "d7191cfdae61ffffbfabdda42b83ba",
      "d53e4ffc8d59fee08be6f59899d5943288bd",
      "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
      "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
      "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
      "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
      "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
    ).map(colors);

    var Spectral = ramp$1(scheme$i);

    var scheme$h = new Array(3).concat(
      "e5f5f999d8c92ca25f",
      "edf8fbb2e2e266c2a4238b45",
      "edf8fbb2e2e266c2a42ca25f006d2c",
      "edf8fbccece699d8c966c2a42ca25f006d2c",
      "edf8fbccece699d8c966c2a441ae76238b45005824",
      "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
      "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
    ).map(colors);

    var BuGn = ramp$1(scheme$h);

    var scheme$g = new Array(3).concat(
      "e0ecf49ebcda8856a7",
      "edf8fbb3cde38c96c688419d",
      "edf8fbb3cde38c96c68856a7810f7c",
      "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
      "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
      "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
      "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
    ).map(colors);

    var BuPu = ramp$1(scheme$g);

    var scheme$f = new Array(3).concat(
      "e0f3dba8ddb543a2ca",
      "f0f9e8bae4bc7bccc42b8cbe",
      "f0f9e8bae4bc7bccc443a2ca0868ac",
      "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
      "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
      "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
      "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
    ).map(colors);

    var GnBu = ramp$1(scheme$f);

    var scheme$e = new Array(3).concat(
      "fee8c8fdbb84e34a33",
      "fef0d9fdcc8afc8d59d7301f",
      "fef0d9fdcc8afc8d59e34a33b30000",
      "fef0d9fdd49efdbb84fc8d59e34a33b30000",
      "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
      "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
      "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
    ).map(colors);

    var OrRd = ramp$1(scheme$e);

    var scheme$d = new Array(3).concat(
      "ece2f0a6bddb1c9099",
      "f6eff7bdc9e167a9cf02818a",
      "f6eff7bdc9e167a9cf1c9099016c59",
      "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
      "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
      "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
      "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
    ).map(colors);

    var PuBuGn = ramp$1(scheme$d);

    var scheme$c = new Array(3).concat(
      "ece7f2a6bddb2b8cbe",
      "f1eef6bdc9e174a9cf0570b0",
      "f1eef6bdc9e174a9cf2b8cbe045a8d",
      "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
      "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
      "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
      "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
    ).map(colors);

    var PuBu = ramp$1(scheme$c);

    var scheme$b = new Array(3).concat(
      "e7e1efc994c7dd1c77",
      "f1eef6d7b5d8df65b0ce1256",
      "f1eef6d7b5d8df65b0dd1c77980043",
      "f1eef6d4b9dac994c7df65b0dd1c77980043",
      "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
      "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
      "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
    ).map(colors);

    var PuRd = ramp$1(scheme$b);

    var scheme$a = new Array(3).concat(
      "fde0ddfa9fb5c51b8a",
      "feebe2fbb4b9f768a1ae017e",
      "feebe2fbb4b9f768a1c51b8a7a0177",
      "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
      "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
      "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
      "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
    ).map(colors);

    var RdPu = ramp$1(scheme$a);

    var scheme$9 = new Array(3).concat(
      "edf8b17fcdbb2c7fb8",
      "ffffcca1dab441b6c4225ea8",
      "ffffcca1dab441b6c42c7fb8253494",
      "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
      "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
      "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
      "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
    ).map(colors);

    var YlGnBu = ramp$1(scheme$9);

    var scheme$8 = new Array(3).concat(
      "f7fcb9addd8e31a354",
      "ffffccc2e69978c679238443",
      "ffffccc2e69978c67931a354006837",
      "ffffccd9f0a3addd8e78c67931a354006837",
      "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
      "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
      "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
    ).map(colors);

    var YlGn = ramp$1(scheme$8);

    var scheme$7 = new Array(3).concat(
      "fff7bcfec44fd95f0e",
      "ffffd4fed98efe9929cc4c02",
      "ffffd4fed98efe9929d95f0e993404",
      "ffffd4fee391fec44ffe9929d95f0e993404",
      "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
      "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
      "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
    ).map(colors);

    var YlOrBr = ramp$1(scheme$7);

    var scheme$6 = new Array(3).concat(
      "ffeda0feb24cf03b20",
      "ffffb2fecc5cfd8d3ce31a1c",
      "ffffb2fecc5cfd8d3cf03b20bd0026",
      "ffffb2fed976feb24cfd8d3cf03b20bd0026",
      "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
      "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
      "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
    ).map(colors);

    var YlOrRd = ramp$1(scheme$6);

    var scheme$5 = new Array(3).concat(
      "deebf79ecae13182bd",
      "eff3ffbdd7e76baed62171b5",
      "eff3ffbdd7e76baed63182bd08519c",
      "eff3ffc6dbef9ecae16baed63182bd08519c",
      "eff3ffc6dbef9ecae16baed64292c62171b5084594",
      "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
      "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
    ).map(colors);

    var Blues = ramp$1(scheme$5);

    var scheme$4 = new Array(3).concat(
      "e5f5e0a1d99b31a354",
      "edf8e9bae4b374c476238b45",
      "edf8e9bae4b374c47631a354006d2c",
      "edf8e9c7e9c0a1d99b74c47631a354006d2c",
      "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
      "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
      "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
    ).map(colors);

    var Greens = ramp$1(scheme$4);

    var scheme$3 = new Array(3).concat(
      "f0f0f0bdbdbd636363",
      "f7f7f7cccccc969696525252",
      "f7f7f7cccccc969696636363252525",
      "f7f7f7d9d9d9bdbdbd969696636363252525",
      "f7f7f7d9d9d9bdbdbd969696737373525252252525",
      "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
      "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
    ).map(colors);

    var Greys = ramp$1(scheme$3);

    var scheme$2 = new Array(3).concat(
      "efedf5bcbddc756bb1",
      "f2f0f7cbc9e29e9ac86a51a3",
      "f2f0f7cbc9e29e9ac8756bb154278f",
      "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
      "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
      "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
      "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
    ).map(colors);

    var Purples = ramp$1(scheme$2);

    var scheme$1 = new Array(3).concat(
      "fee0d2fc9272de2d26",
      "fee5d9fcae91fb6a4acb181d",
      "fee5d9fcae91fb6a4ade2d26a50f15",
      "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
      "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
      "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
      "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
    ).map(colors);

    var Reds = ramp$1(scheme$1);

    var scheme = new Array(3).concat(
      "fee6cefdae6be6550d",
      "feeddefdbe85fd8d3cd94701",
      "feeddefdbe85fd8d3ce6550da63603",
      "feeddefdd0a2fdae6bfd8d3ce6550da63603",
      "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
      "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
      "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
    ).map(colors);

    var Oranges = ramp$1(scheme);

    function cividis(t) {
      t = Math.max(0, Math.min(1, t));
      return "rgb("
          + Math.max(0, Math.min(255, Math.round(-4.54 - t * (35.34 - t * (2381.73 - t * (6402.7 - t * (7024.72 - t * 2710.57))))))) + ", "
          + Math.max(0, Math.min(255, Math.round(32.49 + t * (170.73 + t * (52.82 - t * (131.46 - t * (176.58 - t * 67.37))))))) + ", "
          + Math.max(0, Math.min(255, Math.round(81.24 + t * (442.36 - t * (2482.43 - t * (6167.24 - t * (6614.94 - t * 2475.67)))))))
          + ")";
    }

    var cubehelix = cubehelixLong(cubehelix$3(300, 0.5, 0.0), cubehelix$3(-240, 0.5, 1.0));

    var warm = cubehelixLong(cubehelix$3(-100, 0.75, 0.35), cubehelix$3(80, 1.50, 0.8));

    var cool = cubehelixLong(cubehelix$3(260, 0.75, 0.35), cubehelix$3(80, 1.50, 0.8));

    var c$2 = cubehelix$3();

    function rainbow(t) {
      if (t < 0 || t > 1) t -= Math.floor(t);
      var ts = Math.abs(t - 0.5);
      c$2.h = 360 * t - 100;
      c$2.s = 1.5 - 1.5 * ts;
      c$2.l = 0.8 - 0.9 * ts;
      return c$2 + "";
    }

    var c$1 = rgb(),
        pi_1_3 = Math.PI / 3,
        pi_2_3 = Math.PI * 2 / 3;

    function sinebow(t) {
      var x;
      t = (0.5 - t) * Math.PI;
      c$1.r = 255 * (x = Math.sin(t)) * x;
      c$1.g = 255 * (x = Math.sin(t + pi_1_3)) * x;
      c$1.b = 255 * (x = Math.sin(t + pi_2_3)) * x;
      return c$1 + "";
    }

    function turbo(t) {
      t = Math.max(0, Math.min(1, t));
      return "rgb("
          + Math.max(0, Math.min(255, Math.round(34.61 + t * (1172.33 - t * (10793.56 - t * (33300.12 - t * (38394.49 - t * 14825.05))))))) + ", "
          + Math.max(0, Math.min(255, Math.round(23.31 + t * (557.33 + t * (1225.33 - t * (3574.96 - t * (1073.77 + t * 707.56))))))) + ", "
          + Math.max(0, Math.min(255, Math.round(27.2 + t * (3211.1 - t * (15327.97 - t * (27814 - t * (22569.18 - t * 6838.66)))))))
          + ")";
    }

    function ramp(range) {
      var n = range.length;
      return function(t) {
        return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
      };
    }

    var viridis = ramp(colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));

    var magma = ramp(colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));

    var inferno = ramp(colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));

    var plasma = ramp(colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

    function constant$2(x) {
      return function constant() {
        return x;
      };
    }

    var abs = Math.abs;
    var atan2 = Math.atan2;
    var cos = Math.cos;
    var max = Math.max;
    var min = Math.min;
    var sin = Math.sin;
    var sqrt = Math.sqrt;

    var epsilon$1 = 1e-12;
    var pi = Math.PI;
    var halfPi = pi / 2;
    var tau = 2 * pi;

    function acos(x) {
      return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
    }

    function asin(x) {
      return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);
    }

    function arcInnerRadius(d) {
      return d.innerRadius;
    }

    function arcOuterRadius(d) {
      return d.outerRadius;
    }

    function arcStartAngle(d) {
      return d.startAngle;
    }

    function arcEndAngle(d) {
      return d.endAngle;
    }

    function arcPadAngle(d) {
      return d && d.padAngle; // Note: optional!
    }

    function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
      var x10 = x1 - x0, y10 = y1 - y0,
          x32 = x3 - x2, y32 = y3 - y2,
          t = y32 * x10 - x32 * y10;
      if (t * t < epsilon$1) return;
      t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
      return [x0 + t * x10, y0 + t * y10];
    }

    // Compute perpendicular offset line of length rc.
    // http://mathworld.wolfram.com/Circle-LineIntersection.html
    function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
      var x01 = x0 - x1,
          y01 = y0 - y1,
          lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01),
          ox = lo * y01,
          oy = -lo * x01,
          x11 = x0 + ox,
          y11 = y0 + oy,
          x10 = x1 + ox,
          y10 = y1 + oy,
          x00 = (x11 + x10) / 2,
          y00 = (y11 + y10) / 2,
          dx = x10 - x11,
          dy = y10 - y11,
          d2 = dx * dx + dy * dy,
          r = r1 - rc,
          D = x11 * y10 - x10 * y11,
          d = (dy < 0 ? -1 : 1) * sqrt(max(0, r * r * d2 - D * D)),
          cx0 = (D * dy - dx * d) / d2,
          cy0 = (-D * dx - dy * d) / d2,
          cx1 = (D * dy + dx * d) / d2,
          cy1 = (-D * dx + dy * d) / d2,
          dx0 = cx0 - x00,
          dy0 = cy0 - y00,
          dx1 = cx1 - x00,
          dy1 = cy1 - y00;

      // Pick the closer of the two intersection points.
      // TODO Is there a faster way to determine which intersection to use?
      if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

      return {
        cx: cx0,
        cy: cy0,
        x01: -ox,
        y01: -oy,
        x11: cx0 * (r1 / r - 1),
        y11: cy0 * (r1 / r - 1)
      };
    }

    function arc() {
      var innerRadius = arcInnerRadius,
          outerRadius = arcOuterRadius,
          cornerRadius = constant$2(0),
          padRadius = null,
          startAngle = arcStartAngle,
          endAngle = arcEndAngle,
          padAngle = arcPadAngle,
          context = null;

      function arc() {
        var buffer,
            r,
            r0 = +innerRadius.apply(this, arguments),
            r1 = +outerRadius.apply(this, arguments),
            a0 = startAngle.apply(this, arguments) - halfPi,
            a1 = endAngle.apply(this, arguments) - halfPi,
            da = abs(a1 - a0),
            cw = a1 > a0;

        if (!context) context = buffer = path();

        // Ensure that the outer radius is always larger than the inner radius.
        if (r1 < r0) r = r1, r1 = r0, r0 = r;

        // Is it a point?
        if (!(r1 > epsilon$1)) context.moveTo(0, 0);

        // Or is it a circle or annulus?
        else if (da > tau - epsilon$1) {
          context.moveTo(r1 * cos(a0), r1 * sin(a0));
          context.arc(0, 0, r1, a0, a1, !cw);
          if (r0 > epsilon$1) {
            context.moveTo(r0 * cos(a1), r0 * sin(a1));
            context.arc(0, 0, r0, a1, a0, cw);
          }
        }

        // Or is it a circular or annular sector?
        else {
          var a01 = a0,
              a11 = a1,
              a00 = a0,
              a10 = a1,
              da0 = da,
              da1 = da,
              ap = padAngle.apply(this, arguments) / 2,
              rp = (ap > epsilon$1) && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)),
              rc = min(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
              rc0 = rc,
              rc1 = rc,
              t0,
              t1;

          // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.
          if (rp > epsilon$1) {
            var p0 = asin(rp / r0 * sin(ap)),
                p1 = asin(rp / r1 * sin(ap));
            if ((da0 -= p0 * 2) > epsilon$1) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
            else da0 = 0, a00 = a10 = (a0 + a1) / 2;
            if ((da1 -= p1 * 2) > epsilon$1) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
            else da1 = 0, a01 = a11 = (a0 + a1) / 2;
          }

          var x01 = r1 * cos(a01),
              y01 = r1 * sin(a01),
              x10 = r0 * cos(a10),
              y10 = r0 * sin(a10);

          // Apply rounded corners?
          if (rc > epsilon$1) {
            var x11 = r1 * cos(a11),
                y11 = r1 * sin(a11),
                x00 = r0 * cos(a00),
                y00 = r0 * sin(a00),
                oc;

            // Restrict the corner radius according to the sector angle.
            if (da < pi && (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10))) {
              var ax = x01 - oc[0],
                  ay = y01 - oc[1],
                  bx = x11 - oc[0],
                  by = y11 - oc[1],
                  kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2),
                  lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
              rc0 = min(rc, (r0 - lc) / (kc - 1));
              rc1 = min(rc, (r1 - lc) / (kc + 1));
            }
          }

          // Is the sector collapsed to a line?
          if (!(da1 > epsilon$1)) context.moveTo(x01, y01);

          // Does the sector’s outer ring have rounded corners?
          else if (rc1 > epsilon$1) {
            t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
            t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

            context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

            // Have the corners merged?
            if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

            // Otherwise, draw the two corners and the ring.
            else {
              context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
              context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
              context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
            }
          }

          // Or is the outer ring just a circular arc?
          else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

          // Is there no inner ring, and it’s a circular sector?
          // Or perhaps it’s an annular sector collapsed due to padding?
          if (!(r0 > epsilon$1) || !(da0 > epsilon$1)) context.lineTo(x10, y10);

          // Does the sector’s inner ring (or point) have rounded corners?
          else if (rc0 > epsilon$1) {
            t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
            t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

            context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

            // Have the corners merged?
            if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

            // Otherwise, draw the two corners and the ring.
            else {
              context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
              context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
              context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
            }
          }

          // Or is the inner ring just a circular arc?
          else context.arc(0, 0, r0, a10, a00, cw);
        }

        context.closePath();

        if (buffer) return context = null, buffer + "" || null;
      }

      arc.centroid = function() {
        var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
            a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;
        return [cos(a) * r, sin(a) * r];
      };

      arc.innerRadius = function(_) {
        return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant$2(+_), arc) : innerRadius;
      };

      arc.outerRadius = function(_) {
        return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant$2(+_), arc) : outerRadius;
      };

      arc.cornerRadius = function(_) {
        return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant$2(+_), arc) : cornerRadius;
      };

      arc.padRadius = function(_) {
        return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant$2(+_), arc) : padRadius;
      };

      arc.startAngle = function(_) {
        return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$2(+_), arc) : startAngle;
      };

      arc.endAngle = function(_) {
        return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$2(+_), arc) : endAngle;
      };

      arc.padAngle = function(_) {
        return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$2(+_), arc) : padAngle;
      };

      arc.context = function(_) {
        return arguments.length ? ((context = _ == null ? null : _), arc) : context;
      };

      return arc;
    }

    function Linear(context) {
      this._context = context;
    }

    Linear.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; // proceed
          default: this._context.lineTo(x, y); break;
        }
      }
    };

    function curveLinear(context) {
      return new Linear(context);
    }

    function x$1(p) {
      return p[0];
    }

    function y$1(p) {
      return p[1];
    }

    function line() {
      var x = x$1,
          y = y$1,
          defined = constant$2(true),
          context = null,
          curve = curveLinear,
          output = null;

      function line(data) {
        var i,
            n = data.length,
            d,
            defined0 = false,
            buffer;

        if (context == null) output = curve(buffer = path());

        for (i = 0; i <= n; ++i) {
          if (!(i < n && defined(d = data[i], i, data)) === defined0) {
            if (defined0 = !defined0) output.lineStart();
            else output.lineEnd();
          }
          if (defined0) output.point(+x(d, i, data), +y(d, i, data));
        }

        if (buffer) return output = null, buffer + "" || null;
      }

      line.x = function(_) {
        return arguments.length ? (x = typeof _ === "function" ? _ : constant$2(+_), line) : x;
      };

      line.y = function(_) {
        return arguments.length ? (y = typeof _ === "function" ? _ : constant$2(+_), line) : y;
      };

      line.defined = function(_) {
        return arguments.length ? (defined = typeof _ === "function" ? _ : constant$2(!!_), line) : defined;
      };

      line.curve = function(_) {
        return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
      };

      line.context = function(_) {
        return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
      };

      return line;
    }

    function area() {
      var x0 = x$1,
          x1 = null,
          y0 = constant$2(0),
          y1 = y$1,
          defined = constant$2(true),
          context = null,
          curve = curveLinear,
          output = null;

      function area(data) {
        var i,
            j,
            k,
            n = data.length,
            d,
            defined0 = false,
            buffer,
            x0z = new Array(n),
            y0z = new Array(n);

        if (context == null) output = curve(buffer = path());

        for (i = 0; i <= n; ++i) {
          if (!(i < n && defined(d = data[i], i, data)) === defined0) {
            if (defined0 = !defined0) {
              j = i;
              output.areaStart();
              output.lineStart();
            } else {
              output.lineEnd();
              output.lineStart();
              for (k = i - 1; k >= j; --k) {
                output.point(x0z[k], y0z[k]);
              }
              output.lineEnd();
              output.areaEnd();
            }
          }
          if (defined0) {
            x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
            output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
          }
        }

        if (buffer) return output = null, buffer + "" || null;
      }

      function arealine() {
        return line().defined(defined).curve(curve).context(context);
      }

      area.x = function(_) {
        return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$2(+_), x1 = null, area) : x0;
      };

      area.x0 = function(_) {
        return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$2(+_), area) : x0;
      };

      area.x1 = function(_) {
        return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant$2(+_), area) : x1;
      };

      area.y = function(_) {
        return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$2(+_), y1 = null, area) : y0;
      };

      area.y0 = function(_) {
        return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$2(+_), area) : y0;
      };

      area.y1 = function(_) {
        return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant$2(+_), area) : y1;
      };

      area.lineX0 =
      area.lineY0 = function() {
        return arealine().x(x0).y(y0);
      };

      area.lineY1 = function() {
        return arealine().x(x0).y(y1);
      };

      area.lineX1 = function() {
        return arealine().x(x1).y(y0);
      };

      area.defined = function(_) {
        return arguments.length ? (defined = typeof _ === "function" ? _ : constant$2(!!_), area) : defined;
      };

      area.curve = function(_) {
        return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
      };

      area.context = function(_) {
        return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
      };

      return area;
    }

    function descending$1(a, b) {
      return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
    }

    function identity$1(d) {
      return d;
    }

    function pie() {
      var value = identity$1,
          sortValues = descending$1,
          sort = null,
          startAngle = constant$2(0),
          endAngle = constant$2(tau),
          padAngle = constant$2(0);

      function pie(data) {
        var i,
            n = data.length,
            j,
            k,
            sum = 0,
            index = new Array(n),
            arcs = new Array(n),
            a0 = +startAngle.apply(this, arguments),
            da = Math.min(tau, Math.max(-tau, endAngle.apply(this, arguments) - a0)),
            a1,
            p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
            pa = p * (da < 0 ? -1 : 1),
            v;

        for (i = 0; i < n; ++i) {
          if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
            sum += v;
          }
        }

        // Optionally sort the arcs by previously-computed values or by data.
        if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });
        else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });

        // Compute the arcs! They are stored in the original data's order.
        for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
          j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
            data: data[j],
            index: i,
            value: v,
            startAngle: a0,
            endAngle: a1,
            padAngle: p
          };
        }

        return arcs;
      }

      pie.value = function(_) {
        return arguments.length ? (value = typeof _ === "function" ? _ : constant$2(+_), pie) : value;
      };

      pie.sortValues = function(_) {
        return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
      };

      pie.sort = function(_) {
        return arguments.length ? (sort = _, sortValues = null, pie) : sort;
      };

      pie.startAngle = function(_) {
        return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$2(+_), pie) : startAngle;
      };

      pie.endAngle = function(_) {
        return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$2(+_), pie) : endAngle;
      };

      pie.padAngle = function(_) {
        return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$2(+_), pie) : padAngle;
      };

      return pie;
    }

    var curveRadialLinear = curveRadial$1(curveLinear);

    function Radial(curve) {
      this._curve = curve;
    }

    Radial.prototype = {
      areaStart: function() {
        this._curve.areaStart();
      },
      areaEnd: function() {
        this._curve.areaEnd();
      },
      lineStart: function() {
        this._curve.lineStart();
      },
      lineEnd: function() {
        this._curve.lineEnd();
      },
      point: function(a, r) {
        this._curve.point(r * Math.sin(a), r * -Math.cos(a));
      }
    };

    function curveRadial$1(curve) {

      function radial(context) {
        return new Radial(curve(context));
      }

      radial._curve = curve;

      return radial;
    }

    function lineRadial(l) {
      var c = l.curve;

      l.angle = l.x, delete l.x;
      l.radius = l.y, delete l.y;

      l.curve = function(_) {
        return arguments.length ? c(curveRadial$1(_)) : c()._curve;
      };

      return l;
    }

    function lineRadial$1() {
      return lineRadial(line().curve(curveRadialLinear));
    }

    function areaRadial() {
      var a = area().curve(curveRadialLinear),
          c = a.curve,
          x0 = a.lineX0,
          x1 = a.lineX1,
          y0 = a.lineY0,
          y1 = a.lineY1;

      a.angle = a.x, delete a.x;
      a.startAngle = a.x0, delete a.x0;
      a.endAngle = a.x1, delete a.x1;
      a.radius = a.y, delete a.y;
      a.innerRadius = a.y0, delete a.y0;
      a.outerRadius = a.y1, delete a.y1;
      a.lineStartAngle = function() { return lineRadial(x0()); }, delete a.lineX0;
      a.lineEndAngle = function() { return lineRadial(x1()); }, delete a.lineX1;
      a.lineInnerRadius = function() { return lineRadial(y0()); }, delete a.lineY0;
      a.lineOuterRadius = function() { return lineRadial(y1()); }, delete a.lineY1;

      a.curve = function(_) {
        return arguments.length ? c(curveRadial$1(_)) : c()._curve;
      };

      return a;
    }

    function pointRadial(x, y) {
      return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
    }

    var slice = Array.prototype.slice;

    function linkSource(d) {
      return d.source;
    }

    function linkTarget(d) {
      return d.target;
    }

    function link(curve) {
      var source = linkSource,
          target = linkTarget,
          x = x$1,
          y = y$1,
          context = null;

      function link() {
        var buffer, argv = slice.call(arguments), s = source.apply(this, argv), t = target.apply(this, argv);
        if (!context) context = buffer = path();
        curve(context, +x.apply(this, (argv[0] = s, argv)), +y.apply(this, argv), +x.apply(this, (argv[0] = t, argv)), +y.apply(this, argv));
        if (buffer) return context = null, buffer + "" || null;
      }

      link.source = function(_) {
        return arguments.length ? (source = _, link) : source;
      };

      link.target = function(_) {
        return arguments.length ? (target = _, link) : target;
      };

      link.x = function(_) {
        return arguments.length ? (x = typeof _ === "function" ? _ : constant$2(+_), link) : x;
      };

      link.y = function(_) {
        return arguments.length ? (y = typeof _ === "function" ? _ : constant$2(+_), link) : y;
      };

      link.context = function(_) {
        return arguments.length ? ((context = _ == null ? null : _), link) : context;
      };

      return link;
    }

    function curveHorizontal(context, x0, y0, x1, y1) {
      context.moveTo(x0, y0);
      context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);
    }

    function curveVertical(context, x0, y0, x1, y1) {
      context.moveTo(x0, y0);
      context.bezierCurveTo(x0, y0 = (y0 + y1) / 2, x1, y0, x1, y1);
    }

    function curveRadial(context, x0, y0, x1, y1) {
      var p0 = pointRadial(x0, y0),
          p1 = pointRadial(x0, y0 = (y0 + y1) / 2),
          p2 = pointRadial(x1, y0),
          p3 = pointRadial(x1, y1);
      context.moveTo(p0[0], p0[1]);
      context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
    }

    function linkHorizontal() {
      return link(curveHorizontal);
    }

    function linkVertical() {
      return link(curveVertical);
    }

    function linkRadial() {
      var l = link(curveRadial);
      l.angle = l.x, delete l.x;
      l.radius = l.y, delete l.y;
      return l;
    }

    var circle = {
      draw: function(context, size) {
        var r = Math.sqrt(size / pi);
        context.moveTo(r, 0);
        context.arc(0, 0, r, 0, tau);
      }
    };

    var cross = {
      draw: function(context, size) {
        var r = Math.sqrt(size / 5) / 2;
        context.moveTo(-3 * r, -r);
        context.lineTo(-r, -r);
        context.lineTo(-r, -3 * r);
        context.lineTo(r, -3 * r);
        context.lineTo(r, -r);
        context.lineTo(3 * r, -r);
        context.lineTo(3 * r, r);
        context.lineTo(r, r);
        context.lineTo(r, 3 * r);
        context.lineTo(-r, 3 * r);
        context.lineTo(-r, r);
        context.lineTo(-3 * r, r);
        context.closePath();
      }
    };

    var tan30 = Math.sqrt(1 / 3),
        tan30_2 = tan30 * 2;

    var diamond = {
      draw: function(context, size) {
        var y = Math.sqrt(size / tan30_2),
            x = y * tan30;
        context.moveTo(0, -y);
        context.lineTo(x, 0);
        context.lineTo(0, y);
        context.lineTo(-x, 0);
        context.closePath();
      }
    };

    var ka = 0.89081309152928522810,
        kr = Math.sin(pi / 10) / Math.sin(7 * pi / 10),
        kx = Math.sin(tau / 10) * kr,
        ky = -Math.cos(tau / 10) * kr;

    var star = {
      draw: function(context, size) {
        var r = Math.sqrt(size * ka),
            x = kx * r,
            y = ky * r;
        context.moveTo(0, -r);
        context.lineTo(x, y);
        for (var i = 1; i < 5; ++i) {
          var a = tau * i / 5,
              c = Math.cos(a),
              s = Math.sin(a);
          context.lineTo(s * r, -c * r);
          context.lineTo(c * x - s * y, s * x + c * y);
        }
        context.closePath();
      }
    };

    var square = {
      draw: function(context, size) {
        var w = Math.sqrt(size),
            x = -w / 2;
        context.rect(x, x, w, w);
      }
    };

    var sqrt3 = Math.sqrt(3);

    var triangle = {
      draw: function(context, size) {
        var y = -Math.sqrt(size / (sqrt3 * 3));
        context.moveTo(0, y * 2);
        context.lineTo(-sqrt3 * y, -y);
        context.lineTo(sqrt3 * y, -y);
        context.closePath();
      }
    };

    var c = -0.5,
        s = Math.sqrt(3) / 2,
        k = 1 / Math.sqrt(12),
        a = (k / 2 + 1) * 3;

    var wye = {
      draw: function(context, size) {
        var r = Math.sqrt(size / a),
            x0 = r / 2,
            y0 = r * k,
            x1 = x0,
            y1 = r * k + r,
            x2 = -x1,
            y2 = y1;
        context.moveTo(x0, y0);
        context.lineTo(x1, y1);
        context.lineTo(x2, y2);
        context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
        context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
        context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
        context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
        context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
        context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
        context.closePath();
      }
    };

    var symbols = [
      circle,
      cross,
      diamond,
      square,
      star,
      triangle,
      wye
    ];

    function symbol() {
      var type = constant$2(circle),
          size = constant$2(64),
          context = null;

      function symbol() {
        var buffer;
        if (!context) context = buffer = path();
        type.apply(this, arguments).draw(context, +size.apply(this, arguments));
        if (buffer) return context = null, buffer + "" || null;
      }

      symbol.type = function(_) {
        return arguments.length ? (type = typeof _ === "function" ? _ : constant$2(_), symbol) : type;
      };

      symbol.size = function(_) {
        return arguments.length ? (size = typeof _ === "function" ? _ : constant$2(+_), symbol) : size;
      };

      symbol.context = function(_) {
        return arguments.length ? (context = _ == null ? null : _, symbol) : context;
      };

      return symbol;
    }

    function noop() {}

    function point$3(that, x, y) {
      that._context.bezierCurveTo(
        (2 * that._x0 + that._x1) / 3,
        (2 * that._y0 + that._y1) / 3,
        (that._x0 + 2 * that._x1) / 3,
        (that._y0 + 2 * that._y1) / 3,
        (that._x0 + 4 * that._x1 + x) / 6,
        (that._y0 + 4 * that._y1 + y) / 6
      );
    }

    function Basis(context) {
      this._context = context;
    }

    Basis.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 =
        this._y0 = this._y1 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 3: point$3(this, this._x1, this._y1); // proceed
          case 2: this._context.lineTo(this._x1, this._y1); break;
        }
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed
          default: point$3(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
      }
    };

    function basis(context) {
      return new Basis(context);
    }

    function BasisClosed(context) {
      this._context = context;
    }

    BasisClosed.prototype = {
      areaStart: noop,
      areaEnd: noop,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =
        this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x2, this._y2);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
            this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x2, this._y2);
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            break;
          }
        }
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._x2 = x, this._y2 = y; break;
          case 1: this._point = 2; this._x3 = x, this._y3 = y; break;
          case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;
          default: point$3(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
      }
    };

    function basisClosed(context) {
      return new BasisClosed(context);
    }

    function BasisOpen(context) {
      this._context = context;
    }

    BasisOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 =
        this._y0 = this._y1 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;
          case 3: this._point = 4; // proceed
          default: point$3(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
      }
    };

    function basisOpen(context) {
      return new BasisOpen(context);
    }

    function Bundle(context, beta) {
      this._basis = new Basis(context);
      this._beta = beta;
    }

    Bundle.prototype = {
      lineStart: function() {
        this._x = [];
        this._y = [];
        this._basis.lineStart();
      },
      lineEnd: function() {
        var x = this._x,
            y = this._y,
            j = x.length - 1;

        if (j > 0) {
          var x0 = x[0],
              y0 = y[0],
              dx = x[j] - x0,
              dy = y[j] - y0,
              i = -1,
              t;

          while (++i <= j) {
            t = i / j;
            this._basis.point(
              this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),
              this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)
            );
          }
        }

        this._x = this._y = null;
        this._basis.lineEnd();
      },
      point: function(x, y) {
        this._x.push(+x);
        this._y.push(+y);
      }
    };

    var bundle = (function custom(beta) {

      function bundle(context) {
        return beta === 1 ? new Basis(context) : new Bundle(context, beta);
      }

      bundle.beta = function(beta) {
        return custom(+beta);
      };

      return bundle;
    })(0.85);

    function point$2(that, x, y) {
      that._context.bezierCurveTo(
        that._x1 + that._k * (that._x2 - that._x0),
        that._y1 + that._k * (that._y2 - that._y0),
        that._x2 + that._k * (that._x1 - x),
        that._y2 + that._k * (that._y1 - y),
        that._x2,
        that._y2
      );
    }

    function Cardinal(context, tension) {
      this._context = context;
      this._k = (1 - tension) / 6;
    }

    Cardinal.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 =
        this._y0 = this._y1 = this._y2 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2: this._context.lineTo(this._x2, this._y2); break;
          case 3: point$2(this, this._x1, this._y1); break;
        }
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; this._x1 = x, this._y1 = y; break;
          case 2: this._point = 3; // proceed
          default: point$2(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var cardinal = (function custom(tension) {

      function cardinal(context) {
        return new Cardinal(context, tension);
      }

      cardinal.tension = function(tension) {
        return custom(+tension);
      };

      return cardinal;
    })(0);

    function CardinalClosed(context, tension) {
      this._context = context;
      this._k = (1 - tension) / 6;
    }

    CardinalClosed.prototype = {
      areaStart: noop,
      areaEnd: noop,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
        this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.lineTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            this.point(this._x5, this._y5);
            break;
          }
        }
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
          case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
          case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
          default: point$2(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var cardinalClosed = (function custom(tension) {

      function cardinal(context) {
        return new CardinalClosed(context, tension);
      }

      cardinal.tension = function(tension) {
        return custom(+tension);
      };

      return cardinal;
    })(0);

    function CardinalOpen(context, tension) {
      this._context = context;
      this._k = (1 - tension) / 6;
    }

    CardinalOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 =
        this._y0 = this._y1 = this._y2 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
          case 3: this._point = 4; // proceed
          default: point$2(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var cardinalOpen = (function custom(tension) {

      function cardinal(context) {
        return new CardinalOpen(context, tension);
      }

      cardinal.tension = function(tension) {
        return custom(+tension);
      };

      return cardinal;
    })(0);

    function point$1(that, x, y) {
      var x1 = that._x1,
          y1 = that._y1,
          x2 = that._x2,
          y2 = that._y2;

      if (that._l01_a > epsilon$1) {
        var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
            n = 3 * that._l01_a * (that._l01_a + that._l12_a);
        x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
        y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
      }

      if (that._l23_a > epsilon$1) {
        var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
            m = 3 * that._l23_a * (that._l23_a + that._l12_a);
        x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
        y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
      }

      that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
    }

    function CatmullRom(context, alpha) {
      this._context = context;
      this._alpha = alpha;
    }

    CatmullRom.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 =
        this._y0 = this._y1 = this._y2 = NaN;
        this._l01_a = this._l12_a = this._l23_a =
        this._l01_2a = this._l12_2a = this._l23_2a =
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2: this._context.lineTo(this._x2, this._y2); break;
          case 3: this.point(this._x2, this._y2); break;
        }
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;

        if (this._point) {
          var x23 = this._x2 - x,
              y23 = this._y2 - y;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }

        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; // proceed
          default: point$1(this, x, y); break;
        }

        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var catmullRom = (function custom(alpha) {

      function catmullRom(context) {
        return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
      }

      catmullRom.alpha = function(alpha) {
        return custom(+alpha);
      };

      return catmullRom;
    })(0.5);

    function CatmullRomClosed(context, alpha) {
      this._context = context;
      this._alpha = alpha;
    }

    CatmullRomClosed.prototype = {
      areaStart: noop,
      areaEnd: noop,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
        this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
        this._l01_a = this._l12_a = this._l23_a =
        this._l01_2a = this._l12_2a = this._l23_2a =
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.lineTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            this.point(this._x5, this._y5);
            break;
          }
        }
      },
      point: function(x, y) {
        x = +x, y = +y;

        if (this._point) {
          var x23 = this._x2 - x,
              y23 = this._y2 - y;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }

        switch (this._point) {
          case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
          case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
          case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
          default: point$1(this, x, y); break;
        }

        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var catmullRomClosed = (function custom(alpha) {

      function catmullRom(context) {
        return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
      }

      catmullRom.alpha = function(alpha) {
        return custom(+alpha);
      };

      return catmullRom;
    })(0.5);

    function CatmullRomOpen(context, alpha) {
      this._context = context;
      this._alpha = alpha;
    }

    CatmullRomOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 =
        this._y0 = this._y1 = this._y2 = NaN;
        this._l01_a = this._l12_a = this._l23_a =
        this._l01_2a = this._l12_2a = this._l23_2a =
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;

        if (this._point) {
          var x23 = this._x2 - x,
              y23 = this._y2 - y;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }

        switch (this._point) {
          case 0: this._point = 1; break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
          case 3: this._point = 4; // proceed
          default: point$1(this, x, y); break;
        }

        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var catmullRomOpen = (function custom(alpha) {

      function catmullRom(context) {
        return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
      }

      catmullRom.alpha = function(alpha) {
        return custom(+alpha);
      };

      return catmullRom;
    })(0.5);

    function LinearClosed(context) {
      this._context = context;
    }

    LinearClosed.prototype = {
      areaStart: noop,
      areaEnd: noop,
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._point) this._context.closePath();
      },
      point: function(x, y) {
        x = +x, y = +y;
        if (this._point) this._context.lineTo(x, y);
        else this._point = 1, this._context.moveTo(x, y);
      }
    };

    function linearClosed(context) {
      return new LinearClosed(context);
    }

    function sign(x) {
      return x < 0 ? -1 : 1;
    }

    // Calculate the slopes of the tangents (Hermite-type interpolation) based on
    // the following paper: Steffen, M. 1990. A Simple Method for Monotonic
    // Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
    // NOV(II), P. 443, 1990.
    function slope3(that, x2, y2) {
      var h0 = that._x1 - that._x0,
          h1 = x2 - that._x1,
          s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
          s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
          p = (s0 * h1 + s1 * h0) / (h0 + h1);
      return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
    }

    // Calculate a one-sided slope.
    function slope2(that, t) {
      var h = that._x1 - that._x0;
      return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
    }

    // According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
    // "you can express cubic Hermite interpolation in terms of cubic Bézier curves
    // with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
    function point(that, t0, t1) {
      var x0 = that._x0,
          y0 = that._y0,
          x1 = that._x1,
          y1 = that._y1,
          dx = (x1 - x0) / 3;
      that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
    }

    function MonotoneX(context) {
      this._context = context;
    }

    MonotoneX.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 =
        this._y0 = this._y1 =
        this._t0 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2: this._context.lineTo(this._x1, this._y1); break;
          case 3: point(this, this._t0, slope2(this, this._t0)); break;
        }
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        var t1 = NaN;

        x = +x, y = +y;
        if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; point(this, slope2(this, t1 = slope3(this, x, y)), t1); break;
          default: point(this, this._t0, t1 = slope3(this, x, y)); break;
        }

        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
        this._t0 = t1;
      }
    };

    function MonotoneY(context) {
      this._context = new ReflectContext(context);
    }

    (MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
      MonotoneX.prototype.point.call(this, y, x);
    };

    function ReflectContext(context) {
      this._context = context;
    }

    ReflectContext.prototype = {
      moveTo: function(x, y) { this._context.moveTo(y, x); },
      closePath: function() { this._context.closePath(); },
      lineTo: function(x, y) { this._context.lineTo(y, x); },
      bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
    };

    function monotoneX(context) {
      return new MonotoneX(context);
    }

    function monotoneY(context) {
      return new MonotoneY(context);
    }

    function Natural(context) {
      this._context = context;
    }

    Natural.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x = [];
        this._y = [];
      },
      lineEnd: function() {
        var x = this._x,
            y = this._y,
            n = x.length;

        if (n) {
          this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
          if (n === 2) {
            this._context.lineTo(x[1], y[1]);
          } else {
            var px = controlPoints(x),
                py = controlPoints(y);
            for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
              this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
            }
          }
        }

        if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();
        this._line = 1 - this._line;
        this._x = this._y = null;
      },
      point: function(x, y) {
        this._x.push(+x);
        this._y.push(+y);
      }
    };

    // See https://www.particleincell.com/2012/bezier-splines/ for derivation.
    function controlPoints(x) {
      var i,
          n = x.length - 1,
          m,
          a = new Array(n),
          b = new Array(n),
          r = new Array(n);
      a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
      for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
      a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
      for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
      a[n - 1] = r[n - 1] / b[n - 1];
      for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];
      b[n - 1] = (x[n] + a[n - 1]) / 2;
      for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];
      return [a, b];
    }

    function natural(context) {
      return new Natural(context);
    }

    function Step(context, t) {
      this._context = context;
      this._t = t;
    }

    Step.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x = this._y = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; // proceed
          default: {
            if (this._t <= 0) {
              this._context.lineTo(this._x, y);
              this._context.lineTo(x, y);
            } else {
              var x1 = this._x * (1 - this._t) + x * this._t;
              this._context.lineTo(x1, this._y);
              this._context.lineTo(x1, y);
            }
            break;
          }
        }
        this._x = x, this._y = y;
      }
    };

    function step(context) {
      return new Step(context, 0.5);
    }

    function stepBefore(context) {
      return new Step(context, 0);
    }

    function stepAfter(context) {
      return new Step(context, 1);
    }

    function none$1(series, order) {
      if (!((n = series.length) > 1)) return;
      for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
        s0 = s1, s1 = series[order[i]];
        for (j = 0; j < m; ++j) {
          s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
        }
      }
    }

    function none(series) {
      var n = series.length, o = new Array(n);
      while (--n >= 0) o[n] = n;
      return o;
    }

    function stackValue(d, key) {
      return d[key];
    }

    function stack() {
      var keys = constant$2([]),
          order = none,
          offset = none$1,
          value = stackValue;

      function stack(data) {
        var kz = keys.apply(this, arguments),
            i,
            m = data.length,
            n = kz.length,
            sz = new Array(n),
            oz;

        for (i = 0; i < n; ++i) {
          for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {
            si[j] = sij = [0, +value(data[j], ki, j, data)];
            sij.data = data[j];
          }
          si.key = ki;
        }

        for (i = 0, oz = order(sz); i < n; ++i) {
          sz[oz[i]].index = i;
        }

        offset(sz, oz);
        return sz;
      }

      stack.keys = function(_) {
        return arguments.length ? (keys = typeof _ === "function" ? _ : constant$2(slice.call(_)), stack) : keys;
      };

      stack.value = function(_) {
        return arguments.length ? (value = typeof _ === "function" ? _ : constant$2(+_), stack) : value;
      };

      stack.order = function(_) {
        return arguments.length ? (order = _ == null ? none : typeof _ === "function" ? _ : constant$2(slice.call(_)), stack) : order;
      };

      stack.offset = function(_) {
        return arguments.length ? (offset = _ == null ? none$1 : _, stack) : offset;
      };

      return stack;
    }

    function expand(series, order) {
      if (!((n = series.length) > 0)) return;
      for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
        for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;
        if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;
      }
      none$1(series, order);
    }

    function diverging(series, order) {
      if (!((n = series.length) > 0)) return;
      for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
        for (yp = yn = 0, i = 0; i < n; ++i) {
          if ((dy = (d = series[order[i]][j])[1] - d[0]) > 0) {
            d[0] = yp, d[1] = yp += dy;
          } else if (dy < 0) {
            d[1] = yn, d[0] = yn += dy;
          } else {
            d[0] = 0, d[1] = dy;
          }
        }
      }
    }

    function silhouette(series, order) {
      if (!((n = series.length) > 0)) return;
      for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
        for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;
        s0[j][1] += s0[j][0] = -y / 2;
      }
      none$1(series, order);
    }

    function wiggle(series, order) {
      if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
      for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
        for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
          var si = series[order[i]],
              sij0 = si[j][1] || 0,
              sij1 = si[j - 1][1] || 0,
              s3 = (sij0 - sij1) / 2;
          for (var k = 0; k < i; ++k) {
            var sk = series[order[k]],
                skj0 = sk[j][1] || 0,
                skj1 = sk[j - 1][1] || 0;
            s3 += skj0 - skj1;
          }
          s1 += sij0, s2 += s3 * sij0;
        }
        s0[j - 1][1] += s0[j - 1][0] = y;
        if (s1) y -= s2 / s1;
      }
      s0[j - 1][1] += s0[j - 1][0] = y;
      none$1(series, order);
    }

    function appearance(series) {
      var peaks = series.map(peak);
      return none(series).sort(function(a, b) { return peaks[a] - peaks[b]; });
    }

    function peak(series) {
      var i = -1, j = 0, n = series.length, vi, vj = -Infinity;
      while (++i < n) if ((vi = +series[i][1]) > vj) vj = vi, j = i;
      return j;
    }

    function ascending(series) {
      var sums = series.map(sum);
      return none(series).sort(function(a, b) { return sums[a] - sums[b]; });
    }

    function sum(series) {
      var s = 0, i = -1, n = series.length, v;
      while (++i < n) if (v = +series[i][1]) s += v;
      return s;
    }

    function descending(series) {
      return ascending(series).reverse();
    }

    function insideOut(series) {
      var n = series.length,
          i,
          j,
          sums = series.map(sum),
          order = appearance(series),
          top = 0,
          bottom = 0,
          tops = [],
          bottoms = [];

      for (i = 0; i < n; ++i) {
        j = order[i];
        if (top < bottom) {
          top += sums[j];
          tops.push(j);
        } else {
          bottom += sums[j];
          bottoms.push(j);
        }
      }

      return bottoms.reverse().concat(tops);
    }

    function reverse(series) {
      return none(series).reverse();
    }

    function constant$1(x) {
      return function() {
        return x;
      };
    }

    function x(d) {
      return d[0];
    }

    function y(d) {
      return d[1];
    }

    function RedBlackTree() {
      this._ = null; // root node
    }

    function RedBlackNode(node) {
      node.U = // parent node
      node.C = // color - true for red, false for black
      node.L = // left node
      node.R = // right node
      node.P = // previous node
      node.N = null; // next node
    }

    RedBlackTree.prototype = {
      constructor: RedBlackTree,

      insert: function(after, node) {
        var parent, grandpa, uncle;

        if (after) {
          node.P = after;
          node.N = after.N;
          if (after.N) after.N.P = node;
          after.N = node;
          if (after.R) {
            after = after.R;
            while (after.L) after = after.L;
            after.L = node;
          } else {
            after.R = node;
          }
          parent = after;
        } else if (this._) {
          after = RedBlackFirst(this._);
          node.P = null;
          node.N = after;
          after.P = after.L = node;
          parent = after;
        } else {
          node.P = node.N = null;
          this._ = node;
          parent = null;
        }
        node.L = node.R = null;
        node.U = parent;
        node.C = true;

        after = node;
        while (parent && parent.C) {
          grandpa = parent.U;
          if (parent === grandpa.L) {
            uncle = grandpa.R;
            if (uncle && uncle.C) {
              parent.C = uncle.C = false;
              grandpa.C = true;
              after = grandpa;
            } else {
              if (after === parent.R) {
                RedBlackRotateLeft(this, parent);
                after = parent;
                parent = after.U;
              }
              parent.C = false;
              grandpa.C = true;
              RedBlackRotateRight(this, grandpa);
            }
          } else {
            uncle = grandpa.L;
            if (uncle && uncle.C) {
              parent.C = uncle.C = false;
              grandpa.C = true;
              after = grandpa;
            } else {
              if (after === parent.L) {
                RedBlackRotateRight(this, parent);
                after = parent;
                parent = after.U;
              }
              parent.C = false;
              grandpa.C = true;
              RedBlackRotateLeft(this, grandpa);
            }
          }
          parent = after.U;
        }
        this._.C = false;
      },

      remove: function(node) {
        if (node.N) node.N.P = node.P;
        if (node.P) node.P.N = node.N;
        node.N = node.P = null;

        var parent = node.U,
            sibling,
            left = node.L,
            right = node.R,
            next,
            red;

        if (!left) next = right;
        else if (!right) next = left;
        else next = RedBlackFirst(right);

        if (parent) {
          if (parent.L === node) parent.L = next;
          else parent.R = next;
        } else {
          this._ = next;
        }

        if (left && right) {
          red = next.C;
          next.C = node.C;
          next.L = left;
          left.U = next;
          if (next !== right) {
            parent = next.U;
            next.U = node.U;
            node = next.R;
            parent.L = node;
            next.R = right;
            right.U = next;
          } else {
            next.U = parent;
            parent = next;
            node = next.R;
          }
        } else {
          red = node.C;
          node = next;
        }

        if (node) node.U = parent;
        if (red) return;
        if (node && node.C) { node.C = false; return; }

        do {
          if (node === this._) break;
          if (node === parent.L) {
            sibling = parent.R;
            if (sibling.C) {
              sibling.C = false;
              parent.C = true;
              RedBlackRotateLeft(this, parent);
              sibling = parent.R;
            }
            if ((sibling.L && sibling.L.C)
                || (sibling.R && sibling.R.C)) {
              if (!sibling.R || !sibling.R.C) {
                sibling.L.C = false;
                sibling.C = true;
                RedBlackRotateRight(this, sibling);
                sibling = parent.R;
              }
              sibling.C = parent.C;
              parent.C = sibling.R.C = false;
              RedBlackRotateLeft(this, parent);
              node = this._;
              break;
            }
          } else {
            sibling = parent.L;
            if (sibling.C) {
              sibling.C = false;
              parent.C = true;
              RedBlackRotateRight(this, parent);
              sibling = parent.L;
            }
            if ((sibling.L && sibling.L.C)
              || (sibling.R && sibling.R.C)) {
              if (!sibling.L || !sibling.L.C) {
                sibling.R.C = false;
                sibling.C = true;
                RedBlackRotateLeft(this, sibling);
                sibling = parent.L;
              }
              sibling.C = parent.C;
              parent.C = sibling.L.C = false;
              RedBlackRotateRight(this, parent);
              node = this._;
              break;
            }
          }
          sibling.C = true;
          node = parent;
          parent = parent.U;
        } while (!node.C);

        if (node) node.C = false;
      }
    };

    function RedBlackRotateLeft(tree, node) {
      var p = node,
          q = node.R,
          parent = p.U;

      if (parent) {
        if (parent.L === p) parent.L = q;
        else parent.R = q;
      } else {
        tree._ = q;
      }

      q.U = parent;
      p.U = q;
      p.R = q.L;
      if (p.R) p.R.U = p;
      q.L = p;
    }

    function RedBlackRotateRight(tree, node) {
      var p = node,
          q = node.L,
          parent = p.U;

      if (parent) {
        if (parent.L === p) parent.L = q;
        else parent.R = q;
      } else {
        tree._ = q;
      }

      q.U = parent;
      p.U = q;
      p.L = q.R;
      if (p.L) p.L.U = p;
      q.R = p;
    }

    function RedBlackFirst(node) {
      while (node.L) node = node.L;
      return node;
    }

    function createEdge(left, right, v0, v1) {
      var edge = [null, null],
          index = edges.push(edge) - 1;
      edge.left = left;
      edge.right = right;
      if (v0) setEdgeEnd(edge, left, right, v0);
      if (v1) setEdgeEnd(edge, right, left, v1);
      cells[left.index].halfedges.push(index);
      cells[right.index].halfedges.push(index);
      return edge;
    }

    function createBorderEdge(left, v0, v1) {
      var edge = [v0, v1];
      edge.left = left;
      return edge;
    }

    function setEdgeEnd(edge, left, right, vertex) {
      if (!edge[0] && !edge[1]) {
        edge[0] = vertex;
        edge.left = left;
        edge.right = right;
      } else if (edge.left === right) {
        edge[1] = vertex;
      } else {
        edge[0] = vertex;
      }
    }

    // Liang–Barsky line clipping.
    function clipEdge(edge, x0, y0, x1, y1) {
      var a = edge[0],
          b = edge[1],
          ax = a[0],
          ay = a[1],
          bx = b[0],
          by = b[1],
          t0 = 0,
          t1 = 1,
          dx = bx - ax,
          dy = by - ay,
          r;

      r = x0 - ax;
      if (!dx && r > 0) return;
      r /= dx;
      if (dx < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dx > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }

      r = x1 - ax;
      if (!dx && r < 0) return;
      r /= dx;
      if (dx < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dx > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }

      r = y0 - ay;
      if (!dy && r > 0) return;
      r /= dy;
      if (dy < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dy > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }

      r = y1 - ay;
      if (!dy && r < 0) return;
      r /= dy;
      if (dy < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dy > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }

      if (!(t0 > 0) && !(t1 < 1)) return true; // TODO Better check?

      if (t0 > 0) edge[0] = [ax + t0 * dx, ay + t0 * dy];
      if (t1 < 1) edge[1] = [ax + t1 * dx, ay + t1 * dy];
      return true;
    }

    function connectEdge(edge, x0, y0, x1, y1) {
      var v1 = edge[1];
      if (v1) return true;

      var v0 = edge[0],
          left = edge.left,
          right = edge.right,
          lx = left[0],
          ly = left[1],
          rx = right[0],
          ry = right[1],
          fx = (lx + rx) / 2,
          fy = (ly + ry) / 2,
          fm,
          fb;

      if (ry === ly) {
        if (fx < x0 || fx >= x1) return;
        if (lx > rx) {
          if (!v0) v0 = [fx, y0];
          else if (v0[1] >= y1) return;
          v1 = [fx, y1];
        } else {
          if (!v0) v0 = [fx, y1];
          else if (v0[1] < y0) return;
          v1 = [fx, y0];
        }
      } else {
        fm = (lx - rx) / (ry - ly);
        fb = fy - fm * fx;
        if (fm < -1 || fm > 1) {
          if (lx > rx) {
            if (!v0) v0 = [(y0 - fb) / fm, y0];
            else if (v0[1] >= y1) return;
            v1 = [(y1 - fb) / fm, y1];
          } else {
            if (!v0) v0 = [(y1 - fb) / fm, y1];
            else if (v0[1] < y0) return;
            v1 = [(y0 - fb) / fm, y0];
          }
        } else {
          if (ly < ry) {
            if (!v0) v0 = [x0, fm * x0 + fb];
            else if (v0[0] >= x1) return;
            v1 = [x1, fm * x1 + fb];
          } else {
            if (!v0) v0 = [x1, fm * x1 + fb];
            else if (v0[0] < x0) return;
            v1 = [x0, fm * x0 + fb];
          }
        }
      }

      edge[0] = v0;
      edge[1] = v1;
      return true;
    }

    function clipEdges(x0, y0, x1, y1) {
      var i = edges.length,
          edge;

      while (i--) {
        if (!connectEdge(edge = edges[i], x0, y0, x1, y1)
            || !clipEdge(edge, x0, y0, x1, y1)
            || !(Math.abs(edge[0][0] - edge[1][0]) > epsilon
                || Math.abs(edge[0][1] - edge[1][1]) > epsilon)) {
          delete edges[i];
        }
      }
    }

    function createCell(site) {
      return cells[site.index] = {
        site: site,
        halfedges: []
      };
    }

    function cellHalfedgeAngle(cell, edge) {
      var site = cell.site,
          va = edge.left,
          vb = edge.right;
      if (site === vb) vb = va, va = site;
      if (vb) return Math.atan2(vb[1] - va[1], vb[0] - va[0]);
      if (site === va) va = edge[1], vb = edge[0];
      else va = edge[0], vb = edge[1];
      return Math.atan2(va[0] - vb[0], vb[1] - va[1]);
    }

    function cellHalfedgeStart(cell, edge) {
      return edge[+(edge.left !== cell.site)];
    }

    function cellHalfedgeEnd(cell, edge) {
      return edge[+(edge.left === cell.site)];
    }

    function sortCellHalfedges() {
      for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {
        if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {
          var index = new Array(m),
              array = new Array(m);
          for (j = 0; j < m; ++j) index[j] = j, array[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);
          index.sort(function(i, j) { return array[j] - array[i]; });
          for (j = 0; j < m; ++j) array[j] = halfedges[index[j]];
          for (j = 0; j < m; ++j) halfedges[j] = array[j];
        }
      }
    }

    function clipCells(x0, y0, x1, y1) {
      var nCells = cells.length,
          iCell,
          cell,
          site,
          iHalfedge,
          halfedges,
          nHalfedges,
          start,
          startX,
          startY,
          end,
          endX,
          endY,
          cover = true;

      for (iCell = 0; iCell < nCells; ++iCell) {
        if (cell = cells[iCell]) {
          site = cell.site;
          halfedges = cell.halfedges;
          iHalfedge = halfedges.length;

          // Remove any dangling clipped edges.
          while (iHalfedge--) {
            if (!edges[halfedges[iHalfedge]]) {
              halfedges.splice(iHalfedge, 1);
            }
          }

          // Insert any border edges as necessary.
          iHalfedge = 0, nHalfedges = halfedges.length;
          while (iHalfedge < nHalfedges) {
            end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];
            start = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];
            if (Math.abs(endX - startX) > epsilon || Math.abs(endY - startY) > epsilon) {
              halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(site, end,
                  Math.abs(endX - x0) < epsilon && y1 - endY > epsilon ? [x0, Math.abs(startX - x0) < epsilon ? startY : y1]
                  : Math.abs(endY - y1) < epsilon && x1 - endX > epsilon ? [Math.abs(startY - y1) < epsilon ? startX : x1, y1]
                  : Math.abs(endX - x1) < epsilon && endY - y0 > epsilon ? [x1, Math.abs(startX - x1) < epsilon ? startY : y0]
                  : Math.abs(endY - y0) < epsilon && endX - x0 > epsilon ? [Math.abs(startY - y0) < epsilon ? startX : x0, y0]
                  : null)) - 1);
              ++nHalfedges;
            }
          }

          if (nHalfedges) cover = false;
        }
      }

      // If there weren’t any edges, have the closest site cover the extent.
      // It doesn’t matter which corner of the extent we measure!
      if (cover) {
        var dx, dy, d2, dc = Infinity;

        for (iCell = 0, cover = null; iCell < nCells; ++iCell) {
          if (cell = cells[iCell]) {
            site = cell.site;
            dx = site[0] - x0;
            dy = site[1] - y0;
            d2 = dx * dx + dy * dy;
            if (d2 < dc) dc = d2, cover = cell;
          }
        }

        if (cover) {
          var v00 = [x0, y0], v01 = [x0, y1], v11 = [x1, y1], v10 = [x1, y0];
          cover.halfedges.push(
            edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1,
            edges.push(createBorderEdge(site, v01, v11)) - 1,
            edges.push(createBorderEdge(site, v11, v10)) - 1,
            edges.push(createBorderEdge(site, v10, v00)) - 1
          );
        }
      }

      // Lastly delete any cells with no edges; these were entirely clipped.
      for (iCell = 0; iCell < nCells; ++iCell) {
        if (cell = cells[iCell]) {
          if (!cell.halfedges.length) {
            delete cells[iCell];
          }
        }
      }
    }

    var circlePool = [];

    var firstCircle;

    function Circle() {
      RedBlackNode(this);
      this.x =
      this.y =
      this.arc =
      this.site =
      this.cy = null;
    }

    function attachCircle(arc) {
      var lArc = arc.P,
          rArc = arc.N;

      if (!lArc || !rArc) return;

      var lSite = lArc.site,
          cSite = arc.site,
          rSite = rArc.site;

      if (lSite === rSite) return;

      var bx = cSite[0],
          by = cSite[1],
          ax = lSite[0] - bx,
          ay = lSite[1] - by,
          cx = rSite[0] - bx,
          cy = rSite[1] - by;

      var d = 2 * (ax * cy - ay * cx);
      if (d >= -epsilon2) return;

      var ha = ax * ax + ay * ay,
          hc = cx * cx + cy * cy,
          x = (cy * ha - ay * hc) / d,
          y = (ax * hc - cx * ha) / d;

      var circle = circlePool.pop() || new Circle;
      circle.arc = arc;
      circle.site = cSite;
      circle.x = x + bx;
      circle.y = (circle.cy = y + by) + Math.sqrt(x * x + y * y); // y bottom

      arc.circle = circle;

      var before = null,
          node = circles._;

      while (node) {
        if (circle.y < node.y || (circle.y === node.y && circle.x <= node.x)) {
          if (node.L) node = node.L;
          else { before = node.P; break; }
        } else {
          if (node.R) node = node.R;
          else { before = node; break; }
        }
      }

      circles.insert(before, circle);
      if (!before) firstCircle = circle;
    }

    function detachCircle(arc) {
      var circle = arc.circle;
      if (circle) {
        if (!circle.P) firstCircle = circle.N;
        circles.remove(circle);
        circlePool.push(circle);
        RedBlackNode(circle);
        arc.circle = null;
      }
    }

    var beachPool = [];

    function Beach() {
      RedBlackNode(this);
      this.edge =
      this.site =
      this.circle = null;
    }

    function createBeach(site) {
      var beach = beachPool.pop() || new Beach;
      beach.site = site;
      return beach;
    }

    function detachBeach(beach) {
      detachCircle(beach);
      beaches.remove(beach);
      beachPool.push(beach);
      RedBlackNode(beach);
    }

    function removeBeach(beach) {
      var circle = beach.circle,
          x = circle.x,
          y = circle.cy,
          vertex = [x, y],
          previous = beach.P,
          next = beach.N,
          disappearing = [beach];

      detachBeach(beach);

      var lArc = previous;
      while (lArc.circle
          && Math.abs(x - lArc.circle.x) < epsilon
          && Math.abs(y - lArc.circle.cy) < epsilon) {
        previous = lArc.P;
        disappearing.unshift(lArc);
        detachBeach(lArc);
        lArc = previous;
      }

      disappearing.unshift(lArc);
      detachCircle(lArc);

      var rArc = next;
      while (rArc.circle
          && Math.abs(x - rArc.circle.x) < epsilon
          && Math.abs(y - rArc.circle.cy) < epsilon) {
        next = rArc.N;
        disappearing.push(rArc);
        detachBeach(rArc);
        rArc = next;
      }

      disappearing.push(rArc);
      detachCircle(rArc);

      var nArcs = disappearing.length,
          iArc;
      for (iArc = 1; iArc < nArcs; ++iArc) {
        rArc = disappearing[iArc];
        lArc = disappearing[iArc - 1];
        setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
      }

      lArc = disappearing[0];
      rArc = disappearing[nArcs - 1];
      rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);

      attachCircle(lArc);
      attachCircle(rArc);
    }

    function addBeach(site) {
      var x = site[0],
          directrix = site[1],
          lArc,
          rArc,
          dxl,
          dxr,
          node = beaches._;

      while (node) {
        dxl = leftBreakPoint(node, directrix) - x;
        if (dxl > epsilon) node = node.L; else {
          dxr = x - rightBreakPoint(node, directrix);
          if (dxr > epsilon) {
            if (!node.R) {
              lArc = node;
              break;
            }
            node = node.R;
          } else {
            if (dxl > -epsilon) {
              lArc = node.P;
              rArc = node;
            } else if (dxr > -epsilon) {
              lArc = node;
              rArc = node.N;
            } else {
              lArc = rArc = node;
            }
            break;
          }
        }
      }

      createCell(site);
      var newArc = createBeach(site);
      beaches.insert(lArc, newArc);

      if (!lArc && !rArc) return;

      if (lArc === rArc) {
        detachCircle(lArc);
        rArc = createBeach(lArc.site);
        beaches.insert(newArc, rArc);
        newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);
        attachCircle(lArc);
        attachCircle(rArc);
        return;
      }

      if (!rArc) { // && lArc
        newArc.edge = createEdge(lArc.site, newArc.site);
        return;
      }

      // else lArc !== rArc
      detachCircle(lArc);
      detachCircle(rArc);

      var lSite = lArc.site,
          ax = lSite[0],
          ay = lSite[1],
          bx = site[0] - ax,
          by = site[1] - ay,
          rSite = rArc.site,
          cx = rSite[0] - ax,
          cy = rSite[1] - ay,
          d = 2 * (bx * cy - by * cx),
          hb = bx * bx + by * by,
          hc = cx * cx + cy * cy,
          vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];

      setEdgeEnd(rArc.edge, lSite, rSite, vertex);
      newArc.edge = createEdge(lSite, site, null, vertex);
      rArc.edge = createEdge(site, rSite, null, vertex);
      attachCircle(lArc);
      attachCircle(rArc);
    }

    function leftBreakPoint(arc, directrix) {
      var site = arc.site,
          rfocx = site[0],
          rfocy = site[1],
          pby2 = rfocy - directrix;

      if (!pby2) return rfocx;

      var lArc = arc.P;
      if (!lArc) return -Infinity;

      site = lArc.site;
      var lfocx = site[0],
          lfocy = site[1],
          plby2 = lfocy - directrix;

      if (!plby2) return lfocx;

      var hl = lfocx - rfocx,
          aby2 = 1 / pby2 - 1 / plby2,
          b = hl / plby2;

      if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;

      return (rfocx + lfocx) / 2;
    }

    function rightBreakPoint(arc, directrix) {
      var rArc = arc.N;
      if (rArc) return leftBreakPoint(rArc, directrix);
      var site = arc.site;
      return site[1] === directrix ? site[0] : Infinity;
    }

    var epsilon = 1e-6;
    var epsilon2 = 1e-12;
    var beaches;
    var cells;
    var circles;
    var edges;

    function triangleArea(a, b, c) {
      return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);
    }

    function lexicographic(a, b) {
      return b[1] - a[1]
          || b[0] - a[0];
    }

    function Diagram(sites, extent) {
      var site = sites.sort(lexicographic).pop(),
          x,
          y,
          circle;

      edges = [];
      cells = new Array(sites.length);
      beaches = new RedBlackTree;
      circles = new RedBlackTree;

      while (true) {
        circle = firstCircle;
        if (site && (!circle || site[1] < circle.y || (site[1] === circle.y && site[0] < circle.x))) {
          if (site[0] !== x || site[1] !== y) {
            addBeach(site);
            x = site[0], y = site[1];
          }
          site = sites.pop();
        } else if (circle) {
          removeBeach(circle.arc);
        } else {
          break;
        }
      }

      sortCellHalfedges();

      if (extent) {
        var x0 = +extent[0][0],
            y0 = +extent[0][1],
            x1 = +extent[1][0],
            y1 = +extent[1][1];
        clipEdges(x0, y0, x1, y1);
        clipCells(x0, y0, x1, y1);
      }

      this.edges = edges;
      this.cells = cells;

      beaches =
      circles =
      edges =
      cells = null;
    }

    Diagram.prototype = {
      constructor: Diagram,

      polygons: function() {
        var edges = this.edges;

        return this.cells.map(function(cell) {
          var polygon = cell.halfedges.map(function(i) { return cellHalfedgeStart(cell, edges[i]); });
          polygon.data = cell.site.data;
          return polygon;
        });
      },

      triangles: function() {
        var triangles = [],
            edges = this.edges;

        this.cells.forEach(function(cell, i) {
          if (!(m = (halfedges = cell.halfedges).length)) return;
          var site = cell.site,
              halfedges,
              j = -1,
              m,
              s0,
              e1 = edges[halfedges[m - 1]],
              s1 = e1.left === site ? e1.right : e1.left;

          while (++j < m) {
            s0 = s1;
            e1 = edges[halfedges[j]];
            s1 = e1.left === site ? e1.right : e1.left;
            if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {
              triangles.push([site.data, s0.data, s1.data]);
            }
          }
        });

        return triangles;
      },

      links: function() {
        return this.edges.filter(function(edge) {
          return edge.right;
        }).map(function(edge) {
          return {
            source: edge.left.data,
            target: edge.right.data
          };
        });
      },

      find: function(x, y, radius) {
        var that = this, i0, i1 = that._found || 0, n = that.cells.length, cell;

        // Use the previously-found cell, or start with an arbitrary one.
        while (!(cell = that.cells[i1])) if (++i1 >= n) return null;
        var dx = x - cell.site[0], dy = y - cell.site[1], d2 = dx * dx + dy * dy;

        // Traverse the half-edges to find a closer cell, if any.
        do {
          cell = that.cells[i0 = i1], i1 = null;
          cell.halfedges.forEach(function(e) {
            var edge = that.edges[e], v = edge.left;
            if ((v === cell.site || !v) && !(v = edge.right)) return;
            var vx = x - v[0], vy = y - v[1], v2 = vx * vx + vy * vy;
            if (v2 < d2) d2 = v2, i1 = v.index;
          });
        } while (i1 !== null);

        that._found = i0;

        return radius == null || d2 <= radius * radius ? cell.site : null;
      }
    };

    function voronoi() {
      var x$1 = x,
          y$1 = y,
          extent = null;

      function voronoi(data) {
        return new Diagram(data.map(function(d, i) {
          var s = [Math.round(x$1(d, i, data) / epsilon) * epsilon, Math.round(y$1(d, i, data) / epsilon) * epsilon];
          s.index = i;
          s.data = d;
          return s;
        }), extent);
      }

      voronoi.polygons = function(data) {
        return voronoi(data).polygons();
      };

      voronoi.links = function(data) {
        return voronoi(data).links();
      };

      voronoi.triangles = function(data) {
        return voronoi(data).triangles();
      };

      voronoi.x = function(_) {
        return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant$1(+_), voronoi) : x$1;
      };

      voronoi.y = function(_) {
        return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant$1(+_), voronoi) : y$1;
      };

      voronoi.extent = function(_) {
        return arguments.length ? (extent = _ == null ? null : [[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]], voronoi) : extent && [[extent[0][0], extent[0][1]], [extent[1][0], extent[1][1]]];
      };

      voronoi.size = function(_) {
        return arguments.length ? (extent = _ == null ? null : [[0, 0], [+_[0], +_[1]]], voronoi) : extent && [extent[1][0] - extent[0][0], extent[1][1] - extent[0][1]];
      };

      return voronoi;
    }

    function constant(x) {
      return function() {
        return x;
      };
    }

    function ZoomEvent(target, type, transform) {
      this.target = target;
      this.type = type;
      this.transform = transform;
    }

    function Transform(k, x, y) {
      this.k = k;
      this.x = x;
      this.y = y;
    }

    Transform.prototype = {
      constructor: Transform,
      scale: function(k) {
        return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
      },
      translate: function(x, y) {
        return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
      },
      apply: function(point) {
        return [point[0] * this.k + this.x, point[1] * this.k + this.y];
      },
      applyX: function(x) {
        return x * this.k + this.x;
      },
      applyY: function(y) {
        return y * this.k + this.y;
      },
      invert: function(location) {
        return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
      },
      invertX: function(x) {
        return (x - this.x) / this.k;
      },
      invertY: function(y) {
        return (y - this.y) / this.k;
      },
      rescaleX: function(x) {
        return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
      },
      rescaleY: function(y) {
        return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
      },
      toString: function() {
        return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
      }
    };

    var identity = new Transform(1, 0, 0);

    transform.prototype = Transform.prototype;

    function transform(node) {
      while (!node.__zoom) if (!(node = node.parentNode)) return identity;
      return node.__zoom;
    }

    function nopropagation() {
      event.stopImmediatePropagation();
    }

    function noevent() {
      event.preventDefault();
      event.stopImmediatePropagation();
    }

    // Ignore right-click, since that should open the context menu.
    function defaultFilter() {
      return !event.ctrlKey && !event.button;
    }

    function defaultExtent() {
      var e = this;
      if (e instanceof SVGElement) {
        e = e.ownerSVGElement || e;
        if (e.hasAttribute("viewBox")) {
          e = e.viewBox.baseVal;
          return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
        }
        return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
      }
      return [[0, 0], [e.clientWidth, e.clientHeight]];
    }

    function defaultTransform() {
      return this.__zoom || identity;
    }

    function defaultWheelDelta() {
      return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002);
    }

    function defaultTouchable() {
      return navigator.maxTouchPoints || ("ontouchstart" in this);
    }

    function defaultConstrain(transform, extent, translateExtent) {
      var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
          dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
          dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
          dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
      return transform.translate(
        dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
        dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
      );
    }

    function zoom() {
      var filter = defaultFilter,
          extent = defaultExtent,
          constrain = defaultConstrain,
          wheelDelta = defaultWheelDelta,
          touchable = defaultTouchable,
          scaleExtent = [0, Infinity],
          translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
          duration = 250,
          interpolate = interpolateZoom,
          listeners = dispatch("start", "zoom", "end"),
          touchstarting,
          touchending,
          touchDelay = 500,
          wheelDelay = 150,
          clickDistance2 = 0;

      function zoom(selection) {
        selection
            .property("__zoom", defaultTransform)
            .on("wheel.zoom", wheeled)
            .on("mousedown.zoom", mousedowned)
            .on("dblclick.zoom", dblclicked)
          .filter(touchable)
            .on("touchstart.zoom", touchstarted)
            .on("touchmove.zoom", touchmoved)
            .on("touchend.zoom touchcancel.zoom", touchended)
            .style("touch-action", "none")
            .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
      }

      zoom.transform = function(collection, transform, point) {
        var selection = collection.selection ? collection.selection() : collection;
        selection.property("__zoom", defaultTransform);
        if (collection !== selection) {
          schedule(collection, transform, point);
        } else {
          selection.interrupt().each(function() {
            gesture(this, arguments)
                .start()
                .zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform)
                .end();
          });
        }
      };

      zoom.scaleBy = function(selection, k, p) {
        zoom.scaleTo(selection, function() {
          var k0 = this.__zoom.k,
              k1 = typeof k === "function" ? k.apply(this, arguments) : k;
          return k0 * k1;
        }, p);
      };

      zoom.scaleTo = function(selection, k, p) {
        zoom.transform(selection, function() {
          var e = extent.apply(this, arguments),
              t0 = this.__zoom,
              p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p,
              p1 = t0.invert(p0),
              k1 = typeof k === "function" ? k.apply(this, arguments) : k;
          return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
        }, p);
      };

      zoom.translateBy = function(selection, x, y) {
        zoom.transform(selection, function() {
          return constrain(this.__zoom.translate(
            typeof x === "function" ? x.apply(this, arguments) : x,
            typeof y === "function" ? y.apply(this, arguments) : y
          ), extent.apply(this, arguments), translateExtent);
        });
      };

      zoom.translateTo = function(selection, x, y, p) {
        zoom.transform(selection, function() {
          var e = extent.apply(this, arguments),
              t = this.__zoom,
              p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
          return constrain(identity.translate(p0[0], p0[1]).scale(t.k).translate(
            typeof x === "function" ? -x.apply(this, arguments) : -x,
            typeof y === "function" ? -y.apply(this, arguments) : -y
          ), e, translateExtent);
        }, p);
      };

      function scale(transform, k) {
        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
        return k === transform.k ? transform : new Transform(k, transform.x, transform.y);
      }

      function translate(transform, p0, p1) {
        var x = p0[0] - p1[0] * transform.k, y = p0[1] - p1[1] * transform.k;
        return x === transform.x && y === transform.y ? transform : new Transform(transform.k, x, y);
      }

      function centroid(extent) {
        return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
      }

      function schedule(transition, transform, point) {
        transition
            .on("start.zoom", function() { gesture(this, arguments).start(); })
            .on("interrupt.zoom end.zoom", function() { gesture(this, arguments).end(); })
            .tween("zoom", function() {
              var that = this,
                  args = arguments,
                  g = gesture(that, args),
                  e = extent.apply(that, args),
                  p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point,
                  w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
                  a = that.__zoom,
                  b = typeof transform === "function" ? transform.apply(that, args) : transform,
                  i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
              return function(t) {
                if (t === 1) t = b; // Avoid rounding error on end.
                else { var l = i(t), k = w / l[2]; t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k); }
                g.zoom(null, t);
              };
            });
      }

      function gesture(that, args, clean) {
        return (!clean && that.__zooming) || new Gesture(that, args);
      }

      function Gesture(that, args) {
        this.that = that;
        this.args = args;
        this.active = 0;
        this.extent = extent.apply(that, args);
        this.taps = 0;
      }

      Gesture.prototype = {
        start: function() {
          if (++this.active === 1) {
            this.that.__zooming = this;
            this.emit("start");
          }
          return this;
        },
        zoom: function(key, transform) {
          if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
          if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
          if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
          this.that.__zoom = transform;
          this.emit("zoom");
          return this;
        },
        end: function() {
          if (--this.active === 0) {
            delete this.that.__zooming;
            this.emit("end");
          }
          return this;
        },
        emit: function(type) {
          customEvent(new ZoomEvent(zoom, type, this.that.__zoom), listeners.apply, listeners, [type, this.that, this.args]);
        }
      };

      function wheeled() {
        if (!filter.apply(this, arguments)) return;
        var g = gesture(this, arguments),
            t = this.__zoom,
            k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
            p = mouse(this);

        // If the mouse is in the same location as before, reuse it.
        // If there were recent wheel events, reset the wheel idle timeout.
        if (g.wheel) {
          if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
            g.mouse[1] = t.invert(g.mouse[0] = p);
          }
          clearTimeout(g.wheel);
        }

        // If this wheel event won’t trigger a transform change, ignore it.
        else if (t.k === k) return;

        // Otherwise, capture the mouse point and location at the start.
        else {
          g.mouse = [p, t.invert(p)];
          interrupt(this);
          g.start();
        }

        noevent();
        g.wheel = setTimeout(wheelidled, wheelDelay);
        g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));

        function wheelidled() {
          g.wheel = null;
          g.end();
        }
      }

      function mousedowned() {
        if (touchending || !filter.apply(this, arguments)) return;
        var g = gesture(this, arguments, true),
            v = select(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
            p = mouse(this),
            x0 = event.clientX,
            y0 = event.clientY;

        dragDisable(event.view);
        nopropagation();
        g.mouse = [p, this.__zoom.invert(p)];
        interrupt(this);
        g.start();

        function mousemoved() {
          noevent();
          if (!g.moved) {
            var dx = event.clientX - x0, dy = event.clientY - y0;
            g.moved = dx * dx + dy * dy > clickDistance2;
          }
          g.zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = mouse(g.that), g.mouse[1]), g.extent, translateExtent));
        }

        function mouseupped() {
          v.on("mousemove.zoom mouseup.zoom", null);
          yesdrag(event.view, g.moved);
          noevent();
          g.end();
        }
      }

      function dblclicked() {
        if (!filter.apply(this, arguments)) return;
        var t0 = this.__zoom,
            p0 = mouse(this),
            p1 = t0.invert(p0),
            k1 = t0.k * (event.shiftKey ? 0.5 : 2),
            t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, arguments), translateExtent);

        noevent();
        if (duration > 0) select(this).transition().duration(duration).call(schedule, t1, p0);
        else select(this).call(zoom.transform, t1);
      }

      function touchstarted() {
        if (!filter.apply(this, arguments)) return;
        var touches = event.touches,
            n = touches.length,
            g = gesture(this, arguments, event.changedTouches.length === n),
            started, i, t, p;

        nopropagation();
        for (i = 0; i < n; ++i) {
          t = touches[i], p = touch(this, touches, t.identifier);
          p = [p, this.__zoom.invert(p), t.identifier];
          if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
          else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
        }

        if (touchstarting) touchstarting = clearTimeout(touchstarting);

        if (started) {
          if (g.taps < 2) touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);
          interrupt(this);
          g.start();
        }
      }

      function touchmoved() {
        if (!this.__zooming) return;
        var g = gesture(this, arguments),
            touches = event.changedTouches,
            n = touches.length, i, t, p, l;

        noevent();
        if (touchstarting) touchstarting = clearTimeout(touchstarting);
        g.taps = 0;
        for (i = 0; i < n; ++i) {
          t = touches[i], p = touch(this, touches, t.identifier);
          if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
          else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
        }
        t = g.that.__zoom;
        if (g.touch1) {
          var p0 = g.touch0[0], l0 = g.touch0[1],
              p1 = g.touch1[0], l1 = g.touch1[1],
              dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
              dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
          t = scale(t, Math.sqrt(dp / dl));
          p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
          l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
        }
        else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
        else return;
        g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
      }

      function touchended() {
        if (!this.__zooming) return;
        var g = gesture(this, arguments),
            touches = event.changedTouches,
            n = touches.length, i, t;

        nopropagation();
        if (touchending) clearTimeout(touchending);
        touchending = setTimeout(function() { touchending = null; }, touchDelay);
        for (i = 0; i < n; ++i) {
          t = touches[i];
          if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
          else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
        }
        if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
        if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
        else {
          g.end();
          // If this was a dbltap, reroute to the (optional) dblclick.zoom handler.
          if (g.taps === 2) {
            var p = select(this).on("dblclick.zoom");
            if (p) p.apply(this, arguments);
          }
        }
      }

      zoom.wheelDelta = function(_) {
        return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : constant(+_), zoom) : wheelDelta;
      };

      zoom.filter = function(_) {
        return arguments.length ? (filter = typeof _ === "function" ? _ : constant(!!_), zoom) : filter;
      };

      zoom.touchable = function(_) {
        return arguments.length ? (touchable = typeof _ === "function" ? _ : constant(!!_), zoom) : touchable;
      };

      zoom.extent = function(_) {
        return arguments.length ? (extent = typeof _ === "function" ? _ : constant([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
      };

      zoom.scaleExtent = function(_) {
        return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
      };

      zoom.translateExtent = function(_) {
        return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
      };

      zoom.constrain = function(_) {
        return arguments.length ? (constrain = _, zoom) : constrain;
      };

      zoom.duration = function(_) {
        return arguments.length ? (duration = +_, zoom) : duration;
      };

      zoom.interpolate = function(_) {
        return arguments.length ? (interpolate = _, zoom) : interpolate;
      };

      zoom.on = function() {
        var value = listeners.on.apply(listeners, arguments);
        return value === listeners ? zoom : value;
      };

      zoom.clickDistance = function(_) {
        return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
      };

      return zoom;
    }

    var d3 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        version: version,
        bisect: bisectRight,
        bisectRight: bisectRight,
        bisectLeft: bisectLeft,
        ascending: ascending$3,
        bisector: bisector,
        cross: cross$2,
        descending: descending$2,
        deviation: deviation,
        extent: extent$1,
        histogram: histogram,
        thresholdFreedmanDiaconis: freedmanDiaconis,
        thresholdScott: scott,
        thresholdSturges: thresholdSturges,
        max: max$2,
        mean: mean,
        median: median,
        merge: merge,
        min: min$1,
        pairs: pairs,
        permute: permute,
        quantile: threshold$1,
        range: sequence,
        scan: scan,
        shuffle: shuffle$1,
        sum: sum$2,
        ticks: ticks,
        tickIncrement: tickIncrement,
        tickStep: tickStep,
        transpose: transpose,
        variance: variance,
        zip: zip,
        axisTop: axisTop,
        axisRight: axisRight,
        axisBottom: axisBottom,
        axisLeft: axisLeft,
        brush: brush,
        brushX: brushX,
        brushY: brushY,
        brushSelection: brushSelection,
        chord: chord,
        ribbon: ribbon,
        nest: nest,
        set: set,
        map: map$2,
        keys: keys,
        values: values,
        entries: entries,
        color: color,
        rgb: rgb,
        hsl: hsl$2,
        lab: lab$1,
        hcl: hcl$2,
        lch: lch,
        gray: gray,
        cubehelix: cubehelix$3,
        contours: contours,
        contourDensity: density,
        dispatch: dispatch,
        drag: drag,
        dragDisable: dragDisable,
        dragEnable: yesdrag,
        dsvFormat: dsvFormat,
        csvParse: csvParse,
        csvParseRows: csvParseRows,
        csvFormat: csvFormat,
        csvFormatBody: csvFormatBody,
        csvFormatRows: csvFormatRows,
        csvFormatRow: csvFormatRow,
        csvFormatValue: csvFormatValue,
        tsvParse: tsvParse,
        tsvParseRows: tsvParseRows,
        tsvFormat: tsvFormat,
        tsvFormatBody: tsvFormatBody,
        tsvFormatRows: tsvFormatRows,
        tsvFormatRow: tsvFormatRow,
        tsvFormatValue: tsvFormatValue,
        autoType: autoType,
        easeLinear: linear$1,
        easeQuad: quadInOut,
        easeQuadIn: quadIn,
        easeQuadOut: quadOut,
        easeQuadInOut: quadInOut,
        easeCubic: cubicInOut,
        easeCubicIn: cubicIn,
        easeCubicOut: cubicOut,
        easeCubicInOut: cubicInOut,
        easePoly: polyInOut,
        easePolyIn: polyIn,
        easePolyOut: polyOut,
        easePolyInOut: polyInOut,
        easeSin: sinInOut,
        easeSinIn: sinIn,
        easeSinOut: sinOut,
        easeSinInOut: sinInOut,
        easeExp: expInOut,
        easeExpIn: expIn,
        easeExpOut: expOut,
        easeExpInOut: expInOut,
        easeCircle: circleInOut,
        easeCircleIn: circleIn,
        easeCircleOut: circleOut,
        easeCircleInOut: circleInOut,
        easeBounce: bounceOut,
        easeBounceIn: bounceIn,
        easeBounceOut: bounceOut,
        easeBounceInOut: bounceInOut,
        easeBack: backInOut,
        easeBackIn: backIn,
        easeBackOut: backOut,
        easeBackInOut: backInOut,
        easeElastic: elasticOut,
        easeElasticIn: elasticIn,
        easeElasticOut: elasticOut,
        easeElasticInOut: elasticInOut,
        blob: blob,
        buffer: buffer,
        dsv: dsv,
        csv: csv,
        tsv: tsv,
        image: image,
        json: json,
        text: text,
        xml: xml,
        html: html,
        svg: svg,
        forceCenter: center,
        forceCollide: collide,
        forceLink: link$2,
        forceManyBody: manyBody,
        forceRadial: radial,
        forceSimulation: simulation,
        forceX: x$2,
        forceY: y$2,
        formatDefaultLocale: defaultLocale$1,
        get format () { return format; },
        get formatPrefix () { return formatPrefix; },
        formatLocale: formatLocale$1,
        formatSpecifier: formatSpecifier,
        FormatSpecifier: FormatSpecifier,
        precisionFixed: precisionFixed,
        precisionPrefix: precisionPrefix,
        precisionRound: precisionRound,
        geoArea: area$2,
        geoBounds: bounds,
        geoCentroid: centroid$1,
        geoCircle: circle$2,
        geoClipAntimeridian: clipAntimeridian,
        geoClipCircle: clipCircle,
        geoClipExtent: extent,
        geoClipRectangle: clipRectangle,
        geoContains: contains$1,
        geoDistance: distance,
        geoGraticule: graticule,
        geoGraticule10: graticule10,
        geoInterpolate: interpolate,
        geoLength: length$1,
        geoPath: index$2,
        geoAlbers: albers,
        geoAlbersUsa: albersUsa,
        geoAzimuthalEqualArea: azimuthalEqualArea,
        geoAzimuthalEqualAreaRaw: azimuthalEqualAreaRaw,
        geoAzimuthalEquidistant: azimuthalEquidistant,
        geoAzimuthalEquidistantRaw: azimuthalEquidistantRaw,
        geoConicConformal: conicConformal,
        geoConicConformalRaw: conicConformalRaw,
        geoConicEqualArea: conicEqualArea,
        geoConicEqualAreaRaw: conicEqualAreaRaw,
        geoConicEquidistant: conicEquidistant,
        geoConicEquidistantRaw: conicEquidistantRaw,
        geoEqualEarth: equalEarth,
        geoEqualEarthRaw: equalEarthRaw,
        geoEquirectangular: equirectangular,
        geoEquirectangularRaw: equirectangularRaw,
        geoGnomonic: gnomonic,
        geoGnomonicRaw: gnomonicRaw,
        geoIdentity: identity$4,
        geoProjection: projection,
        geoProjectionMutator: projectionMutator,
        geoMercator: mercator,
        geoMercatorRaw: mercatorRaw,
        geoNaturalEarth1: naturalEarth1,
        geoNaturalEarth1Raw: naturalEarth1Raw,
        geoOrthographic: orthographic,
        geoOrthographicRaw: orthographicRaw,
        geoStereographic: stereographic,
        geoStereographicRaw: stereographicRaw,
        geoTransverseMercator: transverseMercator,
        geoTransverseMercatorRaw: transverseMercatorRaw,
        geoRotation: rotation,
        geoStream: geoStream,
        geoTransform: transform$1,
        cluster: cluster,
        hierarchy: hierarchy,
        pack: index$1,
        packSiblings: siblings,
        packEnclose: enclose,
        partition: partition,
        stratify: stratify,
        tree: tree,
        treemap: index,
        treemapBinary: binary,
        treemapDice: treemapDice,
        treemapSlice: treemapSlice,
        treemapSliceDice: sliceDice,
        treemapSquarify: squarify,
        treemapResquarify: resquarify,
        interpolate: interpolateValue,
        interpolateArray: array$2,
        interpolateBasis: basis$2,
        interpolateBasisClosed: basisClosed$1,
        interpolateDate: date$1,
        interpolateDiscrete: discrete,
        interpolateHue: hue,
        interpolateNumber: interpolateNumber,
        interpolateNumberArray: numberArray,
        interpolateObject: object$1,
        interpolateRound: interpolateRound,
        interpolateString: interpolateString,
        interpolateTransformCss: interpolateTransformCss,
        interpolateTransformSvg: interpolateTransformSvg,
        interpolateZoom: interpolateZoom,
        interpolateRgb: interpolateRgb,
        interpolateRgbBasis: rgbBasis,
        interpolateRgbBasisClosed: rgbBasisClosed,
        interpolateHsl: hsl$1,
        interpolateHslLong: hslLong,
        interpolateLab: lab,
        interpolateHcl: hcl$1,
        interpolateHclLong: hclLong,
        interpolateCubehelix: cubehelix$2,
        interpolateCubehelixLong: cubehelixLong,
        piecewise: piecewise,
        quantize: quantize$1,
        path: path,
        polygonArea: area$1,
        polygonCentroid: centroid,
        polygonHull: hull,
        polygonContains: contains,
        polygonLength: length,
        quadtree: quadtree,
        randomUniform: uniform,
        randomNormal: normal,
        randomLogNormal: logNormal,
        randomBates: bates,
        randomIrwinHall: irwinHall,
        randomExponential: exponential,
        scaleBand: band,
        scalePoint: point$4,
        scaleIdentity: identity$2,
        scaleLinear: linear,
        scaleLog: log,
        scaleSymlog: symlog,
        scaleOrdinal: ordinal,
        scaleImplicit: implicit,
        scalePow: pow,
        scaleSqrt: sqrt$1,
        scaleQuantile: quantile,
        scaleQuantize: quantize,
        scaleThreshold: threshold,
        scaleTime: time,
        scaleUtc: utcTime,
        scaleSequential: sequential,
        scaleSequentialLog: sequentialLog,
        scaleSequentialPow: sequentialPow,
        scaleSequentialSqrt: sequentialSqrt,
        scaleSequentialSymlog: sequentialSymlog,
        scaleSequentialQuantile: sequentialQuantile,
        scaleDiverging: diverging$1,
        scaleDivergingLog: divergingLog,
        scaleDivergingPow: divergingPow,
        scaleDivergingSqrt: divergingSqrt,
        scaleDivergingSymlog: divergingSymlog,
        tickFormat: tickFormat,
        schemeCategory10: category10,
        schemeAccent: Accent,
        schemeDark2: Dark2,
        schemePaired: Paired,
        schemePastel1: Pastel1,
        schemePastel2: Pastel2,
        schemeSet1: Set1,
        schemeSet2: Set2,
        schemeSet3: Set3,
        schemeTableau10: Tableau10,
        interpolateBrBG: BrBG,
        schemeBrBG: scheme$q,
        interpolatePRGn: PRGn,
        schemePRGn: scheme$p,
        interpolatePiYG: PiYG,
        schemePiYG: scheme$o,
        interpolatePuOr: PuOr,
        schemePuOr: scheme$n,
        interpolateRdBu: RdBu,
        schemeRdBu: scheme$m,
        interpolateRdGy: RdGy,
        schemeRdGy: scheme$l,
        interpolateRdYlBu: RdYlBu,
        schemeRdYlBu: scheme$k,
        interpolateRdYlGn: RdYlGn,
        schemeRdYlGn: scheme$j,
        interpolateSpectral: Spectral,
        schemeSpectral: scheme$i,
        interpolateBuGn: BuGn,
        schemeBuGn: scheme$h,
        interpolateBuPu: BuPu,
        schemeBuPu: scheme$g,
        interpolateGnBu: GnBu,
        schemeGnBu: scheme$f,
        interpolateOrRd: OrRd,
        schemeOrRd: scheme$e,
        interpolatePuBuGn: PuBuGn,
        schemePuBuGn: scheme$d,
        interpolatePuBu: PuBu,
        schemePuBu: scheme$c,
        interpolatePuRd: PuRd,
        schemePuRd: scheme$b,
        interpolateRdPu: RdPu,
        schemeRdPu: scheme$a,
        interpolateYlGnBu: YlGnBu,
        schemeYlGnBu: scheme$9,
        interpolateYlGn: YlGn,
        schemeYlGn: scheme$8,
        interpolateYlOrBr: YlOrBr,
        schemeYlOrBr: scheme$7,
        interpolateYlOrRd: YlOrRd,
        schemeYlOrRd: scheme$6,
        interpolateBlues: Blues,
        schemeBlues: scheme$5,
        interpolateGreens: Greens,
        schemeGreens: scheme$4,
        interpolateGreys: Greys,
        schemeGreys: scheme$3,
        interpolatePurples: Purples,
        schemePurples: scheme$2,
        interpolateReds: Reds,
        schemeReds: scheme$1,
        interpolateOranges: Oranges,
        schemeOranges: scheme,
        interpolateCividis: cividis,
        interpolateCubehelixDefault: cubehelix,
        interpolateRainbow: rainbow,
        interpolateWarm: warm,
        interpolateCool: cool,
        interpolateSinebow: sinebow,
        interpolateTurbo: turbo,
        interpolateViridis: viridis,
        interpolateMagma: magma,
        interpolateInferno: inferno,
        interpolatePlasma: plasma,
        create: create$1,
        creator: creator,
        local: local$1,
        matcher: matcher,
        mouse: mouse,
        namespace: namespace,
        namespaces: namespaces,
        clientPoint: point$5,
        select: select,
        selectAll: selectAll,
        selection: selection,
        selector: selector,
        selectorAll: selectorAll,
        style: styleValue,
        touch: touch,
        touches: touches,
        window: defaultView,
        get event () { return event; },
        customEvent: customEvent,
        arc: arc,
        area: area,
        line: line,
        pie: pie,
        areaRadial: areaRadial,
        radialArea: areaRadial,
        lineRadial: lineRadial$1,
        radialLine: lineRadial$1,
        pointRadial: pointRadial,
        linkHorizontal: linkHorizontal,
        linkVertical: linkVertical,
        linkRadial: linkRadial,
        symbol: symbol,
        symbols: symbols,
        symbolCircle: circle,
        symbolCross: cross,
        symbolDiamond: diamond,
        symbolSquare: square,
        symbolStar: star,
        symbolTriangle: triangle,
        symbolWye: wye,
        curveBasisClosed: basisClosed,
        curveBasisOpen: basisOpen,
        curveBasis: basis,
        curveBundle: bundle,
        curveCardinalClosed: cardinalClosed,
        curveCardinalOpen: cardinalOpen,
        curveCardinal: cardinal,
        curveCatmullRomClosed: catmullRomClosed,
        curveCatmullRomOpen: catmullRomOpen,
        curveCatmullRom: catmullRom,
        curveLinearClosed: linearClosed,
        curveLinear: curveLinear,
        curveMonotoneX: monotoneX,
        curveMonotoneY: monotoneY,
        curveNatural: natural,
        curveStep: step,
        curveStepAfter: stepAfter,
        curveStepBefore: stepBefore,
        stack: stack,
        stackOffsetExpand: expand,
        stackOffsetDiverging: diverging,
        stackOffsetNone: none$1,
        stackOffsetSilhouette: silhouette,
        stackOffsetWiggle: wiggle,
        stackOrderAppearance: appearance,
        stackOrderAscending: ascending,
        stackOrderDescending: descending,
        stackOrderInsideOut: insideOut,
        stackOrderNone: none,
        stackOrderReverse: reverse,
        timeInterval: newInterval,
        timeMillisecond: utcMillisecond,
        timeMilliseconds: milliseconds,
        utcMillisecond: utcMillisecond,
        utcMilliseconds: milliseconds,
        timeSecond: utcSecond,
        timeSeconds: seconds,
        utcSecond: utcSecond,
        utcSeconds: seconds,
        timeMinute: timeMinute,
        timeMinutes: minutes,
        timeHour: timeHour,
        timeHours: hours,
        timeDay: timeDay,
        timeDays: days,
        timeWeek: sunday,
        timeWeeks: sundays,
        timeSunday: sunday,
        timeSundays: sundays,
        timeMonday: monday,
        timeMondays: mondays,
        timeTuesday: tuesday,
        timeTuesdays: tuesdays,
        timeWednesday: wednesday,
        timeWednesdays: wednesdays,
        timeThursday: thursday,
        timeThursdays: thursdays,
        timeFriday: friday,
        timeFridays: fridays,
        timeSaturday: saturday,
        timeSaturdays: saturdays,
        timeMonth: timeMonth,
        timeMonths: months,
        timeYear: timeYear,
        timeYears: years,
        utcMinute: utcMinute$1,
        utcMinutes: utcMinutes,
        utcHour: utcHour$1,
        utcHours: utcHours,
        utcDay: utcDay$1,
        utcDays: utcDays,
        utcWeek: utcSunday,
        utcWeeks: utcSundays,
        utcSunday: utcSunday,
        utcSundays: utcSundays,
        utcMonday: utcMonday,
        utcMondays: utcMondays,
        utcTuesday: utcTuesday,
        utcTuesdays: utcTuesdays,
        utcWednesday: utcWednesday,
        utcWednesdays: utcWednesdays,
        utcThursday: utcThursday,
        utcThursdays: utcThursdays,
        utcFriday: utcFriday,
        utcFridays: utcFridays,
        utcSaturday: utcSaturday,
        utcSaturdays: utcSaturdays,
        utcMonth: utcMonth$1,
        utcMonths: utcMonths,
        utcYear: utcYear$1,
        utcYears: utcYears,
        timeFormatDefaultLocale: defaultLocale,
        get timeFormat () { return timeFormat; },
        get timeParse () { return timeParse; },
        get utcFormat () { return utcFormat; },
        get utcParse () { return utcParse; },
        timeFormatLocale: formatLocale,
        isoFormat: formatIso$1,
        isoParse: parseIso$1,
        now: now,
        timer: timer,
        timerFlush: timerFlush,
        timeout: timeout,
        interval: interval,
        transition: transition,
        active: active,
        interrupt: interrupt,
        voronoi: voronoi,
        zoom: zoom,
        zoomTransform: transform,
        zoomIdentity: identity
    });

    var require$$0 = /*@__PURE__*/getAugmentedNamespace(d3);

    /* @license C3.js v0.7.20 | (c) C3 Team and other contributors | http://c3js.org/ */

    var c3 = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
      module.exports = factory() ;
    }(commonjsGlobal, (function () {
      function ChartInternal(api) {
          var $$ = this;
          // Note: This part will be replaced by rollup-plugin-modify
          // When bundling esm output. Beware of changing this line.
          // TODO: Maybe we should check that the modification by rollup-plugin-modify
          // is valid during unit tests.
          $$.d3 = window.d3
              ? window.d3
              : typeof commonjsRequire !== 'undefined'
                  ? require$$0
                  : undefined;
          $$.api = api;
          $$.config = $$.getDefaultConfig();
          $$.data = {};
          $$.cache = {};
          $$.axes = {};
      }

      /**
       * The Chart class
       *
       * The methods of this class is the public APIs of the chart object.
       */
      function Chart(config) {
          this.internal = new ChartInternal(this);
          this.internal.loadConfig(config);
          this.internal.beforeInit(config);
          this.internal.init();
          this.internal.afterInit(config);
          (function bindThis(fn, target, argThis) {
              Object.keys(fn).forEach(function (key) {
                  target[key] = fn[key].bind(argThis);
                  if (Object.keys(fn[key]).length > 0) {
                      bindThis(fn[key], target[key], argThis);
                  }
              });
          })(Chart.prototype, this, this);
      }

      var asHalfPixel = function (n) {
          return Math.ceil(n) + 0.5;
      };
      var ceil10 = function (v) {
          return Math.ceil(v / 10) * 10;
      };
      var diffDomain = function (d) {
          return d[1] - d[0];
      };
      var getOption = function (options, key, defaultValue) {
          return isDefined(options[key]) ? options[key] : defaultValue;
      };
      var getPathBox = function (path) {
          var box = getBBox(path), items = [path.pathSegList.getItem(0), path.pathSegList.getItem(1)], minX = items[0].x, minY = Math.min(items[0].y, items[1].y);
          return { x: minX, y: minY, width: box.width, height: box.height };
      };
      var getBBox = function (element) {
          try {
              return element.getBBox();
          }
          catch (ignore) {
              // Firefox will throw an exception if getBBox() is called whereas the
              // element is rendered with display:none
              // See https://github.com/c3js/c3/issues/2692
              // The previous code was using `getBoundingClientRect` which was returning
              // everything at 0 in this case so let's reproduce this behavior here.
              return { x: 0, y: 0, width: 0, height: 0 };
          }
      };
      var hasValue = function (dict, value) {
          var found = false;
          Object.keys(dict).forEach(function (key) {
              if (dict[key] === value) {
                  found = true;
              }
          });
          return found;
      };
      var isArray = function (o) {
          return Array.isArray(o);
      };
      var isDefined = function (v) {
          return typeof v !== 'undefined';
      };
      var isEmpty = function (o) {
          return (typeof o === 'undefined' ||
              o === null ||
              (isString(o) && o.length === 0) ||
              (typeof o === 'object' && Object.keys(o).length === 0));
      };
      var isFunction = function (o) {
          return typeof o === 'function';
      };
      var isNumber = function (o) {
          return typeof o === 'number';
      };
      var isString = function (o) {
          return typeof o === 'string';
      };
      var isUndefined = function (v) {
          return typeof v === 'undefined';
      };
      var isValue = function (v) {
          return v || v === 0;
      };
      var notEmpty = function (o) {
          return !isEmpty(o);
      };
      var sanitise = function (str) {
          return typeof str === 'string'
              ? str.replace(/</g, '&lt;').replace(/>/g, '&gt;')
              : str;
      };
      var flattenArray = function (arr) {
          return Array.isArray(arr) ? [].concat.apply([], arr) : [];
      };
      /**
       * Returns whether the point is within the given box.
       *
       * @param {Array} point An [x,y] coordinate
       * @param {Object} box An object with {x, y, width, height} keys
       * @param {Number} sensitivity An offset to ease check on very small boxes
       */
      var isWithinBox = function (point, box, sensitivity) {
          if (sensitivity === void 0) { sensitivity = 0; }
          var xStart = box.x - sensitivity;
          var xEnd = box.x + box.width + sensitivity;
          var yStart = box.y + box.height + sensitivity;
          var yEnd = box.y - sensitivity;
          return (xStart < point[0] && point[0] < xEnd && yEnd < point[1] && point[1] < yStart);
      };
      /**
       * Returns Internet Explorer version number (or false if no Internet Explorer used).
       *
       * @param string agent Optional parameter to specify user agent
       */
      var getIEVersion = function (agent) {
          // https://stackoverflow.com/questions/19999388/check-if-user-is-using-ie
          if (typeof agent === 'undefined') {
              agent = window.navigator.userAgent;
          }
          var pos = agent.indexOf('MSIE '); // up to IE10
          if (pos > 0) {
              return parseInt(agent.substring(pos + 5, agent.indexOf('.', pos)), 10);
          }
          pos = agent.indexOf('Trident/'); // IE11
          if (pos > 0) {
              pos = agent.indexOf('rv:');
              return parseInt(agent.substring(pos + 3, agent.indexOf('.', pos)), 10);
          }
          return false;
      };
      /**
       * Returns whether the used browser is Internet Explorer.
       *
       * @param version Optional parameter to specify IE version
       */
      var isIE = function (version) {
          var ver = getIEVersion();
          if (typeof version === 'undefined') {
              return !!ver;
          }
          return version === ver;
      };

      function AxisInternal(component, params) {
          var internal = this;
          internal.component = component;
          internal.params = params || {};
          internal.d3 = component.d3;
          internal.scale = internal.d3.scaleLinear();
          internal.range;
          internal.orient = 'bottom';
          internal.innerTickSize = 6;
          internal.outerTickSize = this.params.withOuterTick ? 6 : 0;
          internal.tickPadding = 3;
          internal.tickValues = null;
          internal.tickFormat;
          internal.tickArguments;
          internal.tickOffset = 0;
          internal.tickCulling = true;
          internal.tickCentered;
          internal.tickTextCharSize;
          internal.tickTextRotate = internal.params.tickTextRotate;
          internal.tickLength;
          internal.axis = internal.generateAxis();
      }
      AxisInternal.prototype.axisX = function (selection, x, tickOffset) {
          selection.attr('transform', function (d) {
              return 'translate(' + Math.ceil(x(d) + tickOffset) + ', 0)';
          });
      };
      AxisInternal.prototype.axisY = function (selection, y) {
          selection.attr('transform', function (d) {
              return 'translate(0,' + Math.ceil(y(d)) + ')';
          });
      };
      AxisInternal.prototype.scaleExtent = function (domain) {
          var start = domain[0], stop = domain[domain.length - 1];
          return start < stop ? [start, stop] : [stop, start];
      };
      AxisInternal.prototype.generateTicks = function (scale) {
          var internal = this;
          var i, domain, ticks = [];
          if (scale.ticks) {
              return scale.ticks.apply(scale, internal.tickArguments);
          }
          domain = scale.domain();
          for (i = Math.ceil(domain[0]); i < domain[1]; i++) {
              ticks.push(i);
          }
          if (ticks.length > 0 && ticks[0] > 0) {
              ticks.unshift(ticks[0] - (ticks[1] - ticks[0]));
          }
          return ticks;
      };
      AxisInternal.prototype.copyScale = function () {
          var internal = this;
          var newScale = internal.scale.copy(), domain;
          if (internal.params.isCategory) {
              domain = internal.scale.domain();
              newScale.domain([domain[0], domain[1] - 1]);
          }
          return newScale;
      };
      AxisInternal.prototype.textFormatted = function (v) {
          var internal = this, formatted = internal.tickFormat ? internal.tickFormat(v) : v;
          return typeof formatted !== 'undefined' ? formatted : '';
      };
      AxisInternal.prototype.updateRange = function () {
          var internal = this;
          internal.range = internal.scale.rangeExtent
              ? internal.scale.rangeExtent()
              : internal.scaleExtent(internal.scale.range());
          return internal.range;
      };
      AxisInternal.prototype.updateTickTextCharSize = function (tick) {
          var internal = this;
          if (internal.tickTextCharSize) {
              return internal.tickTextCharSize;
          }
          var size = {
              h: 11.5,
              w: 5.5
          };
          tick
              .select('text')
              .text(function (d) {
              return internal.textFormatted(d);
          })
              .each(function (d) {
              var box = getBBox(this), text = internal.textFormatted(d), h = box.height, w = text ? box.width / text.length : undefined;
              if (h && w) {
                  size.h = h;
                  size.w = w;
              }
          })
              .text('');
          internal.tickTextCharSize = size;
          return size;
      };
      AxisInternal.prototype.isVertical = function () {
          return this.orient === 'left' || this.orient === 'right';
      };
      AxisInternal.prototype.tspanData = function (d, i, scale) {
          var internal = this;
          var splitted = internal.params.tickMultiline
              ? internal.splitTickText(d, scale)
              : [].concat(internal.textFormatted(d));
          if (internal.params.tickMultiline && internal.params.tickMultilineMax > 0) {
              splitted = internal.ellipsify(splitted, internal.params.tickMultilineMax);
          }
          return splitted.map(function (s) {
              return { index: i, splitted: s, length: splitted.length };
          });
      };
      AxisInternal.prototype.splitTickText = function (d, scale) {
          var internal = this, tickText = internal.textFormatted(d), maxWidth = internal.params.tickWidth, subtext, spaceIndex, textWidth, splitted = [];
          if (Object.prototype.toString.call(tickText) === '[object Array]') {
              return tickText;
          }
          if (!maxWidth || maxWidth <= 0) {
              maxWidth = internal.isVertical()
                  ? 95
                  : internal.params.isCategory
                      ? Math.ceil(scale(1) - scale(0)) - 12
                      : 110;
          }
          function split(splitted, text) {
              spaceIndex = undefined;
              for (var i = 1; i < text.length; i++) {
                  if (text.charAt(i) === ' ') {
                      spaceIndex = i;
                  }
                  subtext = text.substr(0, i + 1);
                  textWidth = internal.tickTextCharSize.w * subtext.length;
                  // if text width gets over tick width, split by space index or crrent index
                  if (maxWidth < textWidth) {
                      return split(splitted.concat(text.substr(0, spaceIndex ? spaceIndex : i)), text.slice(spaceIndex ? spaceIndex + 1 : i));
                  }
              }
              return splitted.concat(text);
          }
          return split(splitted, tickText + '');
      };
      AxisInternal.prototype.ellipsify = function (splitted, max) {
          if (splitted.length <= max) {
              return splitted;
          }
          var ellipsified = splitted.slice(0, max);
          var remaining = 3;
          for (var i = max - 1; i >= 0; i--) {
              var available = ellipsified[i].length;
              ellipsified[i] = ellipsified[i]
                  .substr(0, available - remaining)
                  .padEnd(available, '.');
              remaining -= available;
              if (remaining <= 0) {
                  break;
              }
          }
          return ellipsified;
      };
      AxisInternal.prototype.updateTickLength = function () {
          var internal = this;
          internal.tickLength =
              Math.max(internal.innerTickSize, 0) + internal.tickPadding;
      };
      AxisInternal.prototype.lineY2 = function (d) {
          var internal = this, tickPosition = internal.scale(d) + (internal.tickCentered ? 0 : internal.tickOffset);
          return internal.range[0] < tickPosition && tickPosition < internal.range[1]
              ? internal.innerTickSize
              : 0;
      };
      AxisInternal.prototype.textY = function () {
          var internal = this, rotate = internal.tickTextRotate;
          return rotate
              ? 11.5 - 2.5 * (rotate / 15) * (rotate > 0 ? 1 : -1)
              : internal.tickLength;
      };
      AxisInternal.prototype.textTransform = function () {
          var internal = this, rotate = internal.tickTextRotate;
          return rotate ? 'rotate(' + rotate + ')' : '';
      };
      AxisInternal.prototype.textTextAnchor = function () {
          var internal = this, rotate = internal.tickTextRotate;
          return rotate ? (rotate > 0 ? 'start' : 'end') : 'middle';
      };
      AxisInternal.prototype.tspanDx = function () {
          var internal = this, rotate = internal.tickTextRotate;
          return rotate ? 8 * Math.sin(Math.PI * (rotate / 180)) : 0;
      };
      AxisInternal.prototype.tspanDy = function (d, i) {
          var internal = this, dy = internal.tickTextCharSize.h;
          if (i === 0) {
              if (internal.isVertical()) {
                  dy = -((d.length - 1) * (internal.tickTextCharSize.h / 2) - 3);
              }
              else {
                  dy = '.71em';
              }
          }
          return dy;
      };
      AxisInternal.prototype.generateAxis = function () {
          var internal = this, d3 = internal.d3, params = internal.params;
          function axis(g, transition) {
              var self;
              g.each(function () {
                  var g = (axis.g = d3.select(this));
                  var scale0 = this.__chart__ || internal.scale, scale1 = (this.__chart__ = internal.copyScale());
                  var ticksValues = internal.tickValues
                      ? internal.tickValues
                      : internal.generateTicks(scale1), ticks = g.selectAll('.tick').data(ticksValues, scale1), tickEnter = ticks
                      .enter()
                      .insert('g', '.domain')
                      .attr('class', 'tick')
                      .style('opacity', 1e-6), 
                  // MEMO: No exit transition. The reason is this transition affects max tick width calculation because old tick will be included in the ticks.
                  tickExit = ticks.exit().remove(), tickUpdate = ticks.merge(tickEnter), tickTransform, tickX, tickY;
                  if (params.isCategory) {
                      internal.tickOffset = Math.ceil((scale1(1) - scale1(0)) / 2);
                      tickX = internal.tickCentered ? 0 : internal.tickOffset;
                      tickY = internal.tickCentered ? internal.tickOffset : 0;
                  }
                  else {
                      internal.tickOffset = tickX = 0;
                  }
                  internal.updateRange();
                  internal.updateTickLength();
                  internal.updateTickTextCharSize(g.select('.tick'));
                  var lineUpdate = tickUpdate
                      .select('line')
                      .merge(tickEnter.append('line')), textUpdate = tickUpdate.select('text').merge(tickEnter.append('text'));
                  var tspans = tickUpdate
                      .selectAll('text')
                      .selectAll('tspan')
                      .data(function (d, i) {
                      return internal.tspanData(d, i, scale1);
                  }), tspanEnter = tspans.enter().append('tspan'), tspanUpdate = tspanEnter.merge(tspans).text(function (d) {
                      return d.splitted;
                  });
                  tspans.exit().remove();
                  var path = g.selectAll('.domain').data([0]), pathUpdate = path
                      .enter()
                      .append('path')
                      .merge(path)
                      .attr('class', 'domain');
                  // TODO: each attr should be one function and change its behavior by internal.orient, probably
                  switch (internal.orient) {
                      case 'bottom': {
                          tickTransform = internal.axisX;
                          lineUpdate
                              .attr('x1', tickX)
                              .attr('x2', tickX)
                              .attr('y2', function (d, i) {
                              return internal.lineY2(d, i);
                          });
                          textUpdate
                              .attr('x', 0)
                              .attr('y', function (d, i) {
                              return internal.textY(d, i);
                          })
                              .attr('transform', function (d, i) {
                              return internal.textTransform(d, i);
                          })
                              .style('text-anchor', function (d, i) {
                              return internal.textTextAnchor(d, i);
                          });
                          tspanUpdate
                              .attr('x', 0)
                              .attr('dy', function (d, i) {
                              return internal.tspanDy(d, i);
                          })
                              .attr('dx', function (d, i) {
                              return internal.tspanDx(d, i);
                          });
                          pathUpdate.attr('d', 'M' +
                              internal.range[0] +
                              ',' +
                              internal.outerTickSize +
                              'V0H' +
                              internal.range[1] +
                              'V' +
                              internal.outerTickSize);
                          break;
                      }
                      case 'top': {
                          // TODO: rotated tick text
                          tickTransform = internal.axisX;
                          lineUpdate
                              .attr('x1', tickX)
                              .attr('x2', tickX)
                              .attr('y2', function (d, i) {
                              return -1 * internal.lineY2(d, i);
                          });
                          textUpdate
                              .attr('x', 0)
                              .attr('y', function (d, i) {
                              return (-1 * internal.textY(d, i) -
                                  (params.isCategory ? 2 : internal.tickLength - 2));
                          })
                              .attr('transform', function (d, i) {
                              return internal.textTransform(d, i);
                          })
                              .style('text-anchor', function (d, i) {
                              return internal.textTextAnchor(d, i);
                          });
                          tspanUpdate
                              .attr('x', 0)
                              .attr('dy', function (d, i) {
                              return internal.tspanDy(d, i);
                          })
                              .attr('dx', function (d, i) {
                              return internal.tspanDx(d, i);
                          });
                          pathUpdate.attr('d', 'M' +
                              internal.range[0] +
                              ',' +
                              -internal.outerTickSize +
                              'V0H' +
                              internal.range[1] +
                              'V' +
                              -internal.outerTickSize);
                          break;
                      }
                      case 'left': {
                          tickTransform = internal.axisY;
                          lineUpdate
                              .attr('x2', -internal.innerTickSize)
                              .attr('y1', tickY)
                              .attr('y2', tickY);
                          textUpdate
                              .attr('x', -internal.tickLength)
                              .attr('y', internal.tickOffset)
                              .style('text-anchor', 'end');
                          tspanUpdate
                              .attr('x', -internal.tickLength)
                              .attr('dy', function (d, i) {
                              return internal.tspanDy(d, i);
                          });
                          pathUpdate.attr('d', 'M' +
                              -internal.outerTickSize +
                              ',' +
                              internal.range[0] +
                              'H0V' +
                              internal.range[1] +
                              'H' +
                              -internal.outerTickSize);
                          break;
                      }
                      case 'right': {
                          tickTransform = internal.axisY;
                          lineUpdate
                              .attr('x2', internal.innerTickSize)
                              .attr('y1', tickY)
                              .attr('y2', tickY);
                          textUpdate
                              .attr('x', internal.tickLength)
                              .attr('y', internal.tickOffset)
                              .style('text-anchor', 'start');
                          tspanUpdate.attr('x', internal.tickLength).attr('dy', function (d, i) {
                              return internal.tspanDy(d, i);
                          });
                          pathUpdate.attr('d', 'M' +
                              internal.outerTickSize +
                              ',' +
                              internal.range[0] +
                              'H0V' +
                              internal.range[1] +
                              'H' +
                              internal.outerTickSize);
                          break;
                      }
                  }
                  if (scale1.rangeBand) {
                      var x = scale1, dx = x.rangeBand() / 2;
                      scale0 = scale1 = function (d) {
                          return x(d) + dx;
                      };
                  }
                  else if (scale0.rangeBand) {
                      scale0 = scale1;
                  }
                  else {
                      tickExit.call(tickTransform, scale1, internal.tickOffset);
                  }
                  tickEnter.call(tickTransform, scale0, internal.tickOffset);
                  self = (transition ? tickUpdate.transition(transition) : tickUpdate)
                      .style('opacity', 1)
                      .call(tickTransform, scale1, internal.tickOffset);
              });
              return self;
          }
          axis.scale = function (x) {
              if (!arguments.length) {
                  return internal.scale;
              }
              internal.scale = x;
              return axis;
          };
          axis.orient = function (x) {
              if (!arguments.length) {
                  return internal.orient;
              }
              internal.orient =
                  x in { top: 1, right: 1, bottom: 1, left: 1 } ? x + '' : 'bottom';
              return axis;
          };
          axis.tickFormat = function (format) {
              if (!arguments.length) {
                  return internal.tickFormat;
              }
              internal.tickFormat = format;
              return axis;
          };
          axis.tickCentered = function (isCentered) {
              if (!arguments.length) {
                  return internal.tickCentered;
              }
              internal.tickCentered = isCentered;
              return axis;
          };
          axis.tickOffset = function () {
              return internal.tickOffset;
          };
          axis.tickInterval = function () {
              var interval, length;
              if (params.isCategory) {
                  interval = internal.tickOffset * 2;
              }
              else {
                  length =
                      axis.g
                          .select('path.domain')
                          .node()
                          .getTotalLength() -
                          internal.outerTickSize * 2;
                  interval = length / axis.g.selectAll('line').size();
              }
              return interval === Infinity ? 0 : interval;
          };
          axis.ticks = function () {
              if (!arguments.length) {
                  return internal.tickArguments;
              }
              internal.tickArguments = arguments;
              return axis;
          };
          axis.tickCulling = function (culling) {
              if (!arguments.length) {
                  return internal.tickCulling;
              }
              internal.tickCulling = culling;
              return axis;
          };
          axis.tickValues = function (x) {
              if (typeof x === 'function') {
                  internal.tickValues = function () {
                      return x(internal.scale.domain());
                  };
              }
              else {
                  if (!arguments.length) {
                      return internal.tickValues;
                  }
                  internal.tickValues = x;
              }
              return axis;
          };
          return axis;
      };

      var CLASS = {
          target: 'c3-target',
          chart: 'c3-chart',
          chartLine: 'c3-chart-line',
          chartLines: 'c3-chart-lines',
          chartBar: 'c3-chart-bar',
          chartBars: 'c3-chart-bars',
          chartText: 'c3-chart-text',
          chartTexts: 'c3-chart-texts',
          chartArc: 'c3-chart-arc',
          chartArcs: 'c3-chart-arcs',
          chartArcsTitle: 'c3-chart-arcs-title',
          chartArcsBackground: 'c3-chart-arcs-background',
          chartArcsGaugeUnit: 'c3-chart-arcs-gauge-unit',
          chartArcsGaugeMax: 'c3-chart-arcs-gauge-max',
          chartArcsGaugeMin: 'c3-chart-arcs-gauge-min',
          selectedCircle: 'c3-selected-circle',
          selectedCircles: 'c3-selected-circles',
          eventRect: 'c3-event-rect',
          eventRects: 'c3-event-rects',
          eventRectsSingle: 'c3-event-rects-single',
          eventRectsMultiple: 'c3-event-rects-multiple',
          zoomRect: 'c3-zoom-rect',
          brush: 'c3-brush',
          dragZoom: 'c3-drag-zoom',
          focused: 'c3-focused',
          defocused: 'c3-defocused',
          region: 'c3-region',
          regions: 'c3-regions',
          title: 'c3-title',
          tooltipContainer: 'c3-tooltip-container',
          tooltip: 'c3-tooltip',
          tooltipName: 'c3-tooltip-name',
          shape: 'c3-shape',
          shapes: 'c3-shapes',
          line: 'c3-line',
          lines: 'c3-lines',
          bar: 'c3-bar',
          bars: 'c3-bars',
          circle: 'c3-circle',
          circles: 'c3-circles',
          arc: 'c3-arc',
          arcLabelLine: 'c3-arc-label-line',
          arcs: 'c3-arcs',
          area: 'c3-area',
          areas: 'c3-areas',
          empty: 'c3-empty',
          text: 'c3-text',
          texts: 'c3-texts',
          gaugeValue: 'c3-gauge-value',
          grid: 'c3-grid',
          gridLines: 'c3-grid-lines',
          xgrid: 'c3-xgrid',
          xgrids: 'c3-xgrids',
          xgridLine: 'c3-xgrid-line',
          xgridLines: 'c3-xgrid-lines',
          xgridFocus: 'c3-xgrid-focus',
          ygrid: 'c3-ygrid',
          ygrids: 'c3-ygrids',
          ygridLine: 'c3-ygrid-line',
          ygridLines: 'c3-ygrid-lines',
          colorScale: 'c3-colorscale',
          stanfordElements: 'c3-stanford-elements',
          stanfordLine: 'c3-stanford-line',
          stanfordLines: 'c3-stanford-lines',
          stanfordRegion: 'c3-stanford-region',
          stanfordRegions: 'c3-stanford-regions',
          stanfordText: 'c3-stanford-text',
          stanfordTexts: 'c3-stanford-texts',
          axis: 'c3-axis',
          axisX: 'c3-axis-x',
          axisXLabel: 'c3-axis-x-label',
          axisY: 'c3-axis-y',
          axisYLabel: 'c3-axis-y-label',
          axisY2: 'c3-axis-y2',
          axisY2Label: 'c3-axis-y2-label',
          legendBackground: 'c3-legend-background',
          legendItem: 'c3-legend-item',
          legendItemEvent: 'c3-legend-item-event',
          legendItemTile: 'c3-legend-item-tile',
          legendItemHidden: 'c3-legend-item-hidden',
          legendItemFocused: 'c3-legend-item-focused',
          dragarea: 'c3-dragarea',
          EXPANDED: '_expanded_',
          SELECTED: '_selected_',
          INCLUDED: '_included_'
      };

      var AxisClass = /** @class */ (function () {
          function AxisClass(owner) {
              this.owner = owner;
              this.d3 = owner.d3;
              this.internal = AxisInternal;
          }
          return AxisClass;
      }());
      var Axis = AxisClass;
      Axis.prototype.init = function init() {
          var $$ = this.owner, config = $$.config, main = $$.main;
          $$.axes.x = main
              .append('g')
              .attr('class', CLASS.axis + ' ' + CLASS.axisX)
              .attr('clip-path', config.axis_x_inner ? '' : $$.clipPathForXAxis)
              .attr('transform', $$.getTranslate('x'))
              .style('visibility', config.axis_x_show ? 'visible' : 'hidden');
          $$.axes.x
              .append('text')
              .attr('class', CLASS.axisXLabel)
              .attr('transform', config.axis_rotated ? 'rotate(-90)' : '')
              .style('text-anchor', this.textAnchorForXAxisLabel.bind(this));
          $$.axes.y = main
              .append('g')
              .attr('class', CLASS.axis + ' ' + CLASS.axisY)
              .attr('clip-path', config.axis_y_inner ? '' : $$.clipPathForYAxis)
              .attr('transform', $$.getTranslate('y'))
              .style('visibility', config.axis_y_show ? 'visible' : 'hidden');
          $$.axes.y
              .append('text')
              .attr('class', CLASS.axisYLabel)
              .attr('transform', config.axis_rotated ? '' : 'rotate(-90)')
              .style('text-anchor', this.textAnchorForYAxisLabel.bind(this));
          $$.axes.y2 = main
              .append('g')
              .attr('class', CLASS.axis + ' ' + CLASS.axisY2)
              // clip-path?
              .attr('transform', $$.getTranslate('y2'))
              .style('visibility', config.axis_y2_show ? 'visible' : 'hidden');
          $$.axes.y2
              .append('text')
              .attr('class', CLASS.axisY2Label)
              .attr('transform', config.axis_rotated ? '' : 'rotate(-90)')
              .style('text-anchor', this.textAnchorForY2AxisLabel.bind(this));
      };
      Axis.prototype.getXAxis = function getXAxis(scale, orient, tickFormat, tickValues, withOuterTick, withoutTransition, withoutRotateTickText) {
          var $$ = this.owner, config = $$.config, axisParams = {
              isCategory: $$.isCategorized(),
              withOuterTick: withOuterTick,
              tickMultiline: config.axis_x_tick_multiline,
              tickMultilineMax: config.axis_x_tick_multiline
                  ? Number(config.axis_x_tick_multilineMax)
                  : 0,
              tickWidth: config.axis_x_tick_width,
              tickTextRotate: withoutRotateTickText ? 0 : config.axis_x_tick_rotate,
              withoutTransition: withoutTransition
          }, axis = new this.internal(this, axisParams).axis.scale(scale).orient(orient);
          if ($$.isTimeSeries() && tickValues && typeof tickValues !== 'function') {
              tickValues = tickValues.map(function (v) {
                  return $$.parseDate(v);
              });
          }
          // Set tick
          axis.tickFormat(tickFormat).tickValues(tickValues);
          if ($$.isCategorized()) {
              axis.tickCentered(config.axis_x_tick_centered);
              if (isEmpty(config.axis_x_tick_culling)) {
                  config.axis_x_tick_culling = false;
              }
          }
          return axis;
      };
      Axis.prototype.updateXAxisTickValues = function updateXAxisTickValues(targets, axis) {
          var $$ = this.owner, config = $$.config, tickValues;
          if (config.axis_x_tick_fit || config.axis_x_tick_count) {
              tickValues = this.generateTickValues($$.mapTargetsToUniqueXs(targets), config.axis_x_tick_count, $$.isTimeSeries());
          }
          if (axis) {
              axis.tickValues(tickValues);
          }
          else {
              $$.xAxis.tickValues(tickValues);
              $$.subXAxis.tickValues(tickValues);
          }
          return tickValues;
      };
      Axis.prototype.getYAxis = function getYAxis(axisId, scale, orient, tickValues, withOuterTick, withoutTransition, withoutRotateTickText) {
          var $$ = this.owner;
          var config = $$.config;
          var tickFormat = config["axis_" + axisId + "_tick_format"];
          if (!tickFormat && $$.isAxisNormalized(axisId)) {
              tickFormat = function (x) { return x + "%"; };
          }
          var axis = new this.internal(this, {
              withOuterTick: withOuterTick,
              withoutTransition: withoutTransition,
              tickTextRotate: withoutRotateTickText ? 0 : config.axis_y_tick_rotate
          }).axis
              .scale(scale)
              .orient(orient);
          if (tickFormat) {
              axis.tickFormat(tickFormat);
          }
          if ($$.isTimeSeriesY()) {
              axis.ticks(config.axis_y_tick_time_type, config.axis_y_tick_time_interval);
          }
          else {
              axis.tickValues(tickValues);
          }
          return axis;
      };
      Axis.prototype.getId = function getId(id) {
          var config = this.owner.config;
          return id in config.data_axes ? config.data_axes[id] : 'y';
      };
      Axis.prototype.getXAxisTickFormat = function getXAxisTickFormat() {
          // #2251 previously set any negative values to a whole number,
          // however both should be truncated according to the users format specification
          var $$ = this.owner, config = $$.config;
          var format = $$.isTimeSeries()
              ? $$.defaultAxisTimeFormat
              : $$.isCategorized()
                  ? $$.categoryName
                  : function (v) {
                      return v;
                  };
          if (config.axis_x_tick_format) {
              if (isFunction(config.axis_x_tick_format)) {
                  format = config.axis_x_tick_format;
              }
              else if ($$.isTimeSeries()) {
                  format = function (date) {
                      return date ? $$.axisTimeFormat(config.axis_x_tick_format)(date) : '';
                  };
              }
          }
          return isFunction(format)
              ? function (v) {
                  return format.call($$, v);
              }
              : format;
      };
      Axis.prototype.getTickValues = function getTickValues(tickValues, axis) {
          return tickValues ? tickValues : axis ? axis.tickValues() : undefined;
      };
      Axis.prototype.getXAxisTickValues = function getXAxisTickValues() {
          return this.getTickValues(this.owner.config.axis_x_tick_values, this.owner.xAxis);
      };
      Axis.prototype.getYAxisTickValues = function getYAxisTickValues() {
          return this.getTickValues(this.owner.config.axis_y_tick_values, this.owner.yAxis);
      };
      Axis.prototype.getY2AxisTickValues = function getY2AxisTickValues() {
          return this.getTickValues(this.owner.config.axis_y2_tick_values, this.owner.y2Axis);
      };
      Axis.prototype.getLabelOptionByAxisId = function getLabelOptionByAxisId(axisId) {
          var $$ = this.owner, config = $$.config, option;
          if (axisId === 'y') {
              option = config.axis_y_label;
          }
          else if (axisId === 'y2') {
              option = config.axis_y2_label;
          }
          else if (axisId === 'x') {
              option = config.axis_x_label;
          }
          return option;
      };
      Axis.prototype.getLabelText = function getLabelText(axisId) {
          var option = this.getLabelOptionByAxisId(axisId);
          return isString(option) ? option : option ? option.text : null;
      };
      Axis.prototype.setLabelText = function setLabelText(axisId, text) {
          var $$ = this.owner, config = $$.config, option = this.getLabelOptionByAxisId(axisId);
          if (isString(option)) {
              if (axisId === 'y') {
                  config.axis_y_label = text;
              }
              else if (axisId === 'y2') {
                  config.axis_y2_label = text;
              }
              else if (axisId === 'x') {
                  config.axis_x_label = text;
              }
          }
          else if (option) {
              option.text = text;
          }
      };
      Axis.prototype.getLabelPosition = function getLabelPosition(axisId, defaultPosition) {
          var option = this.getLabelOptionByAxisId(axisId), position = option && typeof option === 'object' && option.position
              ? option.position
              : defaultPosition;
          return {
              isInner: position.indexOf('inner') >= 0,
              isOuter: position.indexOf('outer') >= 0,
              isLeft: position.indexOf('left') >= 0,
              isCenter: position.indexOf('center') >= 0,
              isRight: position.indexOf('right') >= 0,
              isTop: position.indexOf('top') >= 0,
              isMiddle: position.indexOf('middle') >= 0,
              isBottom: position.indexOf('bottom') >= 0
          };
      };
      Axis.prototype.getXAxisLabelPosition = function getXAxisLabelPosition() {
          return this.getLabelPosition('x', this.owner.config.axis_rotated ? 'inner-top' : 'inner-right');
      };
      Axis.prototype.getYAxisLabelPosition = function getYAxisLabelPosition() {
          return this.getLabelPosition('y', this.owner.config.axis_rotated ? 'inner-right' : 'inner-top');
      };
      Axis.prototype.getY2AxisLabelPosition = function getY2AxisLabelPosition() {
          return this.getLabelPosition('y2', this.owner.config.axis_rotated ? 'inner-right' : 'inner-top');
      };
      Axis.prototype.getLabelPositionById = function getLabelPositionById(id) {
          return id === 'y2'
              ? this.getY2AxisLabelPosition()
              : id === 'y'
                  ? this.getYAxisLabelPosition()
                  : this.getXAxisLabelPosition();
      };
      Axis.prototype.textForXAxisLabel = function textForXAxisLabel() {
          return this.getLabelText('x');
      };
      Axis.prototype.textForYAxisLabel = function textForYAxisLabel() {
          return this.getLabelText('y');
      };
      Axis.prototype.textForY2AxisLabel = function textForY2AxisLabel() {
          return this.getLabelText('y2');
      };
      Axis.prototype.xForAxisLabel = function xForAxisLabel(forHorizontal, position) {
          var $$ = this.owner;
          if (forHorizontal) {
              return position.isLeft ? 0 : position.isCenter ? $$.width / 2 : $$.width;
          }
          else {
              return position.isBottom
                  ? -$$.height
                  : position.isMiddle
                      ? -$$.height / 2
                      : 0;
          }
      };
      Axis.prototype.dxForAxisLabel = function dxForAxisLabel(forHorizontal, position) {
          if (forHorizontal) {
              return position.isLeft ? '0.5em' : position.isRight ? '-0.5em' : '0';
          }
          else {
              return position.isTop ? '-0.5em' : position.isBottom ? '0.5em' : '0';
          }
      };
      Axis.prototype.textAnchorForAxisLabel = function textAnchorForAxisLabel(forHorizontal, position) {
          if (forHorizontal) {
              return position.isLeft ? 'start' : position.isCenter ? 'middle' : 'end';
          }
          else {
              return position.isBottom ? 'start' : position.isMiddle ? 'middle' : 'end';
          }
      };
      Axis.prototype.xForXAxisLabel = function xForXAxisLabel() {
          return this.xForAxisLabel(!this.owner.config.axis_rotated, this.getXAxisLabelPosition());
      };
      Axis.prototype.xForYAxisLabel = function xForYAxisLabel() {
          return this.xForAxisLabel(this.owner.config.axis_rotated, this.getYAxisLabelPosition());
      };
      Axis.prototype.xForY2AxisLabel = function xForY2AxisLabel() {
          return this.xForAxisLabel(this.owner.config.axis_rotated, this.getY2AxisLabelPosition());
      };
      Axis.prototype.dxForXAxisLabel = function dxForXAxisLabel() {
          return this.dxForAxisLabel(!this.owner.config.axis_rotated, this.getXAxisLabelPosition());
      };
      Axis.prototype.dxForYAxisLabel = function dxForYAxisLabel() {
          return this.dxForAxisLabel(this.owner.config.axis_rotated, this.getYAxisLabelPosition());
      };
      Axis.prototype.dxForY2AxisLabel = function dxForY2AxisLabel() {
          return this.dxForAxisLabel(this.owner.config.axis_rotated, this.getY2AxisLabelPosition());
      };
      Axis.prototype.dyForXAxisLabel = function dyForXAxisLabel() {
          var $$ = this.owner, config = $$.config, position = this.getXAxisLabelPosition();
          if (config.axis_rotated) {
              return position.isInner
                  ? '1.2em'
                  : -25 - ($$.config.axis_x_inner ? 0 : this.getMaxTickWidth('x'));
          }
          else {
              return position.isInner ? '-0.5em' : $$.getHorizontalAxisHeight('x') - 10;
          }
      };
      Axis.prototype.dyForYAxisLabel = function dyForYAxisLabel() {
          var $$ = this.owner, position = this.getYAxisLabelPosition();
          if ($$.config.axis_rotated) {
              return position.isInner ? '-0.5em' : '3em';
          }
          else {
              return position.isInner
                  ? '1.2em'
                  : -10 - ($$.config.axis_y_inner ? 0 : this.getMaxTickWidth('y') + 10);
          }
      };
      Axis.prototype.dyForY2AxisLabel = function dyForY2AxisLabel() {
          var $$ = this.owner, position = this.getY2AxisLabelPosition();
          if ($$.config.axis_rotated) {
              return position.isInner ? '1.2em' : '-2.2em';
          }
          else {
              return position.isInner
                  ? '-0.5em'
                  : 15 + ($$.config.axis_y2_inner ? 0 : this.getMaxTickWidth('y2') + 15);
          }
      };
      Axis.prototype.textAnchorForXAxisLabel = function textAnchorForXAxisLabel() {
          var $$ = this.owner;
          return this.textAnchorForAxisLabel(!$$.config.axis_rotated, this.getXAxisLabelPosition());
      };
      Axis.prototype.textAnchorForYAxisLabel = function textAnchorForYAxisLabel() {
          var $$ = this.owner;
          return this.textAnchorForAxisLabel($$.config.axis_rotated, this.getYAxisLabelPosition());
      };
      Axis.prototype.textAnchorForY2AxisLabel = function textAnchorForY2AxisLabel() {
          var $$ = this.owner;
          return this.textAnchorForAxisLabel($$.config.axis_rotated, this.getY2AxisLabelPosition());
      };
      Axis.prototype.getMaxTickWidth = function getMaxTickWidth(id, withoutRecompute) {
          var $$ = this.owner, maxWidth = 0, targetsToShow, scale, axis, dummy, svg;
          if (withoutRecompute && $$.currentMaxTickWidths[id]) {
              return $$.currentMaxTickWidths[id];
          }
          if ($$.svg) {
              targetsToShow = $$.filterTargetsToShow($$.data.targets);
              if (id === 'y') {
                  scale = $$.y.copy().domain($$.getYDomain(targetsToShow, 'y'));
                  axis = this.getYAxis(id, scale, $$.yOrient, $$.yAxisTickValues, false, true, true);
              }
              else if (id === 'y2') {
                  scale = $$.y2.copy().domain($$.getYDomain(targetsToShow, 'y2'));
                  axis = this.getYAxis(id, scale, $$.y2Orient, $$.y2AxisTickValues, false, true, true);
              }
              else {
                  scale = $$.x.copy().domain($$.getXDomain(targetsToShow));
                  axis = this.getXAxis(scale, $$.xOrient, $$.xAxisTickFormat, $$.xAxisTickValues, false, true, true);
                  this.updateXAxisTickValues(targetsToShow, axis);
              }
              dummy = $$.d3
                  .select('body')
                  .append('div')
                  .classed('c3', true);
              (svg = dummy
                  .append('svg')
                  .style('visibility', 'hidden')
                  .style('position', 'fixed')
                  .style('top', 0)
                  .style('left', 0)),
                  svg
                      .append('g')
                      .call(axis)
                      .each(function () {
                      $$.d3
                          .select(this)
                          .selectAll('text')
                          .each(function () {
                          var box = getBBox(this);
                          if (maxWidth < box.width) {
                              maxWidth = box.width;
                          }
                      });
                      dummy.remove();
                  });
          }
          $$.currentMaxTickWidths[id] =
              maxWidth <= 0 ? $$.currentMaxTickWidths[id] : maxWidth;
          return $$.currentMaxTickWidths[id];
      };
      Axis.prototype.updateLabels = function updateLabels(withTransition) {
          var $$ = this.owner;
          var axisXLabel = $$.main.select('.' + CLASS.axisX + ' .' + CLASS.axisXLabel), axisYLabel = $$.main.select('.' + CLASS.axisY + ' .' + CLASS.axisYLabel), axisY2Label = $$.main.select('.' + CLASS.axisY2 + ' .' + CLASS.axisY2Label);
          (withTransition ? axisXLabel.transition() : axisXLabel)
              .attr('x', this.xForXAxisLabel.bind(this))
              .attr('dx', this.dxForXAxisLabel.bind(this))
              .attr('dy', this.dyForXAxisLabel.bind(this))
              .text(this.textForXAxisLabel.bind(this));
          (withTransition ? axisYLabel.transition() : axisYLabel)
              .attr('x', this.xForYAxisLabel.bind(this))
              .attr('dx', this.dxForYAxisLabel.bind(this))
              .attr('dy', this.dyForYAxisLabel.bind(this))
              .text(this.textForYAxisLabel.bind(this));
          (withTransition ? axisY2Label.transition() : axisY2Label)
              .attr('x', this.xForY2AxisLabel.bind(this))
              .attr('dx', this.dxForY2AxisLabel.bind(this))
              .attr('dy', this.dyForY2AxisLabel.bind(this))
              .text(this.textForY2AxisLabel.bind(this));
      };
      Axis.prototype.getPadding = function getPadding(padding, key, defaultValue, domainLength) {
          var p = typeof padding === 'number' ? padding : padding[key];
          if (!isValue(p)) {
              return defaultValue;
          }
          if (padding.unit === 'ratio') {
              return padding[key] * domainLength;
          }
          // assume padding is pixels if unit is not specified
          return this.convertPixelsToAxisPadding(p, domainLength);
      };
      Axis.prototype.convertPixelsToAxisPadding = function convertPixelsToAxisPadding(pixels, domainLength) {
          var $$ = this.owner, length = $$.config.axis_rotated ? $$.width : $$.height;
          return domainLength * (pixels / length);
      };
      Axis.prototype.generateTickValues = function generateTickValues(values, tickCount, forTimeSeries) {
          var tickValues = values, targetCount, start, end, count, interval, i, tickValue;
          if (tickCount) {
              targetCount = isFunction(tickCount) ? tickCount() : tickCount;
              // compute ticks according to tickCount
              if (targetCount === 1) {
                  tickValues = [values[0]];
              }
              else if (targetCount === 2) {
                  tickValues = [values[0], values[values.length - 1]];
              }
              else if (targetCount > 2) {
                  count = targetCount - 2;
                  start = values[0];
                  end = values[values.length - 1];
                  interval = (end - start) / (count + 1);
                  // re-construct unique values
                  tickValues = [start];
                  for (i = 0; i < count; i++) {
                      tickValue = +start + interval * (i + 1);
                      tickValues.push(forTimeSeries ? new Date(tickValue) : tickValue);
                  }
                  tickValues.push(end);
              }
          }
          if (!forTimeSeries) {
              tickValues = tickValues.sort(function (a, b) {
                  return a - b;
              });
          }
          return tickValues;
      };
      Axis.prototype.generateTransitions = function generateTransitions(duration) {
          var $$ = this.owner, axes = $$.axes;
          return {
              axisX: duration ? axes.x.transition().duration(duration) : axes.x,
              axisY: duration ? axes.y.transition().duration(duration) : axes.y,
              axisY2: duration ? axes.y2.transition().duration(duration) : axes.y2,
              axisSubX: duration ? axes.subx.transition().duration(duration) : axes.subx
          };
      };
      Axis.prototype.redraw = function redraw(duration, isHidden) {
          var $$ = this.owner, transition = duration ? $$.d3.transition().duration(duration) : null;
          $$.axes.x.style('opacity', isHidden ? 0 : 1).call($$.xAxis, transition);
          $$.axes.y.style('opacity', isHidden ? 0 : 1).call($$.yAxis, transition);
          $$.axes.y2.style('opacity', isHidden ? 0 : 1).call($$.y2Axis, transition);
          $$.axes.subx.style('opacity', isHidden ? 0 : 1).call($$.subXAxis, transition);
      };

      var c3 = {
          version: '0.7.20',
          chart: {
              fn: Chart.prototype,
              internal: {
                  fn: ChartInternal.prototype,
                  axis: {
                      fn: AxisClass.prototype,
                      internal: {
                          fn: AxisInternal.prototype
                      }
                  }
              }
          },
          generate: function (config) {
              return new Chart(config);
          }
      };
      ChartInternal.prototype.beforeInit = function () {
          // can do something
      };
      ChartInternal.prototype.afterInit = function () {
          // can do something
      };
      ChartInternal.prototype.init = function () {
          var $$ = this, config = $$.config;
          $$.initParams();
          if (config.data_url) {
              $$.convertUrlToData(config.data_url, config.data_mimeType, config.data_headers, config.data_keys, $$.initWithData);
          }
          else if (config.data_json) {
              $$.initWithData($$.convertJsonToData(config.data_json, config.data_keys));
          }
          else if (config.data_rows) {
              $$.initWithData($$.convertRowsToData(config.data_rows));
          }
          else if (config.data_columns) {
              $$.initWithData($$.convertColumnsToData(config.data_columns));
          }
          else {
              throw Error('url or json or rows or columns is required.');
          }
      };
      ChartInternal.prototype.initParams = function () {
          var $$ = this, d3 = $$.d3, config = $$.config;
          // MEMO: clipId needs to be unique because it conflicts when multiple charts exist
          $$.clipId = 'c3-' + new Date().valueOf() + '-clip';
          $$.clipIdForXAxis = $$.clipId + '-xaxis';
          $$.clipIdForYAxis = $$.clipId + '-yaxis';
          $$.clipIdForGrid = $$.clipId + '-grid';
          $$.clipIdForSubchart = $$.clipId + '-subchart';
          $$.clipPath = $$.getClipPath($$.clipId);
          $$.clipPathForXAxis = $$.getClipPath($$.clipIdForXAxis);
          $$.clipPathForYAxis = $$.getClipPath($$.clipIdForYAxis);
          $$.clipPathForGrid = $$.getClipPath($$.clipIdForGrid);
          $$.clipPathForSubchart = $$.getClipPath($$.clipIdForSubchart);
          $$.dragStart = null;
          $$.dragging = false;
          $$.flowing = false;
          $$.cancelClick = false;
          $$.mouseover = undefined;
          $$.transiting = false;
          $$.color = $$.generateColor();
          $$.levelColor = $$.generateLevelColor();
          $$.dataTimeParse = (config.data_xLocaltime ? d3.timeParse : d3.utcParse)($$.config.data_xFormat);
          $$.axisTimeFormat = config.axis_x_localtime ? d3.timeFormat : d3.utcFormat;
          $$.defaultAxisTimeFormat = function (date) {
              if (date.getMilliseconds()) {
                  return d3.timeFormat('.%L')(date);
              }
              if (date.getSeconds()) {
                  return d3.timeFormat(':%S')(date);
              }
              if (date.getMinutes()) {
                  return d3.timeFormat('%I:%M')(date);
              }
              if (date.getHours()) {
                  return d3.timeFormat('%I %p')(date);
              }
              if (date.getDay() && date.getDate() !== 1) {
                  return d3.timeFormat('%-m/%-d')(date);
              }
              if (date.getDate() !== 1) {
                  return d3.timeFormat('%-m/%-d')(date);
              }
              if (date.getMonth()) {
                  return d3.timeFormat('%-m/%-d')(date);
              }
              return d3.timeFormat('%Y/%-m/%-d')(date);
          };
          $$.hiddenTargetIds = [];
          $$.hiddenLegendIds = [];
          $$.focusedTargetIds = [];
          $$.defocusedTargetIds = [];
          $$.xOrient = config.axis_rotated
              ? config.axis_x_inner
                  ? 'right'
                  : 'left'
              : config.axis_x_inner
                  ? 'top'
                  : 'bottom';
          $$.yOrient = config.axis_rotated
              ? config.axis_y_inner
                  ? 'top'
                  : 'bottom'
              : config.axis_y_inner
                  ? 'right'
                  : 'left';
          $$.y2Orient = config.axis_rotated
              ? config.axis_y2_inner
                  ? 'bottom'
                  : 'top'
              : config.axis_y2_inner
                  ? 'left'
                  : 'right';
          $$.subXOrient = config.axis_rotated ? 'left' : 'bottom';
          $$.isLegendRight = config.legend_position === 'right';
          $$.isLegendInset = config.legend_position === 'inset';
          $$.isLegendTop =
              config.legend_inset_anchor === 'top-left' ||
                  config.legend_inset_anchor === 'top-right';
          $$.isLegendLeft =
              config.legend_inset_anchor === 'top-left' ||
                  config.legend_inset_anchor === 'bottom-left';
          $$.legendStep = 0;
          $$.legendItemWidth = 0;
          $$.legendItemHeight = 0;
          $$.currentMaxTickWidths = {
              x: 0,
              y: 0,
              y2: 0
          };
          $$.rotated_padding_left = 30;
          $$.rotated_padding_right = config.axis_rotated && !config.axis_x_show ? 0 : 30;
          $$.rotated_padding_top = 5;
          $$.withoutFadeIn = {};
          $$.intervalForObserveInserted = undefined;
          $$.axes.subx = d3.selectAll([]); // needs when excluding subchart.js
      };
      ChartInternal.prototype.initChartElements = function () {
          if (this.initBar) {
              this.initBar();
          }
          if (this.initLine) {
              this.initLine();
          }
          if (this.initArc) {
              this.initArc();
          }
          if (this.initGauge) {
              this.initGauge();
          }
          if (this.initText) {
              this.initText();
          }
      };
      ChartInternal.prototype.initWithData = function (data) {
          var $$ = this, d3 = $$.d3, config = $$.config;
          var defs, main, binding = true;
          $$.axis = new AxisClass($$);
          if (!config.bindto) {
              $$.selectChart = d3.selectAll([]);
          }
          else if (typeof config.bindto.node === 'function') {
              $$.selectChart = config.bindto;
          }
          else {
              $$.selectChart = d3.select(config.bindto);
          }
          if ($$.selectChart.empty()) {
              $$.selectChart = d3
                  .select(document.createElement('div'))
                  .style('opacity', 0);
              $$.observeInserted($$.selectChart);
              binding = false;
          }
          $$.selectChart.html('').classed('c3', true);
          // Init data as targets
          $$.data.xs = {};
          $$.data.targets = $$.convertDataToTargets(data);
          if (config.data_filter) {
              $$.data.targets = $$.data.targets.filter(config.data_filter);
          }
          // Set targets to hide if needed
          if (config.data_hide) {
              $$.addHiddenTargetIds(config.data_hide === true
                  ? $$.mapToIds($$.data.targets)
                  : config.data_hide);
          }
          if (config.legend_hide) {
              $$.addHiddenLegendIds(config.legend_hide === true
                  ? $$.mapToIds($$.data.targets)
                  : config.legend_hide);
          }
          if ($$.isStanfordGraphType()) {
              $$.initStanfordData();
          }
          // Init sizes and scales
          $$.updateSizes();
          $$.updateScales();
          // Set domains for each scale
          $$.x.domain(d3.extent($$.getXDomain($$.data.targets)));
          $$.y.domain($$.getYDomain($$.data.targets, 'y'));
          $$.y2.domain($$.getYDomain($$.data.targets, 'y2'));
          $$.subX.domain($$.x.domain());
          $$.subY.domain($$.y.domain());
          $$.subY2.domain($$.y2.domain());
          // Save original x domain for zoom update
          $$.orgXDomain = $$.x.domain();
          /*-- Basic Elements --*/
          // Define svgs
          $$.svg = $$.selectChart
              .append('svg')
              .style('overflow', 'hidden')
              .on('mouseenter', function () {
              return config.onmouseover.call($$);
          })
              .on('mouseleave', function () {
              return config.onmouseout.call($$);
          });
          if ($$.config.svg_classname) {
              $$.svg.attr('class', $$.config.svg_classname);
          }
          // Define defs
          defs = $$.svg.append('defs');
          $$.clipChart = $$.appendClip(defs, $$.clipId);
          $$.clipXAxis = $$.appendClip(defs, $$.clipIdForXAxis);
          $$.clipYAxis = $$.appendClip(defs, $$.clipIdForYAxis);
          $$.clipGrid = $$.appendClip(defs, $$.clipIdForGrid);
          $$.clipSubchart = $$.appendClip(defs, $$.clipIdForSubchart);
          $$.updateSvgSize();
          // Define regions
          main = $$.main = $$.svg.append('g').attr('transform', $$.getTranslate('main'));
          if ($$.initPie) {
              $$.initPie();
          }
          if ($$.initDragZoom) {
              $$.initDragZoom();
          }
          if (config.subchart_show && $$.initSubchart) {
              $$.initSubchart();
          }
          if ($$.initTooltip) {
              $$.initTooltip();
          }
          if ($$.initLegend) {
              $$.initLegend();
          }
          if ($$.initTitle) {
              $$.initTitle();
          }
          if ($$.initZoom) {
              $$.initZoom();
          }
          if ($$.isStanfordGraphType()) {
              $$.drawColorScale();
          }
          // Update selection based on size and scale
          // TODO: currently this must be called after initLegend because of update of sizes, but it should be done in initSubchart.
          if (config.subchart_show && $$.initSubchartBrush) {
              $$.initSubchartBrush();
          }
          /*-- Main Region --*/
          // text when empty
          main
              .append('text')
              .attr('class', CLASS.text + ' ' + CLASS.empty)
              .attr('text-anchor', 'middle') // horizontal centering of text at x position in all browsers.
              .attr('dominant-baseline', 'middle'); // vertical centering of text at y position in all browsers, except IE.
          // Regions
          $$.initRegion();
          // Grids
          $$.initGrid();
          // Define g for chart area
          main
              .append('g')
              .attr('clip-path', $$.clipPath)
              .attr('class', CLASS.chart);
          // Grid lines
          if (config.grid_lines_front) {
              $$.initGridLines();
          }
          $$.initStanfordElements();
          // Cover whole with rects for events
          $$.initEventRect();
          // Define g for chart
          $$.initChartElements();
          // Add Axis
          $$.axis.init();
          // Set targets
          $$.updateTargets($$.data.targets);
          // Set default extent if defined
          if (config.axis_x_selection) {
              $$.brush.selectionAsValue($$.getDefaultSelection());
          }
          // Draw with targets
          if (binding) {
              $$.updateDimension();
              $$.config.oninit.call($$);
              $$.redraw({
                  withTransition: false,
                  withTransform: true,
                  withUpdateXDomain: true,
                  withUpdateOrgXDomain: true,
                  withTransitionForAxis: false
              });
          }
          // Bind to resize event
          $$.bindResize();
          // Bind to window focus event
          $$.bindWindowFocus();
          // export element of the chart
          $$.api.element = $$.selectChart.node();
      };
      ChartInternal.prototype.smoothLines = function (el, type) {
          var $$ = this;
          if (type === 'grid') {
              el.each(function () {
                  var g = $$.d3.select(this), x1 = g.attr('x1'), x2 = g.attr('x2'), y1 = g.attr('y1'), y2 = g.attr('y2');
                  g.attr({
                      x1: Math.ceil(x1),
                      x2: Math.ceil(x2),
                      y1: Math.ceil(y1),
                      y2: Math.ceil(y2)
                  });
              });
          }
      };
      ChartInternal.prototype.updateSizes = function () {
          var $$ = this, config = $$.config;
          var legendHeight = $$.legend ? $$.getLegendHeight() : 0, legendWidth = $$.legend ? $$.getLegendWidth() : 0, legendHeightForBottom = $$.isLegendRight || $$.isLegendInset ? 0 : legendHeight, hasArc = $$.hasArcType(), xAxisHeight = config.axis_rotated || hasArc ? 0 : $$.getHorizontalAxisHeight('x'), subchartXAxisHeight = config.axis_rotated || hasArc ? 0 : $$.getHorizontalAxisHeight('x', true), subchartHeight = config.subchart_show && !hasArc
              ? config.subchart_size_height + subchartXAxisHeight
              : 0;
          $$.currentWidth = $$.getCurrentWidth();
          $$.currentHeight = $$.getCurrentHeight();
          // for main
          $$.margin = config.axis_rotated
              ? {
                  top: $$.getHorizontalAxisHeight('y2') + $$.getCurrentPaddingTop(),
                  right: hasArc ? 0 : $$.getCurrentPaddingRight(),
                  bottom: $$.getHorizontalAxisHeight('y') +
                      legendHeightForBottom +
                      $$.getCurrentPaddingBottom(),
                  left: subchartHeight + (hasArc ? 0 : $$.getCurrentPaddingLeft())
              }
              : {
                  top: 4 + $$.getCurrentPaddingTop(),
                  right: hasArc ? 0 : $$.getCurrentPaddingRight(),
                  bottom: xAxisHeight +
                      subchartHeight +
                      legendHeightForBottom +
                      $$.getCurrentPaddingBottom(),
                  left: hasArc ? 0 : $$.getCurrentPaddingLeft()
              };
          // for subchart
          $$.margin2 = config.axis_rotated
              ? {
                  top: $$.margin.top,
                  right: NaN,
                  bottom: 20 + legendHeightForBottom,
                  left: $$.rotated_padding_left
              }
              : {
                  top: $$.currentHeight - subchartHeight - legendHeightForBottom,
                  right: NaN,
                  bottom: subchartXAxisHeight + legendHeightForBottom,
                  left: $$.margin.left
              };
          // for legend
          $$.margin3 = {
              top: 0,
              right: NaN,
              bottom: 0,
              left: 0
          };
          if ($$.updateSizeForLegend) {
              $$.updateSizeForLegend(legendHeight, legendWidth);
          }
          $$.width = $$.currentWidth - $$.margin.left - $$.margin.right;
          $$.height = $$.currentHeight - $$.margin.top - $$.margin.bottom;
          if ($$.width < 0) {
              $$.width = 0;
          }
          if ($$.height < 0) {
              $$.height = 0;
          }
          $$.width2 = config.axis_rotated
              ? $$.margin.left - $$.rotated_padding_left - $$.rotated_padding_right
              : $$.width;
          $$.height2 = config.axis_rotated
              ? $$.height
              : $$.currentHeight - $$.margin2.top - $$.margin2.bottom;
          if ($$.width2 < 0) {
              $$.width2 = 0;
          }
          if ($$.height2 < 0) {
              $$.height2 = 0;
          }
          // for arc
          $$.arcWidth = $$.width - ($$.isLegendRight ? legendWidth + 10 : 0);
          $$.arcHeight = $$.height - ($$.isLegendRight ? 0 : 10);
          if ($$.hasType('gauge') && !config.gauge_fullCircle) {
              $$.arcHeight += $$.height - $$.getGaugeLabelHeight();
          }
          if ($$.updateRadius) {
              $$.updateRadius();
          }
          if ($$.isLegendRight && hasArc) {
              $$.margin3.left = $$.arcWidth / 2 + $$.radiusExpanded * 1.1;
          }
      };
      ChartInternal.prototype.updateTargets = function (targets) {
          var $$ = this, config = $$.config;
          /*-- Main --*/
          //-- Text --//
          $$.updateTargetsForText(targets);
          //-- Bar --//
          $$.updateTargetsForBar(targets);
          //-- Line --//
          $$.updateTargetsForLine(targets);
          //-- Arc --//
          if ($$.hasArcType() && $$.updateTargetsForArc) {
              $$.updateTargetsForArc(targets);
          }
          /*-- Sub --*/
          if (config.subchart_show && $$.updateTargetsForSubchart) {
              $$.updateTargetsForSubchart(targets);
          }
          // Fade-in each chart
          $$.showTargets();
      };
      ChartInternal.prototype.showTargets = function () {
          var $$ = this;
          $$.svg
              .selectAll('.' + CLASS.target)
              .filter(function (d) {
              return $$.isTargetToShow(d.id);
          })
              .transition()
              .duration($$.config.transition_duration)
              .style('opacity', 1);
      };
      ChartInternal.prototype.redraw = function (options, transitions) {
          var $$ = this, main = $$.main, d3 = $$.d3, config = $$.config;
          var areaIndices = $$.getShapeIndices($$.isAreaType), barIndices = $$.getShapeIndices($$.isBarType), lineIndices = $$.getShapeIndices($$.isLineType);
          var withY, withSubchart, withTransition, withTransitionForExit, withTransitionForAxis, withTransform, withUpdateXDomain, withUpdateOrgXDomain, withTrimXDomain, withLegend, withEventRect, withDimension, withUpdateXAxis;
          var hideAxis = $$.hasArcType();
          var drawArea, drawBar, drawLine, xForText, yForText;
          var duration, durationForExit, durationForAxis;
          var transitionsToWait, waitForDraw, flow, transition;
          var targetsToShow = $$.filterTargetsToShow($$.data.targets), tickValues, i, intervalForCulling, xDomainForZoom;
          var xv = $$.xv.bind($$), cx, cy;
          options = options || {};
          withY = getOption(options, 'withY', true);
          withSubchart = getOption(options, 'withSubchart', true);
          withTransition = getOption(options, 'withTransition', true);
          withTransform = getOption(options, 'withTransform', false);
          withUpdateXDomain = getOption(options, 'withUpdateXDomain', false);
          withUpdateOrgXDomain = getOption(options, 'withUpdateOrgXDomain', false);
          withTrimXDomain = getOption(options, 'withTrimXDomain', true);
          withUpdateXAxis = getOption(options, 'withUpdateXAxis', withUpdateXDomain);
          withLegend = getOption(options, 'withLegend', false);
          withEventRect = getOption(options, 'withEventRect', true);
          withDimension = getOption(options, 'withDimension', true);
          withTransitionForExit = getOption(options, 'withTransitionForExit', withTransition);
          withTransitionForAxis = getOption(options, 'withTransitionForAxis', withTransition);
          duration = withTransition ? config.transition_duration : 0;
          durationForExit = withTransitionForExit ? duration : 0;
          durationForAxis = withTransitionForAxis ? duration : 0;
          transitions = transitions || $$.axis.generateTransitions(durationForAxis);
          // update legend and transform each g
          if (withLegend && config.legend_show) {
              $$.updateLegend($$.mapToIds($$.data.targets), options, transitions);
          }
          else if (withDimension) {
              // need to update dimension (e.g. axis.y.tick.values) because y tick values should change
              // no need to update axis in it because they will be updated in redraw()
              $$.updateDimension(true);
          }
          // MEMO: needed for grids calculation
          if ($$.isCategorized() && targetsToShow.length === 0) {
              $$.x.domain([0, $$.axes.x.selectAll('.tick').size()]);
          }
          if (targetsToShow.length) {
              $$.updateXDomain(targetsToShow, withUpdateXDomain, withUpdateOrgXDomain, withTrimXDomain);
              if (!config.axis_x_tick_values) {
                  tickValues = $$.axis.updateXAxisTickValues(targetsToShow);
              }
          }
          else {
              $$.xAxis.tickValues([]);
              $$.subXAxis.tickValues([]);
          }
          if (config.zoom_rescale && !options.flow) {
              xDomainForZoom = $$.x.orgDomain();
          }
          $$.y.domain($$.getYDomain(targetsToShow, 'y', xDomainForZoom));
          $$.y2.domain($$.getYDomain(targetsToShow, 'y2', xDomainForZoom));
          if (!config.axis_y_tick_values && config.axis_y_tick_count) {
              $$.yAxis.tickValues($$.axis.generateTickValues($$.y.domain(), config.axis_y_tick_count));
          }
          if (!config.axis_y2_tick_values && config.axis_y2_tick_count) {
              $$.y2Axis.tickValues($$.axis.generateTickValues($$.y2.domain(), config.axis_y2_tick_count));
          }
          // axes
          $$.axis.redraw(durationForAxis, hideAxis);
          // Update axis label
          $$.axis.updateLabels(withTransition);
          // show/hide if manual culling needed
          if ((withUpdateXDomain || withUpdateXAxis) && targetsToShow.length) {
              if (config.axis_x_tick_culling && tickValues) {
                  for (i = 1; i < tickValues.length; i++) {
                      if (tickValues.length / i < config.axis_x_tick_culling_max) {
                          intervalForCulling = i;
                          break;
                      }
                  }
                  $$.svg.selectAll('.' + CLASS.axisX + ' .tick text').each(function (e) {
                      var index = tickValues.indexOf(e);
                      if (index >= 0) {
                          d3.select(this).style('display', index % intervalForCulling ? 'none' : 'block');
                      }
                  });
              }
              else {
                  $$.svg
                      .selectAll('.' + CLASS.axisX + ' .tick text')
                      .style('display', 'block');
              }
          }
          // setup drawer - MEMO: these must be called after axis updated
          drawArea = $$.generateDrawArea
              ? $$.generateDrawArea(areaIndices, false)
              : undefined;
          drawBar = $$.generateDrawBar ? $$.generateDrawBar(barIndices) : undefined;
          drawLine = $$.generateDrawLine
              ? $$.generateDrawLine(lineIndices, false)
              : undefined;
          xForText = $$.generateXYForText(areaIndices, barIndices, lineIndices, true);
          yForText = $$.generateXYForText(areaIndices, barIndices, lineIndices, false);
          // update circleY based on updated parameters
          $$.updateCircleY();
          // generate circle x/y functions depending on updated params
          cx = ($$.config.axis_rotated ? $$.circleY : $$.circleX).bind($$);
          cy = ($$.config.axis_rotated ? $$.circleX : $$.circleY).bind($$);
          // Update sub domain
          if (withY) {
              $$.subY.domain($$.getYDomain(targetsToShow, 'y'));
              $$.subY2.domain($$.getYDomain(targetsToShow, 'y2'));
          }
          // xgrid focus
          $$.updateXgridFocus();
          // Data empty label positioning and text.
          main
              .select('text.' + CLASS.text + '.' + CLASS.empty)
              .attr('x', $$.width / 2)
              .attr('y', $$.height / 2)
              .text(config.data_empty_label_text)
              .transition()
              .style('opacity', targetsToShow.length ? 0 : 1);
          // event rect
          if (withEventRect) {
              $$.redrawEventRect();
          }
          // grid
          $$.updateGrid(duration);
          $$.updateStanfordElements(duration);
          // rect for regions
          $$.updateRegion(duration);
          // bars
          $$.updateBar(durationForExit);
          // lines, areas and circles
          $$.updateLine(durationForExit);
          $$.updateArea(durationForExit);
          $$.updateCircle(cx, cy);
          // text
          if ($$.hasDataLabel()) {
              $$.updateText(xForText, yForText, durationForExit);
          }
          // title
          if ($$.redrawTitle) {
              $$.redrawTitle();
          }
          // arc
          if ($$.redrawArc) {
              $$.redrawArc(duration, durationForExit, withTransform);
          }
          // subchart
          if (config.subchart_show && $$.redrawSubchart) {
              $$.redrawSubchart(withSubchart, transitions, duration, durationForExit, areaIndices, barIndices, lineIndices);
          }
          if ($$.isStanfordGraphType()) {
              $$.drawColorScale();
          }
          // circles for select
          main
              .selectAll('.' + CLASS.selectedCircles)
              .filter($$.isBarType.bind($$))
              .selectAll('circle')
              .remove();
          if (options.flow) {
              flow = $$.generateFlow({
                  targets: targetsToShow,
                  flow: options.flow,
                  duration: options.flow.duration,
                  drawBar: drawBar,
                  drawLine: drawLine,
                  drawArea: drawArea,
                  cx: cx,
                  cy: cy,
                  xv: xv,
                  xForText: xForText,
                  yForText: yForText
              });
          }
          if (duration && $$.isTabVisible()) {
              // Only use transition if tab visible. See #938.
              // transition should be derived from one transition
              transition = d3.transition().duration(duration);
              transitionsToWait = [];
              [
                  $$.redrawBar(drawBar, true, transition),
                  $$.redrawLine(drawLine, true, transition),
                  $$.redrawArea(drawArea, true, transition),
                  $$.redrawCircle(cx, cy, true, transition),
                  $$.redrawText(xForText, yForText, options.flow, true, transition),
                  $$.redrawRegion(true, transition),
                  $$.redrawGrid(true, transition)
              ].forEach(function (transitions) {
                  transitions.forEach(function (transition) {
                      transitionsToWait.push(transition);
                  });
              });
              // Wait for end of transitions to call flow and onrendered callback
              waitForDraw = $$.generateWait();
              transitionsToWait.forEach(function (t) {
                  waitForDraw.add(t);
              });
              waitForDraw(function () {
                  if (flow) {
                      flow();
                  }
                  if (config.onrendered) {
                      config.onrendered.call($$);
                  }
              });
          }
          else {
              $$.redrawBar(drawBar);
              $$.redrawLine(drawLine);
              $$.redrawArea(drawArea);
              $$.redrawCircle(cx, cy);
              $$.redrawText(xForText, yForText, options.flow);
              $$.redrawRegion();
              $$.redrawGrid();
              if (flow) {
                  flow();
              }
              if (config.onrendered) {
                  config.onrendered.call($$);
              }
          }
          // update fadein condition
          $$.mapToIds($$.data.targets).forEach(function (id) {
              $$.withoutFadeIn[id] = true;
          });
      };
      ChartInternal.prototype.updateAndRedraw = function (options) {
          var $$ = this, config = $$.config, transitions;
          options = options || {};
          // same with redraw
          options.withTransition = getOption(options, 'withTransition', true);
          options.withTransform = getOption(options, 'withTransform', false);
          options.withLegend = getOption(options, 'withLegend', false);
          // NOT same with redraw
          options.withUpdateXDomain = getOption(options, 'withUpdateXDomain', true);
          options.withUpdateOrgXDomain = getOption(options, 'withUpdateOrgXDomain', true);
          options.withTransitionForExit = false;
          options.withTransitionForTransform = getOption(options, 'withTransitionForTransform', options.withTransition);
          // MEMO: this needs to be called before updateLegend and it means this ALWAYS needs to be called)
          $$.updateSizes();
          // MEMO: called in updateLegend in redraw if withLegend
          if (!(options.withLegend && config.legend_show)) {
              transitions = $$.axis.generateTransitions(options.withTransitionForAxis ? config.transition_duration : 0);
              // Update scales
              $$.updateScales();
              $$.updateSvgSize();
              // Update g positions
              $$.transformAll(options.withTransitionForTransform, transitions);
          }
          // Draw with new sizes & scales
          $$.redraw(options, transitions);
      };
      ChartInternal.prototype.redrawWithoutRescale = function () {
          this.redraw({
              withY: false,
              withSubchart: false,
              withEventRect: false,
              withTransitionForAxis: false
          });
      };
      ChartInternal.prototype.isTimeSeries = function () {
          return this.config.axis_x_type === 'timeseries';
      };
      ChartInternal.prototype.isCategorized = function () {
          return this.config.axis_x_type.indexOf('categor') >= 0;
      };
      ChartInternal.prototype.isCustomX = function () {
          var $$ = this, config = $$.config;
          return !$$.isTimeSeries() && (config.data_x || notEmpty(config.data_xs));
      };
      ChartInternal.prototype.isTimeSeriesY = function () {
          return this.config.axis_y_type === 'timeseries';
      };
      ChartInternal.prototype.getTranslate = function (target) {
          var $$ = this, config = $$.config, x, y;
          if (target === 'main') {
              x = asHalfPixel($$.margin.left);
              y = asHalfPixel($$.margin.top);
          }
          else if (target === 'context') {
              x = asHalfPixel($$.margin2.left);
              y = asHalfPixel($$.margin2.top);
          }
          else if (target === 'legend') {
              x = $$.margin3.left;
              y = $$.margin3.top;
          }
          else if (target === 'x') {
              x = 0;
              y = config.axis_rotated ? 0 : $$.height;
          }
          else if (target === 'y') {
              x = 0;
              y = config.axis_rotated ? $$.height : 0;
          }
          else if (target === 'y2') {
              x = config.axis_rotated ? 0 : $$.width;
              y = config.axis_rotated ? 1 : 0;
          }
          else if (target === 'subx') {
              x = 0;
              y = config.axis_rotated ? 0 : $$.height2;
          }
          else if (target === 'arc') {
              x = $$.arcWidth / 2;
              y = $$.arcHeight / 2 - ($$.hasType('gauge') ? 6 : 0); // to prevent wrong display of min and max label
          }
          return 'translate(' + x + ',' + y + ')';
      };
      ChartInternal.prototype.initialOpacity = function (d) {
          return d.value !== null && this.withoutFadeIn[d.id] ? 1 : 0;
      };
      ChartInternal.prototype.initialOpacityForCircle = function (d) {
          return d.value !== null && this.withoutFadeIn[d.id]
              ? this.opacityForCircle(d)
              : 0;
      };
      ChartInternal.prototype.opacityForCircle = function (d) {
          var isPointShouldBeShown = isFunction(this.config.point_show)
              ? this.config.point_show(d)
              : this.config.point_show;
          var opacity = isPointShouldBeShown || this.isStanfordType(d) ? 1 : 0;
          return isValue(d.value) ? (this.isScatterType(d) ? 0.5 : opacity) : 0;
      };
      ChartInternal.prototype.opacityForText = function () {
          return this.hasDataLabel() ? 1 : 0;
      };
      ChartInternal.prototype.xx = function (d) {
          return d ? this.x(d.x) : null;
      };
      ChartInternal.prototype.xvCustom = function (d, xyValue) {
          var $$ = this, value = xyValue ? d[xyValue] : d.value;
          if ($$.isTimeSeries()) {
              value = $$.parseDate(d.value);
          }
          else if ($$.isCategorized() && typeof d.value === 'string') {
              value = $$.config.axis_x_categories.indexOf(d.value);
          }
          return Math.ceil($$.x(value));
      };
      ChartInternal.prototype.yvCustom = function (d, xyValue) {
          var $$ = this, yScale = d.axis && d.axis === 'y2' ? $$.y2 : $$.y, value = xyValue ? d[xyValue] : d.value;
          return Math.ceil(yScale(value));
      };
      ChartInternal.prototype.xv = function (d) {
          var $$ = this, value = d.value;
          if ($$.isTimeSeries()) {
              value = $$.parseDate(d.value);
          }
          else if ($$.isCategorized() && typeof d.value === 'string') {
              value = $$.config.axis_x_categories.indexOf(d.value);
          }
          return Math.ceil($$.x(value));
      };
      ChartInternal.prototype.yv = function (d) {
          var $$ = this, yScale = d.axis && d.axis === 'y2' ? $$.y2 : $$.y;
          return Math.ceil(yScale(d.value));
      };
      ChartInternal.prototype.subxx = function (d) {
          return d ? this.subX(d.x) : null;
      };
      ChartInternal.prototype.transformMain = function (withTransition, transitions) {
          var $$ = this, xAxis, yAxis, y2Axis;
          if (transitions && transitions.axisX) {
              xAxis = transitions.axisX;
          }
          else {
              xAxis = $$.main.select('.' + CLASS.axisX);
              if (withTransition) {
                  xAxis = xAxis.transition();
              }
          }
          if (transitions && transitions.axisY) {
              yAxis = transitions.axisY;
          }
          else {
              yAxis = $$.main.select('.' + CLASS.axisY);
              if (withTransition) {
                  yAxis = yAxis.transition();
              }
          }
          if (transitions && transitions.axisY2) {
              y2Axis = transitions.axisY2;
          }
          else {
              y2Axis = $$.main.select('.' + CLASS.axisY2);
              if (withTransition) {
                  y2Axis = y2Axis.transition();
              }
          }
          (withTransition ? $$.main.transition() : $$.main).attr('transform', $$.getTranslate('main'));
          xAxis.attr('transform', $$.getTranslate('x'));
          yAxis.attr('transform', $$.getTranslate('y'));
          y2Axis.attr('transform', $$.getTranslate('y2'));
          $$.main
              .select('.' + CLASS.chartArcs)
              .attr('transform', $$.getTranslate('arc'));
      };
      ChartInternal.prototype.transformAll = function (withTransition, transitions) {
          var $$ = this;
          $$.transformMain(withTransition, transitions);
          if ($$.config.subchart_show) {
              $$.transformContext(withTransition, transitions);
          }
          if ($$.legend) {
              $$.transformLegend(withTransition);
          }
      };
      ChartInternal.prototype.updateSvgSize = function () {
          var $$ = this, brush = $$.svg.select("." + CLASS.brush + " .overlay");
          $$.svg.attr('width', $$.currentWidth).attr('height', $$.currentHeight);
          $$.svg
              .selectAll(['#' + $$.clipId, '#' + $$.clipIdForGrid])
              .select('rect')
              .attr('width', $$.width)
              .attr('height', $$.height);
          $$.svg
              .select('#' + $$.clipIdForXAxis)
              .select('rect')
              .attr('x', $$.getXAxisClipX.bind($$))
              .attr('y', $$.getXAxisClipY.bind($$))
              .attr('width', $$.getXAxisClipWidth.bind($$))
              .attr('height', $$.getXAxisClipHeight.bind($$));
          $$.svg
              .select('#' + $$.clipIdForYAxis)
              .select('rect')
              .attr('x', $$.getYAxisClipX.bind($$))
              .attr('y', $$.getYAxisClipY.bind($$))
              .attr('width', $$.getYAxisClipWidth.bind($$))
              .attr('height', $$.getYAxisClipHeight.bind($$));
          $$.svg
              .select('#' + $$.clipIdForSubchart)
              .select('rect')
              .attr('width', $$.width)
              .attr('height', (brush.size() && brush.attr('height')) || 0);
          // MEMO: parent div's height will be bigger than svg when <!DOCTYPE html>
          $$.selectChart.style('max-height', $$.currentHeight + 'px');
      };
      ChartInternal.prototype.updateDimension = function (withoutAxis) {
          var $$ = this;
          if (!withoutAxis) {
              if ($$.config.axis_rotated) {
                  $$.axes.x.call($$.xAxis);
                  $$.axes.subx.call($$.subXAxis);
              }
              else {
                  $$.axes.y.call($$.yAxis);
                  $$.axes.y2.call($$.y2Axis);
              }
          }
          $$.updateSizes();
          $$.updateScales();
          $$.updateSvgSize();
          $$.transformAll(false);
      };
      ChartInternal.prototype.observeInserted = function (selection) {
          var $$ = this, observer;
          if (typeof MutationObserver === 'undefined') {
              window.console.error('MutationObserver not defined.');
              return;
          }
          observer = new MutationObserver(function (mutations) {
              mutations.forEach(function (mutation) {
                  if (mutation.type === 'childList' && mutation.previousSibling) {
                      observer.disconnect();
                      // need to wait for completion of load because size calculation requires the actual sizes determined after that completion
                      $$.intervalForObserveInserted = window.setInterval(function () {
                          // parentNode will NOT be null when completed
                          if (selection.node().parentNode) {
                              window.clearInterval($$.intervalForObserveInserted);
                              $$.updateDimension();
                              if ($$.brush) {
                                  $$.brush.update();
                              }
                              $$.config.oninit.call($$);
                              $$.redraw({
                                  withTransform: true,
                                  withUpdateXDomain: true,
                                  withUpdateOrgXDomain: true,
                                  withTransition: false,
                                  withTransitionForTransform: false,
                                  withLegend: true
                              });
                              selection.transition().style('opacity', 1);
                          }
                      }, 10);
                  }
              });
          });
          observer.observe(selection.node(), {
              attributes: true,
              childList: true,
              characterData: true
          });
      };
      /**
       * Binds handlers to the window resize event.
       */
      ChartInternal.prototype.bindResize = function () {
          var $$ = this, config = $$.config;
          $$.resizeFunction = $$.generateResize(); // need to call .remove
          $$.resizeFunction.add(function () {
              config.onresize.call($$);
          });
          if (config.resize_auto) {
              $$.resizeFunction.add(function () {
                  if ($$.resizeTimeout !== undefined) {
                      window.clearTimeout($$.resizeTimeout);
                  }
                  $$.resizeTimeout = window.setTimeout(function () {
                      delete $$.resizeTimeout;
                      $$.updateAndRedraw({
                          withUpdateXDomain: false,
                          withUpdateOrgXDomain: false,
                          withTransition: false,
                          withTransitionForTransform: false,
                          withLegend: true
                      });
                      if ($$.brush) {
                          $$.brush.update();
                      }
                  }, 100);
              });
          }
          $$.resizeFunction.add(function () {
              config.onresized.call($$);
          });
          $$.resizeIfElementDisplayed = function () {
              // if element not displayed skip it
              if ($$.api == null || !$$.api.element.offsetParent) {
                  return;
              }
              $$.resizeFunction();
          };
          window.addEventListener('resize', $$.resizeIfElementDisplayed, false);
      };
      /**
       * Binds handlers to the window focus event.
       */
      ChartInternal.prototype.bindWindowFocus = function () {
          var _this = this;
          if (this.windowFocusHandler) {
              // The handler is already set
              return;
          }
          this.windowFocusHandler = function () {
              _this.redraw();
          };
          window.addEventListener('focus', this.windowFocusHandler);
      };
      /**
       * Unbinds from the window focus event.
       */
      ChartInternal.prototype.unbindWindowFocus = function () {
          window.removeEventListener('focus', this.windowFocusHandler);
          delete this.windowFocusHandler;
      };
      ChartInternal.prototype.generateResize = function () {
          var resizeFunctions = [];
          function callResizeFunctions() {
              resizeFunctions.forEach(function (f) {
                  f();
              });
          }
          callResizeFunctions.add = function (f) {
              resizeFunctions.push(f);
          };
          callResizeFunctions.remove = function (f) {
              for (var i = 0; i < resizeFunctions.length; i++) {
                  if (resizeFunctions[i] === f) {
                      resizeFunctions.splice(i, 1);
                      break;
                  }
              }
          };
          return callResizeFunctions;
      };
      ChartInternal.prototype.endall = function (transition, callback) {
          var n = 0;
          transition
              .each(function () {
              ++n;
          })
              .on('end', function () {
              if (!--n) {
                  callback.apply(this, arguments);
              }
          });
      };
      ChartInternal.prototype.generateWait = function () {
          var $$ = this;
          var transitionsToWait = [], f = function (callback) {
              var timer = setInterval(function () {
                  if (!$$.isTabVisible()) {
                      return;
                  }
                  var done = 0;
                  transitionsToWait.forEach(function (t) {
                      if (t.empty()) {
                          done += 1;
                          return;
                      }
                      try {
                          t.transition();
                      }
                      catch (e) {
                          done += 1;
                      }
                  });
                  if (done === transitionsToWait.length) {
                      clearInterval(timer);
                      if (callback) {
                          callback();
                      }
                  }
              }, 50);
          };
          f.add = function (transition) {
              transitionsToWait.push(transition);
          };
          return f;
      };
      ChartInternal.prototype.parseDate = function (date) {
          var $$ = this, parsedDate;
          if (date instanceof Date) {
              parsedDate = date;
          }
          else if (typeof date === 'string') {
              parsedDate = $$.dataTimeParse(date);
          }
          else if (typeof date === 'object') {
              parsedDate = new Date(+date);
          }
          else if (typeof date === 'number' && !isNaN(date)) {
              parsedDate = new Date(+date);
          }
          if (!parsedDate || isNaN(+parsedDate)) {
              window.console.error("Failed to parse x '" + date + "' to Date object");
          }
          return parsedDate;
      };
      ChartInternal.prototype.isTabVisible = function () {
          return !document.hidden;
      };
      ChartInternal.prototype.getPathBox = getPathBox;
      ChartInternal.prototype.CLASS = CLASS;

      /* jshint ignore:start */
      (function () {
          if (!('SVGPathSeg' in window)) {
              // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-InterfaceSVGPathSeg
              window.SVGPathSeg = function (type, typeAsLetter, owningPathSegList) {
                  this.pathSegType = type;
                  this.pathSegTypeAsLetter = typeAsLetter;
                  this._owningPathSegList = owningPathSegList;
              };
              window.SVGPathSeg.prototype.classname = 'SVGPathSeg';
              window.SVGPathSeg.PATHSEG_UNKNOWN = 0;
              window.SVGPathSeg.PATHSEG_CLOSEPATH = 1;
              window.SVGPathSeg.PATHSEG_MOVETO_ABS = 2;
              window.SVGPathSeg.PATHSEG_MOVETO_REL = 3;
              window.SVGPathSeg.PATHSEG_LINETO_ABS = 4;
              window.SVGPathSeg.PATHSEG_LINETO_REL = 5;
              window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS = 6;
              window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL = 7;
              window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS = 8;
              window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL = 9;
              window.SVGPathSeg.PATHSEG_ARC_ABS = 10;
              window.SVGPathSeg.PATHSEG_ARC_REL = 11;
              window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS = 12;
              window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL = 13;
              window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS = 14;
              window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL = 15;
              window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS = 16;
              window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL = 17;
              window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS = 18;
              window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL = 19;
              // Notify owning PathSegList on any changes so they can be synchronized back to the path element.
              window.SVGPathSeg.prototype._segmentChanged = function () {
                  if (this._owningPathSegList)
                      this._owningPathSegList.segmentChanged(this);
              };
              window.SVGPathSegClosePath = function (owningPathSegList) {
                  window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CLOSEPATH, 'z', owningPathSegList);
              };
              window.SVGPathSegClosePath.prototype = Object.create(window.SVGPathSeg.prototype);
              window.SVGPathSegClosePath.prototype.toString = function () {
                  return '[object SVGPathSegClosePath]';
              };
              window.SVGPathSegClosePath.prototype._asPathString = function () {
                  return this.pathSegTypeAsLetter;
              };
              window.SVGPathSegClosePath.prototype.clone = function () {
                  return new window.SVGPathSegClosePath(undefined);
              };
              window.SVGPathSegMovetoAbs = function (owningPathSegList, x, y) {
                  window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_MOVETO_ABS, 'M', owningPathSegList);
                  this._x = x;
                  this._y = y;
              };
              window.SVGPathSegMovetoAbs.prototype = Object.create(window.SVGPathSeg.prototype);
              window.SVGPathSegMovetoAbs.prototype.toString = function () {
                  return '[object SVGPathSegMovetoAbs]';
              };
              window.SVGPathSegMovetoAbs.prototype._asPathString = function () {
                  return this.pathSegTypeAsLetter + ' ' + this._x + ' ' + this._y;
              };
              window.SVGPathSegMovetoAbs.prototype.clone = function () {
                  return new window.SVGPathSegMovetoAbs(undefined, this._x, this._y);
              };
              Object.defineProperty(window.SVGPathSegMovetoAbs.prototype, 'x', {
                  get: function () {
                      return this._x;
                  },
                  set: function (x) {
                      this._x = x;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              Object.defineProperty(window.SVGPathSegMovetoAbs.prototype, 'y', {
                  get: function () {
                      return this._y;
                  },
                  set: function (y) {
                      this._y = y;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              window.SVGPathSegMovetoRel = function (owningPathSegList, x, y) {
                  window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_MOVETO_REL, 'm', owningPathSegList);
                  this._x = x;
                  this._y = y;
              };
              window.SVGPathSegMovetoRel.prototype = Object.create(window.SVGPathSeg.prototype);
              window.SVGPathSegMovetoRel.prototype.toString = function () {
                  return '[object SVGPathSegMovetoRel]';
              };
              window.SVGPathSegMovetoRel.prototype._asPathString = function () {
                  return this.pathSegTypeAsLetter + ' ' + this._x + ' ' + this._y;
              };
              window.SVGPathSegMovetoRel.prototype.clone = function () {
                  return new window.SVGPathSegMovetoRel(undefined, this._x, this._y);
              };
              Object.defineProperty(window.SVGPathSegMovetoRel.prototype, 'x', {
                  get: function () {
                      return this._x;
                  },
                  set: function (x) {
                      this._x = x;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              Object.defineProperty(window.SVGPathSegMovetoRel.prototype, 'y', {
                  get: function () {
                      return this._y;
                  },
                  set: function (y) {
                      this._y = y;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              window.SVGPathSegLinetoAbs = function (owningPathSegList, x, y) {
                  window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_ABS, 'L', owningPathSegList);
                  this._x = x;
                  this._y = y;
              };
              window.SVGPathSegLinetoAbs.prototype = Object.create(window.SVGPathSeg.prototype);
              window.SVGPathSegLinetoAbs.prototype.toString = function () {
                  return '[object SVGPathSegLinetoAbs]';
              };
              window.SVGPathSegLinetoAbs.prototype._asPathString = function () {
                  return this.pathSegTypeAsLetter + ' ' + this._x + ' ' + this._y;
              };
              window.SVGPathSegLinetoAbs.prototype.clone = function () {
                  return new window.SVGPathSegLinetoAbs(undefined, this._x, this._y);
              };
              Object.defineProperty(window.SVGPathSegLinetoAbs.prototype, 'x', {
                  get: function () {
                      return this._x;
                  },
                  set: function (x) {
                      this._x = x;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              Object.defineProperty(window.SVGPathSegLinetoAbs.prototype, 'y', {
                  get: function () {
                      return this._y;
                  },
                  set: function (y) {
                      this._y = y;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              window.SVGPathSegLinetoRel = function (owningPathSegList, x, y) {
                  window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_REL, 'l', owningPathSegList);
                  this._x = x;
                  this._y = y;
              };
              window.SVGPathSegLinetoRel.prototype = Object.create(window.SVGPathSeg.prototype);
              window.SVGPathSegLinetoRel.prototype.toString = function () {
                  return '[object SVGPathSegLinetoRel]';
              };
              window.SVGPathSegLinetoRel.prototype._asPathString = function () {
                  return this.pathSegTypeAsLetter + ' ' + this._x + ' ' + this._y;
              };
              window.SVGPathSegLinetoRel.prototype.clone = function () {
                  return new window.SVGPathSegLinetoRel(undefined, this._x, this._y);
              };
              Object.defineProperty(window.SVGPathSegLinetoRel.prototype, 'x', {
                  get: function () {
                      return this._x;
                  },
                  set: function (x) {
                      this._x = x;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              Object.defineProperty(window.SVGPathSegLinetoRel.prototype, 'y', {
                  get: function () {
                      return this._y;
                  },
                  set: function (y) {
                      this._y = y;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              window.SVGPathSegCurvetoCubicAbs = function (owningPathSegList, x, y, x1, y1, x2, y2) {
                  window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS, 'C', owningPathSegList);
                  this._x = x;
                  this._y = y;
                  this._x1 = x1;
                  this._y1 = y1;
                  this._x2 = x2;
                  this._y2 = y2;
              };
              window.SVGPathSegCurvetoCubicAbs.prototype = Object.create(window.SVGPathSeg.prototype);
              window.SVGPathSegCurvetoCubicAbs.prototype.toString = function () {
                  return '[object SVGPathSegCurvetoCubicAbs]';
              };
              window.SVGPathSegCurvetoCubicAbs.prototype._asPathString = function () {
                  return (this.pathSegTypeAsLetter +
                      ' ' +
                      this._x1 +
                      ' ' +
                      this._y1 +
                      ' ' +
                      this._x2 +
                      ' ' +
                      this._y2 +
                      ' ' +
                      this._x +
                      ' ' +
                      this._y);
              };
              window.SVGPathSegCurvetoCubicAbs.prototype.clone = function () {
                  return new window.SVGPathSegCurvetoCubicAbs(undefined, this._x, this._y, this._x1, this._y1, this._x2, this._y2);
              };
              Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, 'x', {
                  get: function () {
                      return this._x;
                  },
                  set: function (x) {
                      this._x = x;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, 'y', {
                  get: function () {
                      return this._y;
                  },
                  set: function (y) {
                      this._y = y;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, 'x1', {
                  get: function () {
                      return this._x1;
                  },
                  set: function (x1) {
                      this._x1 = x1;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, 'y1', {
                  get: function () {
                      return this._y1;
                  },
                  set: function (y1) {
                      this._y1 = y1;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, 'x2', {
                  get: function () {
                      return this._x2;
                  },
                  set: function (x2) {
                      this._x2 = x2;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, 'y2', {
                  get: function () {
                      return this._y2;
                  },
                  set: function (y2) {
                      this._y2 = y2;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              window.SVGPathSegCurvetoCubicRel = function (owningPathSegList, x, y, x1, y1, x2, y2) {
                  window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL, 'c', owningPathSegList);
                  this._x = x;
                  this._y = y;
                  this._x1 = x1;
                  this._y1 = y1;
                  this._x2 = x2;
                  this._y2 = y2;
              };
              window.SVGPathSegCurvetoCubicRel.prototype = Object.create(window.SVGPathSeg.prototype);
              window.SVGPathSegCurvetoCubicRel.prototype.toString = function () {
                  return '[object SVGPathSegCurvetoCubicRel]';
              };
              window.SVGPathSegCurvetoCubicRel.prototype._asPathString = function () {
                  return (this.pathSegTypeAsLetter +
                      ' ' +
                      this._x1 +
                      ' ' +
                      this._y1 +
                      ' ' +
                      this._x2 +
                      ' ' +
                      this._y2 +
                      ' ' +
                      this._x +
                      ' ' +
                      this._y);
              };
              window.SVGPathSegCurvetoCubicRel.prototype.clone = function () {
                  return new window.SVGPathSegCurvetoCubicRel(undefined, this._x, this._y, this._x1, this._y1, this._x2, this._y2);
              };
              Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, 'x', {
                  get: function () {
                      return this._x;
                  },
                  set: function (x) {
                      this._x = x;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, 'y', {
                  get: function () {
                      return this._y;
                  },
                  set: function (y) {
                      this._y = y;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, 'x1', {
                  get: function () {
                      return this._x1;
                  },
                  set: function (x1) {
                      this._x1 = x1;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, 'y1', {
                  get: function () {
                      return this._y1;
                  },
                  set: function (y1) {
                      this._y1 = y1;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, 'x2', {
                  get: function () {
                      return this._x2;
                  },
                  set: function (x2) {
                      this._x2 = x2;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, 'y2', {
                  get: function () {
                      return this._y2;
                  },
                  set: function (y2) {
                      this._y2 = y2;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              window.SVGPathSegCurvetoQuadraticAbs = function (owningPathSegList, x, y, x1, y1) {
                  window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS, 'Q', owningPathSegList);
                  this._x = x;
                  this._y = y;
                  this._x1 = x1;
                  this._y1 = y1;
              };
              window.SVGPathSegCurvetoQuadraticAbs.prototype = Object.create(window.SVGPathSeg.prototype);
              window.SVGPathSegCurvetoQuadraticAbs.prototype.toString = function () {
                  return '[object SVGPathSegCurvetoQuadraticAbs]';
              };
              window.SVGPathSegCurvetoQuadraticAbs.prototype._asPathString = function () {
                  return (this.pathSegTypeAsLetter +
                      ' ' +
                      this._x1 +
                      ' ' +
                      this._y1 +
                      ' ' +
                      this._x +
                      ' ' +
                      this._y);
              };
              window.SVGPathSegCurvetoQuadraticAbs.prototype.clone = function () {
                  return new window.SVGPathSegCurvetoQuadraticAbs(undefined, this._x, this._y, this._x1, this._y1);
              };
              Object.defineProperty(window.SVGPathSegCurvetoQuadraticAbs.prototype, 'x', {
                  get: function () {
                      return this._x;
                  },
                  set: function (x) {
                      this._x = x;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              Object.defineProperty(window.SVGPathSegCurvetoQuadraticAbs.prototype, 'y', {
                  get: function () {
                      return this._y;
                  },
                  set: function (y) {
                      this._y = y;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              Object.defineProperty(window.SVGPathSegCurvetoQuadraticAbs.prototype, 'x1', {
                  get: function () {
                      return this._x1;
                  },
                  set: function (x1) {
                      this._x1 = x1;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              Object.defineProperty(window.SVGPathSegCurvetoQuadraticAbs.prototype, 'y1', {
                  get: function () {
                      return this._y1;
                  },
                  set: function (y1) {
                      this._y1 = y1;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              window.SVGPathSegCurvetoQuadraticRel = function (owningPathSegList, x, y, x1, y1) {
                  window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL, 'q', owningPathSegList);
                  this._x = x;
                  this._y = y;
                  this._x1 = x1;
                  this._y1 = y1;
              };
              window.SVGPathSegCurvetoQuadraticRel.prototype = Object.create(window.SVGPathSeg.prototype);
              window.SVGPathSegCurvetoQuadraticRel.prototype.toString = function () {
                  return '[object SVGPathSegCurvetoQuadraticRel]';
              };
              window.SVGPathSegCurvetoQuadraticRel.prototype._asPathString = function () {
                  return (this.pathSegTypeAsLetter +
                      ' ' +
                      this._x1 +
                      ' ' +
                      this._y1 +
                      ' ' +
                      this._x +
                      ' ' +
                      this._y);
              };
              window.SVGPathSegCurvetoQuadraticRel.prototype.clone = function () {
                  return new window.SVGPathSegCurvetoQuadraticRel(undefined, this._x, this._y, this._x1, this._y1);
              };
              Object.defineProperty(window.SVGPathSegCurvetoQuadraticRel.prototype, 'x', {
                  get: function () {
                      return this._x;
                  },
                  set: function (x) {
                      this._x = x;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              Object.defineProperty(window.SVGPathSegCurvetoQuadraticRel.prototype, 'y', {
                  get: function () {
                      return this._y;
                  },
                  set: function (y) {
                      this._y = y;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              Object.defineProperty(window.SVGPathSegCurvetoQuadraticRel.prototype, 'x1', {
                  get: function () {
                      return this._x1;
                  },
                  set: function (x1) {
                      this._x1 = x1;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              Object.defineProperty(window.SVGPathSegCurvetoQuadraticRel.prototype, 'y1', {
                  get: function () {
                      return this._y1;
                  },
                  set: function (y1) {
                      this._y1 = y1;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              window.SVGPathSegArcAbs = function (owningPathSegList, x, y, r1, r2, angle, largeArcFlag, sweepFlag) {
                  window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_ARC_ABS, 'A', owningPathSegList);
                  this._x = x;
                  this._y = y;
                  this._r1 = r1;
                  this._r2 = r2;
                  this._angle = angle;
                  this._largeArcFlag = largeArcFlag;
                  this._sweepFlag = sweepFlag;
              };
              window.SVGPathSegArcAbs.prototype = Object.create(window.SVGPathSeg.prototype);
              window.SVGPathSegArcAbs.prototype.toString = function () {
                  return '[object SVGPathSegArcAbs]';
              };
              window.SVGPathSegArcAbs.prototype._asPathString = function () {
                  return (this.pathSegTypeAsLetter +
                      ' ' +
                      this._r1 +
                      ' ' +
                      this._r2 +
                      ' ' +
                      this._angle +
                      ' ' +
                      (this._largeArcFlag ? '1' : '0') +
                      ' ' +
                      (this._sweepFlag ? '1' : '0') +
                      ' ' +
                      this._x +
                      ' ' +
                      this._y);
              };
              window.SVGPathSegArcAbs.prototype.clone = function () {
                  return new window.SVGPathSegArcAbs(undefined, this._x, this._y, this._r1, this._r2, this._angle, this._largeArcFlag, this._sweepFlag);
              };
              Object.defineProperty(window.SVGPathSegArcAbs.prototype, 'x', {
                  get: function () {
                      return this._x;
                  },
                  set: function (x) {
                      this._x = x;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              Object.defineProperty(window.SVGPathSegArcAbs.prototype, 'y', {
                  get: function () {
                      return this._y;
                  },
                  set: function (y) {
                      this._y = y;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              Object.defineProperty(window.SVGPathSegArcAbs.prototype, 'r1', {
                  get: function () {
                      return this._r1;
                  },
                  set: function (r1) {
                      this._r1 = r1;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              Object.defineProperty(window.SVGPathSegArcAbs.prototype, 'r2', {
                  get: function () {
                      return this._r2;
                  },
                  set: function (r2) {
                      this._r2 = r2;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              Object.defineProperty(window.SVGPathSegArcAbs.prototype, 'angle', {
                  get: function () {
                      return this._angle;
                  },
                  set: function (angle) {
                      this._angle = angle;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              Object.defineProperty(window.SVGPathSegArcAbs.prototype, 'largeArcFlag', {
                  get: function () {
                      return this._largeArcFlag;
                  },
                  set: function (largeArcFlag) {
                      this._largeArcFlag = largeArcFlag;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              Object.defineProperty(window.SVGPathSegArcAbs.prototype, 'sweepFlag', {
                  get: function () {
                      return this._sweepFlag;
                  },
                  set: function (sweepFlag) {
                      this._sweepFlag = sweepFlag;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              window.SVGPathSegArcRel = function (owningPathSegList, x, y, r1, r2, angle, largeArcFlag, sweepFlag) {
                  window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_ARC_REL, 'a', owningPathSegList);
                  this._x = x;
                  this._y = y;
                  this._r1 = r1;
                  this._r2 = r2;
                  this._angle = angle;
                  this._largeArcFlag = largeArcFlag;
                  this._sweepFlag = sweepFlag;
              };
              window.SVGPathSegArcRel.prototype = Object.create(window.SVGPathSeg.prototype);
              window.SVGPathSegArcRel.prototype.toString = function () {
                  return '[object SVGPathSegArcRel]';
              };
              window.SVGPathSegArcRel.prototype._asPathString = function () {
                  return (this.pathSegTypeAsLetter +
                      ' ' +
                      this._r1 +
                      ' ' +
                      this._r2 +
                      ' ' +
                      this._angle +
                      ' ' +
                      (this._largeArcFlag ? '1' : '0') +
                      ' ' +
                      (this._sweepFlag ? '1' : '0') +
                      ' ' +
                      this._x +
                      ' ' +
                      this._y);
              };
              window.SVGPathSegArcRel.prototype.clone = function () {
                  return new window.SVGPathSegArcRel(undefined, this._x, this._y, this._r1, this._r2, this._angle, this._largeArcFlag, this._sweepFlag);
              };
              Object.defineProperty(window.SVGPathSegArcRel.prototype, 'x', {
                  get: function () {
                      return this._x;
                  },
                  set: function (x) {
                      this._x = x;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              Object.defineProperty(window.SVGPathSegArcRel.prototype, 'y', {
                  get: function () {
                      return this._y;
                  },
                  set: function (y) {
                      this._y = y;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              Object.defineProperty(window.SVGPathSegArcRel.prototype, 'r1', {
                  get: function () {
                      return this._r1;
                  },
                  set: function (r1) {
                      this._r1 = r1;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              Object.defineProperty(window.SVGPathSegArcRel.prototype, 'r2', {
                  get: function () {
                      return this._r2;
                  },
                  set: function (r2) {
                      this._r2 = r2;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              Object.defineProperty(window.SVGPathSegArcRel.prototype, 'angle', {
                  get: function () {
                      return this._angle;
                  },
                  set: function (angle) {
                      this._angle = angle;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              Object.defineProperty(window.SVGPathSegArcRel.prototype, 'largeArcFlag', {
                  get: function () {
                      return this._largeArcFlag;
                  },
                  set: function (largeArcFlag) {
                      this._largeArcFlag = largeArcFlag;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              Object.defineProperty(window.SVGPathSegArcRel.prototype, 'sweepFlag', {
                  get: function () {
                      return this._sweepFlag;
                  },
                  set: function (sweepFlag) {
                      this._sweepFlag = sweepFlag;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              window.SVGPathSegLinetoHorizontalAbs = function (owningPathSegList, x) {
                  window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS, 'H', owningPathSegList);
                  this._x = x;
              };
              window.SVGPathSegLinetoHorizontalAbs.prototype = Object.create(window.SVGPathSeg.prototype);
              window.SVGPathSegLinetoHorizontalAbs.prototype.toString = function () {
                  return '[object SVGPathSegLinetoHorizontalAbs]';
              };
              window.SVGPathSegLinetoHorizontalAbs.prototype._asPathString = function () {
                  return this.pathSegTypeAsLetter + ' ' + this._x;
              };
              window.SVGPathSegLinetoHorizontalAbs.prototype.clone = function () {
                  return new window.SVGPathSegLinetoHorizontalAbs(undefined, this._x);
              };
              Object.defineProperty(window.SVGPathSegLinetoHorizontalAbs.prototype, 'x', {
                  get: function () {
                      return this._x;
                  },
                  set: function (x) {
                      this._x = x;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              window.SVGPathSegLinetoHorizontalRel = function (owningPathSegList, x) {
                  window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL, 'h', owningPathSegList);
                  this._x = x;
              };
              window.SVGPathSegLinetoHorizontalRel.prototype = Object.create(window.SVGPathSeg.prototype);
              window.SVGPathSegLinetoHorizontalRel.prototype.toString = function () {
                  return '[object SVGPathSegLinetoHorizontalRel]';
              };
              window.SVGPathSegLinetoHorizontalRel.prototype._asPathString = function () {
                  return this.pathSegTypeAsLetter + ' ' + this._x;
              };
              window.SVGPathSegLinetoHorizontalRel.prototype.clone = function () {
                  return new window.SVGPathSegLinetoHorizontalRel(undefined, this._x);
              };
              Object.defineProperty(window.SVGPathSegLinetoHorizontalRel.prototype, 'x', {
                  get: function () {
                      return this._x;
                  },
                  set: function (x) {
                      this._x = x;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              window.SVGPathSegLinetoVerticalAbs = function (owningPathSegList, y) {
                  window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS, 'V', owningPathSegList);
                  this._y = y;
              };
              window.SVGPathSegLinetoVerticalAbs.prototype = Object.create(window.SVGPathSeg.prototype);
              window.SVGPathSegLinetoVerticalAbs.prototype.toString = function () {
                  return '[object SVGPathSegLinetoVerticalAbs]';
              };
              window.SVGPathSegLinetoVerticalAbs.prototype._asPathString = function () {
                  return this.pathSegTypeAsLetter + ' ' + this._y;
              };
              window.SVGPathSegLinetoVerticalAbs.prototype.clone = function () {
                  return new window.SVGPathSegLinetoVerticalAbs(undefined, this._y);
              };
              Object.defineProperty(window.SVGPathSegLinetoVerticalAbs.prototype, 'y', {
                  get: function () {
                      return this._y;
                  },
                  set: function (y) {
                      this._y = y;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              window.SVGPathSegLinetoVerticalRel = function (owningPathSegList, y) {
                  window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL, 'v', owningPathSegList);
                  this._y = y;
              };
              window.SVGPathSegLinetoVerticalRel.prototype = Object.create(window.SVGPathSeg.prototype);
              window.SVGPathSegLinetoVerticalRel.prototype.toString = function () {
                  return '[object SVGPathSegLinetoVerticalRel]';
              };
              window.SVGPathSegLinetoVerticalRel.prototype._asPathString = function () {
                  return this.pathSegTypeAsLetter + ' ' + this._y;
              };
              window.SVGPathSegLinetoVerticalRel.prototype.clone = function () {
                  return new window.SVGPathSegLinetoVerticalRel(undefined, this._y);
              };
              Object.defineProperty(window.SVGPathSegLinetoVerticalRel.prototype, 'y', {
                  get: function () {
                      return this._y;
                  },
                  set: function (y) {
                      this._y = y;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              window.SVGPathSegCurvetoCubicSmoothAbs = function (owningPathSegList, x, y, x2, y2) {
                  window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS, 'S', owningPathSegList);
                  this._x = x;
                  this._y = y;
                  this._x2 = x2;
                  this._y2 = y2;
              };
              window.SVGPathSegCurvetoCubicSmoothAbs.prototype = Object.create(window.SVGPathSeg.prototype);
              window.SVGPathSegCurvetoCubicSmoothAbs.prototype.toString = function () {
                  return '[object SVGPathSegCurvetoCubicSmoothAbs]';
              };
              window.SVGPathSegCurvetoCubicSmoothAbs.prototype._asPathString = function () {
                  return (this.pathSegTypeAsLetter +
                      ' ' +
                      this._x2 +
                      ' ' +
                      this._y2 +
                      ' ' +
                      this._x +
                      ' ' +
                      this._y);
              };
              window.SVGPathSegCurvetoCubicSmoothAbs.prototype.clone = function () {
                  return new window.SVGPathSegCurvetoCubicSmoothAbs(undefined, this._x, this._y, this._x2, this._y2);
              };
              Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothAbs.prototype, 'x', {
                  get: function () {
                      return this._x;
                  },
                  set: function (x) {
                      this._x = x;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothAbs.prototype, 'y', {
                  get: function () {
                      return this._y;
                  },
                  set: function (y) {
                      this._y = y;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothAbs.prototype, 'x2', {
                  get: function () {
                      return this._x2;
                  },
                  set: function (x2) {
                      this._x2 = x2;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothAbs.prototype, 'y2', {
                  get: function () {
                      return this._y2;
                  },
                  set: function (y2) {
                      this._y2 = y2;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              window.SVGPathSegCurvetoCubicSmoothRel = function (owningPathSegList, x, y, x2, y2) {
                  window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL, 's', owningPathSegList);
                  this._x = x;
                  this._y = y;
                  this._x2 = x2;
                  this._y2 = y2;
              };
              window.SVGPathSegCurvetoCubicSmoothRel.prototype = Object.create(window.SVGPathSeg.prototype);
              window.SVGPathSegCurvetoCubicSmoothRel.prototype.toString = function () {
                  return '[object SVGPathSegCurvetoCubicSmoothRel]';
              };
              window.SVGPathSegCurvetoCubicSmoothRel.prototype._asPathString = function () {
                  return (this.pathSegTypeAsLetter +
                      ' ' +
                      this._x2 +
                      ' ' +
                      this._y2 +
                      ' ' +
                      this._x +
                      ' ' +
                      this._y);
              };
              window.SVGPathSegCurvetoCubicSmoothRel.prototype.clone = function () {
                  return new window.SVGPathSegCurvetoCubicSmoothRel(undefined, this._x, this._y, this._x2, this._y2);
              };
              Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothRel.prototype, 'x', {
                  get: function () {
                      return this._x;
                  },
                  set: function (x) {
                      this._x = x;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothRel.prototype, 'y', {
                  get: function () {
                      return this._y;
                  },
                  set: function (y) {
                      this._y = y;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothRel.prototype, 'x2', {
                  get: function () {
                      return this._x2;
                  },
                  set: function (x2) {
                      this._x2 = x2;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothRel.prototype, 'y2', {
                  get: function () {
                      return this._y2;
                  },
                  set: function (y2) {
                      this._y2 = y2;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              window.SVGPathSegCurvetoQuadraticSmoothAbs = function (owningPathSegList, x, y) {
                  window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS, 'T', owningPathSegList);
                  this._x = x;
                  this._y = y;
              };
              window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype = Object.create(window.SVGPathSeg.prototype);
              window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype.toString = function () {
                  return '[object SVGPathSegCurvetoQuadraticSmoothAbs]';
              };
              window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype._asPathString = function () {
                  return this.pathSegTypeAsLetter + ' ' + this._x + ' ' + this._y;
              };
              window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype.clone = function () {
                  return new window.SVGPathSegCurvetoQuadraticSmoothAbs(undefined, this._x, this._y);
              };
              Object.defineProperty(window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype, 'x', {
                  get: function () {
                      return this._x;
                  },
                  set: function (x) {
                      this._x = x;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              Object.defineProperty(window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype, 'y', {
                  get: function () {
                      return this._y;
                  },
                  set: function (y) {
                      this._y = y;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              window.SVGPathSegCurvetoQuadraticSmoothRel = function (owningPathSegList, x, y) {
                  window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL, 't', owningPathSegList);
                  this._x = x;
                  this._y = y;
              };
              window.SVGPathSegCurvetoQuadraticSmoothRel.prototype = Object.create(window.SVGPathSeg.prototype);
              window.SVGPathSegCurvetoQuadraticSmoothRel.prototype.toString = function () {
                  return '[object SVGPathSegCurvetoQuadraticSmoothRel]';
              };
              window.SVGPathSegCurvetoQuadraticSmoothRel.prototype._asPathString = function () {
                  return this.pathSegTypeAsLetter + ' ' + this._x + ' ' + this._y;
              };
              window.SVGPathSegCurvetoQuadraticSmoothRel.prototype.clone = function () {
                  return new window.SVGPathSegCurvetoQuadraticSmoothRel(undefined, this._x, this._y);
              };
              Object.defineProperty(window.SVGPathSegCurvetoQuadraticSmoothRel.prototype, 'x', {
                  get: function () {
                      return this._x;
                  },
                  set: function (x) {
                      this._x = x;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              Object.defineProperty(window.SVGPathSegCurvetoQuadraticSmoothRel.prototype, 'y', {
                  get: function () {
                      return this._y;
                  },
                  set: function (y) {
                      this._y = y;
                      this._segmentChanged();
                  },
                  enumerable: true
              });
              // Add createSVGPathSeg* functions to window.SVGPathElement.
              // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-Interfacewindow.SVGPathElement.
              window.SVGPathElement.prototype.createSVGPathSegClosePath = function () {
                  return new window.SVGPathSegClosePath(undefined);
              };
              window.SVGPathElement.prototype.createSVGPathSegMovetoAbs = function (x, y) {
                  return new window.SVGPathSegMovetoAbs(undefined, x, y);
              };
              window.SVGPathElement.prototype.createSVGPathSegMovetoRel = function (x, y) {
                  return new window.SVGPathSegMovetoRel(undefined, x, y);
              };
              window.SVGPathElement.prototype.createSVGPathSegLinetoAbs = function (x, y) {
                  return new window.SVGPathSegLinetoAbs(undefined, x, y);
              };
              window.SVGPathElement.prototype.createSVGPathSegLinetoRel = function (x, y) {
                  return new window.SVGPathSegLinetoRel(undefined, x, y);
              };
              window.SVGPathElement.prototype.createSVGPathSegCurvetoCubicAbs = function (x, y, x1, y1, x2, y2) {
                  return new window.SVGPathSegCurvetoCubicAbs(undefined, x, y, x1, y1, x2, y2);
              };
              window.SVGPathElement.prototype.createSVGPathSegCurvetoCubicRel = function (x, y, x1, y1, x2, y2) {
                  return new window.SVGPathSegCurvetoCubicRel(undefined, x, y, x1, y1, x2, y2);
              };
              window.SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticAbs = function (x, y, x1, y1) {
                  return new window.SVGPathSegCurvetoQuadraticAbs(undefined, x, y, x1, y1);
              };
              window.SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticRel = function (x, y, x1, y1) {
                  return new window.SVGPathSegCurvetoQuadraticRel(undefined, x, y, x1, y1);
              };
              window.SVGPathElement.prototype.createSVGPathSegArcAbs = function (x, y, r1, r2, angle, largeArcFlag, sweepFlag) {
                  return new window.SVGPathSegArcAbs(undefined, x, y, r1, r2, angle, largeArcFlag, sweepFlag);
              };
              window.SVGPathElement.prototype.createSVGPathSegArcRel = function (x, y, r1, r2, angle, largeArcFlag, sweepFlag) {
                  return new window.SVGPathSegArcRel(undefined, x, y, r1, r2, angle, largeArcFlag, sweepFlag);
              };
              window.SVGPathElement.prototype.createSVGPathSegLinetoHorizontalAbs = function (x) {
                  return new window.SVGPathSegLinetoHorizontalAbs(undefined, x);
              };
              window.SVGPathElement.prototype.createSVGPathSegLinetoHorizontalRel = function (x) {
                  return new window.SVGPathSegLinetoHorizontalRel(undefined, x);
              };
              window.SVGPathElement.prototype.createSVGPathSegLinetoVerticalAbs = function (y) {
                  return new window.SVGPathSegLinetoVerticalAbs(undefined, y);
              };
              window.SVGPathElement.prototype.createSVGPathSegLinetoVerticalRel = function (y) {
                  return new window.SVGPathSegLinetoVerticalRel(undefined, y);
              };
              window.SVGPathElement.prototype.createSVGPathSegCurvetoCubicSmoothAbs = function (x, y, x2, y2) {
                  return new window.SVGPathSegCurvetoCubicSmoothAbs(undefined, x, y, x2, y2);
              };
              window.SVGPathElement.prototype.createSVGPathSegCurvetoCubicSmoothRel = function (x, y, x2, y2) {
                  return new window.SVGPathSegCurvetoCubicSmoothRel(undefined, x, y, x2, y2);
              };
              window.SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticSmoothAbs = function (x, y) {
                  return new window.SVGPathSegCurvetoQuadraticSmoothAbs(undefined, x, y);
              };
              window.SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticSmoothRel = function (x, y) {
                  return new window.SVGPathSegCurvetoQuadraticSmoothRel(undefined, x, y);
              };
              if (!('getPathSegAtLength' in window.SVGPathElement.prototype)) {
                  // Add getPathSegAtLength to SVGPathElement.
                  // Spec: https://www.w3.org/TR/SVG11/single-page.html#paths-__svg__SVGPathElement__getPathSegAtLength
                  // This polyfill requires SVGPathElement.getTotalLength to implement the distance-along-a-path algorithm.
                  window.SVGPathElement.prototype.getPathSegAtLength = function (distance) {
                      if (distance === undefined || !isFinite(distance))
                          throw 'Invalid arguments.';
                      var measurementElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                      measurementElement.setAttribute('d', this.getAttribute('d'));
                      var lastPathSegment = measurementElement.pathSegList.numberOfItems - 1;
                      // If the path is empty, return 0.
                      if (lastPathSegment <= 0)
                          return 0;
                      do {
                          measurementElement.pathSegList.removeItem(lastPathSegment);
                          if (distance > measurementElement.getTotalLength())
                              break;
                          lastPathSegment--;
                      } while (lastPathSegment > 0);
                      return lastPathSegment;
                  };
              }
          }
          if (!('SVGPathSegList' in window)) {
              // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-InterfaceSVGPathSegList
              window.SVGPathSegList = function (pathElement) {
                  this._pathElement = pathElement;
                  this._list = this._parsePath(this._pathElement.getAttribute('d'));
                  // Use a MutationObserver to catch changes to the path's "d" attribute.
                  this._mutationObserverConfig = {
                      attributes: true,
                      attributeFilter: ['d']
                  };
                  this._pathElementMutationObserver = new MutationObserver(this._updateListFromPathMutations.bind(this));
                  this._pathElementMutationObserver.observe(this._pathElement, this._mutationObserverConfig);
              };
              window.SVGPathSegList.prototype.classname = 'SVGPathSegList';
              Object.defineProperty(window.SVGPathSegList.prototype, 'numberOfItems', {
                  get: function () {
                      this._checkPathSynchronizedToList();
                      return this._list.length;
                  },
                  enumerable: true
              });
              // Add the pathSegList accessors to window.SVGPathElement.
              // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-InterfaceSVGAnimatedPathData
              Object.defineProperty(window.SVGPathElement.prototype, 'pathSegList', {
                  get: function () {
                      if (!this._pathSegList)
                          this._pathSegList = new window.SVGPathSegList(this);
                      return this._pathSegList;
                  },
                  enumerable: true
              });
              // FIXME: The following are not implemented and simply return window.SVGPathElement.pathSegList.
              Object.defineProperty(window.SVGPathElement.prototype, 'normalizedPathSegList', {
                  get: function () {
                      return this.pathSegList;
                  },
                  enumerable: true
              });
              Object.defineProperty(window.SVGPathElement.prototype, 'animatedPathSegList', {
                  get: function () {
                      return this.pathSegList;
                  },
                  enumerable: true
              });
              Object.defineProperty(window.SVGPathElement.prototype, 'animatedNormalizedPathSegList', {
                  get: function () {
                      return this.pathSegList;
                  },
                  enumerable: true
              });
              // Process any pending mutations to the path element and update the list as needed.
              // This should be the first call of all public functions and is needed because
              // MutationObservers are not synchronous so we can have pending asynchronous mutations.
              window.SVGPathSegList.prototype._checkPathSynchronizedToList = function () {
                  this._updateListFromPathMutations(this._pathElementMutationObserver.takeRecords());
              };
              window.SVGPathSegList.prototype._updateListFromPathMutations = function (mutationRecords) {
                  if (!this._pathElement)
                      return;
                  var hasPathMutations = false;
                  mutationRecords.forEach(function (record) {
                      if (record.attributeName == 'd')
                          hasPathMutations = true;
                  });
                  if (hasPathMutations)
                      this._list = this._parsePath(this._pathElement.getAttribute('d'));
              };
              // Serialize the list and update the path's 'd' attribute.
              window.SVGPathSegList.prototype._writeListToPath = function () {
                  this._pathElementMutationObserver.disconnect();
                  this._pathElement.setAttribute('d', window.SVGPathSegList._pathSegArrayAsString(this._list));
                  this._pathElementMutationObserver.observe(this._pathElement, this._mutationObserverConfig);
              };
              // When a path segment changes the list needs to be synchronized back to the path element.
              window.SVGPathSegList.prototype.segmentChanged = function (pathSeg) {
                  this._writeListToPath();
              };
              window.SVGPathSegList.prototype.clear = function () {
                  this._checkPathSynchronizedToList();
                  this._list.forEach(function (pathSeg) {
                      pathSeg._owningPathSegList = null;
                  });
                  this._list = [];
                  this._writeListToPath();
              };
              window.SVGPathSegList.prototype.initialize = function (newItem) {
                  this._checkPathSynchronizedToList();
                  this._list = [newItem];
                  newItem._owningPathSegList = this;
                  this._writeListToPath();
                  return newItem;
              };
              window.SVGPathSegList.prototype._checkValidIndex = function (index) {
                  if (isNaN(index) || index < 0 || index >= this.numberOfItems)
                      throw 'INDEX_SIZE_ERR';
              };
              window.SVGPathSegList.prototype.getItem = function (index) {
                  this._checkPathSynchronizedToList();
                  this._checkValidIndex(index);
                  return this._list[index];
              };
              window.SVGPathSegList.prototype.insertItemBefore = function (newItem, index) {
                  this._checkPathSynchronizedToList();
                  // Spec: If the index is greater than or equal to numberOfItems, then the new item is appended to the end of the list.
                  if (index > this.numberOfItems)
                      index = this.numberOfItems;
                  if (newItem._owningPathSegList) {
                      // SVG2 spec says to make a copy.
                      newItem = newItem.clone();
                  }
                  this._list.splice(index, 0, newItem);
                  newItem._owningPathSegList = this;
                  this._writeListToPath();
                  return newItem;
              };
              window.SVGPathSegList.prototype.replaceItem = function (newItem, index) {
                  this._checkPathSynchronizedToList();
                  if (newItem._owningPathSegList) {
                      // SVG2 spec says to make a copy.
                      newItem = newItem.clone();
                  }
                  this._checkValidIndex(index);
                  this._list[index] = newItem;
                  newItem._owningPathSegList = this;
                  this._writeListToPath();
                  return newItem;
              };
              window.SVGPathSegList.prototype.removeItem = function (index) {
                  this._checkPathSynchronizedToList();
                  this._checkValidIndex(index);
                  var item = this._list[index];
                  this._list.splice(index, 1);
                  this._writeListToPath();
                  return item;
              };
              window.SVGPathSegList.prototype.appendItem = function (newItem) {
                  this._checkPathSynchronizedToList();
                  if (newItem._owningPathSegList) {
                      // SVG2 spec says to make a copy.
                      newItem = newItem.clone();
                  }
                  this._list.push(newItem);
                  newItem._owningPathSegList = this;
                  // TODO: Optimize this to just append to the existing attribute.
                  this._writeListToPath();
                  return newItem;
              };
              window.SVGPathSegList._pathSegArrayAsString = function (pathSegArray) {
                  var string = '';
                  var first = true;
                  pathSegArray.forEach(function (pathSeg) {
                      if (first) {
                          first = false;
                          string += pathSeg._asPathString();
                      }
                      else {
                          string += ' ' + pathSeg._asPathString();
                      }
                  });
                  return string;
              };
              // This closely follows SVGPathParser::parsePath from Source/core/svg/SVGPathParser.cpp.
              window.SVGPathSegList.prototype._parsePath = function (string) {
                  if (!string || string.length == 0)
                      return [];
                  var owningPathSegList = this;
                  var Builder = function () {
                      this.pathSegList = [];
                  };
                  Builder.prototype.appendSegment = function (pathSeg) {
                      this.pathSegList.push(pathSeg);
                  };
                  var Source = function (string) {
                      this._string = string;
                      this._currentIndex = 0;
                      this._endIndex = this._string.length;
                      this._previousCommand = window.SVGPathSeg.PATHSEG_UNKNOWN;
                      this._skipOptionalSpaces();
                  };
                  Source.prototype._isCurrentSpace = function () {
                      var character = this._string[this._currentIndex];
                      return (character <= ' ' &&
                          (character == ' ' ||
                              character == '\n' ||
                              character == '\t' ||
                              character == '\r' ||
                              character == '\f'));
                  };
                  Source.prototype._skipOptionalSpaces = function () {
                      while (this._currentIndex < this._endIndex && this._isCurrentSpace())
                          this._currentIndex++;
                      return this._currentIndex < this._endIndex;
                  };
                  Source.prototype._skipOptionalSpacesOrDelimiter = function () {
                      if (this._currentIndex < this._endIndex &&
                          !this._isCurrentSpace() &&
                          this._string.charAt(this._currentIndex) != ',')
                          return false;
                      if (this._skipOptionalSpaces()) {
                          if (this._currentIndex < this._endIndex &&
                              this._string.charAt(this._currentIndex) == ',') {
                              this._currentIndex++;
                              this._skipOptionalSpaces();
                          }
                      }
                      return this._currentIndex < this._endIndex;
                  };
                  Source.prototype.hasMoreData = function () {
                      return this._currentIndex < this._endIndex;
                  };
                  Source.prototype.peekSegmentType = function () {
                      var lookahead = this._string[this._currentIndex];
                      return this._pathSegTypeFromChar(lookahead);
                  };
                  Source.prototype._pathSegTypeFromChar = function (lookahead) {
                      switch (lookahead) {
                          case 'Z':
                          case 'z':
                              return window.SVGPathSeg.PATHSEG_CLOSEPATH;
                          case 'M':
                              return window.SVGPathSeg.PATHSEG_MOVETO_ABS;
                          case 'm':
                              return window.SVGPathSeg.PATHSEG_MOVETO_REL;
                          case 'L':
                              return window.SVGPathSeg.PATHSEG_LINETO_ABS;
                          case 'l':
                              return window.SVGPathSeg.PATHSEG_LINETO_REL;
                          case 'C':
                              return window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS;
                          case 'c':
                              return window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL;
                          case 'Q':
                              return window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS;
                          case 'q':
                              return window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL;
                          case 'A':
                              return window.SVGPathSeg.PATHSEG_ARC_ABS;
                          case 'a':
                              return window.SVGPathSeg.PATHSEG_ARC_REL;
                          case 'H':
                              return window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS;
                          case 'h':
                              return window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL;
                          case 'V':
                              return window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS;
                          case 'v':
                              return window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL;
                          case 'S':
                              return window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS;
                          case 's':
                              return window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL;
                          case 'T':
                              return window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS;
                          case 't':
                              return window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL;
                          default:
                              return window.SVGPathSeg.PATHSEG_UNKNOWN;
                      }
                  };
                  Source.prototype._nextCommandHelper = function (lookahead, previousCommand) {
                      // Check for remaining coordinates in the current command.
                      if ((lookahead == '+' ||
                          lookahead == '-' ||
                          lookahead == '.' ||
                          (lookahead >= '0' && lookahead <= '9')) &&
                          previousCommand != window.SVGPathSeg.PATHSEG_CLOSEPATH) {
                          if (previousCommand == window.SVGPathSeg.PATHSEG_MOVETO_ABS)
                              return window.SVGPathSeg.PATHSEG_LINETO_ABS;
                          if (previousCommand == window.SVGPathSeg.PATHSEG_MOVETO_REL)
                              return window.SVGPathSeg.PATHSEG_LINETO_REL;
                          return previousCommand;
                      }
                      return window.SVGPathSeg.PATHSEG_UNKNOWN;
                  };
                  Source.prototype.initialCommandIsMoveTo = function () {
                      // If the path is empty it is still valid, so return true.
                      if (!this.hasMoreData())
                          return true;
                      var command = this.peekSegmentType();
                      // Path must start with moveTo.
                      return (command == window.SVGPathSeg.PATHSEG_MOVETO_ABS ||
                          command == window.SVGPathSeg.PATHSEG_MOVETO_REL);
                  };
                  // Parse a number from an SVG path. This very closely follows genericParseNumber(...) from Source/core/svg/SVGParserUtilities.cpp.
                  // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-PathDataBNF
                  Source.prototype._parseNumber = function () {
                      var exponent = 0;
                      var integer = 0;
                      var frac = 1;
                      var decimal = 0;
                      var sign = 1;
                      var expsign = 1;
                      var startIndex = this._currentIndex;
                      this._skipOptionalSpaces();
                      // Read the sign.
                      if (this._currentIndex < this._endIndex &&
                          this._string.charAt(this._currentIndex) == '+')
                          this._currentIndex++;
                      else if (this._currentIndex < this._endIndex &&
                          this._string.charAt(this._currentIndex) == '-') {
                          this._currentIndex++;
                          sign = -1;
                      }
                      if (this._currentIndex == this._endIndex ||
                          ((this._string.charAt(this._currentIndex) < '0' ||
                              this._string.charAt(this._currentIndex) > '9') &&
                              this._string.charAt(this._currentIndex) != '.'))
                          // The first character of a number must be one of [0-9+-.].
                          return undefined;
                      // Read the integer part, build right-to-left.
                      var startIntPartIndex = this._currentIndex;
                      while (this._currentIndex < this._endIndex &&
                          this._string.charAt(this._currentIndex) >= '0' &&
                          this._string.charAt(this._currentIndex) <= '9')
                          this._currentIndex++; // Advance to first non-digit.
                      if (this._currentIndex != startIntPartIndex) {
                          var scanIntPartIndex = this._currentIndex - 1;
                          var multiplier = 1;
                          while (scanIntPartIndex >= startIntPartIndex) {
                              integer +=
                                  multiplier * (this._string.charAt(scanIntPartIndex--) - '0');
                              multiplier *= 10;
                          }
                      }
                      // Read the decimals.
                      if (this._currentIndex < this._endIndex &&
                          this._string.charAt(this._currentIndex) == '.') {
                          this._currentIndex++;
                          // There must be a least one digit following the .
                          if (this._currentIndex >= this._endIndex ||
                              this._string.charAt(this._currentIndex) < '0' ||
                              this._string.charAt(this._currentIndex) > '9')
                              return undefined;
                          while (this._currentIndex < this._endIndex &&
                              this._string.charAt(this._currentIndex) >= '0' &&
                              this._string.charAt(this._currentIndex) <= '9') {
                              frac *= 10;
                              decimal += (this._string.charAt(this._currentIndex) - '0') / frac;
                              this._currentIndex += 1;
                          }
                      }
                      // Read the exponent part.
                      if (this._currentIndex != startIndex &&
                          this._currentIndex + 1 < this._endIndex &&
                          (this._string.charAt(this._currentIndex) == 'e' ||
                              this._string.charAt(this._currentIndex) == 'E') &&
                          this._string.charAt(this._currentIndex + 1) != 'x' &&
                          this._string.charAt(this._currentIndex + 1) != 'm') {
                          this._currentIndex++;
                          // Read the sign of the exponent.
                          if (this._string.charAt(this._currentIndex) == '+') {
                              this._currentIndex++;
                          }
                          else if (this._string.charAt(this._currentIndex) == '-') {
                              this._currentIndex++;
                              expsign = -1;
                          }
                          // There must be an exponent.
                          if (this._currentIndex >= this._endIndex ||
                              this._string.charAt(this._currentIndex) < '0' ||
                              this._string.charAt(this._currentIndex) > '9')
                              return undefined;
                          while (this._currentIndex < this._endIndex &&
                              this._string.charAt(this._currentIndex) >= '0' &&
                              this._string.charAt(this._currentIndex) <= '9') {
                              exponent *= 10;
                              exponent += this._string.charAt(this._currentIndex) - '0';
                              this._currentIndex++;
                          }
                      }
                      var number = integer + decimal;
                      number *= sign;
                      if (exponent)
                          number *= Math.pow(10, expsign * exponent);
                      if (startIndex == this._currentIndex)
                          return undefined;
                      this._skipOptionalSpacesOrDelimiter();
                      return number;
                  };
                  Source.prototype._parseArcFlag = function () {
                      if (this._currentIndex >= this._endIndex)
                          return undefined;
                      var flag = false;
                      var flagChar = this._string.charAt(this._currentIndex++);
                      if (flagChar == '0')
                          flag = false;
                      else if (flagChar == '1')
                          flag = true;
                      else
                          return undefined;
                      this._skipOptionalSpacesOrDelimiter();
                      return flag;
                  };
                  Source.prototype.parseSegment = function () {
                      var lookahead = this._string[this._currentIndex];
                      var command = this._pathSegTypeFromChar(lookahead);
                      if (command == window.SVGPathSeg.PATHSEG_UNKNOWN) {
                          // Possibly an implicit command. Not allowed if this is the first command.
                          if (this._previousCommand == window.SVGPathSeg.PATHSEG_UNKNOWN)
                              return null;
                          command = this._nextCommandHelper(lookahead, this._previousCommand);
                          if (command == window.SVGPathSeg.PATHSEG_UNKNOWN)
                              return null;
                      }
                      else {
                          this._currentIndex++;
                      }
                      this._previousCommand = command;
                      switch (command) {
                          case window.SVGPathSeg.PATHSEG_MOVETO_REL:
                              return new window.SVGPathSegMovetoRel(owningPathSegList, this._parseNumber(), this._parseNumber());
                          case window.SVGPathSeg.PATHSEG_MOVETO_ABS:
                              return new window.SVGPathSegMovetoAbs(owningPathSegList, this._parseNumber(), this._parseNumber());
                          case window.SVGPathSeg.PATHSEG_LINETO_REL:
                              return new window.SVGPathSegLinetoRel(owningPathSegList, this._parseNumber(), this._parseNumber());
                          case window.SVGPathSeg.PATHSEG_LINETO_ABS:
                              return new window.SVGPathSegLinetoAbs(owningPathSegList, this._parseNumber(), this._parseNumber());
                          case window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL:
                              return new window.SVGPathSegLinetoHorizontalRel(owningPathSegList, this._parseNumber());
                          case window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS:
                              return new window.SVGPathSegLinetoHorizontalAbs(owningPathSegList, this._parseNumber());
                          case window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL:
                              return new window.SVGPathSegLinetoVerticalRel(owningPathSegList, this._parseNumber());
                          case window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS:
                              return new window.SVGPathSegLinetoVerticalAbs(owningPathSegList, this._parseNumber());
                          case window.SVGPathSeg.PATHSEG_CLOSEPATH:
                              this._skipOptionalSpaces();
                              return new window.SVGPathSegClosePath(owningPathSegList);
                          case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL:
                              var points = {
                                  x1: this._parseNumber(),
                                  y1: this._parseNumber(),
                                  x2: this._parseNumber(),
                                  y2: this._parseNumber(),
                                  x: this._parseNumber(),
                                  y: this._parseNumber()
                              };
                              return new window.SVGPathSegCurvetoCubicRel(owningPathSegList, points.x, points.y, points.x1, points.y1, points.x2, points.y2);
                          case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS:
                              var points = {
                                  x1: this._parseNumber(),
                                  y1: this._parseNumber(),
                                  x2: this._parseNumber(),
                                  y2: this._parseNumber(),
                                  x: this._parseNumber(),
                                  y: this._parseNumber()
                              };
                              return new window.SVGPathSegCurvetoCubicAbs(owningPathSegList, points.x, points.y, points.x1, points.y1, points.x2, points.y2);
                          case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL:
                              var points = {
                                  x2: this._parseNumber(),
                                  y2: this._parseNumber(),
                                  x: this._parseNumber(),
                                  y: this._parseNumber()
                              };
                              return new window.SVGPathSegCurvetoCubicSmoothRel(owningPathSegList, points.x, points.y, points.x2, points.y2);
                          case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS:
                              var points = {
                                  x2: this._parseNumber(),
                                  y2: this._parseNumber(),
                                  x: this._parseNumber(),
                                  y: this._parseNumber()
                              };
                              return new window.SVGPathSegCurvetoCubicSmoothAbs(owningPathSegList, points.x, points.y, points.x2, points.y2);
                          case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL:
                              var points = {
                                  x1: this._parseNumber(),
                                  y1: this._parseNumber(),
                                  x: this._parseNumber(),
                                  y: this._parseNumber()
                              };
                              return new window.SVGPathSegCurvetoQuadraticRel(owningPathSegList, points.x, points.y, points.x1, points.y1);
                          case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS:
                              var points = {
                                  x1: this._parseNumber(),
                                  y1: this._parseNumber(),
                                  x: this._parseNumber(),
                                  y: this._parseNumber()
                              };
                              return new window.SVGPathSegCurvetoQuadraticAbs(owningPathSegList, points.x, points.y, points.x1, points.y1);
                          case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL:
                              return new window.SVGPathSegCurvetoQuadraticSmoothRel(owningPathSegList, this._parseNumber(), this._parseNumber());
                          case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS:
                              return new window.SVGPathSegCurvetoQuadraticSmoothAbs(owningPathSegList, this._parseNumber(), this._parseNumber());
                          case window.SVGPathSeg.PATHSEG_ARC_REL:
                              var points = {
                                  x1: this._parseNumber(),
                                  y1: this._parseNumber(),
                                  arcAngle: this._parseNumber(),
                                  arcLarge: this._parseArcFlag(),
                                  arcSweep: this._parseArcFlag(),
                                  x: this._parseNumber(),
                                  y: this._parseNumber()
                              };
                              return new window.SVGPathSegArcRel(owningPathSegList, points.x, points.y, points.x1, points.y1, points.arcAngle, points.arcLarge, points.arcSweep);
                          case window.SVGPathSeg.PATHSEG_ARC_ABS:
                              var points = {
                                  x1: this._parseNumber(),
                                  y1: this._parseNumber(),
                                  arcAngle: this._parseNumber(),
                                  arcLarge: this._parseArcFlag(),
                                  arcSweep: this._parseArcFlag(),
                                  x: this._parseNumber(),
                                  y: this._parseNumber()
                              };
                              return new window.SVGPathSegArcAbs(owningPathSegList, points.x, points.y, points.x1, points.y1, points.arcAngle, points.arcLarge, points.arcSweep);
                          default:
                              throw 'Unknown path seg type.';
                      }
                  };
                  var builder = new Builder();
                  var source = new Source(string);
                  if (!source.initialCommandIsMoveTo())
                      return [];
                  while (source.hasMoreData()) {
                      var pathSeg = source.parseSegment();
                      if (!pathSeg)
                          return [];
                      builder.appendSegment(pathSeg);
                  }
                  return builder.pathSegList;
              };
          }
      })();
      // String.padEnd polyfill for IE11
      //
      // https://github.com/uxitten/polyfill/blob/master/string.polyfill.js
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padEnd
      if (!String.prototype.padEnd) {
          String.prototype.padEnd = function padEnd(targetLength, padString) {
              targetLength = targetLength >> 0; //floor if number or convert non-number to 0;
              padString = String(typeof padString !== 'undefined' ? padString : ' ');
              if (this.length > targetLength) {
                  return String(this);
              }
              else {
                  targetLength = targetLength - this.length;
                  if (targetLength > padString.length) {
                      padString += padString.repeat(targetLength / padString.length); //append to original to ensure we are longer than needed
                  }
                  return String(this) + padString.slice(0, targetLength);
              }
          };
      }
      // Object.assign polyfill for IE11
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Polyfill
      if (typeof Object.assign !== 'function') {
          // Must be writable: true, enumerable: false, configurable: true
          Object.defineProperty(Object, 'assign', {
              value: function assign(target, varArgs) {
                  if (target === null || target === undefined) {
                      throw new TypeError('Cannot convert undefined or null to object');
                  }
                  var to = Object(target);
                  for (var index = 1; index < arguments.length; index++) {
                      var nextSource = arguments[index];
                      if (nextSource !== null && nextSource !== undefined) {
                          for (var nextKey in nextSource) {
                              // Avoid bugs when hasOwnProperty is shadowed
                              if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                                  to[nextKey] = nextSource[nextKey];
                              }
                          }
                      }
                  }
                  return to;
              },
              writable: true,
              configurable: true
          });
      }
      /* jshint ignore:end */

      Chart.prototype.axis = function () { };
      Chart.prototype.axis.labels = function (labels) {
          var $$ = this.internal;
          if (arguments.length) {
              Object.keys(labels).forEach(function (axisId) {
                  $$.axis.setLabelText(axisId, labels[axisId]);
              });
              $$.axis.updateLabels();
          }
          // TODO: return some values?
      };
      Chart.prototype.axis.max = function (max) {
          var $$ = this.internal, config = $$.config;
          if (arguments.length) {
              if (typeof max === 'object') {
                  if (isValue(max.x)) {
                      config.axis_x_max = max.x;
                  }
                  if (isValue(max.y)) {
                      config.axis_y_max = max.y;
                  }
                  if (isValue(max.y2)) {
                      config.axis_y2_max = max.y2;
                  }
              }
              else {
                  config.axis_y_max = config.axis_y2_max = max;
              }
              $$.redraw({ withUpdateOrgXDomain: true, withUpdateXDomain: true });
          }
          else {
              return {
                  x: config.axis_x_max,
                  y: config.axis_y_max,
                  y2: config.axis_y2_max
              };
          }
      };
      Chart.prototype.axis.min = function (min) {
          var $$ = this.internal, config = $$.config;
          if (arguments.length) {
              if (typeof min === 'object') {
                  if (isValue(min.x)) {
                      config.axis_x_min = min.x;
                  }
                  if (isValue(min.y)) {
                      config.axis_y_min = min.y;
                  }
                  if (isValue(min.y2)) {
                      config.axis_y2_min = min.y2;
                  }
              }
              else {
                  config.axis_y_min = config.axis_y2_min = min;
              }
              $$.redraw({ withUpdateOrgXDomain: true, withUpdateXDomain: true });
          }
          else {
              return {
                  x: config.axis_x_min,
                  y: config.axis_y_min,
                  y2: config.axis_y2_min
              };
          }
      };
      Chart.prototype.axis.range = function (range) {
          if (arguments.length) {
              if (isDefined(range.max)) {
                  this.axis.max(range.max);
              }
              if (isDefined(range.min)) {
                  this.axis.min(range.min);
              }
          }
          else {
              return {
                  max: this.axis.max(),
                  min: this.axis.min()
              };
          }
      };
      Chart.prototype.axis.types = function (types) {
          var $$ = this.internal;
          if (types === undefined) {
              return {
                  y: $$.config.axis_y_type,
                  y2: $$.config.axis_y2_type
              };
          }
          else {
              if (isDefined(types.y)) {
                  $$.config.axis_y_type = types.y;
              }
              if (isDefined(types.y2)) {
                  $$.config.axis_y2_type = types.y2;
              }
              $$.updateScales();
              $$.redraw();
          }
      };

      Chart.prototype.category = function (i, category) {
          var $$ = this.internal, config = $$.config;
          if (arguments.length > 1) {
              config.axis_x_categories[i] = category;
              $$.redraw();
          }
          return config.axis_x_categories[i];
      };
      Chart.prototype.categories = function (categories) {
          var $$ = this.internal, config = $$.config;
          if (!arguments.length) {
              return config.axis_x_categories;
          }
          config.axis_x_categories = categories;
          $$.redraw();
          return config.axis_x_categories;
      };

      Chart.prototype.resize = function (size) {
          var $$ = this.internal, config = $$.config;
          config.size_width = size ? size.width : null;
          config.size_height = size ? size.height : null;
          this.flush();
      };
      Chart.prototype.flush = function () {
          var $$ = this.internal;
          $$.updateAndRedraw({
              withLegend: true,
              withTransition: false,
              withTransitionForTransform: false
          });
      };
      Chart.prototype.destroy = function () {
          var $$ = this.internal;
          window.clearInterval($$.intervalForObserveInserted);
          if ($$.resizeTimeout !== undefined) {
              window.clearTimeout($$.resizeTimeout);
          }
          window.removeEventListener('resize', $$.resizeIfElementDisplayed);
          // Removes the inner resize functions
          $$.resizeFunction.remove();
          // Unbinds from the window focus event
          $$.unbindWindowFocus();
          $$.selectChart.classed('c3', false).html('');
          // MEMO: this is needed because the reference of some elements will not be released, then memory leak will happen.
          Object.keys($$).forEach(function (key) {
              $$[key] = null;
          });
          return null;
      };

      // TODO: fix
      Chart.prototype.color = function (id) {
          var $$ = this.internal;
          return $$.color(id); // more patterns
      };

      Chart.prototype.data = function (targetIds) {
          var targets = this.internal.data.targets;
          return typeof targetIds === 'undefined'
              ? targets
              : targets.filter(function (t) {
                  return [].concat(targetIds).indexOf(t.id) >= 0;
              });
      };
      Chart.prototype.data.shown = function (targetIds) {
          return this.internal.filterTargetsToShow(this.data(targetIds));
      };
      /**
       * Get values of the data loaded in the chart.
       *
       * @param {String|Array} targetId This API returns the value of specified target.
       * @param flat
       * @return {Array} Data values
       */
      Chart.prototype.data.values = function (targetId, flat) {
          if (flat === void 0) { flat = true; }
          var values = null;
          if (targetId) {
              var targets = this.data(targetId);
              if (targets && isArray(targets)) {
                  values = targets.reduce(function (ret, v) {
                      var dataValue = v.values.map(function (d) { return d.value; });
                      if (flat) {
                          ret = ret.concat(dataValue);
                      }
                      else {
                          ret.push(dataValue);
                      }
                      return ret;
                  }, []);
              }
          }
          return values;
      };
      Chart.prototype.data.names = function (names) {
          this.internal.clearLegendItemTextBoxCache();
          return this.internal.updateDataAttributes('names', names);
      };
      Chart.prototype.data.colors = function (colors) {
          return this.internal.updateDataAttributes('colors', colors);
      };
      Chart.prototype.data.axes = function (axes) {
          return this.internal.updateDataAttributes('axes', axes);
      };
      Chart.prototype.data.stackNormalized = function (normalized) {
          if (normalized === undefined) {
              return this.internal.isStackNormalized();
          }
          this.internal.config.data_stack_normalize = !!normalized;
          this.internal.redraw();
      };

      Chart.prototype.donut = function () { };
      Chart.prototype.donut.padAngle = function (padAngle) {
          if (padAngle === undefined) {
              return this.internal.config.donut_padAngle;
          }
          this.internal.config.donut_padAngle = padAngle;
          this.flush();
      };

      Chart.prototype.flow = function (args) {
          var $$ = this.internal, targets, data, notfoundIds = [], orgDataCount = $$.getMaxDataCount(), domain, baseTarget, baseValue, length = 0, tail = 0, diff, to;
          if (args.json) {
              data = $$.convertJsonToData(args.json, args.keys);
          }
          else if (args.rows) {
              data = $$.convertRowsToData(args.rows);
          }
          else if (args.columns) {
              data = $$.convertColumnsToData(args.columns);
          }
          else {
              return;
          }
          targets = $$.convertDataToTargets(data, true);
          // Update/Add data
          $$.data.targets.forEach(function (t) {
              var found = false, i, j;
              for (i = 0; i < targets.length; i++) {
                  if (t.id === targets[i].id) {
                      found = true;
                      if (t.values[t.values.length - 1]) {
                          tail = t.values[t.values.length - 1].index + 1;
                      }
                      length = targets[i].values.length;
                      for (j = 0; j < length; j++) {
                          targets[i].values[j].index = tail + j;
                          if (!$$.isTimeSeries()) {
                              targets[i].values[j].x = tail + j;
                          }
                      }
                      t.values = t.values.concat(targets[i].values);
                      targets.splice(i, 1);
                      break;
                  }
              }
              if (!found) {
                  notfoundIds.push(t.id);
              }
          });
          // Append null for not found targets
          $$.data.targets.forEach(function (t) {
              var i, j;
              for (i = 0; i < notfoundIds.length; i++) {
                  if (t.id === notfoundIds[i]) {
                      tail = t.values[t.values.length - 1].index + 1;
                      for (j = 0; j < length; j++) {
                          t.values.push({
                              id: t.id,
                              index: tail + j,
                              x: $$.isTimeSeries() ? $$.getOtherTargetX(tail + j) : tail + j,
                              value: null
                          });
                      }
                  }
              }
          });
          // Generate null values for new target
          if ($$.data.targets.length) {
              targets.forEach(function (t) {
                  var i, missing = [];
                  for (i = $$.data.targets[0].values[0].index; i < tail; i++) {
                      missing.push({
                          id: t.id,
                          index: i,
                          x: $$.isTimeSeries() ? $$.getOtherTargetX(i) : i,
                          value: null
                      });
                  }
                  t.values.forEach(function (v) {
                      v.index += tail;
                      if (!$$.isTimeSeries()) {
                          v.x += tail;
                      }
                  });
                  t.values = missing.concat(t.values);
              });
          }
          $$.data.targets = $$.data.targets.concat(targets); // add remained
          // check data count because behavior needs to change when it's only one
          $$.getMaxDataCount();
          baseTarget = $$.data.targets[0];
          baseValue = baseTarget.values[0];
          // Update length to flow if needed
          if (isDefined(args.to)) {
              length = 0;
              to = $$.isTimeSeries() ? $$.parseDate(args.to) : args.to;
              baseTarget.values.forEach(function (v) {
                  if (v.x < to) {
                      length++;
                  }
              });
          }
          else if (isDefined(args.length)) {
              length = args.length;
          }
          // If only one data, update the domain to flow from left edge of the chart
          if (!orgDataCount) {
              if ($$.isTimeSeries()) {
                  if (baseTarget.values.length > 1) {
                      diff = baseTarget.values[baseTarget.values.length - 1].x - baseValue.x;
                  }
                  else {
                      diff = baseValue.x - $$.getXDomain($$.data.targets)[0];
                  }
              }
              else {
                  diff = 1;
              }
              domain = [baseValue.x - diff, baseValue.x];
              $$.updateXDomain(null, true, true, false, domain);
          }
          else if (orgDataCount === 1) {
              if ($$.isTimeSeries()) {
                  diff =
                      (baseTarget.values[baseTarget.values.length - 1].x - baseValue.x) / 2;
                  domain = [new Date(+baseValue.x - diff), new Date(+baseValue.x + diff)];
                  $$.updateXDomain(null, true, true, false, domain);
              }
          }
          // Set targets
          $$.updateTargets($$.data.targets);
          // Redraw with new targets
          $$.redraw({
              flow: {
                  index: baseValue.index,
                  length: length,
                  duration: isValue(args.duration)
                      ? args.duration
                      : $$.config.transition_duration,
                  done: args.done,
                  orgDataCount: orgDataCount
              },
              withLegend: true,
              withTransition: orgDataCount > 1,
              withTrimXDomain: false,
              withUpdateXAxis: true
          });
      };
      ChartInternal.prototype.generateFlow = function (args) {
          var $$ = this, config = $$.config, d3 = $$.d3;
          return function () {
              var targets = args.targets, flow = args.flow, drawBar = args.drawBar, drawLine = args.drawLine, drawArea = args.drawArea, cx = args.cx, cy = args.cy, xv = args.xv, xForText = args.xForText, yForText = args.yForText, duration = args.duration;
              var translateX, scaleX = 1, transform, flowIndex = flow.index, flowLength = flow.length, flowStart = $$.getValueOnIndex($$.data.targets[0].values, flowIndex), flowEnd = $$.getValueOnIndex($$.data.targets[0].values, flowIndex + flowLength), orgDomain = $$.x.domain(), domain, durationForFlow = flow.duration || duration, done = flow.done || function () { }, wait = $$.generateWait();
              var xgrid, xgridLines, mainRegion, mainText, mainBar, mainLine, mainArea, mainCircle;
              // set flag
              $$.flowing = true;
              // remove head data after rendered
              $$.data.targets.forEach(function (d) {
                  d.values.splice(0, flowLength);
              });
              // update x domain to generate axis elements for flow
              domain = $$.updateXDomain(targets, true, true);
              // update elements related to x scale
              if ($$.updateXGrid) {
                  $$.updateXGrid(true);
              }
              xgrid = $$.xgrid || d3.selectAll([]); // xgrid needs to be obtained after updateXGrid
              xgridLines = $$.xgridLines || d3.selectAll([]);
              mainRegion = $$.mainRegion || d3.selectAll([]);
              mainText = $$.mainText || d3.selectAll([]);
              mainBar = $$.mainBar || d3.selectAll([]);
              mainLine = $$.mainLine || d3.selectAll([]);
              mainArea = $$.mainArea || d3.selectAll([]);
              mainCircle = $$.mainCircle || d3.selectAll([]);
              // generate transform to flow
              if (!flow.orgDataCount) {
                  // if empty
                  if ($$.data.targets[0].values.length !== 1) {
                      translateX = $$.x(orgDomain[0]) - $$.x(domain[0]);
                  }
                  else {
                      if ($$.isTimeSeries()) {
                          flowStart = $$.getValueOnIndex($$.data.targets[0].values, 0);
                          flowEnd = $$.getValueOnIndex($$.data.targets[0].values, $$.data.targets[0].values.length - 1);
                          translateX = $$.x(flowStart.x) - $$.x(flowEnd.x);
                      }
                      else {
                          translateX = diffDomain(domain) / 2;
                      }
                  }
              }
              else if (flow.orgDataCount === 1 ||
                  (flowStart && flowStart.x) === (flowEnd && flowEnd.x)) {
                  translateX = $$.x(orgDomain[0]) - $$.x(domain[0]);
              }
              else {
                  if ($$.isTimeSeries()) {
                      translateX = $$.x(orgDomain[0]) - $$.x(domain[0]);
                  }
                  else {
                      translateX = $$.x(flowStart.x) - $$.x(flowEnd.x);
                  }
              }
              scaleX = diffDomain(orgDomain) / diffDomain(domain);
              transform = 'translate(' + translateX + ',0) scale(' + scaleX + ',1)';
              $$.hideXGridFocus();
              var flowTransition = d3
                  .transition()
                  .ease(d3.easeLinear)
                  .duration(durationForFlow);
              wait.add($$.xAxis($$.axes.x, flowTransition));
              wait.add(mainBar.transition(flowTransition).attr('transform', transform));
              wait.add(mainLine.transition(flowTransition).attr('transform', transform));
              wait.add(mainArea.transition(flowTransition).attr('transform', transform));
              wait.add(mainCircle.transition(flowTransition).attr('transform', transform));
              wait.add(mainText.transition(flowTransition).attr('transform', transform));
              wait.add(mainRegion
                  .filter($$.isRegionOnX)
                  .transition(flowTransition)
                  .attr('transform', transform));
              wait.add(xgrid.transition(flowTransition).attr('transform', transform));
              wait.add(xgridLines.transition(flowTransition).attr('transform', transform));
              wait(function () {
                  var i, shapes = [], texts = [];
                  // remove flowed elements
                  if (flowLength) {
                      for (i = 0; i < flowLength; i++) {
                          shapes.push('.' + CLASS.shape + '-' + (flowIndex + i));
                          texts.push('.' + CLASS.text + '-' + (flowIndex + i));
                      }
                      $$.svg
                          .selectAll('.' + CLASS.shapes)
                          .selectAll(shapes)
                          .remove();
                      $$.svg
                          .selectAll('.' + CLASS.texts)
                          .selectAll(texts)
                          .remove();
                      $$.svg.select('.' + CLASS.xgrid).remove();
                  }
                  // draw again for removing flowed elements and reverting attr
                  xgrid
                      .attr('transform', null)
                      .attr('x1', $$.xgridAttr.x1)
                      .attr('x2', $$.xgridAttr.x2)
                      .attr('y1', $$.xgridAttr.y1)
                      .attr('y2', $$.xgridAttr.y2)
                      .style('opacity', $$.xgridAttr.opacity);
                  xgridLines.attr('transform', null);
                  xgridLines
                      .select('line')
                      .attr('x1', config.axis_rotated ? 0 : xv)
                      .attr('x2', config.axis_rotated ? $$.width : xv);
                  xgridLines
                      .select('text')
                      .attr('x', config.axis_rotated ? $$.width : 0)
                      .attr('y', xv);
                  mainBar.attr('transform', null).attr('d', drawBar);
                  mainLine.attr('transform', null).attr('d', drawLine);
                  mainArea.attr('transform', null).attr('d', drawArea);
                  mainCircle
                      .attr('transform', null)
                      .attr('cx', cx)
                      .attr('cy', cy);
                  mainText
                      .attr('transform', null)
                      .attr('x', xForText)
                      .attr('y', yForText)
                      .style('fill-opacity', $$.opacityForText.bind($$));
                  mainRegion.attr('transform', null);
                  mainRegion
                      .filter($$.isRegionOnX)
                      .attr('x', $$.regionX.bind($$))
                      .attr('width', $$.regionWidth.bind($$));
                  // callback for end of flow
                  done();
                  $$.flowing = false;
              });
          };
      };

      Chart.prototype.focus = function (targetIds) {
          var $$ = this.internal, candidates;
          targetIds = $$.mapToTargetIds(targetIds);
          (candidates = $$.svg.selectAll($$.selectorTargets(targetIds.filter($$.isTargetToShow, $$)))),
              this.revert();
          this.defocus();
          candidates.classed(CLASS.focused, true).classed(CLASS.defocused, false);
          if ($$.hasArcType()) {
              $$.expandArc(targetIds);
          }
          $$.toggleFocusLegend(targetIds, true);
          $$.focusedTargetIds = targetIds;
          $$.defocusedTargetIds = $$.defocusedTargetIds.filter(function (id) {
              return targetIds.indexOf(id) < 0;
          });
      };
      Chart.prototype.defocus = function (targetIds) {
          var $$ = this.internal, candidates;
          targetIds = $$.mapToTargetIds(targetIds);
          (candidates = $$.svg.selectAll($$.selectorTargets(targetIds.filter($$.isTargetToShow, $$)))),
              candidates.classed(CLASS.focused, false).classed(CLASS.defocused, true);
          if ($$.hasArcType()) {
              $$.unexpandArc(targetIds);
          }
          $$.toggleFocusLegend(targetIds, false);
          $$.focusedTargetIds = $$.focusedTargetIds.filter(function (id) {
              return targetIds.indexOf(id) < 0;
          });
          $$.defocusedTargetIds = targetIds;
      };
      Chart.prototype.revert = function (targetIds) {
          var $$ = this.internal, candidates;
          targetIds = $$.mapToTargetIds(targetIds);
          candidates = $$.svg.selectAll($$.selectorTargets(targetIds)); // should be for all targets
          candidates.classed(CLASS.focused, false).classed(CLASS.defocused, false);
          if ($$.hasArcType()) {
              $$.unexpandArc(targetIds);
          }
          if ($$.config.legend_show) {
              $$.showLegend(targetIds.filter($$.isLegendToShow.bind($$)));
              $$.legend
                  .selectAll($$.selectorLegends(targetIds))
                  .filter(function () {
                  return $$.d3.select(this).classed(CLASS.legendItemFocused);
              })
                  .classed(CLASS.legendItemFocused, false);
          }
          $$.focusedTargetIds = [];
          $$.defocusedTargetIds = [];
      };

      Chart.prototype.xgrids = function (grids) {
          var $$ = this.internal, config = $$.config;
          if (!grids) {
              return config.grid_x_lines;
          }
          config.grid_x_lines = grids;
          $$.redrawWithoutRescale();
          return config.grid_x_lines;
      };
      Chart.prototype.xgrids.add = function (grids) {
          var $$ = this.internal;
          return this.xgrids($$.config.grid_x_lines.concat(grids ? grids : []));
      };
      Chart.prototype.xgrids.remove = function (params) {
          // TODO: multiple
          var $$ = this.internal;
          $$.removeGridLines(params, true);
      };
      Chart.prototype.ygrids = function (grids) {
          var $$ = this.internal, config = $$.config;
          if (!grids) {
              return config.grid_y_lines;
          }
          config.grid_y_lines = grids;
          $$.redrawWithoutRescale();
          return config.grid_y_lines;
      };
      Chart.prototype.ygrids.add = function (grids) {
          var $$ = this.internal;
          return this.ygrids($$.config.grid_y_lines.concat(grids ? grids : []));
      };
      Chart.prototype.ygrids.remove = function (params) {
          // TODO: multiple
          var $$ = this.internal;
          $$.removeGridLines(params, false);
      };

      Chart.prototype.groups = function (groups) {
          var $$ = this.internal, config = $$.config;
          if (isUndefined(groups)) {
              return config.data_groups;
          }
          config.data_groups = groups;
          $$.redraw();
          return config.data_groups;
      };

      Chart.prototype.legend = function () { };
      Chart.prototype.legend.show = function (targetIds) {
          var $$ = this.internal;
          $$.showLegend($$.mapToTargetIds(targetIds));
          $$.updateAndRedraw({ withLegend: true });
      };
      Chart.prototype.legend.hide = function (targetIds) {
          var $$ = this.internal;
          $$.hideLegend($$.mapToTargetIds(targetIds));
          $$.updateAndRedraw({ withLegend: false });
      };

      Chart.prototype.load = function (args) {
          var $$ = this.internal, config = $$.config;
          // update xs if specified
          if (args.xs) {
              $$.addXs(args.xs);
          }
          // update names if exists
          if ('names' in args) {
              Chart.prototype.data.names.bind(this)(args.names);
          }
          // update classes if exists
          if ('classes' in args) {
              Object.keys(args.classes).forEach(function (id) {
                  config.data_classes[id] = args.classes[id];
              });
          }
          // update categories if exists
          if ('categories' in args && $$.isCategorized()) {
              config.axis_x_categories = args.categories;
          }
          // update axes if exists
          if ('axes' in args) {
              Object.keys(args.axes).forEach(function (id) {
                  config.data_axes[id] = args.axes[id];
              });
          }
          // update colors if exists
          if ('colors' in args) {
              Object.keys(args.colors).forEach(function (id) {
                  config.data_colors[id] = args.colors[id];
              });
          }
          // use cache if exists
          if ('cacheIds' in args && $$.hasCaches(args.cacheIds)) {
              $$.load($$.getCaches(args.cacheIds), args.done);
              return;
          }
          // unload if needed
          if (args.unload) {
              // TODO: do not unload if target will load (included in url/rows/columns)
              $$.unload($$.mapToTargetIds(args.unload === true ? null : args.unload), function () {
                  $$.loadFromArgs(args);
              });
          }
          else {
              $$.loadFromArgs(args);
          }
      };
      Chart.prototype.unload = function (args) {
          var $$ = this.internal;
          args = args || {};
          if (args instanceof Array) {
              args = { ids: args };
          }
          else if (typeof args === 'string') {
              args = { ids: [args] };
          }
          $$.unload($$.mapToTargetIds(args.ids), function () {
              $$.redraw({
                  withUpdateOrgXDomain: true,
                  withUpdateXDomain: true,
                  withLegend: true
              });
              if (args.done) {
                  args.done();
              }
          });
      };

      Chart.prototype.pie = function () { };
      Chart.prototype.pie.padAngle = function (padAngle) {
          if (padAngle === undefined) {
              return this.internal.config.pie_padAngle;
          }
          this.internal.config.pie_padAngle = padAngle;
          this.flush();
      };

      Chart.prototype.regions = function (regions) {
          var $$ = this.internal, config = $$.config;
          if (!regions) {
              return config.regions;
          }
          config.regions = regions;
          $$.redrawWithoutRescale();
          return config.regions;
      };
      Chart.prototype.regions.add = function (regions) {
          var $$ = this.internal, config = $$.config;
          if (!regions) {
              return config.regions;
          }
          config.regions = config.regions.concat(regions);
          $$.redrawWithoutRescale();
          return config.regions;
      };
      Chart.prototype.regions.remove = function (options) {
          var $$ = this.internal, config = $$.config, duration, classes, regions;
          options = options || {};
          duration = getOption(options, 'duration', config.transition_duration);
          classes = getOption(options, 'classes', [CLASS.region]);
          regions = $$.main.select('.' + CLASS.regions).selectAll(classes.map(function (c) {
              return '.' + c;
          }));
          (duration ? regions.transition().duration(duration) : regions)
              .style('opacity', 0)
              .remove();
          config.regions = config.regions.filter(function (region) {
              var found = false;
              if (!region['class']) {
                  return true;
              }
              region['class'].split(' ').forEach(function (c) {
                  if (classes.indexOf(c) >= 0) {
                      found = true;
                  }
              });
              return !found;
          });
          return config.regions;
      };

      Chart.prototype.selected = function (targetId) {
          var $$ = this.internal, d3 = $$.d3;
          return $$.main
              .selectAll('.' + CLASS.shapes + $$.getTargetSelectorSuffix(targetId))
              .selectAll('.' + CLASS.shape)
              .filter(function () {
              return d3.select(this).classed(CLASS.SELECTED);
          })
              .nodes()
              .map(function (d) {
              var data = d.__data__;
              return data.data ? data.data : data;
          });
      };
      Chart.prototype.select = function (ids, indices, resetOther) {
          var $$ = this.internal, d3 = $$.d3, config = $$.config;
          if (!config.data_selection_enabled) {
              return;
          }
          $$.main
              .selectAll('.' + CLASS.shapes)
              .selectAll('.' + CLASS.shape)
              .each(function (d, i) {
              var shape = d3.select(this), id = d.data ? d.data.id : d.id, toggle = $$.getToggle(this, d).bind($$), isTargetId = config.data_selection_grouped || !ids || ids.indexOf(id) >= 0, isTargetIndex = !indices || indices.indexOf(i) >= 0, isSelected = shape.classed(CLASS.SELECTED);
              // line/area selection not supported yet
              if (shape.classed(CLASS.line) || shape.classed(CLASS.area)) {
                  return;
              }
              if (isTargetId && isTargetIndex) {
                  if (config.data_selection_isselectable(d) && !isSelected) {
                      toggle(true, shape.classed(CLASS.SELECTED, true), d, i);
                  }
              }
              else if (isDefined(resetOther) && resetOther) {
                  if (isSelected) {
                      toggle(false, shape.classed(CLASS.SELECTED, false), d, i);
                  }
              }
          });
      };
      Chart.prototype.unselect = function (ids, indices) {
          var $$ = this.internal, d3 = $$.d3, config = $$.config;
          if (!config.data_selection_enabled) {
              return;
          }
          $$.main
              .selectAll('.' + CLASS.shapes)
              .selectAll('.' + CLASS.shape)
              .each(function (d, i) {
              var shape = d3.select(this), id = d.data ? d.data.id : d.id, toggle = $$.getToggle(this, d).bind($$), isTargetId = config.data_selection_grouped || !ids || ids.indexOf(id) >= 0, isTargetIndex = !indices || indices.indexOf(i) >= 0, isSelected = shape.classed(CLASS.SELECTED);
              // line/area selection not supported yet
              if (shape.classed(CLASS.line) || shape.classed(CLASS.area)) {
                  return;
              }
              if (isTargetId && isTargetIndex) {
                  if (config.data_selection_isselectable(d)) {
                      if (isSelected) {
                          toggle(false, shape.classed(CLASS.SELECTED, false), d, i);
                      }
                  }
              }
          });
      };

      Chart.prototype.show = function (targetIds, options) {
          var $$ = this.internal, targets;
          targetIds = $$.mapToTargetIds(targetIds);
          options = options || {};
          $$.removeHiddenTargetIds(targetIds);
          targets = $$.svg.selectAll($$.selectorTargets(targetIds));
          targets
              .transition()
              .style('display', isIE() ? 'block' : 'initial', 'important')
              .style('opacity', 1, 'important')
              .call($$.endall, function () {
              targets.style('opacity', null).style('opacity', 1);
          });
          if (options.withLegend) {
              $$.showLegend(targetIds);
          }
          $$.redraw({
              withUpdateOrgXDomain: true,
              withUpdateXDomain: true,
              withLegend: true
          });
      };
      Chart.prototype.hide = function (targetIds, options) {
          var $$ = this.internal, targets;
          targetIds = $$.mapToTargetIds(targetIds);
          options = options || {};
          $$.addHiddenTargetIds(targetIds);
          targets = $$.svg.selectAll($$.selectorTargets(targetIds));
          targets
              .transition()
              .style('opacity', 0, 'important')
              .call($$.endall, function () {
              targets.style('opacity', null).style('opacity', 0);
              targets.style('display', 'none');
          });
          if (options.withLegend) {
              $$.hideLegend(targetIds);
          }
          $$.redraw({
              withUpdateOrgXDomain: true,
              withUpdateXDomain: true,
              withLegend: true
          });
      };
      Chart.prototype.toggle = function (targetIds, options) {
          var that = this, $$ = this.internal;
          $$.mapToTargetIds(targetIds).forEach(function (targetId) {
              $$.isTargetToShow(targetId)
                  ? that.hide(targetId, options)
                  : that.show(targetId, options);
          });
      };

      Chart.prototype.subchart = function () { };
      Chart.prototype.subchart.isShown = function () {
          var $$ = this.internal;
          return $$.config.subchart_show;
      };
      Chart.prototype.subchart.show = function () {
          var $$ = this.internal;
          if ($$.config.subchart_show) {
              return;
          }
          $$.config.subchart_show = true;
          // insert DOM
          $$.initSubchart();
          // update dimensions with sub chart now visible
          $$.updateDimension();
          // insert brush (depends on sizes previously updated)
          $$.initSubchartBrush();
          // attach data
          $$.updateTargetsForSubchart($$.getTargets());
          // reset fade-in state
          $$.mapToIds($$.data.targets).forEach(function (id) {
              $$.withoutFadeIn[id] = false;
          });
          // redraw chart !
          $$.updateAndRedraw();
          // update visible targets !
          $$.showTargets();
      };
      Chart.prototype.subchart.hide = function () {
          var $$ = this.internal;
          if (!$$.config.subchart_show) {
              return;
          }
          $$.config.subchart_show = false;
          // remove DOM
          $$.removeSubchart();
          // re-render chart
          $$.redraw();
      };

      Chart.prototype.tooltip = function () { };
      Chart.prototype.tooltip.show = function (args) {
          var $$ = this.internal, targets, data, mouse = {};
          // determine mouse position on the chart
          if (args.mouse) {
              mouse = args.mouse;
          }
          else {
              // determine focus data
              if (args.data) {
                  data = args.data;
              }
              else if (typeof args.x !== 'undefined') {
                  if (args.id) {
                      targets = $$.data.targets.filter(function (t) {
                          return t.id === args.id;
                      });
                  }
                  else {
                      targets = $$.data.targets;
                  }
                  data = $$.filterByX(targets, args.x).slice(0, 1)[0];
              }
              mouse = data ? $$.getMousePosition(data) : null;
          }
          // emulate mouse events to show
          $$.dispatchEvent('mousemove', mouse);
          $$.config.tooltip_onshow.call($$, data);
      };
      Chart.prototype.tooltip.hide = function () {
          // TODO: get target data by checking the state of focus
          this.internal.dispatchEvent('mouseout', 0);
          this.internal.config.tooltip_onhide.call(this);
      };

      Chart.prototype.transform = function (type, targetIds) {
          var $$ = this.internal, options = ['pie', 'donut'].indexOf(type) >= 0 ? { withTransform: true } : null;
          $$.transformTo(targetIds, type, options);
      };
      ChartInternal.prototype.transformTo = function (targetIds, type, optionsForRedraw) {
          var $$ = this, withTransitionForAxis = !$$.hasArcType(), options = optionsForRedraw || {
              withTransitionForAxis: withTransitionForAxis
          };
          options.withTransitionForTransform = false;
          $$.transiting = false;
          $$.setTargetType(targetIds, type);
          $$.updateTargets($$.data.targets); // this is needed when transforming to arc
          $$.updateAndRedraw(options);
      };

      Chart.prototype.x = function (x) {
          var $$ = this.internal;
          if (arguments.length) {
              $$.updateTargetX($$.data.targets, x);
              $$.redraw({ withUpdateOrgXDomain: true, withUpdateXDomain: true });
          }
          return $$.data.xs;
      };
      Chart.prototype.xs = function (xs) {
          var $$ = this.internal;
          if (arguments.length) {
              $$.updateTargetXs($$.data.targets, xs);
              $$.redraw({ withUpdateOrgXDomain: true, withUpdateXDomain: true });
          }
          return $$.data.xs;
      };

      Chart.prototype.zoom = function (domain) {
          var $$ = this.internal;
          if (domain) {
              if ($$.isTimeSeries()) {
                  domain = domain.map(function (x) {
                      return $$.parseDate(x);
                  });
              }
              if ($$.config.subchart_show) {
                  $$.brush.selectionAsValue(domain, true);
              }
              else {
                  $$.updateXDomain(null, true, false, false, domain);
                  $$.redraw({ withY: $$.config.zoom_rescale, withSubchart: false });
              }
              $$.config.zoom_onzoom.call(this, $$.x.orgDomain());
              return domain;
          }
          else {
              return $$.x.domain();
          }
      };
      Chart.prototype.zoom.enable = function (enabled) {
          var $$ = this.internal;
          $$.config.zoom_enabled = enabled;
          $$.updateAndRedraw();
      };
      Chart.prototype.unzoom = function () {
          var $$ = this.internal;
          if ($$.config.subchart_show) {
              $$.brush.clear();
          }
          else {
              $$.updateXDomain(null, true, false, false, $$.subX.domain());
              $$.redraw({ withY: $$.config.zoom_rescale, withSubchart: false });
          }
      };
      Chart.prototype.zoom.max = function (max) {
          var $$ = this.internal, config = $$.config, d3 = $$.d3;
          if (max === 0 || max) {
              config.zoom_x_max = d3.max([$$.orgXDomain[1], max]);
          }
          else {
              return config.zoom_x_max;
          }
      };
      Chart.prototype.zoom.min = function (min) {
          var $$ = this.internal, config = $$.config, d3 = $$.d3;
          if (min === 0 || min) {
              config.zoom_x_min = d3.min([$$.orgXDomain[0], min]);
          }
          else {
              return config.zoom_x_min;
          }
      };
      Chart.prototype.zoom.range = function (range) {
          if (arguments.length) {
              if (isDefined(range.max)) {
                  this.domain.max(range.max);
              }
              if (isDefined(range.min)) {
                  this.domain.min(range.min);
              }
          }
          else {
              return {
                  max: this.domain.max(),
                  min: this.domain.min()
              };
          }
      };

      ChartInternal.prototype.initPie = function () {
          var $$ = this, d3 = $$.d3;
          $$.pie = d3
              .pie()
              .padAngle(this.getPadAngle.bind(this))
              .value(function (d) {
              return d.values.reduce(function (a, b) {
                  return a + b.value;
              }, 0);
          });
          var orderFct = $$.getOrderFunction();
          // we need to reverse the returned order if asc or desc to have the slice in expected order.
          if (orderFct && ($$.isOrderAsc() || $$.isOrderDesc())) {
              var defaultSort_1 = orderFct;
              orderFct = function (t1, t2) { return defaultSort_1(t1, t2) * -1; };
          }
          $$.pie.sort(orderFct || null);
      };
      ChartInternal.prototype.updateRadius = function () {
          var $$ = this, config = $$.config, w = config.gauge_width || config.donut_width, gaugeArcWidth = $$.filterTargetsToShow($$.data.targets).length *
              $$.config.gauge_arcs_minWidth;
          $$.radiusExpanded =
              (Math.min($$.arcWidth, $$.arcHeight) / 2) * ($$.hasType('gauge') ? 0.85 : 1);
          $$.radius = $$.radiusExpanded * 0.95;
          $$.innerRadiusRatio = w ? ($$.radius - w) / $$.radius : 0.6;
          $$.innerRadius =
              $$.hasType('donut') || $$.hasType('gauge')
                  ? $$.radius * $$.innerRadiusRatio
                  : 0;
          $$.gaugeArcWidth = w
              ? w
              : gaugeArcWidth <= $$.radius - $$.innerRadius
                  ? $$.radius - $$.innerRadius
                  : gaugeArcWidth <= $$.radius
                      ? gaugeArcWidth
                      : $$.radius;
      };
      ChartInternal.prototype.getPadAngle = function () {
          if (this.hasType('pie')) {
              return this.config.pie_padAngle || 0;
          }
          else if (this.hasType('donut')) {
              return this.config.donut_padAngle || 0;
          }
          else {
              return 0;
          }
      };
      ChartInternal.prototype.updateArc = function () {
          var $$ = this;
          $$.svgArc = $$.getSvgArc();
          $$.svgArcExpanded = $$.getSvgArcExpanded();
          $$.svgArcExpandedSub = $$.getSvgArcExpanded(0.98);
      };
      ChartInternal.prototype.updateAngle = function (d) {
          var $$ = this, config = $$.config, found = false, index = 0, gMin, gMax, gTic, gValue;
          if (!config) {
              return null;
          }
          $$.pie($$.filterTargetsToShow($$.data.targets)).forEach(function (t) {
              if (!found && t.data.id === d.data.id) {
                  found = true;
                  d = t;
                  d.index = index;
              }
              index++;
          });
          if (isNaN(d.startAngle)) {
              d.startAngle = 0;
          }
          if (isNaN(d.endAngle)) {
              d.endAngle = d.startAngle;
          }
          if ($$.isGaugeType(d.data)) {
              gMin = config.gauge_min;
              gMax = config.gauge_max;
              gTic = (Math.PI * (config.gauge_fullCircle ? 2 : 1)) / (gMax - gMin);
              gValue = d.value < gMin ? 0 : d.value < gMax ? d.value - gMin : gMax - gMin;
              d.startAngle = config.gauge_startingAngle;
              d.endAngle = d.startAngle + gTic * gValue;
          }
          return found ? d : null;
      };
      ChartInternal.prototype.getSvgArc = function () {
          var $$ = this, hasGaugeType = $$.hasType('gauge'), singleArcWidth = $$.gaugeArcWidth / $$.filterTargetsToShow($$.data.targets).length, arc = $$.d3
              .arc()
              .outerRadius(function (d) {
              return hasGaugeType ? $$.radius - singleArcWidth * d.index : $$.radius;
          })
              .innerRadius(function (d) {
              return hasGaugeType
                  ? $$.radius - singleArcWidth * (d.index + 1)
                  : $$.innerRadius;
          }), newArc = function (d, withoutUpdate) {
              var updated;
              if (withoutUpdate) {
                  return arc(d);
              } // for interpolate
              updated = $$.updateAngle(d);
              return updated ? arc(updated) : 'M 0 0';
          };
          newArc.centroid = arc.centroid;
          return newArc;
      };
      ChartInternal.prototype.getSvgArcExpanded = function (rate) {
          rate = rate || 1;
          var $$ = this, hasGaugeType = $$.hasType('gauge'), singleArcWidth = $$.gaugeArcWidth / $$.filterTargetsToShow($$.data.targets).length, expandWidth = Math.min($$.radiusExpanded * rate - $$.radius, singleArcWidth * 0.8 - (1 - rate) * 100), arc = $$.d3
              .arc()
              .outerRadius(function (d) {
              return hasGaugeType
                  ? $$.radius - singleArcWidth * d.index + expandWidth
                  : $$.radiusExpanded * rate;
          })
              .innerRadius(function (d) {
              return hasGaugeType
                  ? $$.radius - singleArcWidth * (d.index + 1)
                  : $$.innerRadius;
          });
          return function (d) {
              var updated = $$.updateAngle(d);
              return updated ? arc(updated) : 'M 0 0';
          };
      };
      ChartInternal.prototype.getArc = function (d, withoutUpdate, force) {
          return force || this.isArcType(d.data)
              ? this.svgArc(d, withoutUpdate)
              : 'M 0 0';
      };
      ChartInternal.prototype.transformForArcLabel = function (d) {
          var $$ = this, config = $$.config, updated = $$.updateAngle(d), c, x, y, h, ratio, translate = '', hasGauge = $$.hasType('gauge');
          if (updated && !hasGauge) {
              c = this.svgArc.centroid(updated);
              x = isNaN(c[0]) ? 0 : c[0];
              y = isNaN(c[1]) ? 0 : c[1];
              h = Math.sqrt(x * x + y * y);
              if ($$.hasType('donut') && config.donut_label_ratio) {
                  ratio = isFunction(config.donut_label_ratio)
                      ? config.donut_label_ratio(d, $$.radius, h)
                      : config.donut_label_ratio;
              }
              else if ($$.hasType('pie') && config.pie_label_ratio) {
                  ratio = isFunction(config.pie_label_ratio)
                      ? config.pie_label_ratio(d, $$.radius, h)
                      : config.pie_label_ratio;
              }
              else {
                  ratio =
                      $$.radius && h
                          ? ((36 / $$.radius > 0.375 ? 1.175 - 36 / $$.radius : 0.8) *
                              $$.radius) /
                              h
                          : 0;
              }
              translate = 'translate(' + x * ratio + ',' + y * ratio + ')';
          }
          else if (updated &&
              hasGauge &&
              $$.filterTargetsToShow($$.data.targets).length > 1) {
              var y1 = Math.sin(updated.endAngle - Math.PI / 2);
              x = Math.cos(updated.endAngle - Math.PI / 2) * ($$.radiusExpanded + 25);
              y = y1 * ($$.radiusExpanded + 15 - Math.abs(y1 * 10)) + 3;
              translate = 'translate(' + x + ',' + y + ')';
          }
          return translate;
      };
      /**
       * @deprecated Use `getRatio('arc', d)` instead.
       */
      ChartInternal.prototype.getArcRatio = function (d) {
          return this.getRatio('arc', d);
      };
      ChartInternal.prototype.convertToArcData = function (d) {
          return this.addName({
              id: d.data.id,
              value: d.value,
              ratio: this.getRatio('arc', d),
              index: d.index
          });
      };
      ChartInternal.prototype.textForArcLabel = function (d) {
          var $$ = this, updated, value, ratio, id, format;
          if (!$$.shouldShowArcLabel()) {
              return '';
          }
          updated = $$.updateAngle(d);
          value = updated ? updated.value : null;
          ratio = $$.getRatio('arc', updated);
          id = d.data.id;
          if (!$$.hasType('gauge') && !$$.meetsArcLabelThreshold(ratio)) {
              return '';
          }
          format = $$.getArcLabelFormat();
          return format
              ? format(value, ratio, id)
              : $$.defaultArcValueFormat(value, ratio);
      };
      ChartInternal.prototype.textForGaugeMinMax = function (value, isMax) {
          var $$ = this, format = $$.getGaugeLabelExtents();
          return format ? format(value, isMax) : value;
      };
      ChartInternal.prototype.expandArc = function (targetIds) {
          var $$ = this, interval;
          // MEMO: avoid to cancel transition
          if ($$.transiting) {
              interval = window.setInterval(function () {
                  if (!$$.transiting) {
                      window.clearInterval(interval);
                      if ($$.legend.selectAll('.c3-legend-item-focused').size() > 0) {
                          $$.expandArc(targetIds);
                      }
                  }
              }, 10);
              return;
          }
          targetIds = $$.mapToTargetIds(targetIds);
          $$.svg
              .selectAll($$.selectorTargets(targetIds, '.' + CLASS.chartArc))
              .each(function (d) {
              if (!$$.shouldExpand(d.data.id)) {
                  return;
              }
              $$.d3
                  .select(this)
                  .selectAll('path')
                  .transition()
                  .duration($$.expandDuration(d.data.id))
                  .attr('d', $$.svgArcExpanded)
                  .transition()
                  .duration($$.expandDuration(d.data.id) * 2)
                  .attr('d', $$.svgArcExpandedSub)
                  .each(function (d) {
                  if ($$.isDonutType(d.data)) ;
              });
          });
      };
      ChartInternal.prototype.unexpandArc = function (targetIds) {
          var $$ = this;
          if ($$.transiting) {
              return;
          }
          targetIds = $$.mapToTargetIds(targetIds);
          $$.svg
              .selectAll($$.selectorTargets(targetIds, '.' + CLASS.chartArc))
              .selectAll('path')
              .transition()
              .duration(function (d) {
              return $$.expandDuration(d.data.id);
          })
              .attr('d', $$.svgArc);
          $$.svg.selectAll('.' + CLASS.arc);
      };
      ChartInternal.prototype.expandDuration = function (id) {
          var $$ = this, config = $$.config;
          if ($$.isDonutType(id)) {
              return config.donut_expand_duration;
          }
          else if ($$.isGaugeType(id)) {
              return config.gauge_expand_duration;
          }
          else if ($$.isPieType(id)) {
              return config.pie_expand_duration;
          }
          else {
              return 50;
          }
      };
      ChartInternal.prototype.shouldExpand = function (id) {
          var $$ = this, config = $$.config;
          return (($$.isDonutType(id) && config.donut_expand) ||
              ($$.isGaugeType(id) && config.gauge_expand) ||
              ($$.isPieType(id) && config.pie_expand));
      };
      ChartInternal.prototype.shouldShowArcLabel = function () {
          var $$ = this, config = $$.config, shouldShow = true;
          if ($$.hasType('donut')) {
              shouldShow = config.donut_label_show;
          }
          else if ($$.hasType('pie')) {
              shouldShow = config.pie_label_show;
          }
          // when gauge, always true
          return shouldShow;
      };
      ChartInternal.prototype.meetsArcLabelThreshold = function (ratio) {
          var $$ = this, config = $$.config, threshold = $$.hasType('donut')
              ? config.donut_label_threshold
              : config.pie_label_threshold;
          return ratio >= threshold;
      };
      ChartInternal.prototype.getArcLabelFormat = function () {
          var $$ = this, config = $$.config, format = config.pie_label_format;
          if ($$.hasType('gauge')) {
              format = config.gauge_label_format;
          }
          else if ($$.hasType('donut')) {
              format = config.donut_label_format;
          }
          return format;
      };
      ChartInternal.prototype.getGaugeLabelExtents = function () {
          var $$ = this, config = $$.config;
          return config.gauge_label_extents;
      };
      ChartInternal.prototype.getArcTitle = function () {
          var $$ = this;
          return $$.hasType('donut') ? $$.config.donut_title : '';
      };
      ChartInternal.prototype.updateTargetsForArc = function (targets) {
          var $$ = this, main = $$.main, mainPies, mainPieEnter, classChartArc = $$.classChartArc.bind($$), classArcs = $$.classArcs.bind($$), classFocus = $$.classFocus.bind($$);
          mainPies = main
              .select('.' + CLASS.chartArcs)
              .selectAll('.' + CLASS.chartArc)
              .data($$.pie(targets))
              .attr('class', function (d) {
              return classChartArc(d) + classFocus(d.data);
          });
          mainPieEnter = mainPies
              .enter()
              .append('g')
              .attr('class', classChartArc);
          mainPieEnter.append('g').attr('class', classArcs);
          mainPieEnter
              .append('text')
              .attr('dy', $$.hasType('gauge') ? '-.1em' : '.35em')
              .style('opacity', 0)
              .style('text-anchor', 'middle')
              .style('pointer-events', 'none');
          // MEMO: can not keep same color..., but not bad to update color in redraw
          //mainPieUpdate.exit().remove();
      };
      ChartInternal.prototype.initArc = function () {
          var $$ = this;
          $$.arcs = $$.main
              .select('.' + CLASS.chart)
              .append('g')
              .attr('class', CLASS.chartArcs)
              .attr('transform', $$.getTranslate('arc'));
          $$.arcs
              .append('text')
              .attr('class', CLASS.chartArcsTitle)
              .style('text-anchor', 'middle')
              .text($$.getArcTitle());
      };
      ChartInternal.prototype.redrawArc = function (duration, durationForExit, withTransform) {
          var $$ = this, d3 = $$.d3, config = $$.config, main = $$.main, arcs, mainArc, arcLabelLines, mainArcLabelLine, hasGaugeType = $$.hasType('gauge');
          arcs = main
              .selectAll('.' + CLASS.arcs)
              .selectAll('.' + CLASS.arc)
              .data($$.arcData.bind($$));
          mainArc = arcs
              .enter()
              .append('path')
              .attr('class', $$.classArc.bind($$))
              .style('fill', function (d) {
              return $$.color(d.data);
          })
              .style('cursor', function (d) {
              return config.interaction_enabled && config.data_selection_isselectable(d)
                  ? 'pointer'
                  : null;
          })
              .each(function (d) {
              if ($$.isGaugeType(d.data)) {
                  d.startAngle = d.endAngle = config.gauge_startingAngle;
              }
              this._current = d;
          })
              .merge(arcs);
          if (hasGaugeType) {
              arcLabelLines = main
                  .selectAll('.' + CLASS.arcs)
                  .selectAll('.' + CLASS.arcLabelLine)
                  .data($$.arcData.bind($$));
              mainArcLabelLine = arcLabelLines
                  .enter()
                  .append('rect')
                  .attr('class', function (d) {
                  return (CLASS.arcLabelLine +
                      ' ' +
                      CLASS.target +
                      ' ' +
                      CLASS.target +
                      '-' +
                      d.data.id);
              })
                  .merge(arcLabelLines);
              if ($$.filterTargetsToShow($$.data.targets).length === 1) {
                  mainArcLabelLine.style('display', 'none');
              }
              else {
                  mainArcLabelLine
                      .style('fill', function (d) {
                      return $$.levelColor
                          ? $$.levelColor(d.data.values.reduce(function (total, item) {
                              return total + item.value;
                          }, 0))
                          : $$.color(d.data);
                  })
                      .style('display', config.gauge_labelLine_show ? '' : 'none')
                      .each(function (d) {
                      var lineLength = 0, lineThickness = 2, x = 0, y = 0, transform = '';
                      if ($$.hiddenTargetIds.indexOf(d.data.id) < 0) {
                          var updated = $$.updateAngle(d), innerLineLength = ($$.gaugeArcWidth /
                              $$.filterTargetsToShow($$.data.targets).length) *
                              (updated.index + 1), lineAngle = updated.endAngle - Math.PI / 2, arcInnerRadius = $$.radius - innerLineLength, linePositioningAngle = lineAngle - (arcInnerRadius === 0 ? 0 : 1 / arcInnerRadius);
                          lineLength = $$.radiusExpanded - $$.radius + innerLineLength;
                          x = Math.cos(linePositioningAngle) * arcInnerRadius;
                          y = Math.sin(linePositioningAngle) * arcInnerRadius;
                          transform =
                              'rotate(' +
                                  (lineAngle * 180) / Math.PI +
                                  ', ' +
                                  x +
                                  ', ' +
                                  y +
                                  ')';
                      }
                      d3.select(this)
                          .attr('x', x)
                          .attr('y', y)
                          .attr('width', lineLength)
                          .attr('height', lineThickness)
                          .attr('transform', transform)
                          .style('stroke-dasharray', '0, ' + (lineLength + lineThickness) + ', 0');
                  });
              }
          }
          mainArc
              .attr('transform', function (d) {
              return !$$.isGaugeType(d.data) && withTransform ? 'scale(0)' : '';
          })
              .on('mouseover', config.interaction_enabled
              ? function (d) {
                  var updated, arcData;
                  if ($$.transiting) {
                      // skip while transiting
                      return;
                  }
                  updated = $$.updateAngle(d);
                  if (updated) {
                      arcData = $$.convertToArcData(updated);
                      // transitions
                      $$.expandArc(updated.data.id);
                      $$.api.focus(updated.data.id);
                      $$.toggleFocusLegend(updated.data.id, true);
                      $$.config.data_onmouseover(arcData, this);
                  }
              }
              : null)
              .on('mousemove', config.interaction_enabled
              ? function (d) {
                  var updated = $$.updateAngle(d), arcData, selectedData;
                  if (updated) {
                      (arcData = $$.convertToArcData(updated)),
                          (selectedData = [arcData]);
                      $$.showTooltip(selectedData, this);
                  }
              }
              : null)
              .on('mouseout', config.interaction_enabled
              ? function (d) {
                  var updated, arcData;
                  if ($$.transiting) {
                      // skip while transiting
                      return;
                  }
                  updated = $$.updateAngle(d);
                  if (updated) {
                      arcData = $$.convertToArcData(updated);
                      // transitions
                      $$.unexpandArc(updated.data.id);
                      $$.api.revert();
                      $$.revertLegend();
                      $$.hideTooltip();
                      $$.config.data_onmouseout(arcData, this);
                  }
              }
              : null)
              .on('click', config.interaction_enabled
              ? function (d, i) {
                  var updated = $$.updateAngle(d), arcData;
                  if (updated) {
                      arcData = $$.convertToArcData(updated);
                      if ($$.toggleShape) {
                          $$.toggleShape(this, arcData, i);
                      }
                      $$.config.data_onclick.call($$.api, arcData, this);
                  }
              }
              : null)
              .each(function () {
              $$.transiting = true;
          })
              .transition()
              .duration(duration)
              .attrTween('d', function (d) {
              var updated = $$.updateAngle(d), interpolate;
              if (!updated) {
                  return function () {
                      return 'M 0 0';
                  };
              }
              //                if (this._current === d) {
              //                    this._current = {
              //                        startAngle: Math.PI*2,
              //                        endAngle: Math.PI*2,
              //                    };
              //                }
              if (isNaN(this._current.startAngle)) {
                  this._current.startAngle = 0;
              }
              if (isNaN(this._current.endAngle)) {
                  this._current.endAngle = this._current.startAngle;
              }
              interpolate = d3.interpolate(this._current, updated);
              this._current = interpolate(0);
              return function (t) {
                  // prevents crashing the charts once in transition and chart.destroy() has been called
                  if ($$.config === null) {
                      return 'M 0 0';
                  }
                  var interpolated = interpolate(t);
                  interpolated.data = d.data; // data.id will be updated by interporator
                  return $$.getArc(interpolated, true);
              };
          })
              .attr('transform', withTransform ? 'scale(1)' : '')
              .style('fill', function (d) {
              return $$.levelColor
                  ? $$.levelColor(d.data.values.reduce(function (total, item) {
                      return total + item.value;
                  }, 0))
                  : $$.color(d.data.id);
          }) // Where gauge reading color would receive customization.
              .call($$.endall, function () {
              $$.transiting = false;
          });
          arcs
              .exit()
              .transition()
              .duration(durationForExit)
              .style('opacity', 0)
              .remove();
          main
              .selectAll('.' + CLASS.chartArc)
              .select('text')
              .style('opacity', 0)
              .attr('class', function (d) {
              return $$.isGaugeType(d.data) ? CLASS.gaugeValue : '';
          })
              .text($$.textForArcLabel.bind($$))
              .attr('transform', $$.transformForArcLabel.bind($$))
              .style('font-size', function (d) {
              return $$.isGaugeType(d.data) &&
                  $$.filterTargetsToShow($$.data.targets).length === 1
                  ? Math.round($$.radius / 5) + 'px'
                  : '';
          })
              .transition()
              .duration(duration)
              .style('opacity', function (d) {
              return $$.isTargetToShow(d.data.id) && $$.isArcType(d.data) ? 1 : 0;
          });
          main
              .select('.' + CLASS.chartArcsTitle)
              .style('opacity', $$.hasType('donut') || hasGaugeType ? 1 : 0);
          if (hasGaugeType) {
              var index_1 = 0;
              var backgroundArc = $$.arcs
                  .select('g.' + CLASS.chartArcsBackground)
                  .selectAll('path.' + CLASS.chartArcsBackground)
                  .data($$.data.targets);
              backgroundArc
                  .enter()
                  .append('path')
                  .attr('class', function (d, i) {
                  return CLASS.chartArcsBackground + ' ' + CLASS.chartArcsBackground + '-' + i;
              })
                  .merge(backgroundArc)
                  .attr('d', function (d1) {
                  if ($$.hiddenTargetIds.indexOf(d1.id) >= 0) {
                      return 'M 0 0';
                  }
                  var d = {
                      data: [{ value: config.gauge_max }],
                      startAngle: config.gauge_startingAngle,
                      endAngle: -1 *
                          config.gauge_startingAngle *
                          (config.gauge_fullCircle ? Math.PI : 1),
                      index: index_1++
                  };
                  return $$.getArc(d, true, true);
              });
              backgroundArc.exit().remove();
              $$.arcs
                  .select('.' + CLASS.chartArcsGaugeUnit)
                  .attr('dy', '.75em')
                  .text(config.gauge_label_show ? config.gauge_units : '');
              $$.arcs
                  .select('.' + CLASS.chartArcsGaugeMin)
                  .attr('dx', -1 *
                  ($$.innerRadius +
                      ($$.radius - $$.innerRadius) / (config.gauge_fullCircle ? 1 : 2)) +
                  'px')
                  .attr('dy', '1.2em')
                  .text(config.gauge_label_show
                  ? $$.textForGaugeMinMax(config.gauge_min, false)
                  : '');
              $$.arcs
                  .select('.' + CLASS.chartArcsGaugeMax)
                  .attr('dx', $$.innerRadius +
                  ($$.radius - $$.innerRadius) / (config.gauge_fullCircle ? 1 : 2) +
                  'px')
                  .attr('dy', '1.2em')
                  .text(config.gauge_label_show
                  ? $$.textForGaugeMinMax(config.gauge_max, true)
                  : '');
          }
      };
      ChartInternal.prototype.initGauge = function () {
          var arcs = this.arcs;
          if (this.hasType('gauge')) {
              arcs.append('g').attr('class', CLASS.chartArcsBackground);
              arcs
                  .append('text')
                  .attr('class', CLASS.chartArcsGaugeUnit)
                  .style('text-anchor', 'middle')
                  .style('pointer-events', 'none');
              arcs
                  .append('text')
                  .attr('class', CLASS.chartArcsGaugeMin)
                  .style('text-anchor', 'middle')
                  .style('pointer-events', 'none');
              arcs
                  .append('text')
                  .attr('class', CLASS.chartArcsGaugeMax)
                  .style('text-anchor', 'middle')
                  .style('pointer-events', 'none');
          }
      };
      ChartInternal.prototype.getGaugeLabelHeight = function () {
          return this.config.gauge_label_show ? 20 : 0;
      };

      /**
       * Store value into cache
       *
       * @param key
       * @param value
       */
      ChartInternal.prototype.addToCache = function (key, value) {
          this.cache["$" + key] = value;
      };
      /**
       * Returns a cached value or undefined
       *
       * @param key
       * @return {*}
       */
      ChartInternal.prototype.getFromCache = function (key) {
          return this.cache["$" + key];
      };
      /**
       * Reset cached data
       */
      ChartInternal.prototype.resetCache = function () {
          var _this = this;
          Object.keys(this.cache)
              .filter(function (key) { return /^\$/.test(key); })
              .forEach(function (key) {
              delete _this.cache[key];
          });
      };
      // Old API that stores Targets
      ChartInternal.prototype.hasCaches = function (ids) {
          for (var i = 0; i < ids.length; i++) {
              if (!(ids[i] in this.cache)) {
                  return false;
              }
          }
          return true;
      };
      ChartInternal.prototype.addCache = function (id, target) {
          this.cache[id] = this.cloneTarget(target);
      };
      ChartInternal.prototype.getCaches = function (ids) {
          var targets = [], i;
          for (i = 0; i < ids.length; i++) {
              if (ids[i] in this.cache) {
                  targets.push(this.cloneTarget(this.cache[ids[i]]));
              }
          }
          return targets;
      };

      ChartInternal.prototype.categoryName = function (i) {
          var config = this.config;
          return i < config.axis_x_categories.length ? config.axis_x_categories[i] : i;
      };

      ChartInternal.prototype.generateTargetClass = function (targetId) {
          return targetId || targetId === 0 ? ('-' + targetId).replace(/\s/g, '-') : '';
      };
      ChartInternal.prototype.generateClass = function (prefix, targetId) {
          return ' ' + prefix + ' ' + prefix + this.generateTargetClass(targetId);
      };
      ChartInternal.prototype.classText = function (d) {
          return this.generateClass(CLASS.text, d.index);
      };
      ChartInternal.prototype.classTexts = function (d) {
          return this.generateClass(CLASS.texts, d.id);
      };
      ChartInternal.prototype.classShape = function (d) {
          return this.generateClass(CLASS.shape, d.index);
      };
      ChartInternal.prototype.classShapes = function (d) {
          return this.generateClass(CLASS.shapes, d.id);
      };
      ChartInternal.prototype.classLine = function (d) {
          return this.classShape(d) + this.generateClass(CLASS.line, d.id);
      };
      ChartInternal.prototype.classLines = function (d) {
          return this.classShapes(d) + this.generateClass(CLASS.lines, d.id);
      };
      ChartInternal.prototype.classCircle = function (d) {
          return this.classShape(d) + this.generateClass(CLASS.circle, d.index);
      };
      ChartInternal.prototype.classCircles = function (d) {
          return this.classShapes(d) + this.generateClass(CLASS.circles, d.id);
      };
      ChartInternal.prototype.classBar = function (d) {
          return this.classShape(d) + this.generateClass(CLASS.bar, d.index);
      };
      ChartInternal.prototype.classBars = function (d) {
          return this.classShapes(d) + this.generateClass(CLASS.bars, d.id);
      };
      ChartInternal.prototype.classArc = function (d) {
          return this.classShape(d.data) + this.generateClass(CLASS.arc, d.data.id);
      };
      ChartInternal.prototype.classArcs = function (d) {
          return this.classShapes(d.data) + this.generateClass(CLASS.arcs, d.data.id);
      };
      ChartInternal.prototype.classArea = function (d) {
          return this.classShape(d) + this.generateClass(CLASS.area, d.id);
      };
      ChartInternal.prototype.classAreas = function (d) {
          return this.classShapes(d) + this.generateClass(CLASS.areas, d.id);
      };
      ChartInternal.prototype.classRegion = function (d, i) {
          return (this.generateClass(CLASS.region, i) + ' ' + ('class' in d ? d['class'] : ''));
      };
      ChartInternal.prototype.classEvent = function (d) {
          return this.generateClass(CLASS.eventRect, d.index);
      };
      ChartInternal.prototype.classTarget = function (id) {
          var $$ = this;
          var additionalClassSuffix = $$.config.data_classes[id], additionalClass = '';
          if (additionalClassSuffix) {
              additionalClass = ' ' + CLASS.target + '-' + additionalClassSuffix;
          }
          return $$.generateClass(CLASS.target, id) + additionalClass;
      };
      ChartInternal.prototype.classFocus = function (d) {
          return this.classFocused(d) + this.classDefocused(d);
      };
      ChartInternal.prototype.classFocused = function (d) {
          return ' ' + (this.focusedTargetIds.indexOf(d.id) >= 0 ? CLASS.focused : '');
      };
      ChartInternal.prototype.classDefocused = function (d) {
          return (' ' + (this.defocusedTargetIds.indexOf(d.id) >= 0 ? CLASS.defocused : ''));
      };
      ChartInternal.prototype.classChartText = function (d) {
          return CLASS.chartText + this.classTarget(d.id);
      };
      ChartInternal.prototype.classChartLine = function (d) {
          return CLASS.chartLine + this.classTarget(d.id);
      };
      ChartInternal.prototype.classChartBar = function (d) {
          return CLASS.chartBar + this.classTarget(d.id);
      };
      ChartInternal.prototype.classChartArc = function (d) {
          return CLASS.chartArc + this.classTarget(d.data.id);
      };
      ChartInternal.prototype.getTargetSelectorSuffix = function (targetId) {
          var targetClass = this.generateTargetClass(targetId);
          if (window.CSS && window.CSS.escape) {
              return window.CSS.escape(targetClass);
          }
          // fallback on imperfect method for old browsers (does not handles unicode)
          return targetClass.replace(/([?!@#$%^&*()=+,.<>'":;\[\]\/|~`{}\\])/g, '\\$1');
      };
      ChartInternal.prototype.selectorTarget = function (id, prefix) {
          return (prefix || '') + '.' + CLASS.target + this.getTargetSelectorSuffix(id);
      };
      ChartInternal.prototype.selectorTargets = function (ids, prefix) {
          var $$ = this;
          ids = ids || [];
          return ids.length
              ? ids.map(function (id) {
                  return $$.selectorTarget(id, prefix);
              })
              : null;
      };
      ChartInternal.prototype.selectorLegend = function (id) {
          return '.' + CLASS.legendItem + this.getTargetSelectorSuffix(id);
      };
      ChartInternal.prototype.selectorLegends = function (ids) {
          var $$ = this;
          return ids && ids.length
              ? ids.map(function (id) {
                  return $$.selectorLegend(id);
              })
              : null;
      };

      ChartInternal.prototype.getClipPath = function (id) {
          return 'url(' + (isIE(9) ? '' : document.URL.split('#')[0]) + '#' + id + ')';
      };
      ChartInternal.prototype.appendClip = function (parent, id) {
          return parent
              .append('clipPath')
              .attr('id', id)
              .append('rect');
      };
      ChartInternal.prototype.getAxisClipX = function (forHorizontal) {
          // axis line width + padding for left
          var left = Math.max(30, this.margin.left);
          return forHorizontal ? -(1 + left) : -(left - 1);
      };
      ChartInternal.prototype.getAxisClipY = function (forHorizontal) {
          return forHorizontal ? -20 : -this.margin.top;
      };
      ChartInternal.prototype.getXAxisClipX = function () {
          var $$ = this;
          return $$.getAxisClipX(!$$.config.axis_rotated);
      };
      ChartInternal.prototype.getXAxisClipY = function () {
          var $$ = this;
          return $$.getAxisClipY(!$$.config.axis_rotated);
      };
      ChartInternal.prototype.getYAxisClipX = function () {
          var $$ = this;
          return $$.config.axis_y_inner ? -1 : $$.getAxisClipX($$.config.axis_rotated);
      };
      ChartInternal.prototype.getYAxisClipY = function () {
          var $$ = this;
          return $$.getAxisClipY($$.config.axis_rotated);
      };
      ChartInternal.prototype.getAxisClipWidth = function (forHorizontal) {
          var $$ = this, left = Math.max(30, $$.margin.left), right = Math.max(30, $$.margin.right);
          // width + axis line width + padding for left/right
          return forHorizontal ? $$.width + 2 + left + right : $$.margin.left + 20;
      };
      ChartInternal.prototype.getAxisClipHeight = function (forHorizontal) {
          // less than 20 is not enough to show the axis label 'outer' without legend
          return ((forHorizontal ? this.margin.bottom : this.margin.top + this.height) + 20);
      };
      ChartInternal.prototype.getXAxisClipWidth = function () {
          var $$ = this;
          return $$.getAxisClipWidth(!$$.config.axis_rotated);
      };
      ChartInternal.prototype.getXAxisClipHeight = function () {
          var $$ = this;
          return $$.getAxisClipHeight(!$$.config.axis_rotated);
      };
      ChartInternal.prototype.getYAxisClipWidth = function () {
          var $$ = this;
          return ($$.getAxisClipWidth($$.config.axis_rotated) +
              ($$.config.axis_y_inner ? 20 : 0));
      };
      ChartInternal.prototype.getYAxisClipHeight = function () {
          var $$ = this;
          return $$.getAxisClipHeight($$.config.axis_rotated);
      };

      ChartInternal.prototype.generateColor = function () {
          var $$ = this, config = $$.config, d3 = $$.d3, colors = config.data_colors, pattern = notEmpty(config.color_pattern)
              ? config.color_pattern
              : d3.schemeCategory10, callback = config.data_color, ids = [];
          return function (d) {
              var id = d.id || (d.data && d.data.id) || d, color;
              // if callback function is provided
              if (colors[id] instanceof Function) {
                  color = colors[id](d);
              }
              // if specified, choose that color
              else if (colors[id]) {
                  color = colors[id];
              }
              // if not specified, choose from pattern
              else {
                  if (ids.indexOf(id) < 0) {
                      ids.push(id);
                  }
                  color = pattern[ids.indexOf(id) % pattern.length];
                  colors[id] = color;
              }
              return callback instanceof Function ? callback(color, d) : color;
          };
      };
      ChartInternal.prototype.generateLevelColor = function () {
          var $$ = this, config = $$.config, colors = config.color_pattern, threshold = config.color_threshold, asValue = threshold.unit === 'value', values = threshold.values && threshold.values.length ? threshold.values : [], max = threshold.max || 100;
          return notEmpty(threshold) && notEmpty(colors)
              ? function (value) {
                  var i, v, color = colors[colors.length - 1];
                  for (i = 0; i < values.length; i++) {
                      v = asValue ? value : (value * 100) / max;
                      if (v < values[i]) {
                          color = colors[i];
                          break;
                      }
                  }
                  return color;
              }
              : null;
      };

      ChartInternal.prototype.getDefaultConfig = function () {
          var config = {
              bindto: '#chart',
              svg_classname: undefined,
              size_width: undefined,
              size_height: undefined,
              padding_left: undefined,
              padding_right: undefined,
              padding_top: undefined,
              padding_bottom: undefined,
              resize_auto: true,
              zoom_enabled: false,
              zoom_initialRange: undefined,
              zoom_type: 'scroll',
              zoom_disableDefaultBehavior: false,
              zoom_privileged: false,
              zoom_rescale: false,
              zoom_onzoom: function () { },
              zoom_onzoomstart: function () { },
              zoom_onzoomend: function () { },
              zoom_x_min: undefined,
              zoom_x_max: undefined,
              interaction_brighten: true,
              interaction_enabled: true,
              onmouseover: function () { },
              onmouseout: function () { },
              onresize: function () { },
              onresized: function () { },
              oninit: function () { },
              onrendered: function () { },
              transition_duration: 350,
              data_epochs: 'epochs',
              data_x: undefined,
              data_xs: {},
              data_xFormat: '%Y-%m-%d',
              data_xLocaltime: true,
              data_xSort: true,
              data_idConverter: function (id) {
                  return id;
              },
              data_names: {},
              data_classes: {},
              data_groups: [],
              data_axes: {},
              data_type: undefined,
              data_types: {},
              data_labels: {},
              data_order: 'desc',
              data_regions: {},
              data_color: undefined,
              data_colors: {},
              data_hide: false,
              data_filter: undefined,
              data_selection_enabled: false,
              data_selection_grouped: false,
              data_selection_isselectable: function () {
                  return true;
              },
              data_selection_multiple: true,
              data_selection_draggable: false,
              data_stack_normalize: false,
              data_onclick: function () { },
              data_onmouseover: function () { },
              data_onmouseout: function () { },
              data_onselected: function () { },
              data_onunselected: function () { },
              data_url: undefined,
              data_headers: undefined,
              data_json: undefined,
              data_rows: undefined,
              data_columns: undefined,
              data_mimeType: undefined,
              data_keys: undefined,
              // configuration for no plot-able data supplied.
              data_empty_label_text: '',
              // subchart
              subchart_show: false,
              subchart_size_height: 60,
              subchart_axis_x_show: true,
              subchart_onbrush: function () { },
              // color
              color_pattern: [],
              color_threshold: {},
              // legend
              legend_show: true,
              legend_hide: false,
              legend_position: 'bottom',
              legend_inset_anchor: 'top-left',
              legend_inset_x: 10,
              legend_inset_y: 0,
              legend_inset_step: undefined,
              legend_item_onclick: undefined,
              legend_item_onmouseover: undefined,
              legend_item_onmouseout: undefined,
              legend_equally: false,
              legend_padding: 0,
              legend_item_tile_width: 10,
              legend_item_tile_height: 10,
              // axis
              axis_rotated: false,
              axis_x_show: true,
              axis_x_type: 'indexed',
              axis_x_localtime: true,
              axis_x_categories: [],
              axis_x_tick_centered: false,
              axis_x_tick_format: undefined,
              axis_x_tick_culling: {},
              axis_x_tick_culling_max: 10,
              axis_x_tick_count: undefined,
              axis_x_tick_fit: true,
              axis_x_tick_values: null,
              axis_x_tick_rotate: 0,
              axis_x_tick_outer: true,
              axis_x_tick_multiline: true,
              axis_x_tick_multilineMax: 0,
              axis_x_tick_width: null,
              axis_x_max: undefined,
              axis_x_min: undefined,
              axis_x_padding: {},
              axis_x_height: undefined,
              axis_x_selection: undefined,
              axis_x_label: {},
              axis_x_inner: undefined,
              axis_y_show: true,
              axis_y_type: 'linear',
              axis_y_max: undefined,
              axis_y_min: undefined,
              axis_y_inverted: false,
              axis_y_center: undefined,
              axis_y_inner: undefined,
              axis_y_label: {},
              axis_y_tick_format: undefined,
              axis_y_tick_outer: true,
              axis_y_tick_values: null,
              axis_y_tick_rotate: 0,
              axis_y_tick_count: undefined,
              axis_y_tick_time_type: undefined,
              axis_y_tick_time_interval: undefined,
              axis_y_padding: {},
              axis_y_default: undefined,
              axis_y2_show: false,
              axis_y2_type: 'linear',
              axis_y2_max: undefined,
              axis_y2_min: undefined,
              axis_y2_inverted: false,
              axis_y2_center: undefined,
              axis_y2_inner: undefined,
              axis_y2_label: {},
              axis_y2_tick_format: undefined,
              axis_y2_tick_outer: true,
              axis_y2_tick_values: null,
              axis_y2_tick_count: undefined,
              axis_y2_padding: {},
              axis_y2_default: undefined,
              // grid
              grid_x_show: false,
              grid_x_type: 'tick',
              grid_x_lines: [],
              grid_y_show: false,
              // not used
              // grid_y_type: 'tick',
              grid_y_lines: [],
              grid_y_ticks: 10,
              grid_focus_show: true,
              grid_lines_front: true,
              // point - point of each data
              point_show: true,
              point_r: 2.5,
              point_sensitivity: 10,
              point_focus_expand_enabled: true,
              point_focus_expand_r: undefined,
              point_select_r: undefined,
              // line
              line_connectNull: false,
              line_step_type: 'step',
              // bar
              bar_width: undefined,
              bar_width_ratio: 0.6,
              bar_width_max: undefined,
              bar_zerobased: true,
              bar_space: 0,
              // area
              area_zerobased: true,
              area_above: false,
              // pie
              pie_label_show: true,
              pie_label_format: undefined,
              pie_label_threshold: 0.05,
              pie_label_ratio: undefined,
              pie_expand: {},
              pie_expand_duration: 50,
              pie_padAngle: 0,
              // gauge
              gauge_fullCircle: false,
              gauge_label_show: true,
              gauge_labelLine_show: true,
              gauge_label_format: undefined,
              gauge_min: 0,
              gauge_max: 100,
              gauge_startingAngle: (-1 * Math.PI) / 2,
              gauge_label_extents: undefined,
              gauge_units: undefined,
              gauge_width: undefined,
              gauge_arcs_minWidth: 5,
              gauge_expand: {},
              gauge_expand_duration: 50,
              // donut
              donut_label_show: true,
              donut_label_format: undefined,
              donut_label_threshold: 0.05,
              donut_label_ratio: undefined,
              donut_width: undefined,
              donut_title: '',
              donut_expand: {},
              donut_expand_duration: 50,
              donut_padAngle: 0,
              // spline
              spline_interpolation_type: 'cardinal',
              // stanford
              stanford_lines: [],
              stanford_regions: [],
              stanford_texts: [],
              stanford_scaleMin: undefined,
              stanford_scaleMax: undefined,
              stanford_scaleWidth: undefined,
              stanford_scaleFormat: undefined,
              stanford_scaleValues: undefined,
              stanford_colors: undefined,
              stanford_padding: {
                  top: 0,
                  right: 0,
                  bottom: 0,
                  left: 0
              },
              // region - region to change style
              regions: [],
              // tooltip - show when mouseover on each data
              tooltip_show: true,
              tooltip_grouped: true,
              tooltip_order: undefined,
              tooltip_format_title: undefined,
              tooltip_format_name: undefined,
              tooltip_format_value: undefined,
              tooltip_horizontal: undefined,
              tooltip_position: undefined,
              tooltip_contents: function (d, defaultTitleFormat, defaultValueFormat, color) {
                  return this.getTooltipContent
                      ? this.getTooltipContent(d, defaultTitleFormat, defaultValueFormat, color)
                      : '';
              },
              tooltip_init_show: false,
              tooltip_init_x: 0,
              tooltip_init_position: { top: '0px', left: '50px' },
              tooltip_onshow: function () { },
              tooltip_onhide: function () { },
              // title
              title_text: undefined,
              title_padding: {
                  top: 0,
                  right: 0,
                  bottom: 0,
                  left: 0
              },
              title_position: 'top-center'
          };
          Object.keys(this.additionalConfig).forEach(function (key) {
              config[key] = this.additionalConfig[key];
          }, this);
          return config;
      };
      ChartInternal.prototype.additionalConfig = {};
      ChartInternal.prototype.loadConfig = function (config) {
          var this_config = this.config, target, keys, read;
          function find() {
              var key = keys.shift();
              //        console.log("key =>", key, ", target =>", target);
              if (key && target && typeof target === 'object' && key in target) {
                  target = target[key];
                  return find();
              }
              else if (!key) {
                  return target;
              }
              else {
                  return undefined;
              }
          }
          Object.keys(this_config).forEach(function (key) {
              target = config;
              keys = key.split('_');
              read = find();
              //        console.log("CONFIG : ", key, read);
              if (isDefined(read)) {
                  this_config[key] = read;
              }
          });
      };

      ChartInternal.prototype.convertUrlToData = function (url, mimeType, headers, keys, done) {
          var $$ = this, type = mimeType ? mimeType : 'csv', f, converter;
          if (type === 'json') {
              f = $$.d3.json;
              converter = $$.convertJsonToData;
          }
          else if (type === 'tsv') {
              f = $$.d3.tsv;
              converter = $$.convertXsvToData;
          }
          else {
              f = $$.d3.csv;
              converter = $$.convertXsvToData;
          }
          f(url, headers)
              .then(function (data) {
              done.call($$, converter.call($$, data, keys));
          })
              .catch(function (error) {
              throw error;
          });
      };
      ChartInternal.prototype.convertXsvToData = function (xsv) {
          var keys = xsv.columns, rows = xsv;
          if (rows.length === 0) {
              return {
                  keys: keys,
                  rows: [keys.reduce(function (row, key) {
                          var _a;
                          return Object.assign(row, (_a = {}, _a[key] = null, _a));
                      }, {})]
              };
          }
          else {
              // [].concat() is to convert result into a plain array otherwise
              // test is not happy because rows have properties.
              return { keys: keys, rows: [].concat(xsv) };
          }
      };
      ChartInternal.prototype.convertJsonToData = function (json, keys) {
          var $$ = this, new_rows = [], targetKeys, data;
          if (keys) {
              // when keys specified, json would be an array that includes objects
              if (keys.x) {
                  targetKeys = keys.value.concat(keys.x);
                  $$.config.data_x = keys.x;
              }
              else {
                  targetKeys = keys.value;
              }
              new_rows.push(targetKeys);
              json.forEach(function (o) {
                  var new_row = [];
                  targetKeys.forEach(function (key) {
                      // convert undefined to null because undefined data will be removed in convertDataToTargets()
                      var v = $$.findValueInJson(o, key);
                      if (isUndefined(v)) {
                          v = null;
                      }
                      new_row.push(v);
                  });
                  new_rows.push(new_row);
              });
              data = $$.convertRowsToData(new_rows);
          }
          else {
              Object.keys(json).forEach(function (key) {
                  new_rows.push([key].concat(json[key]));
              });
              data = $$.convertColumnsToData(new_rows);
          }
          return data;
      };
      /**
       * Finds value from the given nested object by the given path.
       * If it's not found, then this returns undefined.
       * @param {Object} object the object
       * @param {string} path the path
       */
      ChartInternal.prototype.findValueInJson = function (object, path) {
          if (path in object) {
              // If object has a key that contains . or [], return the key's value
              // instead of searching for an inner object.
              // See https://github.com/c3js/c3/issues/1691 for details.
              return object[path];
          }
          path = path.replace(/\[(\w+)\]/g, '.$1'); // convert indexes to properties (replace [] with .)
          path = path.replace(/^\./, ''); // strip a leading dot
          var pathArray = path.split('.');
          for (var i = 0; i < pathArray.length; ++i) {
              var k = pathArray[i];
              if (k in object) {
                  object = object[k];
              }
              else {
                  return;
              }
          }
          return object;
      };
      /**
       * Converts the rows to normalized data.
       * @param {any[][]} rows The row data
       * @return {Object}
       */
      ChartInternal.prototype.convertRowsToData = function (rows) {
          var newRows = [];
          var keys = rows[0];
          for (var i = 1; i < rows.length; i++) {
              var newRow = {};
              for (var j = 0; j < rows[i].length; j++) {
                  if (isUndefined(rows[i][j])) {
                      throw new Error('Source data is missing a component at (' + i + ',' + j + ')!');
                  }
                  newRow[keys[j]] = rows[i][j];
              }
              newRows.push(newRow);
          }
          return { keys: keys, rows: newRows };
      };
      /**
       * Converts the columns to normalized data.
       * @param {any[][]} columns The column data
       * @return {Object}
       */
      ChartInternal.prototype.convertColumnsToData = function (columns) {
          var newRows = [];
          var keys = [];
          for (var i = 0; i < columns.length; i++) {
              var key = columns[i][0];
              for (var j = 1; j < columns[i].length; j++) {
                  if (isUndefined(newRows[j - 1])) {
                      newRows[j - 1] = {};
                  }
                  if (isUndefined(columns[i][j])) {
                      throw new Error('Source data is missing a component at (' + i + ',' + j + ')!');
                  }
                  newRows[j - 1][key] = columns[i][j];
              }
              keys.push(key);
          }
          return { keys: keys, rows: newRows };
      };
      /**
       * Converts the data format into the target format.
       * @param {!Object} data
       * @param {!Array} data.keys Ordered list of target IDs.
       * @param {!Array} data.rows Rows of data to convert.
       * @param {boolean} appendXs True to append to $$.data.xs, False to replace.
       * @return {!Array}
       */
      ChartInternal.prototype.convertDataToTargets = function (data, appendXs) {
          var $$ = this, config = $$.config, targets, ids, xs, keys, epochs;
          // handles format where keys are not orderly provided
          if (isArray(data)) {
              keys = Object.keys(data[0]);
          }
          else {
              keys = data.keys;
              data = data.rows;
          }
          xs = keys.filter($$.isX, $$);
          if (!$$.isStanfordGraphType()) {
              ids = keys.filter($$.isNotX, $$);
          }
          else {
              epochs = keys.filter($$.isEpochs, $$);
              ids = keys.filter($$.isNotXAndNotEpochs, $$);
              if (xs.length !== 1 || epochs.length !== 1 || ids.length !== 1) {
                  throw new Error("You must define the 'x' key name and the 'epochs' for Stanford Diagrams");
              }
          }
          // save x for update data by load when custom x and c3.x API
          ids.forEach(function (id) {
              var xKey = $$.getXKey(id);
              if ($$.isCustomX() || $$.isTimeSeries()) {
                  // if included in input data
                  if (xs.indexOf(xKey) >= 0) {
                      $$.data.xs[id] = (appendXs && $$.data.xs[id]
                          ? $$.data.xs[id]
                          : []).concat(data
                          .map(function (d) {
                          return d[xKey];
                      })
                          .filter(isValue)
                          .map(function (rawX, i) {
                          return $$.generateTargetX(rawX, id, i);
                      }));
                  }
                  // if not included in input data, find from preloaded data of other id's x
                  else if (config.data_x) {
                      $$.data.xs[id] = $$.getOtherTargetXs();
                  }
                  // if not included in input data, find from preloaded data
                  else if (notEmpty(config.data_xs)) {
                      $$.data.xs[id] = $$.getXValuesOfXKey(xKey, $$.data.targets);
                  }
                  // MEMO: if no x included, use same x of current will be used
              }
              else {
                  $$.data.xs[id] = data.map(function (d, i) {
                      return i;
                  });
              }
          });
          // check x is defined
          ids.forEach(function (id) {
              if (!$$.data.xs[id]) {
                  throw new Error('x is not defined for id = "' + id + '".');
              }
          });
          // convert to target
          targets = ids.map(function (id, index) {
              var convertedId = config.data_idConverter(id);
              return {
                  id: convertedId,
                  id_org: id,
                  values: data
                      .map(function (d, i) {
                      var xKey = $$.getXKey(id), rawX = d[xKey], value = d[id] !== null && !isNaN(d[id]) ? +d[id] : null, x, returnData;
                      // use x as categories if custom x and categorized
                      if ($$.isCustomX() && $$.isCategorized() && !isUndefined(rawX)) {
                          if (index === 0 && i === 0) {
                              config.axis_x_categories = [];
                          }
                          x = config.axis_x_categories.indexOf(rawX);
                          if (x === -1) {
                              x = config.axis_x_categories.length;
                              config.axis_x_categories.push(rawX);
                          }
                      }
                      else {
                          x = $$.generateTargetX(rawX, id, i);
                      }
                      // mark as x = undefined if value is undefined and filter to remove after mapped
                      if (isUndefined(d[id]) || $$.data.xs[id].length <= i) {
                          x = undefined;
                      }
                      returnData = { x: x, value: value, id: convertedId };
                      if ($$.isStanfordGraphType()) {
                          returnData.epochs = d[epochs];
                      }
                      return returnData;
                  })
                      .filter(function (v) {
                      return isDefined(v.x);
                  })
              };
          });
          // finish targets
          targets.forEach(function (t) {
              var i;
              // sort values by its x
              if (config.data_xSort) {
                  t.values = t.values.sort(function (v1, v2) {
                      var x1 = v1.x || v1.x === 0 ? v1.x : Infinity, x2 = v2.x || v2.x === 0 ? v2.x : Infinity;
                      return x1 - x2;
                  });
              }
              // indexing each value
              i = 0;
              t.values.forEach(function (v) {
                  v.index = i++;
              });
              // this needs to be sorted because its index and value.index is identical
              $$.data.xs[t.id].sort(function (v1, v2) {
                  return v1 - v2;
              });
          });
          // cache information about values
          $$.hasNegativeValue = $$.hasNegativeValueInTargets(targets);
          $$.hasPositiveValue = $$.hasPositiveValueInTargets(targets);
          // set target types
          if (config.data_type) {
              $$.setTargetType($$.mapToIds(targets).filter(function (id) {
                  return !(id in config.data_types);
              }), config.data_type);
          }
          // cache as original id keyed
          targets.forEach(function (d) {
              $$.addCache(d.id_org, d);
          });
          return targets;
      };

      ChartInternal.prototype.isEpochs = function (key) {
          var $$ = this, config = $$.config;
          return config.data_epochs && key === config.data_epochs;
      };
      ChartInternal.prototype.isX = function (key) {
          var $$ = this, config = $$.config;
          return ((config.data_x && key === config.data_x) ||
              (notEmpty(config.data_xs) && hasValue(config.data_xs, key)));
      };
      ChartInternal.prototype.isNotX = function (key) {
          return !this.isX(key);
      };
      ChartInternal.prototype.isNotXAndNotEpochs = function (key) {
          return !this.isX(key) && !this.isEpochs(key);
      };
      /**
       * Returns whether the normalized stack option is enabled or not.
       *
       * To be enabled it must also have data.groups defined.
       *
       * @return {boolean}
       */
      ChartInternal.prototype.isStackNormalized = function () {
          return this.config.data_stack_normalize && this.config.data_groups.length > 0;
      };
      /**
       * Returns whether the axis is normalized or not.
       *
       * An axis is normalized as long as one of its associated target
       * is normalized.
       *
       * @param axisId Axis ID (y or y2)
       * @return {Boolean}
       */
      ChartInternal.prototype.isAxisNormalized = function (axisId) {
          var $$ = this;
          if (!$$.isStackNormalized()) {
              // shortcut
              return false;
          }
          return $$.data.targets
              .filter(function (target) { return $$.axis.getId(target.id) === axisId; })
              .some(function (target) { return $$.isTargetNormalized(target.id); });
      };
      /**
       * Returns whether the values for this target ID is normalized or not.
       *
       * To be normalized the option needs to be enabled and target needs
       * to be defined in `data.groups`.
       *
       * @param targetId ID of the target
       * @return {Boolean} True if the target is normalized, false otherwise.
       */
      ChartInternal.prototype.isTargetNormalized = function (targetId) {
          var $$ = this;
          return ($$.isStackNormalized() &&
              $$.config.data_groups.some(function (group) { return group.includes(targetId); }));
      };
      ChartInternal.prototype.getXKey = function (id) {
          var $$ = this, config = $$.config;
          return config.data_x
              ? config.data_x
              : notEmpty(config.data_xs)
                  ? config.data_xs[id]
                  : null;
      };
      /**
       * Get sum of visible data per index for given axis.
       *
       * Expect axisId to be either 'y' or 'y2'.
       *
       * @private
       * @param axisId Compute sum for data associated to given axis.
       * @return {Array}
       */
      ChartInternal.prototype.getTotalPerIndex = function (axisId) {
          var $$ = this;
          if (!$$.isStackNormalized()) {
              return null;
          }
          var cached = $$.getFromCache('getTotalPerIndex');
          if (cached !== undefined) {
              return cached[axisId];
          }
          var sum = { y: [], y2: [] };
          $$.data.targets
              // keep only target that are normalized
              .filter(function (target) { return $$.isTargetNormalized(target.id); })
              // keep only target that are visible
              .filter(function (target) { return $$.isTargetToShow(target.id); })
              // compute sum per axis
              .forEach(function (target) {
              var sumByAxis = sum[$$.axis.getId(target.id)];
              target.values.forEach(function (v, i) {
                  if (!sumByAxis[i]) {
                      sumByAxis[i] = 0;
                  }
                  sumByAxis[i] += isNumber(v.value) ? v.value : 0;
              });
          });
          $$.addToCache('getTotalPerIndex', sum);
          return sum[axisId];
      };
      /**
       * Get sum of visible data.
       *
       * Should be used for normalised data only since all values
       * are expected to be positive.
       *
       * @private
       * @return {Number}
       */
      ChartInternal.prototype.getTotalDataSum = function () {
          var $$ = this;
          var cached = $$.getFromCache('getTotalDataSum');
          if (cached !== undefined) {
              return cached;
          }
          var totalDataSum = flattenArray($$.data.targets
              .filter(function (target) { return $$.isTargetToShow(target.id); })
              .map(function (target) { return target.values; }))
              .map(function (d) { return d.value; })
              .reduce(function (p, c) { return p + c; }, 0);
          $$.addToCache('getTotalDataSum', totalDataSum);
          return totalDataSum;
      };
      ChartInternal.prototype.getXValuesOfXKey = function (key, targets) {
          var $$ = this, xValues, ids = targets && notEmpty(targets) ? $$.mapToIds(targets) : [];
          ids.forEach(function (id) {
              if ($$.getXKey(id) === key) {
                  xValues = $$.data.xs[id];
              }
          });
          return xValues;
      };
      ChartInternal.prototype.getXValue = function (id, i) {
          var $$ = this;
          return id in $$.data.xs && $$.data.xs[id] && isValue($$.data.xs[id][i])
              ? $$.data.xs[id][i]
              : i;
      };
      ChartInternal.prototype.getOtherTargetXs = function () {
          var $$ = this, idsForX = Object.keys($$.data.xs);
          return idsForX.length ? $$.data.xs[idsForX[0]] : null;
      };
      ChartInternal.prototype.getOtherTargetX = function (index) {
          var xs = this.getOtherTargetXs();
          return xs && index < xs.length ? xs[index] : null;
      };
      ChartInternal.prototype.addXs = function (xs) {
          var $$ = this;
          Object.keys(xs).forEach(function (id) {
              $$.config.data_xs[id] = xs[id];
          });
      };
      ChartInternal.prototype.addName = function (data) {
          var $$ = this, name;
          if (data) {
              name = $$.config.data_names[data.id];
              data.name = name !== undefined ? name : data.id;
          }
          return data;
      };
      ChartInternal.prototype.getValueOnIndex = function (values, index) {
          var valueOnIndex = values.filter(function (v) {
              return v.index === index;
          });
          return valueOnIndex.length ? valueOnIndex[0] : null;
      };
      ChartInternal.prototype.updateTargetX = function (targets, x) {
          var $$ = this;
          targets.forEach(function (t) {
              t.values.forEach(function (v, i) {
                  v.x = $$.generateTargetX(x[i], t.id, i);
              });
              $$.data.xs[t.id] = x;
          });
      };
      ChartInternal.prototype.updateTargetXs = function (targets, xs) {
          var $$ = this;
          targets.forEach(function (t) {
              if (xs[t.id]) {
                  $$.updateTargetX([t], xs[t.id]);
              }
          });
      };
      ChartInternal.prototype.generateTargetX = function (rawX, id, index) {
          var $$ = this, x;
          if ($$.isTimeSeries()) {
              x = rawX ? $$.parseDate(rawX) : $$.parseDate($$.getXValue(id, index));
          }
          else if ($$.isCustomX() && !$$.isCategorized()) {
              x = isValue(rawX) ? +rawX : $$.getXValue(id, index);
          }
          else {
              x = index;
          }
          return x;
      };
      ChartInternal.prototype.cloneTarget = function (target) {
          return {
              id: target.id,
              id_org: target.id_org,
              values: target.values.map(function (d) {
                  return {
                      x: d.x,
                      value: d.value,
                      id: d.id
                  };
              })
          };
      };
      ChartInternal.prototype.getMaxDataCount = function () {
          var $$ = this;
          return $$.d3.max($$.data.targets, function (t) {
              return t.values.length;
          });
      };
      ChartInternal.prototype.mapToIds = function (targets) {
          return targets.map(function (d) {
              return d.id;
          });
      };
      ChartInternal.prototype.mapToTargetIds = function (ids) {
          var $$ = this;
          return ids ? [].concat(ids) : $$.mapToIds($$.data.targets);
      };
      ChartInternal.prototype.hasTarget = function (targets, id) {
          var ids = this.mapToIds(targets), i;
          for (i = 0; i < ids.length; i++) {
              if (ids[i] === id) {
                  return true;
              }
          }
          return false;
      };
      ChartInternal.prototype.isTargetToShow = function (targetId) {
          return this.hiddenTargetIds.indexOf(targetId) < 0;
      };
      ChartInternal.prototype.isLegendToShow = function (targetId) {
          return this.hiddenLegendIds.indexOf(targetId) < 0;
      };
      /**
       * Returns only visible targets.
       *
       * This is the same as calling {@link filterTargetsToShow} on $$.data.targets.
       *
       * @return {Array}
       */
      ChartInternal.prototype.getTargetsToShow = function () {
          var $$ = this;
          return $$.filterTargetsToShow($$.data.targets);
      };
      ChartInternal.prototype.filterTargetsToShow = function (targets) {
          var $$ = this;
          return targets.filter(function (t) {
              return $$.isTargetToShow(t.id);
          });
      };
      /**
       * @return {Array} Returns all the targets attached to the chart, visible or not
       */
      ChartInternal.prototype.getTargets = function () {
          var $$ = this;
          return $$.data.targets;
      };
      ChartInternal.prototype.mapTargetsToUniqueXs = function (targets) {
          var $$ = this;
          var xs = $$.d3
              .set($$.d3.merge(targets.map(function (t) {
              return t.values.map(function (v) {
                  return +v.x;
              });
          })))
              .values();
          xs = $$.isTimeSeries()
              ? xs.map(function (x) {
                  return new Date(+x);
              })
              : xs.map(function (x) {
                  return +x;
              });
          return xs.sort(function (a, b) {
              return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
          });
      };
      ChartInternal.prototype.addHiddenTargetIds = function (targetIds) {
          targetIds = targetIds instanceof Array ? targetIds : new Array(targetIds);
          for (var i = 0; i < targetIds.length; i++) {
              if (this.hiddenTargetIds.indexOf(targetIds[i]) < 0) {
                  this.hiddenTargetIds = this.hiddenTargetIds.concat(targetIds[i]);
              }
          }
          this.resetCache();
      };
      ChartInternal.prototype.removeHiddenTargetIds = function (targetIds) {
          this.hiddenTargetIds = this.hiddenTargetIds.filter(function (id) {
              return targetIds.indexOf(id) < 0;
          });
          this.resetCache();
      };
      ChartInternal.prototype.addHiddenLegendIds = function (targetIds) {
          targetIds = targetIds instanceof Array ? targetIds : new Array(targetIds);
          for (var i = 0; i < targetIds.length; i++) {
              if (this.hiddenLegendIds.indexOf(targetIds[i]) < 0) {
                  this.hiddenLegendIds = this.hiddenLegendIds.concat(targetIds[i]);
              }
          }
      };
      ChartInternal.prototype.removeHiddenLegendIds = function (targetIds) {
          this.hiddenLegendIds = this.hiddenLegendIds.filter(function (id) {
              return targetIds.indexOf(id) < 0;
          });
      };
      ChartInternal.prototype.getValuesAsIdKeyed = function (targets) {
          var ys = {};
          targets.forEach(function (t) {
              ys[t.id] = [];
              t.values.forEach(function (v) {
                  ys[t.id].push(v.value);
              });
          });
          return ys;
      };
      ChartInternal.prototype.checkValueInTargets = function (targets, checker) {
          var ids = Object.keys(targets), i, j, values;
          for (i = 0; i < ids.length; i++) {
              values = targets[ids[i]].values;
              for (j = 0; j < values.length; j++) {
                  if (checker(values[j].value)) {
                      return true;
                  }
              }
          }
          return false;
      };
      ChartInternal.prototype.hasNegativeValueInTargets = function (targets) {
          return this.checkValueInTargets(targets, function (v) {
              return v < 0;
          });
      };
      ChartInternal.prototype.hasPositiveValueInTargets = function (targets) {
          return this.checkValueInTargets(targets, function (v) {
              return v > 0;
          });
      };
      ChartInternal.prototype.isOrderDesc = function () {
          var config = this.config;
          return (typeof config.data_order === 'string' &&
              config.data_order.toLowerCase() === 'desc');
      };
      ChartInternal.prototype.isOrderAsc = function () {
          var config = this.config;
          return (typeof config.data_order === 'string' &&
              config.data_order.toLowerCase() === 'asc');
      };
      ChartInternal.prototype.getOrderFunction = function () {
          var $$ = this, config = $$.config, orderAsc = $$.isOrderAsc(), orderDesc = $$.isOrderDesc();
          if (orderAsc || orderDesc) {
              var reducer = function (p, c) {
                  return p + Math.abs(c.value);
              };
              return function (t1, t2) {
                  var t1Sum = t1.values.reduce(reducer, 0), t2Sum = t2.values.reduce(reducer, 0);
                  return orderAsc ? t2Sum - t1Sum : t1Sum - t2Sum;
              };
          }
          else if (isFunction(config.data_order)) {
              return config.data_order;
          }
          else if (isArray(config.data_order)) {
              var order = config.data_order;
              return function (t1, t2) {
                  return order.indexOf(t1.id) - order.indexOf(t2.id);
              };
          }
      };
      ChartInternal.prototype.orderTargets = function (targets) {
          var fct = this.getOrderFunction();
          if (fct) {
              targets.sort(fct);
          }
          return targets;
      };
      /**
       * Returns all the values from the given targets at the given index.
       *
       * @param {Array} targets
       * @param {Number} index
       * @return {Array}
       */
      ChartInternal.prototype.filterByIndex = function (targets, index) {
          return this.d3.merge(targets.map(function (t) { return t.values.filter(function (v) { return v.index === index; }); }));
      };
      ChartInternal.prototype.filterByX = function (targets, x) {
          return this.d3
              .merge(targets.map(function (t) {
              return t.values;
          }))
              .filter(function (v) {
              return v.x - x === 0;
          });
      };
      ChartInternal.prototype.filterRemoveNull = function (data) {
          return data.filter(function (d) {
              return isValue(d.value);
          });
      };
      ChartInternal.prototype.filterByXDomain = function (targets, xDomain) {
          return targets.map(function (t) {
              return {
                  id: t.id,
                  id_org: t.id_org,
                  values: t.values.filter(function (v) {
                      return xDomain[0] <= v.x && v.x <= xDomain[1];
                  })
              };
          });
      };
      ChartInternal.prototype.hasDataLabel = function () {
          var config = this.config;
          if (typeof config.data_labels === 'boolean' && config.data_labels) {
              return true;
          }
          else if (typeof config.data_labels === 'object' &&
              notEmpty(config.data_labels)) {
              return true;
          }
          return false;
      };
      ChartInternal.prototype.getDataLabelLength = function (min, max, key) {
          var $$ = this, lengths = [0, 0], paddingCoef = 1.3;
          $$.selectChart
              .select('svg')
              .selectAll('.dummy')
              .data([min, max])
              .enter()
              .append('text')
              .text(function (d) {
              return $$.dataLabelFormat(d.id)(d);
          })
              .each(function (d, i) {
              lengths[i] = getBBox(this)[key] * paddingCoef;
          })
              .remove();
          return lengths;
      };
      /**
       * Returns true if the given data point is not arc type, otherwise false.
       * @param {Object} d The data point
       * @return {boolean}
       */
      ChartInternal.prototype.isNoneArc = function (d) {
          return this.hasTarget(this.data.targets, d.id);
      };
      /**
       * Returns true if the given data point is arc type, otherwise false.
       * @param {Object} d The data point
       * @return {boolean}
       */
      ChartInternal.prototype.isArc = function (d) {
          return 'data' in d && this.hasTarget(this.data.targets, d.data.id);
      };
      /**
       * Find the closest point from the given pos among the given targets or
       * undefined if none satisfies conditions.
       *
       * @param {Array} targets
       * @param {Array} pos An [x,y] coordinate
       * @return {Object|undefined}
       */
      ChartInternal.prototype.findClosestFromTargets = function (targets, pos) {
          var $$ = this;
          // for each target, find the closest point
          var candidates = targets
              .map(function (t) {
              return $$.findClosest(t.values, pos, $$.config.tooltip_horizontal
                  ? $$.horizontalDistance.bind($$)
                  : $$.dist.bind($$), $$.config.point_sensitivity);
          })
              .filter(function (v) { return v; });
          // returns the closest of candidates
          if (candidates.length === 0) {
              return undefined;
          }
          else if (candidates.length === 1) {
              return candidates[0];
          }
          else {
              return $$.findClosest(candidates, pos, $$.dist.bind($$));
          }
      };
      /**
       * Find the closest point from the x value or undefined if none satisfies conditions.
       *
       * @param {Array} targets
       * @param {Array} x A value on X axis
       * @return {Object|undefined}
       */
      ChartInternal.prototype.findClosestFromTargetsByX = function (targets, x) {
          var closest;
          var diff;
          targets.forEach(function (t) {
              t.values.forEach(function (d) {
                  var newDiff = Math.abs(x - d.x);
                  if (diff === undefined || newDiff < diff) {
                      closest = d;
                      diff = newDiff;
                  }
              });
          });
          return closest;
      };
      /**
       * Using given compute distance method, returns the closest data point from the
       * given position.
       *
       * Giving optionally a minimum distance to satisfy.
       *
       * @param {Array} dataPoints List of DataPoints
       * @param {Array} pos An [x,y] coordinate
       * @param {Function} computeDist Function to compute distance between 2 points
       * @param {Number} minDist Minimal distance to satisfy
       * @return {Object|undefined} Closest data point
       */
      ChartInternal.prototype.findClosest = function (dataPoints, pos, computeDist, minDist) {
          if (minDist === void 0) { minDist = Infinity; }
          var $$ = this;
          var closest;
          // find closest bar
          dataPoints
              .filter(function (v) { return v && $$.isBarType(v.id); })
              .forEach(function (v) {
              if (!closest) {
                  var shape = $$.main
                      .select('.' +
                      CLASS.bars +
                      $$.getTargetSelectorSuffix(v.id) +
                      ' .' +
                      CLASS.bar +
                      '-' +
                      v.index)
                      .node();
                  if ($$.isWithinBar(pos, shape)) {
                      closest = v;
                  }
              }
          });
          // find closest point from non-bar
          dataPoints
              .filter(function (v) { return v && !$$.isBarType(v.id); })
              .forEach(function (v) {
              var d = computeDist(v, pos);
              if (d < minDist) {
                  minDist = d;
                  closest = v;
              }
          });
          return closest;
      };
      ChartInternal.prototype.dist = function (data, pos) {
          var $$ = this, config = $$.config, xIndex = config.axis_rotated ? 1 : 0, yIndex = config.axis_rotated ? 0 : 1, y = $$.circleY(data, data.index), x = $$.x(data.x);
          return Math.sqrt(Math.pow(x - pos[xIndex], 2) + Math.pow(y - pos[yIndex], 2));
      };
      ChartInternal.prototype.horizontalDistance = function (data, pos) {
          var $$ = this, config = $$.config, xIndex = config.axis_rotated ? 1 : 0, x = $$.x(data.x);
          return Math.abs(x - pos[xIndex]);
      };
      ChartInternal.prototype.convertValuesToStep = function (values) {
          var converted = [].concat(values), i;
          if (!this.isCategorized()) {
              return values;
          }
          for (i = values.length + 1; 0 < i; i--) {
              converted[i] = converted[i - 1];
          }
          converted[0] = {
              x: converted[0].x - 1,
              value: converted[0].value,
              id: converted[0].id
          };
          converted[values.length + 1] = {
              x: converted[values.length].x + 1,
              value: converted[values.length].value,
              id: converted[values.length].id
          };
          return converted;
      };
      /**
       * Get ratio value
       *
       * @param {String} type Ratio for given type
       * @param {Object} d Data value object
       * @param {Boolean} asPercent Convert the return as percent or not
       * @return {Number} Ratio value
       * @private
       */
      ChartInternal.prototype.getRatio = function (type, d, asPercent) {
          if (asPercent === void 0) { asPercent = false; }
          var $$ = this;
          var api = $$.api;
          var ratio = 0;
          if (d && api.data.shown.call(api).length) {
              ratio = d.ratio || d.value;
              if (type === 'arc') {
                  if ($$.hasType('gauge')) {
                      ratio =
                          (d.endAngle - d.startAngle) /
                              (Math.PI * ($$.config.gauge_fullCircle ? 2 : 1));
                  }
                  else {
                      var total = $$.getTotalDataSum();
                      ratio = d.value / total;
                  }
              }
              else if (type === 'index') {
                  var total = $$.getTotalPerIndex($$.axis.getId(d.id));
                  d.ratio =
                      isNumber(d.value) && total && total[d.index] > 0
                          ? d.value / total[d.index]
                          : 0;
                  ratio = d.ratio;
              }
          }
          return asPercent && ratio ? ratio * 100 : ratio;
      };
      ChartInternal.prototype.updateDataAttributes = function (name, attrs) {
          var $$ = this, config = $$.config, current = config['data_' + name];
          if (typeof attrs === 'undefined') {
              return current;
          }
          Object.keys(attrs).forEach(function (id) {
              current[id] = attrs[id];
          });
          $$.redraw({
              withLegend: true
          });
          return current;
      };

      ChartInternal.prototype.load = function (targets, args) {
          var $$ = this;
          if (targets) {
              // filter loading targets if needed
              if (args.filter) {
                  targets = targets.filter(args.filter);
              }
              // set type if args.types || args.type specified
              if (args.type || args.types) {
                  targets.forEach(function (t) {
                      var type = args.types && args.types[t.id] ? args.types[t.id] : args.type;
                      $$.setTargetType(t.id, type);
                  });
              }
              // Update/Add data
              $$.data.targets.forEach(function (d) {
                  for (var i = 0; i < targets.length; i++) {
                      if (d.id === targets[i].id) {
                          d.values = targets[i].values;
                          targets.splice(i, 1);
                          break;
                      }
                  }
              });
              $$.data.targets = $$.data.targets.concat(targets); // add remained
          }
          // Set targets
          $$.updateTargets($$.data.targets);
          // Redraw with new targets
          $$.redraw({
              withUpdateOrgXDomain: true,
              withUpdateXDomain: true,
              withLegend: true
          });
          if (args.done) {
              args.done();
          }
      };
      ChartInternal.prototype.loadFromArgs = function (args) {
          var $$ = this;
          $$.resetCache();
          if (args.data) {
              $$.load($$.convertDataToTargets(args.data), args);
          }
          else if (args.url) {
              $$.convertUrlToData(args.url, args.mimeType, args.headers, args.keys, function (data) {
                  $$.load($$.convertDataToTargets(data), args);
              });
          }
          else if (args.json) {
              $$.load($$.convertDataToTargets($$.convertJsonToData(args.json, args.keys)), args);
          }
          else if (args.rows) {
              $$.load($$.convertDataToTargets($$.convertRowsToData(args.rows)), args);
          }
          else if (args.columns) {
              $$.load($$.convertDataToTargets($$.convertColumnsToData(args.columns)), args);
          }
          else {
              $$.load(null, args);
          }
      };
      ChartInternal.prototype.unload = function (targetIds, done) {
          var $$ = this;
          $$.resetCache();
          if (!done) {
              done = function () { };
          }
          // filter existing target
          targetIds = targetIds.filter(function (id) {
              return $$.hasTarget($$.data.targets, id);
          });
          // If no target, call done and return
          if (!targetIds || targetIds.length === 0) {
              done();
              return;
          }
          $$.svg
              .selectAll(targetIds.map(function (id) {
              return $$.selectorTarget(id);
          }))
              .transition()
              .style('opacity', 0)
              .remove()
              .call($$.endall, done);
          targetIds.forEach(function (id) {
              // Reset fadein for future load
              $$.withoutFadeIn[id] = false;
              // Remove target's elements
              if ($$.legend) {
                  $$.legend
                      .selectAll('.' + CLASS.legendItem + $$.getTargetSelectorSuffix(id))
                      .remove();
              }
              // Remove target
              $$.data.targets = $$.data.targets.filter(function (t) {
                  return t.id !== id;
              });
          });
      };

      ChartInternal.prototype.getYDomainMin = function (targets) {
          var $$ = this, config = $$.config, ids = $$.mapToIds(targets), ys = $$.getValuesAsIdKeyed(targets), j, k, baseId, idsInGroup, id, hasNegativeValue;
          if (config.data_groups.length > 0) {
              hasNegativeValue = $$.hasNegativeValueInTargets(targets);
              for (j = 0; j < config.data_groups.length; j++) {
                  // Determine baseId
                  idsInGroup = config.data_groups[j].filter(function (id) {
                      return ids.indexOf(id) >= 0;
                  });
                  if (idsInGroup.length === 0) {
                      continue;
                  }
                  baseId = idsInGroup[0];
                  // Consider negative values
                  if (hasNegativeValue && ys[baseId]) {
                      ys[baseId].forEach(function (v, i) {
                          ys[baseId][i] = v < 0 ? v : 0;
                      });
                  }
                  // Compute min
                  for (k = 1; k < idsInGroup.length; k++) {
                      id = idsInGroup[k];
                      if (!ys[id]) {
                          continue;
                      }
                      ys[id].forEach(function (v, i) {
                          if ($$.axis.getId(id) === $$.axis.getId(baseId) &&
                              ys[baseId] &&
                              !(hasNegativeValue && +v > 0)) {
                              ys[baseId][i] += +v;
                          }
                      });
                  }
              }
          }
          return $$.d3.min(Object.keys(ys).map(function (key) {
              return $$.d3.min(ys[key]);
          }));
      };
      ChartInternal.prototype.getYDomainMax = function (targets) {
          var $$ = this, config = $$.config, ids = $$.mapToIds(targets), ys = $$.getValuesAsIdKeyed(targets), j, k, baseId, idsInGroup, id, hasPositiveValue;
          if (config.data_groups.length > 0) {
              hasPositiveValue = $$.hasPositiveValueInTargets(targets);
              for (j = 0; j < config.data_groups.length; j++) {
                  // Determine baseId
                  idsInGroup = config.data_groups[j].filter(function (id) {
                      return ids.indexOf(id) >= 0;
                  });
                  if (idsInGroup.length === 0) {
                      continue;
                  }
                  baseId = idsInGroup[0];
                  // Consider positive values
                  if (hasPositiveValue && ys[baseId]) {
                      ys[baseId].forEach(function (v, i) {
                          ys[baseId][i] = v > 0 ? v : 0;
                      });
                  }
                  // Compute max
                  for (k = 1; k < idsInGroup.length; k++) {
                      id = idsInGroup[k];
                      if (!ys[id]) {
                          continue;
                      }
                      ys[id].forEach(function (v, i) {
                          if ($$.axis.getId(id) === $$.axis.getId(baseId) &&
                              ys[baseId] &&
                              !(hasPositiveValue && +v < 0)) {
                              ys[baseId][i] += +v;
                          }
                      });
                  }
              }
          }
          return $$.d3.max(Object.keys(ys).map(function (key) {
              return $$.d3.max(ys[key]);
          }));
      };
      ChartInternal.prototype.getYDomain = function (targets, axisId, xDomain) {
          var $$ = this, config = $$.config;
          if ($$.isAxisNormalized(axisId)) {
              return [0, 100];
          }
          var targetsByAxisId = targets.filter(function (t) {
              return $$.axis.getId(t.id) === axisId;
          }), yTargets = xDomain
              ? $$.filterByXDomain(targetsByAxisId, xDomain)
              : targetsByAxisId, yMin = axisId === 'y2' ? config.axis_y2_min : config.axis_y_min, yMax = axisId === 'y2' ? config.axis_y2_max : config.axis_y_max, yDomainMin = $$.getYDomainMin(yTargets), yDomainMax = $$.getYDomainMax(yTargets), domain, domainLength, padding_top, padding_bottom, center = axisId === 'y2' ? config.axis_y2_center : config.axis_y_center, yDomainAbs, lengths, diff, ratio, isAllPositive, isAllNegative, isZeroBased = ($$.hasType('bar', yTargets) && config.bar_zerobased) ||
              ($$.hasType('area', yTargets) && config.area_zerobased), isInverted = axisId === 'y2' ? config.axis_y2_inverted : config.axis_y_inverted, showHorizontalDataLabel = $$.hasDataLabel() && config.axis_rotated, showVerticalDataLabel = $$.hasDataLabel() && !config.axis_rotated;
          // MEMO: avoid inverting domain unexpectedly
          yDomainMin = isValue(yMin)
              ? yMin
              : isValue(yMax)
                  ? yDomainMin < yMax
                      ? yDomainMin
                      : yMax - 10
                  : yDomainMin;
          yDomainMax = isValue(yMax)
              ? yMax
              : isValue(yMin)
                  ? yMin < yDomainMax
                      ? yDomainMax
                      : yMin + 10
                  : yDomainMax;
          if (yTargets.length === 0) {
              // use current domain if target of axisId is none
              return axisId === 'y2' ? $$.y2.domain() : $$.y.domain();
          }
          if (isNaN(yDomainMin)) {
              // set minimum to zero when not number
              yDomainMin = 0;
          }
          if (isNaN(yDomainMax)) {
              // set maximum to have same value as yDomainMin
              yDomainMax = yDomainMin;
          }
          if (yDomainMin === yDomainMax) {
              yDomainMin < 0 ? (yDomainMax = 0) : (yDomainMin = 0);
          }
          isAllPositive = yDomainMin >= 0 && yDomainMax >= 0;
          isAllNegative = yDomainMin <= 0 && yDomainMax <= 0;
          // Cancel zerobased if axis_*_min / axis_*_max specified
          if ((isValue(yMin) && isAllPositive) || (isValue(yMax) && isAllNegative)) {
              isZeroBased = false;
          }
          // Bar/Area chart should be 0-based if all positive|negative
          if (isZeroBased) {
              if (isAllPositive) {
                  yDomainMin = 0;
              }
              if (isAllNegative) {
                  yDomainMax = 0;
              }
          }
          domainLength = Math.abs(yDomainMax - yDomainMin);
          padding_top = padding_bottom = domainLength * 0.1;
          if (typeof center !== 'undefined') {
              yDomainAbs = Math.max(Math.abs(yDomainMin), Math.abs(yDomainMax));
              yDomainMax = center + yDomainAbs;
              yDomainMin = center - yDomainAbs;
          }
          // add padding for data label
          if (showHorizontalDataLabel) {
              lengths = $$.getDataLabelLength(yDomainMin, yDomainMax, 'width');
              diff = diffDomain($$.y.range());
              ratio = [lengths[0] / diff, lengths[1] / diff];
              padding_top += domainLength * (ratio[1] / (1 - ratio[0] - ratio[1]));
              padding_bottom += domainLength * (ratio[0] / (1 - ratio[0] - ratio[1]));
          }
          else if (showVerticalDataLabel) {
              lengths = $$.getDataLabelLength(yDomainMin, yDomainMax, 'height');
              var pixelsToAxisPadding = $$.getY(config["axis_" + axisId + "_type"], 
              // input domain as pixels
              [0, config.axis_rotated ? $$.width : $$.height], 
              // output range as axis padding
              [0, domainLength]);
              padding_top += pixelsToAxisPadding(lengths[1]);
              padding_bottom += pixelsToAxisPadding(lengths[0]);
          }
          if (axisId === 'y' && notEmpty(config.axis_y_padding)) {
              padding_top = $$.axis.getPadding(config.axis_y_padding, 'top', padding_top, domainLength);
              padding_bottom = $$.axis.getPadding(config.axis_y_padding, 'bottom', padding_bottom, domainLength);
          }
          if (axisId === 'y2' && notEmpty(config.axis_y2_padding)) {
              padding_top = $$.axis.getPadding(config.axis_y2_padding, 'top', padding_top, domainLength);
              padding_bottom = $$.axis.getPadding(config.axis_y2_padding, 'bottom', padding_bottom, domainLength);
          }
          // Bar/Area chart should be 0-based if all positive|negative
          if (isZeroBased) {
              if (isAllPositive) {
                  padding_bottom = yDomainMin;
              }
              if (isAllNegative) {
                  padding_top = -yDomainMax;
              }
          }
          domain = [yDomainMin - padding_bottom, yDomainMax + padding_top];
          return isInverted ? domain.reverse() : domain;
      };
      ChartInternal.prototype.getXDomainMin = function (targets) {
          var $$ = this, config = $$.config;
          return isDefined(config.axis_x_min)
              ? $$.isTimeSeries()
                  ? this.parseDate(config.axis_x_min)
                  : config.axis_x_min
              : $$.d3.min(targets, function (t) {
                  return $$.d3.min(t.values, function (v) {
                      return v.x;
                  });
              });
      };
      ChartInternal.prototype.getXDomainMax = function (targets) {
          var $$ = this, config = $$.config;
          return isDefined(config.axis_x_max)
              ? $$.isTimeSeries()
                  ? this.parseDate(config.axis_x_max)
                  : config.axis_x_max
              : $$.d3.max(targets, function (t) {
                  return $$.d3.max(t.values, function (v) {
                      return v.x;
                  });
              });
      };
      ChartInternal.prototype.getXDomainPadding = function (domain) {
          var $$ = this, config = $$.config, diff = domain[1] - domain[0], maxDataCount, padding, paddingLeft, paddingRight;
          if ($$.isCategorized()) {
              padding = 0;
          }
          else if ($$.hasType('bar')) {
              maxDataCount = $$.getMaxDataCount();
              padding = maxDataCount > 1 ? diff / (maxDataCount - 1) / 2 : 0.5;
          }
          else {
              padding = diff * 0.01;
          }
          if (typeof config.axis_x_padding === 'object' &&
              notEmpty(config.axis_x_padding)) {
              paddingLeft = isValue(config.axis_x_padding.left)
                  ? config.axis_x_padding.left
                  : padding;
              paddingRight = isValue(config.axis_x_padding.right)
                  ? config.axis_x_padding.right
                  : padding;
          }
          else if (typeof config.axis_x_padding === 'number') {
              paddingLeft = paddingRight = config.axis_x_padding;
          }
          else {
              paddingLeft = paddingRight = padding;
          }
          return { left: paddingLeft, right: paddingRight };
      };
      ChartInternal.prototype.getXDomain = function (targets) {
          var $$ = this, xDomain = [$$.getXDomainMin(targets), $$.getXDomainMax(targets)], firstX = xDomain[0], lastX = xDomain[1], padding = $$.getXDomainPadding(xDomain), min = 0, max = 0;
          // show center of x domain if min and max are the same
          if (firstX - lastX === 0 && !$$.isCategorized()) {
              if ($$.isTimeSeries()) {
                  firstX = new Date(firstX.getTime() * 0.5);
                  lastX = new Date(lastX.getTime() * 1.5);
              }
              else {
                  firstX = firstX === 0 ? 1 : firstX * 0.5;
                  lastX = lastX === 0 ? -1 : lastX * 1.5;
              }
          }
          if (firstX || firstX === 0) {
              min = $$.isTimeSeries()
                  ? new Date(firstX.getTime() - padding.left)
                  : firstX - padding.left;
          }
          if (lastX || lastX === 0) {
              max = $$.isTimeSeries()
                  ? new Date(lastX.getTime() + padding.right)
                  : lastX + padding.right;
          }
          return [min, max];
      };
      ChartInternal.prototype.updateXDomain = function (targets, withUpdateXDomain, withUpdateOrgXDomain, withTrim, domain) {
          var $$ = this, config = $$.config;
          if (withUpdateOrgXDomain) {
              $$.x.domain(domain ? domain : $$.d3.extent($$.getXDomain(targets)));
              $$.orgXDomain = $$.x.domain();
              if (config.zoom_enabled) {
                  $$.zoom.update();
              }
              $$.subX.domain($$.x.domain());
              if ($$.brush) {
                  $$.brush.updateScale($$.subX);
              }
          }
          if (withUpdateXDomain) {
              $$.x.domain(domain
                  ? domain
                  : !$$.brush || $$.brush.empty()
                      ? $$.orgXDomain
                      : $$.brush.selectionAsValue());
          }
          // Trim domain when too big by zoom mousemove event
          if (withTrim) {
              $$.x.domain($$.trimXDomain($$.x.orgDomain()));
          }
          return $$.x.domain();
      };
      ChartInternal.prototype.trimXDomain = function (domain) {
          var zoomDomain = this.getZoomDomain(), min = zoomDomain[0], max = zoomDomain[1];
          if (domain[0] <= min) {
              domain[1] = +domain[1] + (min - domain[0]);
              domain[0] = min;
          }
          if (max <= domain[1]) {
              domain[0] = +domain[0] - (domain[1] - max);
              domain[1] = max;
          }
          return domain;
      };

      ChartInternal.prototype.drag = function (mouse) {
          var $$ = this, config = $$.config, main = $$.main, d3 = $$.d3;
          var sx, sy, mx, my, minX, maxX, minY, maxY;
          if ($$.hasArcType()) {
              return;
          }
          if (!config.data_selection_enabled) {
              return;
          } // do nothing if not selectable
          if (!config.data_selection_multiple) {
              return;
          } // skip when single selection because drag is used for multiple selection
          sx = $$.dragStart[0];
          sy = $$.dragStart[1];
          mx = mouse[0];
          my = mouse[1];
          minX = Math.min(sx, mx);
          maxX = Math.max(sx, mx);
          minY = config.data_selection_grouped ? $$.margin.top : Math.min(sy, my);
          maxY = config.data_selection_grouped ? $$.height : Math.max(sy, my);
          main
              .select('.' + CLASS.dragarea)
              .attr('x', minX)
              .attr('y', minY)
              .attr('width', maxX - minX)
              .attr('height', maxY - minY);
          // TODO: binary search when multiple xs
          main
              .selectAll('.' + CLASS.shapes)
              .selectAll('.' + CLASS.shape)
              .each(function (d, i) {
              if (!config.data_selection_isselectable(d)) {
                  return;
              }
              var shape = d3.select(this), isSelected = shape.classed(CLASS.SELECTED), isIncluded = shape.classed(CLASS.INCLUDED), _x, _y, _w, _h, toggle, isWithin = false, box;
              if (shape.classed(CLASS.circle)) {
                  _x = shape.attr('cx') * 1;
                  _y = shape.attr('cy') * 1;
                  toggle = $$.togglePoint;
                  isWithin = minX < _x && _x < maxX && minY < _y && _y < maxY;
              }
              else if (shape.classed(CLASS.bar)) {
                  box = getPathBox(this);
                  _x = box.x;
                  _y = box.y;
                  _w = box.width;
                  _h = box.height;
                  toggle = $$.togglePath;
                  isWithin =
                      !(maxX < _x || _x + _w < minX) && !(maxY < _y || _y + _h < minY);
              }
              else {
                  // line/area selection not supported yet
                  return;
              }
              if (isWithin ^ isIncluded) {
                  shape.classed(CLASS.INCLUDED, !isIncluded);
                  // TODO: included/unincluded callback here
                  shape.classed(CLASS.SELECTED, !isSelected);
                  toggle.call($$, !isSelected, shape, d, i);
              }
          });
      };
      ChartInternal.prototype.dragstart = function (mouse) {
          var $$ = this, config = $$.config;
          if ($$.hasArcType()) {
              return;
          }
          if (!config.data_selection_enabled) {
              return;
          } // do nothing if not selectable
          $$.dragStart = mouse;
          $$.main
              .select('.' + CLASS.chart)
              .append('rect')
              .attr('class', CLASS.dragarea)
              .style('opacity', 0.1);
          $$.dragging = true;
      };
      ChartInternal.prototype.dragend = function () {
          var $$ = this, config = $$.config;
          if ($$.hasArcType()) {
              return;
          }
          if (!config.data_selection_enabled) {
              return;
          } // do nothing if not selectable
          $$.main
              .select('.' + CLASS.dragarea)
              .transition()
              .duration(100)
              .style('opacity', 0)
              .remove();
          $$.main.selectAll('.' + CLASS.shape).classed(CLASS.INCLUDED, false);
          $$.dragging = false;
      };

      ChartInternal.prototype.getYFormat = function (forArc) {
          var $$ = this, formatForY = forArc && !$$.hasType('gauge') ? $$.defaultArcValueFormat : $$.yFormat, formatForY2 = forArc && !$$.hasType('gauge') ? $$.defaultArcValueFormat : $$.y2Format;
          return function (v, ratio, id) {
              var format = $$.axis.getId(id) === 'y2' ? formatForY2 : formatForY;
              return format.call($$, v, ratio);
          };
      };
      ChartInternal.prototype.yFormat = function (v) {
          var $$ = this, config = $$.config, format = config.axis_y_tick_format
              ? config.axis_y_tick_format
              : $$.defaultValueFormat;
          return format(v);
      };
      ChartInternal.prototype.y2Format = function (v) {
          var $$ = this, config = $$.config, format = config.axis_y2_tick_format
              ? config.axis_y2_tick_format
              : $$.defaultValueFormat;
          return format(v);
      };
      ChartInternal.prototype.defaultValueFormat = function (v) {
          return isValue(v) ? +v : '';
      };
      ChartInternal.prototype.defaultArcValueFormat = function (v, ratio) {
          return (ratio * 100).toFixed(1) + '%';
      };
      ChartInternal.prototype.dataLabelFormat = function (targetId) {
          var $$ = this, data_labels = $$.config.data_labels, format, defaultFormat = function (v) {
              return isValue(v) ? +v : '';
          };
          // find format according to axis id
          if (typeof data_labels.format === 'function') {
              format = data_labels.format;
          }
          else if (typeof data_labels.format === 'object') {
              if (data_labels.format[targetId]) {
                  format =
                      data_labels.format[targetId] === true
                          ? defaultFormat
                          : data_labels.format[targetId];
              }
              else {
                  format = function () {
                      return '';
                  };
              }
          }
          else {
              format = defaultFormat;
          }
          return format;
      };

      ChartInternal.prototype.initGrid = function () {
          var $$ = this, config = $$.config, d3 = $$.d3;
          $$.grid = $$.main
              .append('g')
              .attr('clip-path', $$.clipPathForGrid)
              .attr('class', CLASS.grid);
          if (config.grid_x_show) {
              $$.grid.append('g').attr('class', CLASS.xgrids);
          }
          if (config.grid_y_show) {
              $$.grid.append('g').attr('class', CLASS.ygrids);
          }
          if (config.grid_focus_show) {
              $$.grid
                  .append('g')
                  .attr('class', CLASS.xgridFocus)
                  .append('line')
                  .attr('class', CLASS.xgridFocus);
          }
          $$.xgrid = d3.selectAll([]);
          if (!config.grid_lines_front) {
              $$.initGridLines();
          }
      };
      ChartInternal.prototype.initGridLines = function () {
          var $$ = this, d3 = $$.d3;
          $$.gridLines = $$.main
              .append('g')
              .attr('clip-path', $$.clipPathForGrid)
              .attr('class', CLASS.grid + ' ' + CLASS.gridLines);
          $$.gridLines.append('g').attr('class', CLASS.xgridLines);
          $$.gridLines.append('g').attr('class', CLASS.ygridLines);
          $$.xgridLines = d3.selectAll([]);
      };
      ChartInternal.prototype.updateXGrid = function (withoutUpdate) {
          var $$ = this, config = $$.config, d3 = $$.d3, xgridData = $$.generateGridData(config.grid_x_type, $$.x), tickOffset = $$.isCategorized() ? $$.xAxis.tickOffset() : 0;
          $$.xgridAttr = config.axis_rotated
              ? {
                  x1: 0,
                  x2: $$.width,
                  y1: function (d) {
                      return $$.x(d) - tickOffset;
                  },
                  y2: function (d) {
                      return $$.x(d) - tickOffset;
                  }
              }
              : {
                  x1: function (d) {
                      return $$.x(d) + tickOffset;
                  },
                  x2: function (d) {
                      return $$.x(d) + tickOffset;
                  },
                  y1: 0,
                  y2: $$.height
              };
          $$.xgridAttr.opacity = function () {
              var pos = +d3.select(this).attr(config.axis_rotated ? 'y1' : 'x1');
              return pos === (config.axis_rotated ? $$.height : 0) ? 0 : 1;
          };
          var xgrid = $$.main
              .select('.' + CLASS.xgrids)
              .selectAll('.' + CLASS.xgrid)
              .data(xgridData);
          var xgridEnter = xgrid
              .enter()
              .append('line')
              .attr('class', CLASS.xgrid)
              .attr('x1', $$.xgridAttr.x1)
              .attr('x2', $$.xgridAttr.x2)
              .attr('y1', $$.xgridAttr.y1)
              .attr('y2', $$.xgridAttr.y2)
              .style('opacity', 0);
          $$.xgrid = xgridEnter.merge(xgrid);
          if (!withoutUpdate) {
              $$.xgrid
                  .attr('x1', $$.xgridAttr.x1)
                  .attr('x2', $$.xgridAttr.x2)
                  .attr('y1', $$.xgridAttr.y1)
                  .attr('y2', $$.xgridAttr.y2)
                  .style('opacity', $$.xgridAttr.opacity);
          }
          xgrid.exit().remove();
      };
      ChartInternal.prototype.updateYGrid = function () {
          var $$ = this, config = $$.config, gridValues = $$.yAxis.tickValues() || $$.y.ticks(config.grid_y_ticks);
          var ygrid = $$.main
              .select('.' + CLASS.ygrids)
              .selectAll('.' + CLASS.ygrid)
              .data(gridValues);
          var ygridEnter = ygrid
              .enter()
              .append('line')
              // TODO: x1, x2, y1, y2, opacity need to be set here maybe
              .attr('class', CLASS.ygrid);
          $$.ygrid = ygridEnter.merge(ygrid);
          $$.ygrid
              .attr('x1', config.axis_rotated ? $$.y : 0)
              .attr('x2', config.axis_rotated ? $$.y : $$.width)
              .attr('y1', config.axis_rotated ? 0 : $$.y)
              .attr('y2', config.axis_rotated ? $$.height : $$.y);
          ygrid.exit().remove();
          $$.smoothLines($$.ygrid, 'grid');
      };
      ChartInternal.prototype.gridTextAnchor = function (d) {
          return d.position ? d.position : 'end';
      };
      ChartInternal.prototype.gridTextDx = function (d) {
          return d.position === 'start' ? 4 : d.position === 'middle' ? 0 : -4;
      };
      ChartInternal.prototype.xGridTextX = function (d) {
          return d.position === 'start'
              ? -this.height
              : d.position === 'middle'
                  ? -this.height / 2
                  : 0;
      };
      ChartInternal.prototype.yGridTextX = function (d) {
          return d.position === 'start'
              ? 0
              : d.position === 'middle'
                  ? this.width / 2
                  : this.width;
      };
      ChartInternal.prototype.updateGrid = function (duration) {
          var $$ = this, main = $$.main, config = $$.config, xgridLine, xgridLineEnter, ygridLine, ygridLineEnter, xv = $$.xv.bind($$), yv = $$.yv.bind($$), xGridTextX = $$.xGridTextX.bind($$), yGridTextX = $$.yGridTextX.bind($$);
          // hide if arc type
          $$.grid.style('visibility', $$.hasArcType() ? 'hidden' : 'visible');
          main.select('line.' + CLASS.xgridFocus).style('visibility', 'hidden');
          if (config.grid_x_show) {
              $$.updateXGrid();
          }
          xgridLine = main
              .select('.' + CLASS.xgridLines)
              .selectAll('.' + CLASS.xgridLine)
              .data(config.grid_x_lines);
          // enter
          xgridLineEnter = xgridLine
              .enter()
              .append('g')
              .attr('class', function (d) {
              return CLASS.xgridLine + (d['class'] ? ' ' + d['class'] : '');
          });
          xgridLineEnter
              .append('line')
              .attr('x1', config.axis_rotated ? 0 : xv)
              .attr('x2', config.axis_rotated ? $$.width : xv)
              .attr('y1', config.axis_rotated ? xv : 0)
              .attr('y2', config.axis_rotated ? xv : $$.height)
              .style('opacity', 0);
          xgridLineEnter
              .append('text')
              .attr('text-anchor', $$.gridTextAnchor)
              .attr('transform', config.axis_rotated ? '' : 'rotate(-90)')
              .attr('x', config.axis_rotated ? yGridTextX : xGridTextX)
              .attr('y', xv)
              .attr('dx', $$.gridTextDx)
              .attr('dy', -5)
              .style('opacity', 0);
          // udpate
          $$.xgridLines = xgridLineEnter.merge(xgridLine);
          // done in d3.transition() of the end of this function
          // exit
          xgridLine
              .exit()
              .transition()
              .duration(duration)
              .style('opacity', 0)
              .remove();
          // Y-Grid
          if (config.grid_y_show) {
              $$.updateYGrid();
          }
          ygridLine = main
              .select('.' + CLASS.ygridLines)
              .selectAll('.' + CLASS.ygridLine)
              .data(config.grid_y_lines);
          // enter
          ygridLineEnter = ygridLine
              .enter()
              .append('g')
              .attr('class', function (d) {
              return CLASS.ygridLine + (d['class'] ? ' ' + d['class'] : '');
          });
          ygridLineEnter
              .append('line')
              .attr('x1', config.axis_rotated ? yv : 0)
              .attr('x2', config.axis_rotated ? yv : $$.width)
              .attr('y1', config.axis_rotated ? 0 : yv)
              .attr('y2', config.axis_rotated ? $$.height : yv)
              .style('opacity', 0);
          ygridLineEnter
              .append('text')
              .attr('text-anchor', $$.gridTextAnchor)
              .attr('transform', config.axis_rotated ? 'rotate(-90)' : '')
              .attr('x', config.axis_rotated ? xGridTextX : yGridTextX)
              .attr('y', yv)
              .attr('dx', $$.gridTextDx)
              .attr('dy', -5)
              .style('opacity', 0);
          // update
          $$.ygridLines = ygridLineEnter.merge(ygridLine);
          $$.ygridLines
              .select('line')
              .transition()
              .duration(duration)
              .attr('x1', config.axis_rotated ? yv : 0)
              .attr('x2', config.axis_rotated ? yv : $$.width)
              .attr('y1', config.axis_rotated ? 0 : yv)
              .attr('y2', config.axis_rotated ? $$.height : yv)
              .style('opacity', 1);
          $$.ygridLines
              .select('text')
              .transition()
              .duration(duration)
              .attr('x', config.axis_rotated ? $$.xGridTextX.bind($$) : $$.yGridTextX.bind($$))
              .attr('y', yv)
              .text(function (d) {
              return d.text;
          })
              .style('opacity', 1);
          // exit
          ygridLine
              .exit()
              .transition()
              .duration(duration)
              .style('opacity', 0)
              .remove();
      };
      ChartInternal.prototype.redrawGrid = function (withTransition, transition) {
          var $$ = this, config = $$.config, xv = $$.xv.bind($$), lines = $$.xgridLines.select('line'), texts = $$.xgridLines.select('text');
          return [
              (withTransition ? lines.transition(transition) : lines)
                  .attr('x1', config.axis_rotated ? 0 : xv)
                  .attr('x2', config.axis_rotated ? $$.width : xv)
                  .attr('y1', config.axis_rotated ? xv : 0)
                  .attr('y2', config.axis_rotated ? xv : $$.height)
                  .style('opacity', 1),
              (withTransition ? texts.transition(transition) : texts)
                  .attr('x', config.axis_rotated ? $$.yGridTextX.bind($$) : $$.xGridTextX.bind($$))
                  .attr('y', xv)
                  .text(function (d) {
                  return d.text;
              })
                  .style('opacity', 1)
          ];
      };
      ChartInternal.prototype.showXGridFocus = function (selectedData) {
          var $$ = this, config = $$.config, dataToShow = selectedData.filter(function (d) {
              return d && isValue(d.value);
          }), focusEl = $$.main.selectAll('line.' + CLASS.xgridFocus), xx = $$.xx.bind($$);
          if (!config.tooltip_show) {
              return;
          }
          // Hide when stanford plot exists
          if ($$.hasType('stanford') || $$.hasArcType()) {
              return;
          }
          focusEl
              .style('visibility', 'visible')
              .data([dataToShow[0]])
              .attr(config.axis_rotated ? 'y1' : 'x1', xx)
              .attr(config.axis_rotated ? 'y2' : 'x2', xx);
          $$.smoothLines(focusEl, 'grid');
      };
      ChartInternal.prototype.hideXGridFocus = function () {
          this.main.select('line.' + CLASS.xgridFocus).style('visibility', 'hidden');
      };
      ChartInternal.prototype.updateXgridFocus = function () {
          var $$ = this, config = $$.config;
          $$.main
              .select('line.' + CLASS.xgridFocus)
              .attr('x1', config.axis_rotated ? 0 : -10)
              .attr('x2', config.axis_rotated ? $$.width : -10)
              .attr('y1', config.axis_rotated ? -10 : 0)
              .attr('y2', config.axis_rotated ? -10 : $$.height);
      };
      ChartInternal.prototype.generateGridData = function (type, scale) {
          var $$ = this, gridData = [], xDomain, firstYear, lastYear, i, tickNum = $$.main
              .select('.' + CLASS.axisX)
              .selectAll('.tick')
              .size();
          if (type === 'year') {
              xDomain = $$.getXDomain();
              firstYear = xDomain[0].getFullYear();
              lastYear = xDomain[1].getFullYear();
              for (i = firstYear; i <= lastYear; i++) {
                  gridData.push(new Date(i + '-01-01 00:00:00'));
              }
          }
          else {
              gridData = scale.ticks(10);
              if (gridData.length > tickNum) {
                  // use only int
                  gridData = gridData.filter(function (d) {
                      return ('' + d).indexOf('.') < 0;
                  });
              }
          }
          return gridData;
      };
      ChartInternal.prototype.getGridFilterToRemove = function (params) {
          return params
              ? function (line) {
                  var found = false;
                  [].concat(params).forEach(function (param) {
                      if (('value' in param && line.value === param.value) ||
                          ('class' in param && line['class'] === param['class'])) {
                          found = true;
                      }
                  });
                  return found;
              }
              : function () {
                  return true;
              };
      };
      ChartInternal.prototype.removeGridLines = function (params, forX) {
          var $$ = this, config = $$.config, toRemove = $$.getGridFilterToRemove(params), toShow = function (line) {
              return !toRemove(line);
          }, classLines = forX ? CLASS.xgridLines : CLASS.ygridLines, classLine = forX ? CLASS.xgridLine : CLASS.ygridLine;
          $$.main
              .select('.' + classLines)
              .selectAll('.' + classLine)
              .filter(toRemove)
              .transition()
              .duration(config.transition_duration)
              .style('opacity', 0)
              .remove();
          if (forX) {
              config.grid_x_lines = config.grid_x_lines.filter(toShow);
          }
          else {
              config.grid_y_lines = config.grid_y_lines.filter(toShow);
          }
      };

      ChartInternal.prototype.initEventRect = function () {
          var $$ = this, config = $$.config;
          $$.main
              .select('.' + CLASS.chart)
              .append('g')
              .attr('class', CLASS.eventRects)
              .style('fill-opacity', 0);
          $$.eventRect = $$.main
              .select('.' + CLASS.eventRects)
              .append('rect')
              .attr('class', CLASS.eventRect);
          // event rect handle zoom event as well
          if (config.zoom_enabled && $$.zoom) {
              $$.eventRect.call($$.zoom).on('dblclick.zoom', null);
              if (config.zoom_initialRange) {
                  // WORKAROUND: Add transition to apply transform immediately when no subchart
                  $$.eventRect
                      .transition()
                      .duration(0)
                      .call($$.zoom.transform, $$.zoomTransform(config.zoom_initialRange));
              }
          }
      };
      ChartInternal.prototype.redrawEventRect = function () {
          var $$ = this, d3 = $$.d3, config = $$.config;
          function mouseout() {
              $$.svg.select('.' + CLASS.eventRect).style('cursor', null);
              $$.hideXGridFocus();
              $$.hideTooltip();
              $$.unexpandCircles();
              $$.unexpandBars();
          }
          var isHoveringDataPoint = function (mouse, closest) {
              return closest &&
                  ($$.isBarType(closest.id) ||
                      $$.dist(closest, mouse) < config.point_sensitivity);
          };
          var withName = function (d) { return (d ? $$.addName(Object.assign({}, d)) : null); };
          // rects for mouseover
          $$.main
              .select('.' + CLASS.eventRects)
              .style('cursor', config.zoom_enabled
              ? config.axis_rotated
                  ? 'ns-resize'
                  : 'ew-resize'
              : null);
          $$.eventRect
              .attr('x', 0)
              .attr('y', 0)
              .attr('width', $$.width)
              .attr('height', $$.height)
              .on('mouseout', config.interaction_enabled
              ? function () {
                  if (!config) {
                      return;
                  } // chart is destroyed
                  if ($$.hasArcType()) {
                      return;
                  }
                  if ($$.mouseover) {
                      config.data_onmouseout.call($$.api, $$.mouseover);
                      $$.mouseover = undefined;
                  }
                  mouseout();
              }
              : null)
              .on('mousemove', config.interaction_enabled
              ? function () {
                  // do nothing when dragging
                  if ($$.dragging) {
                      return;
                  }
                  var targetsToShow = $$.getTargetsToShow();
                  // do nothing if arc type
                  if ($$.hasArcType(targetsToShow)) {
                      return;
                  }
                  var mouse = d3.mouse(this);
                  var closest = withName($$.findClosestFromTargets(targetsToShow, mouse));
                  var isMouseCloseToDataPoint = isHoveringDataPoint(mouse, closest);
                  // ensure onmouseout is always called if mousemove switch between 2 targets
                  if ($$.mouseover &&
                      (!closest ||
                          closest.id !== $$.mouseover.id ||
                          closest.index !== $$.mouseover.index)) {
                      config.data_onmouseout.call($$.api, $$.mouseover);
                      $$.mouseover = undefined;
                  }
                  if (closest && !$$.mouseover) {
                      config.data_onmouseover.call($$.api, closest);
                      $$.mouseover = closest;
                  }
                  // show cursor as pointer if we're hovering a data point close enough
                  $$.svg
                      .select('.' + CLASS.eventRect)
                      .style('cursor', isMouseCloseToDataPoint ? 'pointer' : null);
                  // if tooltip not grouped, we want to display only data from closest data point
                  var showSingleDataPoint = !config.tooltip_grouped || $$.hasType('stanford', targetsToShow);
                  // find data to highlight
                  var selectedData;
                  if (showSingleDataPoint) {
                      if (closest) {
                          selectedData = [closest];
                      }
                  }
                  else {
                      var closestByX = void 0;
                      if (closest) {
                          // reuse closest value
                          closestByX = closest;
                      }
                      else {
                          // try to find the closest value by X values from the mouse position
                          var mouseX = config.axis_rotated ? mouse[1] : mouse[0];
                          closestByX = $$.findClosestFromTargetsByX(targetsToShow, $$.x.invert(mouseX));
                      }
                      // highlight all data for this 'x' value
                      if (closestByX) {
                          selectedData = $$.filterByX(targetsToShow, closestByX.x);
                      }
                  }
                  // ensure we have data to show
                  if (!selectedData || selectedData.length === 0) {
                      return mouseout();
                  }
                  // inject names for each point
                  selectedData = selectedData.map(withName);
                  // show tooltip
                  $$.showTooltip(selectedData, this);
                  // expand points
                  if (config.point_focus_expand_enabled) {
                      $$.unexpandCircles();
                      selectedData.forEach(function (d) {
                          $$.expandCircles(d.index, d.id, false);
                      });
                  }
                  // expand bars
                  $$.unexpandBars();
                  selectedData.forEach(function (d) {
                      $$.expandBars(d.index, d.id, false);
                  });
                  // Show xgrid focus line
                  $$.showXGridFocus(selectedData);
              }
              : null)
              .on('click', config.interaction_enabled
              ? function () {
                  var targetsToShow = $$.getTargetsToShow();
                  if ($$.hasArcType(targetsToShow)) {
                      return;
                  }
                  var mouse = d3.mouse(this);
                  var closest = withName($$.findClosestFromTargets(targetsToShow, mouse));
                  if (!isHoveringDataPoint(mouse, closest)) {
                      return;
                  }
                  // select if selection enabled
                  var sameXData;
                  if (!config.data_selection_grouped || $$.isStanfordType(closest)) {
                      sameXData = [closest];
                  }
                  else {
                      sameXData = $$.filterByX(targetsToShow, closest.x);
                  }
                  // toggle selected state
                  sameXData.forEach(function (d) {
                      $$.main
                          .selectAll('.' + CLASS.shapes + $$.getTargetSelectorSuffix(d.id))
                          .selectAll('.' + CLASS.shape + '-' + d.index)
                          .each(function () {
                          if (config.data_selection_grouped ||
                              $$.isWithinShape(this, d)) {
                              $$.toggleShape(this, d, d.index);
                          }
                      });
                  });
                  // call data_onclick on the closest data point
                  if (closest) {
                      var shape = $$.main
                          .selectAll('.' + CLASS.shapes + $$.getTargetSelectorSuffix(closest.id))
                          .select('.' + CLASS.shape + '-' + closest.index);
                      config.data_onclick.call($$.api, closest, shape.node());
                  }
              }
              : null)
              .call(config.interaction_enabled && config.data_selection_draggable && $$.drag
              ? d3
                  .drag()
                  .on('drag', function () {
                  $$.drag(d3.mouse(this));
              })
                  .on('start', function () {
                  $$.dragstart(d3.mouse(this));
              })
                  .on('end', function () {
                  $$.dragend();
              })
              : function () { });
      };
      ChartInternal.prototype.getMousePosition = function (data) {
          var $$ = this;
          return [$$.x(data.x), $$.getYScale(data.id)(data.value)];
      };
      ChartInternal.prototype.dispatchEvent = function (type, mouse) {
          var $$ = this, selector = '.' + CLASS.eventRect, eventRect = $$.main.select(selector).node(), box = eventRect.getBoundingClientRect(), x = box.left + (mouse ? mouse[0] : 0), y = box.top + (mouse ? mouse[1] : 0), event = document.createEvent('MouseEvents');
          event.initMouseEvent(type, true, true, window, 0, x, y, x, y, false, false, false, false, 0, null);
          eventRect.dispatchEvent(event);
      };

      ChartInternal.prototype.initLegend = function () {
          var $$ = this;
          $$.legendItemTextBox = {};
          $$.legendHasRendered = false;
          $$.legend = $$.svg.append('g').attr('transform', $$.getTranslate('legend'));
          if (!$$.config.legend_show) {
              $$.legend.style('visibility', 'hidden');
              $$.hiddenLegendIds = $$.mapToIds($$.data.targets);
              return;
          }
          // MEMO: call here to update legend box and tranlate for all
          // MEMO: translate will be updated by this, so transform not needed in updateLegend()
          $$.updateLegendWithDefaults();
      };
      ChartInternal.prototype.updateLegendWithDefaults = function () {
          var $$ = this;
          $$.updateLegend($$.mapToIds($$.data.targets), {
              withTransform: false,
              withTransitionForTransform: false,
              withTransition: false
          });
      };
      ChartInternal.prototype.updateSizeForLegend = function (legendHeight, legendWidth) {
          var $$ = this, config = $$.config, insetLegendPosition = {
              top: $$.isLegendTop
                  ? $$.getCurrentPaddingTop() + config.legend_inset_y + 5.5
                  : $$.currentHeight -
                      legendHeight -
                      $$.getCurrentPaddingBottom() -
                      config.legend_inset_y,
              left: $$.isLegendLeft
                  ? $$.getCurrentPaddingLeft() + config.legend_inset_x + 0.5
                  : $$.currentWidth -
                      legendWidth -
                      $$.getCurrentPaddingRight() -
                      config.legend_inset_x +
                      0.5
          };
          $$.margin3 = {
              top: $$.isLegendRight
                  ? 0
                  : $$.isLegendInset
                      ? insetLegendPosition.top
                      : $$.currentHeight - legendHeight,
              right: NaN,
              bottom: 0,
              left: $$.isLegendRight
                  ? $$.currentWidth - legendWidth
                  : $$.isLegendInset
                      ? insetLegendPosition.left
                      : 0
          };
      };
      ChartInternal.prototype.transformLegend = function (withTransition) {
          var $$ = this;
          (withTransition ? $$.legend.transition() : $$.legend).attr('transform', $$.getTranslate('legend'));
      };
      ChartInternal.prototype.updateLegendStep = function (step) {
          this.legendStep = step;
      };
      ChartInternal.prototype.updateLegendItemWidth = function (w) {
          this.legendItemWidth = w;
      };
      ChartInternal.prototype.updateLegendItemHeight = function (h) {
          this.legendItemHeight = h;
      };
      ChartInternal.prototype.getLegendWidth = function () {
          var $$ = this;
          return $$.config.legend_show
              ? $$.isLegendRight || $$.isLegendInset
                  ? $$.legendItemWidth * ($$.legendStep + 1)
                  : $$.currentWidth
              : 0;
      };
      ChartInternal.prototype.getLegendHeight = function () {
          var $$ = this, h = 0;
          if ($$.config.legend_show) {
              if ($$.isLegendRight) {
                  h = $$.currentHeight;
              }
              else {
                  h = Math.max(20, $$.legendItemHeight) * ($$.legendStep + 1);
              }
          }
          return h;
      };
      ChartInternal.prototype.opacityForLegend = function (legendItem) {
          return legendItem.classed(CLASS.legendItemHidden) ? null : 1;
      };
      ChartInternal.prototype.opacityForUnfocusedLegend = function (legendItem) {
          return legendItem.classed(CLASS.legendItemHidden) ? null : 0.3;
      };
      ChartInternal.prototype.toggleFocusLegend = function (targetIds, focus) {
          var $$ = this;
          targetIds = $$.mapToTargetIds(targetIds);
          $$.legend
              .selectAll('.' + CLASS.legendItem)
              .filter(function (id) {
              return targetIds.indexOf(id) >= 0;
          })
              .classed(CLASS.legendItemFocused, focus)
              .transition()
              .duration(100)
              .style('opacity', function () {
              var opacity = focus ? $$.opacityForLegend : $$.opacityForUnfocusedLegend;
              return opacity.call($$, $$.d3.select(this));
          });
      };
      ChartInternal.prototype.revertLegend = function () {
          var $$ = this, d3 = $$.d3;
          $$.legend
              .selectAll('.' + CLASS.legendItem)
              .classed(CLASS.legendItemFocused, false)
              .transition()
              .duration(100)
              .style('opacity', function () {
              return $$.opacityForLegend(d3.select(this));
          });
      };
      ChartInternal.prototype.showLegend = function (targetIds) {
          var $$ = this, config = $$.config;
          if (!config.legend_show) {
              config.legend_show = true;
              $$.legend.style('visibility', 'visible');
              if (!$$.legendHasRendered) {
                  $$.updateLegendWithDefaults();
              }
          }
          $$.removeHiddenLegendIds(targetIds);
          $$.legend
              .selectAll($$.selectorLegends(targetIds))
              .style('visibility', 'visible')
              .transition()
              .style('opacity', function () {
              return $$.opacityForLegend($$.d3.select(this));
          });
      };
      ChartInternal.prototype.hideLegend = function (targetIds) {
          var $$ = this, config = $$.config;
          if (config.legend_show && isEmpty(targetIds)) {
              config.legend_show = false;
              $$.legend.style('visibility', 'hidden');
          }
          $$.addHiddenLegendIds(targetIds);
          $$.legend
              .selectAll($$.selectorLegends(targetIds))
              .style('opacity', 0)
              .style('visibility', 'hidden');
      };
      ChartInternal.prototype.clearLegendItemTextBoxCache = function () {
          this.legendItemTextBox = {};
      };
      ChartInternal.prototype.updateLegend = function (targetIds, options, transitions) {
          var $$ = this, config = $$.config;
          var xForLegend, xForLegendText, xForLegendRect, yForLegend, yForLegendText, yForLegendRect, x1ForLegendTile, x2ForLegendTile, yForLegendTile;
          var paddingTop = 4, paddingRight = 10, maxWidth = 0, maxHeight = 0, posMin = 10, tileWidth = config.legend_item_tile_width + 5;
          var l, totalLength = 0, offsets = {}, widths = {}, heights = {}, margins = [0], steps = {}, step = 0;
          var withTransition, withTransitionForTransform;
          var texts, rects, tiles, background;
          // Skip elements when their name is set to null
          targetIds = targetIds.filter(function (id) {
              return !isDefined(config.data_names[id]) || config.data_names[id] !== null;
          });
          options = options || {};
          withTransition = getOption(options, 'withTransition', true);
          withTransitionForTransform = getOption(options, 'withTransitionForTransform', true);
          function getTextBox(textElement, id) {
              if (!$$.legendItemTextBox[id]) {
                  $$.legendItemTextBox[id] = $$.getTextRect(textElement.textContent, CLASS.legendItem, textElement);
              }
              return $$.legendItemTextBox[id];
          }
          function updatePositions(textElement, id, index) {
              var reset = index === 0, isLast = index === targetIds.length - 1, box = getTextBox(textElement, id), itemWidth = box.width +
                  tileWidth +
                  (isLast && !($$.isLegendRight || $$.isLegendInset) ? 0 : paddingRight) +
                  config.legend_padding, itemHeight = box.height + paddingTop, itemLength = $$.isLegendRight || $$.isLegendInset ? itemHeight : itemWidth, areaLength = $$.isLegendRight || $$.isLegendInset
                  ? $$.getLegendHeight()
                  : $$.getLegendWidth(), margin, maxLength;
              // MEMO: care about condifion of step, totalLength
              function updateValues(id, withoutStep) {
                  if (!withoutStep) {
                      margin = (areaLength - totalLength - itemLength) / 2;
                      if (margin < posMin) {
                          margin = (areaLength - itemLength) / 2;
                          totalLength = 0;
                          step++;
                      }
                  }
                  steps[id] = step;
                  margins[step] = $$.isLegendInset ? 10 : margin;
                  offsets[id] = totalLength;
                  totalLength += itemLength;
              }
              if (reset) {
                  totalLength = 0;
                  step = 0;
                  maxWidth = 0;
                  maxHeight = 0;
              }
              if (config.legend_show && !$$.isLegendToShow(id)) {
                  widths[id] = heights[id] = steps[id] = offsets[id] = 0;
                  return;
              }
              widths[id] = itemWidth;
              heights[id] = itemHeight;
              if (!maxWidth || itemWidth >= maxWidth) {
                  maxWidth = itemWidth;
              }
              if (!maxHeight || itemHeight >= maxHeight) {
                  maxHeight = itemHeight;
              }
              maxLength = $$.isLegendRight || $$.isLegendInset ? maxHeight : maxWidth;
              if (config.legend_equally) {
                  Object.keys(widths).forEach(function (id) {
                      widths[id] = maxWidth;
                  });
                  Object.keys(heights).forEach(function (id) {
                      heights[id] = maxHeight;
                  });
                  margin = (areaLength - maxLength * targetIds.length) / 2;
                  if (margin < posMin) {
                      totalLength = 0;
                      step = 0;
                      targetIds.forEach(function (id) {
                          updateValues(id);
                      });
                  }
                  else {
                      updateValues(id, true);
                  }
              }
              else {
                  updateValues(id);
              }
          }
          if ($$.isLegendInset) {
              step = config.legend_inset_step
                  ? config.legend_inset_step
                  : targetIds.length;
              $$.updateLegendStep(step);
          }
          if ($$.isLegendRight) {
              xForLegend = function (id) {
                  return maxWidth * steps[id];
              };
              yForLegend = function (id) {
                  return margins[steps[id]] + offsets[id];
              };
          }
          else if ($$.isLegendInset) {
              xForLegend = function (id) {
                  return maxWidth * steps[id] + 10;
              };
              yForLegend = function (id) {
                  return margins[steps[id]] + offsets[id];
              };
          }
          else {
              xForLegend = function (id) {
                  return margins[steps[id]] + offsets[id];
              };
              yForLegend = function (id) {
                  return maxHeight * steps[id];
              };
          }
          xForLegendText = function (id, i) {
              return xForLegend(id, i) + 4 + config.legend_item_tile_width;
          };
          yForLegendText = function (id, i) {
              return yForLegend(id, i) + 9;
          };
          xForLegendRect = function (id, i) {
              return xForLegend(id, i);
          };
          yForLegendRect = function (id, i) {
              return yForLegend(id, i) - 5;
          };
          x1ForLegendTile = function (id, i) {
              return xForLegend(id, i) - 2;
          };
          x2ForLegendTile = function (id, i) {
              return xForLegend(id, i) - 2 + config.legend_item_tile_width;
          };
          yForLegendTile = function (id, i) {
              return yForLegend(id, i) + 4;
          };
          // Define g for legend area
          l = $$.legend
              .selectAll('.' + CLASS.legendItem)
              .data(targetIds)
              .enter()
              .append('g')
              .attr('class', function (id) {
              return $$.generateClass(CLASS.legendItem, id);
          })
              .style('visibility', function (id) {
              return $$.isLegendToShow(id) ? 'visible' : 'hidden';
          })
              .style('cursor', function () {
              return config.interaction_enabled ? 'pointer' : 'auto';
          })
              .on('click', config.interaction_enabled
              ? function (id) {
                  if (config.legend_item_onclick) {
                      config.legend_item_onclick.call($$, id);
                  }
                  else {
                      if ($$.d3.event.altKey) {
                          $$.api.hide();
                          $$.api.show(id);
                      }
                      else {
                          $$.api.toggle(id);
                          $$.isTargetToShow(id) ? $$.api.focus(id) : $$.api.revert();
                      }
                  }
              }
              : null)
              .on('mouseover', config.interaction_enabled
              ? function (id) {
                  if (config.legend_item_onmouseover) {
                      config.legend_item_onmouseover.call($$, id);
                  }
                  else {
                      $$.d3.select(this).classed(CLASS.legendItemFocused, true);
                      if (!$$.transiting && $$.isTargetToShow(id)) {
                          $$.api.focus(id);
                      }
                  }
              }
              : null)
              .on('mouseout', config.interaction_enabled
              ? function (id) {
                  if (config.legend_item_onmouseout) {
                      config.legend_item_onmouseout.call($$, id);
                  }
                  else {
                      $$.d3.select(this).classed(CLASS.legendItemFocused, false);
                      $$.api.revert();
                  }
              }
              : null);
          l.append('text')
              .text(function (id) {
              return isDefined(config.data_names[id]) ? config.data_names[id] : id;
          })
              .each(function (id, i) {
              updatePositions(this, id, i);
          })
              .style('pointer-events', 'none')
              .attr('x', $$.isLegendRight || $$.isLegendInset ? xForLegendText : -200)
              .attr('y', $$.isLegendRight || $$.isLegendInset ? -200 : yForLegendText);
          l.append('rect')
              .attr('class', CLASS.legendItemEvent)
              .style('fill-opacity', 0)
              .attr('x', $$.isLegendRight || $$.isLegendInset ? xForLegendRect : -200)
              .attr('y', $$.isLegendRight || $$.isLegendInset ? -200 : yForLegendRect);
          l.append('line')
              .attr('class', CLASS.legendItemTile)
              .style('stroke', $$.color)
              .style('pointer-events', 'none')
              .attr('x1', $$.isLegendRight || $$.isLegendInset ? x1ForLegendTile : -200)
              .attr('y1', $$.isLegendRight || $$.isLegendInset ? -200 : yForLegendTile)
              .attr('x2', $$.isLegendRight || $$.isLegendInset ? x2ForLegendTile : -200)
              .attr('y2', $$.isLegendRight || $$.isLegendInset ? -200 : yForLegendTile)
              .attr('stroke-width', config.legend_item_tile_height);
          // Set background for inset legend
          background = $$.legend.select('.' + CLASS.legendBackground + ' rect');
          if ($$.isLegendInset && maxWidth > 0 && background.size() === 0) {
              background = $$.legend
                  .insert('g', '.' + CLASS.legendItem)
                  .attr('class', CLASS.legendBackground)
                  .append('rect');
          }
          texts = $$.legend
              .selectAll('text')
              .data(targetIds)
              .text(function (id) {
              return isDefined(config.data_names[id]) ? config.data_names[id] : id;
          }) // MEMO: needed for update
              .each(function (id, i) {
              updatePositions(this, id, i);
          });
          (withTransition ? texts.transition() : texts)
              .attr('x', xForLegendText)
              .attr('y', yForLegendText);
          rects = $$.legend.selectAll('rect.' + CLASS.legendItemEvent).data(targetIds);
          (withTransition ? rects.transition() : rects)
              .attr('width', function (id) {
              return widths[id];
          })
              .attr('height', function (id) {
              return heights[id];
          })
              .attr('x', xForLegendRect)
              .attr('y', yForLegendRect);
          tiles = $$.legend.selectAll('line.' + CLASS.legendItemTile).data(targetIds);
          (withTransition ? tiles.transition() : tiles)
              .style('stroke', $$.levelColor
              ? function (id) {
                  return $$.levelColor($$.cache[id].values.reduce(function (total, item) {
                      return total + item.value;
                  }, 0));
              }
              : $$.color)
              .attr('x1', x1ForLegendTile)
              .attr('y1', yForLegendTile)
              .attr('x2', x2ForLegendTile)
              .attr('y2', yForLegendTile);
          if (background) {
              (withTransition ? background.transition() : background)
                  .attr('height', $$.getLegendHeight() - 12)
                  .attr('width', maxWidth * (step + 1) + 10);
          }
          // toggle legend state
          $$.legend
              .selectAll('.' + CLASS.legendItem)
              .classed(CLASS.legendItemHidden, function (id) {
              return !$$.isTargetToShow(id);
          });
          // Update all to reflect change of legend
          $$.updateLegendItemWidth(maxWidth);
          $$.updateLegendItemHeight(maxHeight);
          $$.updateLegendStep(step);
          // Update size and scale
          $$.updateSizes();
          $$.updateScales();
          $$.updateSvgSize();
          // Update g positions
          $$.transformAll(withTransitionForTransform, transitions);
          $$.legendHasRendered = true;
      };

      ChartInternal.prototype.initRegion = function () {
          var $$ = this;
          $$.region = $$.main
              .append('g')
              .attr('clip-path', $$.clipPath)
              .attr('class', CLASS.regions);
      };
      ChartInternal.prototype.updateRegion = function (duration) {
          var $$ = this, config = $$.config;
          // hide if arc type
          $$.region.style('visibility', $$.hasArcType() ? 'hidden' : 'visible');
          var mainRegion = $$.main
              .select('.' + CLASS.regions)
              .selectAll('.' + CLASS.region)
              .data(config.regions);
          var g = mainRegion.enter().append('g');
          g.append('rect')
              .attr('x', $$.regionX.bind($$))
              .attr('y', $$.regionY.bind($$))
              .attr('width', $$.regionWidth.bind($$))
              .attr('height', $$.regionHeight.bind($$))
              .style('fill-opacity', function (d) {
              return isValue(d.opacity) ? d.opacity : 0.1;
          });
          g.append('text').text($$.labelRegion.bind($$));
          $$.mainRegion = g.merge(mainRegion).attr('class', $$.classRegion.bind($$));
          mainRegion
              .exit()
              .transition()
              .duration(duration)
              .style('opacity', 0)
              .remove();
      };
      ChartInternal.prototype.redrawRegion = function (withTransition, transition) {
          var $$ = this, regions = $$.mainRegion, regionLabels = $$.mainRegion.selectAll('text');
          return [
              (withTransition ? regions.transition(transition) : regions)
                  .attr('x', $$.regionX.bind($$))
                  .attr('y', $$.regionY.bind($$))
                  .attr('width', $$.regionWidth.bind($$))
                  .attr('height', $$.regionHeight.bind($$))
                  .style('fill-opacity', function (d) {
                  return isValue(d.opacity) ? d.opacity : 0.1;
              }),
              (withTransition ? regionLabels.transition(transition) : regionLabels)
                  .attr('x', $$.labelOffsetX.bind($$))
                  .attr('y', $$.labelOffsetY.bind($$))
                  .attr('transform', $$.labelTransform.bind($$))
                  .attr('style', 'text-anchor: left;')
          ];
      };
      ChartInternal.prototype.regionX = function (d) {
          var $$ = this, config = $$.config, xPos, yScale = d.axis === 'y' ? $$.y : $$.y2;
          if (d.axis === 'y' || d.axis === 'y2') {
              xPos = config.axis_rotated ? ('start' in d ? yScale(d.start) : 0) : 0;
          }
          else {
              xPos = config.axis_rotated
                  ? 0
                  : 'start' in d
                      ? $$.x($$.isTimeSeries() ? $$.parseDate(d.start) : d.start)
                      : 0;
          }
          return xPos;
      };
      ChartInternal.prototype.regionY = function (d) {
          var $$ = this, config = $$.config, yPos, yScale = d.axis === 'y' ? $$.y : $$.y2;
          if (d.axis === 'y' || d.axis === 'y2') {
              yPos = config.axis_rotated ? 0 : 'end' in d ? yScale(d.end) : 0;
          }
          else {
              yPos = config.axis_rotated
                  ? 'start' in d
                      ? $$.x($$.isTimeSeries() ? $$.parseDate(d.start) : d.start)
                      : 0
                  : 0;
          }
          return yPos;
      };
      ChartInternal.prototype.regionWidth = function (d) {
          var $$ = this, config = $$.config, start = $$.regionX(d), end, yScale = d.axis === 'y' ? $$.y : $$.y2;
          if (d.axis === 'y' || d.axis === 'y2') {
              end = config.axis_rotated
                  ? 'end' in d
                      ? yScale(d.end)
                      : $$.width
                  : $$.width;
          }
          else {
              end = config.axis_rotated
                  ? $$.width
                  : 'end' in d
                      ? $$.x($$.isTimeSeries() ? $$.parseDate(d.end) : d.end)
                      : $$.width;
          }
          return end < start ? 0 : end - start;
      };
      ChartInternal.prototype.regionHeight = function (d) {
          var $$ = this, config = $$.config, start = this.regionY(d), end, yScale = d.axis === 'y' ? $$.y : $$.y2;
          if (d.axis === 'y' || d.axis === 'y2') {
              end = config.axis_rotated
                  ? $$.height
                  : 'start' in d
                      ? yScale(d.start)
                      : $$.height;
          }
          else {
              end = config.axis_rotated
                  ? 'end' in d
                      ? $$.x($$.isTimeSeries() ? $$.parseDate(d.end) : d.end)
                      : $$.height
                  : $$.height;
          }
          return end < start ? 0 : end - start;
      };
      ChartInternal.prototype.isRegionOnX = function (d) {
          return !d.axis || d.axis === 'x';
      };
      ChartInternal.prototype.labelRegion = function (d) {
          return 'label' in d ? d.label : '';
      };
      ChartInternal.prototype.labelTransform = function (d) {
          return 'vertical' in d && d.vertical ? 'rotate(90)' : '';
      };
      ChartInternal.prototype.labelOffsetX = function (d) {
          var paddingX = 'paddingX' in d ? d.paddingX : 3;
          var paddingY = 'paddingY' in d ? d.paddingY : 3;
          return 'vertical' in d && d.vertical
              ? this.regionY(d) + paddingY
              : this.regionX(d) + paddingX;
      };
      ChartInternal.prototype.labelOffsetY = function (d) {
          var paddingX = 'paddingX' in d ? d.paddingX : 3;
          var paddingY = 'paddingY' in d ? d.paddingY : 3;
          return 'vertical' in d && d.vertical
              ? -(this.regionX(d) + paddingX)
              : this.regionY(d) + 10 + paddingY;
      };

      function c3LogScale(d3, linearScale, logScale) {
          var PROJECTION = [0.01, 10];
          if (!linearScale) {
              linearScale = d3.scaleLinear();
              linearScale.range(PROJECTION);
          }
          if (!logScale) {
              logScale = d3.scaleLog();
              logScale.domain(PROJECTION);
              logScale.nice();
          }
          // copied from https://github.com/compute-io/logspace
          function logspace(a, b, len) {
              var arr, end, tmp, d;
              if (arguments.length < 3) {
                  len = 10;
              }
              else {
                  if (len === 0) {
                      return [];
                  }
              }
              // Calculate the increment:
              end = len - 1;
              d = (b - a) / end;
              // Build the output array...
              arr = new Array(len);
              tmp = a;
              arr[0] = Math.pow(10, tmp);
              for (var i = 1; i < end; i++) {
                  tmp += d;
                  arr[i] = Math.pow(10, tmp);
              }
              arr[end] = Math.pow(10, b);
              return arr;
          }
          function scale(x) {
              return logScale(linearScale(x));
          }
          scale.domain = function (x) {
              if (!arguments.length) {
                  return linearScale.domain();
              }
              linearScale.domain(x);
              return scale;
          };
          scale.range = function (x) {
              if (!arguments.length) {
                  return logScale.range();
              }
              logScale.range(x);
              return scale;
          };
          scale.ticks = function (m) {
              return logspace(-2, 1, m || 10).map(function (v) {
                  return linearScale.invert(v);
              });
          };
          scale.copy = function () {
              return c3LogScale(d3, linearScale.copy(), logScale.copy());
          };
          return scale;
      }
      ChartInternal.prototype.getScale = function (min, max, forTimeseries) {
          return (forTimeseries ? this.d3.scaleTime() : this.d3.scaleLinear()).range([
              min,
              max
          ]);
      };
      ChartInternal.prototype.getX = function (min, max, domain, offset) {
          var $$ = this, scale = $$.getScale(min, max, $$.isTimeSeries()), _scale = domain ? scale.domain(domain) : scale, key;
          // Define customized scale if categorized axis
          if ($$.isCategorized()) {
              offset =
                  offset ||
                      function () {
                          return 0;
                      };
              scale = function (d, raw) {
                  var v = _scale(d) + offset(d);
                  return raw ? v : Math.ceil(v);
              };
          }
          else {
              scale = function (d, raw) {
                  var v = _scale(d);
                  return raw ? v : Math.ceil(v);
              };
          }
          // define functions
          for (key in _scale) {
              scale[key] = _scale[key];
          }
          scale.orgDomain = function () {
              return _scale.domain();
          };
          // define custom domain() for categorized axis
          if ($$.isCategorized()) {
              scale.domain = function (domain) {
                  if (!arguments.length) {
                      domain = this.orgDomain();
                      return [domain[0], domain[1] + 1];
                  }
                  _scale.domain(domain);
                  return scale;
              };
          }
          return scale;
      };
      /**
       * Creates and configures a D3 scale instance for the given type.
       *
       * By defaults it returns a Linear scale.
       *
       * @param {String} type Type of d3-scale to create. Type can be 'linear', 'time', 'timeseries' or 'log'.
       * @param {Array} domain The scale domain such as [from, to]
       * @param {Array} range The scale's range such as [from, to]
       *
       * @return A d3-scale instance
       */
      ChartInternal.prototype.getY = function (type, domain, range) {
          var scale;
          if (type === 'timeseries' || type === 'time') {
              scale = this.d3.scaleTime();
          }
          else if (type === 'log') {
              scale = c3LogScale(this.d3);
          }
          else if (type === 'linear' || type === undefined) {
              scale = this.d3.scaleLinear();
          }
          else {
              throw new Error("Invalid Y axis type: \"" + type + "\"");
          }
          if (domain) {
              scale.domain(domain);
          }
          if (range) {
              scale.range(range);
          }
          return scale;
      };
      ChartInternal.prototype.getYScale = function (id) {
          return this.axis.getId(id) === 'y2' ? this.y2 : this.y;
      };
      ChartInternal.prototype.getSubYScale = function (id) {
          return this.axis.getId(id) === 'y2' ? this.subY2 : this.subY;
      };
      ChartInternal.prototype.updateScales = function () {
          var $$ = this, config = $$.config, forInit = !$$.x;
          // update edges
          $$.xMin = config.axis_rotated ? 1 : 0;
          $$.xMax = config.axis_rotated ? $$.height : $$.width;
          $$.yMin = config.axis_rotated ? 0 : $$.height;
          $$.yMax = config.axis_rotated ? $$.width : 1;
          $$.subXMin = $$.xMin;
          $$.subXMax = $$.xMax;
          $$.subYMin = config.axis_rotated ? 0 : $$.height2;
          $$.subYMax = config.axis_rotated ? $$.width2 : 1;
          // update scales
          $$.x = $$.getX($$.xMin, $$.xMax, forInit ? undefined : $$.x.orgDomain(), function () {
              return $$.xAxis.tickOffset();
          });
          $$.y = $$.getY(config.axis_y_type, forInit ? config.axis_y_default : $$.y.domain(), [$$.yMin, $$.yMax]);
          $$.y2 = $$.getY(config.axis_y2_type, forInit ? config.axis_y2_default : $$.y2.domain(), [$$.yMin, $$.yMax]);
          $$.subX = $$.getX($$.xMin, $$.xMax, $$.orgXDomain, function (d) {
              return d % 1 ? 0 : $$.subXAxis.tickOffset();
          });
          $$.subY = $$.getY(config.axis_y_type, forInit ? config.axis_y_default : $$.subY.domain(), [$$.subYMin, $$.subYMax]);
          $$.subY2 = $$.getY(config.axis_y2_type, forInit ? config.axis_y2_default : $$.subY2.domain(), [$$.subYMin, $$.subYMax]);
          // update axes
          $$.xAxisTickFormat = $$.axis.getXAxisTickFormat();
          $$.xAxisTickValues = $$.axis.getXAxisTickValues();
          $$.yAxisTickValues = $$.axis.getYAxisTickValues();
          $$.y2AxisTickValues = $$.axis.getY2AxisTickValues();
          $$.xAxis = $$.axis.getXAxis($$.x, $$.xOrient, $$.xAxisTickFormat, $$.xAxisTickValues, config.axis_x_tick_outer);
          $$.subXAxis = $$.axis.getXAxis($$.subX, $$.subXOrient, $$.xAxisTickFormat, $$.xAxisTickValues, config.axis_x_tick_outer);
          $$.yAxis = $$.axis.getYAxis('y', $$.y, $$.yOrient, $$.yAxisTickValues, config.axis_y_tick_outer);
          $$.y2Axis = $$.axis.getYAxis('y2', $$.y2, $$.y2Orient, $$.y2AxisTickValues, config.axis_y2_tick_outer);
          // Set initialized scales to brush and zoom
          if (!forInit) {
              if ($$.brush) {
                  $$.brush.updateScale($$.subX);
              }
          }
          // update for arc
          if ($$.updateArc) {
              $$.updateArc();
          }
      };

      ChartInternal.prototype.selectPoint = function (target, d, i) {
          var $$ = this, config = $$.config, cx = (config.axis_rotated ? $$.circleY : $$.circleX).bind($$), cy = (config.axis_rotated ? $$.circleX : $$.circleY).bind($$), r = $$.pointSelectR.bind($$);
          config.data_onselected.call($$.api, d, target.node());
          // add selected-circle on low layer g
          $$.main
              .select('.' + CLASS.selectedCircles + $$.getTargetSelectorSuffix(d.id))
              .selectAll('.' + CLASS.selectedCircle + '-' + i)
              .data([d])
              .enter()
              .append('circle')
              .attr('class', function () {
              return $$.generateClass(CLASS.selectedCircle, i);
          })
              .attr('cx', cx)
              .attr('cy', cy)
              .attr('stroke', function () {
              return $$.color(d);
          })
              .attr('r', function (d) {
              return $$.pointSelectR(d) * 1.4;
          })
              .transition()
              .duration(100)
              .attr('r', r);
      };
      ChartInternal.prototype.unselectPoint = function (target, d, i) {
          var $$ = this;
          $$.config.data_onunselected.call($$.api, d, target.node());
          // remove selected-circle from low layer g
          $$.main
              .select('.' + CLASS.selectedCircles + $$.getTargetSelectorSuffix(d.id))
              .selectAll('.' + CLASS.selectedCircle + '-' + i)
              .transition()
              .duration(100)
              .attr('r', 0)
              .remove();
      };
      ChartInternal.prototype.togglePoint = function (selected, target, d, i) {
          selected ? this.selectPoint(target, d, i) : this.unselectPoint(target, d, i);
      };
      ChartInternal.prototype.selectPath = function (target, d) {
          var $$ = this;
          $$.config.data_onselected.call($$, d, target.node());
          if ($$.config.interaction_brighten) {
              target
                  .transition()
                  .duration(100)
                  .style('fill', function () {
                  return $$.d3.rgb($$.color(d)).brighter(0.75);
              });
          }
      };
      ChartInternal.prototype.unselectPath = function (target, d) {
          var $$ = this;
          $$.config.data_onunselected.call($$, d, target.node());
          if ($$.config.interaction_brighten) {
              target
                  .transition()
                  .duration(100)
                  .style('fill', function () {
                  return $$.color(d);
              });
          }
      };
      ChartInternal.prototype.togglePath = function (selected, target, d, i) {
          selected ? this.selectPath(target, d, i) : this.unselectPath(target, d, i);
      };
      ChartInternal.prototype.getToggle = function (that, d) {
          var $$ = this, toggle;
          if (that.nodeName === 'circle') {
              if ($$.isStepType(d)) {
                  // circle is hidden in step chart, so treat as within the click area
                  toggle = function () { }; // TODO: how to select step chart?
              }
              else {
                  toggle = $$.togglePoint;
              }
          }
          else if (that.nodeName === 'path') {
              toggle = $$.togglePath;
          }
          return toggle;
      };
      ChartInternal.prototype.toggleShape = function (that, d, i) {
          var $$ = this, d3 = $$.d3, config = $$.config, shape = d3.select(that), isSelected = shape.classed(CLASS.SELECTED), toggle = $$.getToggle(that, d).bind($$);
          if (config.data_selection_enabled && config.data_selection_isselectable(d)) {
              if (!config.data_selection_multiple) {
                  $$.main
                      .selectAll('.' +
                      CLASS.shapes +
                      (config.data_selection_grouped
                          ? $$.getTargetSelectorSuffix(d.id)
                          : ''))
                      .selectAll('.' + CLASS.shape)
                      .each(function (d, i) {
                      var shape = d3.select(this);
                      if (shape.classed(CLASS.SELECTED)) {
                          toggle(false, shape.classed(CLASS.SELECTED, false), d, i);
                      }
                  });
              }
              shape.classed(CLASS.SELECTED, !isSelected);
              toggle(!isSelected, shape, d, i);
          }
      };

      ChartInternal.prototype.initBar = function () {
          var $$ = this;
          $$.main
              .select('.' + CLASS.chart)
              .append('g')
              .attr('class', CLASS.chartBars);
      };
      ChartInternal.prototype.updateTargetsForBar = function (targets) {
          var $$ = this, config = $$.config, mainBars, mainBarEnter, classChartBar = $$.classChartBar.bind($$), classBars = $$.classBars.bind($$), classFocus = $$.classFocus.bind($$);
          mainBars = $$.main
              .select('.' + CLASS.chartBars)
              .selectAll('.' + CLASS.chartBar)
              .data(targets)
              .attr('class', function (d) {
              return classChartBar(d) + classFocus(d);
          });
          mainBarEnter = mainBars
              .enter()
              .append('g')
              .attr('class', classChartBar)
              .style('pointer-events', 'none');
          // Bars for each data
          mainBarEnter
              .append('g')
              .attr('class', classBars)
              .style('cursor', function (d) {
              return config.data_selection_isselectable(d) ? 'pointer' : null;
          });
      };
      ChartInternal.prototype.updateBar = function (durationForExit) {
          var $$ = this, barData = $$.barData.bind($$), classBar = $$.classBar.bind($$), initialOpacity = $$.initialOpacity.bind($$), color = function (d) {
              return $$.color(d.id);
          };
          var mainBar = $$.main
              .selectAll('.' + CLASS.bars)
              .selectAll('.' + CLASS.bar)
              .data(barData);
          var mainBarEnter = mainBar
              .enter()
              .append('path')
              .attr('class', classBar)
              .style('stroke', color)
              .style('fill', color);
          $$.mainBar = mainBarEnter.merge(mainBar).style('opacity', initialOpacity);
          mainBar
              .exit()
              .transition()
              .duration(durationForExit)
              .style('opacity', 0);
      };
      ChartInternal.prototype.redrawBar = function (drawBar, withTransition, transition) {
          var $$ = this;
          return [
              (withTransition ? this.mainBar.transition(transition) : this.mainBar)
                  .attr('d', drawBar)
                  .style('stroke', this.color)
                  .style('fill', this.color)
                  .style('opacity', function (d) { return ($$.isTargetToShow(d.id) ? 1 : 0); })
          ];
      };
      ChartInternal.prototype.getBarW = function (axis, barTargetsNum) {
          var $$ = this, config = $$.config, w = typeof config.bar_width === 'number'
              ? config.bar_width
              : barTargetsNum
                  ? (axis.tickInterval() * config.bar_width_ratio) / barTargetsNum
                  : 0;
          return config.bar_width_max && w > config.bar_width_max
              ? config.bar_width_max
              : w;
      };
      ChartInternal.prototype.getBars = function (i, id) {
          var $$ = this;
          return (id
              ? $$.main.selectAll('.' + CLASS.bars + $$.getTargetSelectorSuffix(id))
              : $$.main).selectAll('.' + CLASS.bar + (isValue(i) ? '-' + i : ''));
      };
      ChartInternal.prototype.expandBars = function (i, id, reset) {
          var $$ = this;
          if (reset) {
              $$.unexpandBars();
          }
          $$.getBars(i, id).classed(CLASS.EXPANDED, true);
      };
      ChartInternal.prototype.unexpandBars = function (i) {
          var $$ = this;
          $$.getBars(i).classed(CLASS.EXPANDED, false);
      };
      ChartInternal.prototype.generateDrawBar = function (barIndices, isSub) {
          var $$ = this, config = $$.config, getPoints = $$.generateGetBarPoints(barIndices, isSub);
          return function (d, i) {
              // 4 points that make a bar
              var points = getPoints(d, i);
              // switch points if axis is rotated, not applicable for sub chart
              var indexX = config.axis_rotated ? 1 : 0;
              var indexY = config.axis_rotated ? 0 : 1;
              var path = 'M ' +
                  points[0][indexX] +
                  ',' +
                  points[0][indexY] +
                  ' ' +
                  'L' +
                  points[1][indexX] +
                  ',' +
                  points[1][indexY] +
                  ' ' +
                  'L' +
                  points[2][indexX] +
                  ',' +
                  points[2][indexY] +
                  ' ' +
                  'L' +
                  points[3][indexX] +
                  ',' +
                  points[3][indexY] +
                  ' ' +
                  'z';
              return path;
          };
      };
      ChartInternal.prototype.generateGetBarPoints = function (barIndices, isSub) {
          var $$ = this, axis = isSub ? $$.subXAxis : $$.xAxis, barTargetsNum = barIndices.__max__ + 1, barW = $$.getBarW(axis, barTargetsNum), barX = $$.getShapeX(barW, barTargetsNum, barIndices, !!isSub), barY = $$.getShapeY(!!isSub), barOffset = $$.getShapeOffset($$.isBarType, barIndices, !!isSub), barSpaceOffset = barW * ($$.config.bar_space / 2), yScale = isSub ? $$.getSubYScale : $$.getYScale;
          return function (d, i) {
              var y0 = yScale.call($$, d.id)(0), offset = barOffset(d, i) || y0, // offset is for stacked bar chart
              posX = barX(d), posY = barY(d);
              // fix posY not to overflow opposite quadrant
              if ($$.config.axis_rotated) {
                  if ((0 < d.value && posY < y0) || (d.value < 0 && y0 < posY)) {
                      posY = y0;
                  }
              }
              posY -= y0 - offset;
              // 4 points that make a bar
              return [
                  [posX + barSpaceOffset, offset],
                  [posX + barSpaceOffset, posY],
                  [posX + barW - barSpaceOffset, posY],
                  [posX + barW - barSpaceOffset, offset]
              ];
          };
      };
      /**
       * Returns whether the data point is within the given bar shape.
       *
       * @param mouse
       * @param barShape
       * @return {boolean}
       */
      ChartInternal.prototype.isWithinBar = function (mouse, barShape) {
          return isWithinBox(mouse, getBBox(barShape), 2);
      };

      ChartInternal.prototype.getShapeIndices = function (typeFilter) {
          var $$ = this, config = $$.config, indices = {}, i = 0, j, k;
          $$.filterTargetsToShow($$.data.targets.filter(typeFilter, $$)).forEach(function (d) {
              for (j = 0; j < config.data_groups.length; j++) {
                  if (config.data_groups[j].indexOf(d.id) < 0) {
                      continue;
                  }
                  for (k = 0; k < config.data_groups[j].length; k++) {
                      if (config.data_groups[j][k] in indices) {
                          indices[d.id] = indices[config.data_groups[j][k]];
                          break;
                      }
                  }
              }
              if (isUndefined(indices[d.id])) {
                  indices[d.id] = i++;
              }
          });
          indices.__max__ = i - 1;
          return indices;
      };
      ChartInternal.prototype.getShapeX = function (offset, targetsNum, indices, isSub) {
          var $$ = this, scale = isSub ? $$.subX : $$.x;
          return function (d) {
              var index = d.id in indices ? indices[d.id] : 0;
              return d.x || d.x === 0 ? scale(d.x) - offset * (targetsNum / 2 - index) : 0;
          };
      };
      ChartInternal.prototype.getShapeY = function (isSub) {
          var $$ = this;
          return function (d) {
              var scale = isSub ? $$.getSubYScale(d.id) : $$.getYScale(d.id);
              return scale($$.isTargetNormalized(d.id) ? $$.getRatio('index', d, true) : d.value);
          };
      };
      ChartInternal.prototype.getShapeOffset = function (typeFilter, indices, isSub) {
          var $$ = this, targets = $$.orderTargets($$.filterTargetsToShow($$.data.targets.filter(typeFilter, $$))), targetIds = targets.map(function (t) {
              return t.id;
          });
          return function (d, i) {
              var scale = isSub ? $$.getSubYScale(d.id) : $$.getYScale(d.id), y0 = scale(0), offset = y0;
              targets.forEach(function (t) {
                  var rowValues = $$.isStepType(d)
                      ? $$.convertValuesToStep(t.values)
                      : t.values;
                  var isTargetNormalized = $$.isTargetNormalized(d.id);
                  var values = rowValues.map(function (v) {
                      return isTargetNormalized ? $$.getRatio('index', v, true) : v.value;
                  });
                  if (t.id === d.id || indices[t.id] !== indices[d.id]) {
                      return;
                  }
                  if (targetIds.indexOf(t.id) < targetIds.indexOf(d.id)) {
                      // check if the x values line up
                      if (isUndefined(rowValues[i]) || +rowValues[i].x !== +d.x) {
                          // "+" for timeseries
                          // if not, try to find the value that does line up
                          i = -1;
                          rowValues.forEach(function (v, j) {
                              var x1 = v.x.constructor === Date ? +v.x : v.x;
                              var x2 = d.x.constructor === Date ? +d.x : d.x;
                              if (x1 === x2) {
                                  i = j;
                              }
                          });
                      }
                      if (i in rowValues && rowValues[i].value * d.value >= 0) {
                          offset += scale(values[i]) - y0;
                      }
                  }
              });
              return offset;
          };
      };
      ChartInternal.prototype.isWithinShape = function (that, d) {
          var $$ = this, shape = $$.d3.select(that), isWithin;
          if (!$$.isTargetToShow(d.id)) {
              isWithin = false;
          }
          else if (that.nodeName === 'circle') {
              isWithin = $$.isStepType(d)
                  ? $$.isWithinStep(that, $$.getYScale(d.id)(d.value))
                  : $$.isWithinCircle(that, $$.pointSelectR(d) * 1.5);
          }
          else if (that.nodeName === 'path') {
              isWithin = shape.classed(CLASS.bar)
                  ? $$.isWithinBar($$.d3.mouse(that), that)
                  : true;
          }
          return isWithin;
      };
      ChartInternal.prototype.getInterpolate = function (d) {
          var $$ = this, d3 = $$.d3, types = {
              linear: d3.curveLinear,
              'linear-closed': d3.curveLinearClosed,
              basis: d3.curveBasis,
              'basis-open': d3.curveBasisOpen,
              'basis-closed': d3.curveBasisClosed,
              bundle: d3.curveBundle,
              cardinal: d3.curveCardinal,
              'cardinal-open': d3.curveCardinalOpen,
              'cardinal-closed': d3.curveCardinalClosed,
              monotone: d3.curveMonotoneX,
              step: d3.curveStep,
              'step-before': d3.curveStepBefore,
              'step-after': d3.curveStepAfter
          }, type;
          if ($$.isSplineType(d)) {
              type = types[$$.config.spline_interpolation_type] || types.cardinal;
          }
          else if ($$.isStepType(d)) {
              type = types[$$.config.line_step_type];
          }
          else {
              type = types.linear;
          }
          return type;
      };

      ChartInternal.prototype.initLine = function () {
          var $$ = this;
          $$.main
              .select('.' + CLASS.chart)
              .append('g')
              .attr('class', CLASS.chartLines);
      };
      ChartInternal.prototype.updateTargetsForLine = function (targets) {
          var $$ = this, config = $$.config, mainLines, mainLineEnter, classChartLine = $$.classChartLine.bind($$), classLines = $$.classLines.bind($$), classAreas = $$.classAreas.bind($$), classCircles = $$.classCircles.bind($$), classFocus = $$.classFocus.bind($$);
          mainLines = $$.main
              .select('.' + CLASS.chartLines)
              .selectAll('.' + CLASS.chartLine)
              .data(targets)
              .attr('class', function (d) {
              return classChartLine(d) + classFocus(d);
          });
          mainLineEnter = mainLines
              .enter()
              .append('g')
              .attr('class', classChartLine)
              .style('opacity', 0)
              .style('pointer-events', 'none');
          // Lines for each data
          mainLineEnter.append('g').attr('class', classLines);
          // Areas
          mainLineEnter.append('g').attr('class', classAreas);
          // Circles for each data point on lines
          mainLineEnter.append('g').attr('class', function (d) {
              return $$.generateClass(CLASS.selectedCircles, d.id);
          });
          mainLineEnter
              .append('g')
              .attr('class', classCircles)
              .style('cursor', function (d) {
              return config.data_selection_isselectable(d) ? 'pointer' : null;
          });
          // Update date for selected circles
          targets.forEach(function (t) {
              $$.main
                  .selectAll('.' + CLASS.selectedCircles + $$.getTargetSelectorSuffix(t.id))
                  .selectAll('.' + CLASS.selectedCircle)
                  .each(function (d) {
                  d.value = t.values[d.index].value;
              });
          });
          // MEMO: can not keep same color...
          //mainLineUpdate.exit().remove();
      };
      ChartInternal.prototype.updateLine = function (durationForExit) {
          var $$ = this;
          var mainLine = $$.main
              .selectAll('.' + CLASS.lines)
              .selectAll('.' + CLASS.line)
              .data($$.lineData.bind($$));
          var mainLineEnter = mainLine
              .enter()
              .append('path')
              .attr('class', $$.classLine.bind($$))
              .style('stroke', $$.color);
          $$.mainLine = mainLineEnter
              .merge(mainLine)
              .style('opacity', $$.initialOpacity.bind($$))
              .style('shape-rendering', function (d) {
              return $$.isStepType(d) ? 'crispEdges' : '';
          })
              .attr('transform', null);
          mainLine
              .exit()
              .transition()
              .duration(durationForExit)
              .style('opacity', 0);
      };
      ChartInternal.prototype.redrawLine = function (drawLine, withTransition, transition) {
          return [
              (withTransition ? this.mainLine.transition(transition) : this.mainLine)
                  .attr('d', drawLine)
                  .style('stroke', this.color)
                  .style('opacity', 1)
          ];
      };
      ChartInternal.prototype.generateDrawLine = function (lineIndices, isSub) {
          var $$ = this, config = $$.config, line = $$.d3.line(), getPoints = $$.generateGetLinePoints(lineIndices, isSub), yScaleGetter = isSub ? $$.getSubYScale : $$.getYScale, xValue = function (d) {
              return (isSub ? $$.subxx : $$.xx).call($$, d);
          }, yValue = function (d, i) {
              return config.data_groups.length > 0
                  ? getPoints(d, i)[0][1]
                  : yScaleGetter.call($$, d.id)(d.value);
          };
          line = config.axis_rotated
              ? line.x(yValue).y(xValue)
              : line.x(xValue).y(yValue);
          if (!config.line_connectNull) {
              line = line.defined(function (d) {
                  return d.value != null;
              });
          }
          return function (d) {
              var values = config.line_connectNull
                  ? $$.filterRemoveNull(d.values)
                  : d.values, x = isSub ? $$.subX : $$.x, y = yScaleGetter.call($$, d.id), x0 = 0, y0 = 0, path;
              if ($$.isLineType(d)) {
                  if (config.data_regions[d.id]) {
                      path = $$.lineWithRegions(values, x, y, config.data_regions[d.id]);
                  }
                  else {
                      if ($$.isStepType(d)) {
                          values = $$.convertValuesToStep(values);
                      }
                      path = line.curve($$.getInterpolate(d))(values);
                  }
              }
              else {
                  if (values[0]) {
                      x0 = x(values[0].x);
                      y0 = y(values[0].value);
                  }
                  path = config.axis_rotated ? 'M ' + y0 + ' ' + x0 : 'M ' + x0 + ' ' + y0;
              }
              return path ? path : 'M 0 0';
          };
      };
      ChartInternal.prototype.generateGetLinePoints = function (lineIndices, isSub) {
          // partial duplication of generateGetBarPoints
          var $$ = this, config = $$.config, lineTargetsNum = lineIndices.__max__ + 1, x = $$.getShapeX(0, lineTargetsNum, lineIndices, !!isSub), y = $$.getShapeY(!!isSub), lineOffset = $$.getShapeOffset($$.isLineType, lineIndices, !!isSub), yScale = isSub ? $$.getSubYScale : $$.getYScale;
          return function (d, i) {
              var y0 = yScale.call($$, d.id)(0), offset = lineOffset(d, i) || y0, // offset is for stacked area chart
              posX = x(d), posY = y(d);
              // fix posY not to overflow opposite quadrant
              if (config.axis_rotated) {
                  if ((0 < d.value && posY < y0) || (d.value < 0 && y0 < posY)) {
                      posY = y0;
                  }
              }
              // 1 point that marks the line position
              return [
                  [posX, posY - (y0 - offset)],
                  [posX, posY - (y0 - offset)],
                  [posX, posY - (y0 - offset)],
                  [posX, posY - (y0 - offset)] // needed for compatibility
              ];
          };
      };
      ChartInternal.prototype.lineWithRegions = function (d, x, y, _regions) {
          var $$ = this, config = $$.config, i, j, s = 'M', sWithRegion, xp, yp, dx, dy, dd, diff, diffx2, xOffset = $$.isCategorized() ? 0.5 : 0, xValue, yValue, regions = [];
          function isWithinRegions(x, regions) {
              var i;
              for (i = 0; i < regions.length; i++) {
                  if (regions[i].start < x && x <= regions[i].end) {
                      return true;
                  }
              }
              return false;
          }
          // Check start/end of regions
          if (isDefined(_regions)) {
              for (i = 0; i < _regions.length; i++) {
                  regions[i] = {};
                  if (isUndefined(_regions[i].start)) {
                      regions[i].start = d[0].x;
                  }
                  else {
                      regions[i].start = $$.isTimeSeries()
                          ? $$.parseDate(_regions[i].start)
                          : _regions[i].start;
                  }
                  if (isUndefined(_regions[i].end)) {
                      regions[i].end = d[d.length - 1].x;
                  }
                  else {
                      regions[i].end = $$.isTimeSeries()
                          ? $$.parseDate(_regions[i].end)
                          : _regions[i].end;
                  }
              }
          }
          // Set scales
          xValue = config.axis_rotated
              ? function (d) {
                  return y(d.value);
              }
              : function (d) {
                  return x(d.x);
              };
          yValue = config.axis_rotated
              ? function (d) {
                  return x(d.x);
              }
              : function (d) {
                  return y(d.value);
              };
          // Define svg generator function for region
          function generateM(points) {
              return ('M' +
                  points[0][0] +
                  ' ' +
                  points[0][1] +
                  ' ' +
                  points[1][0] +
                  ' ' +
                  points[1][1]);
          }
          if ($$.isTimeSeries()) {
              sWithRegion = function (d0, d1, j, diff) {
                  var x0 = d0.x.getTime(), x_diff = d1.x - d0.x, xv0 = new Date(x0 + x_diff * j), xv1 = new Date(x0 + x_diff * (j + diff)), points;
                  if (config.axis_rotated) {
                      points = [
                          [y(yp(j)), x(xv0)],
                          [y(yp(j + diff)), x(xv1)]
                      ];
                  }
                  else {
                      points = [
                          [x(xv0), y(yp(j))],
                          [x(xv1), y(yp(j + diff))]
                      ];
                  }
                  return generateM(points);
              };
          }
          else {
              sWithRegion = function (d0, d1, j, diff) {
                  var points;
                  if (config.axis_rotated) {
                      points = [
                          [y(yp(j), true), x(xp(j))],
                          [y(yp(j + diff), true), x(xp(j + diff))]
                      ];
                  }
                  else {
                      points = [
                          [x(xp(j), true), y(yp(j))],
                          [x(xp(j + diff), true), y(yp(j + diff))]
                      ];
                  }
                  return generateM(points);
              };
          }
          // Generate
          for (i = 0; i < d.length; i++) {
              // Draw as normal
              if (isUndefined(regions) || !isWithinRegions(d[i].x, regions)) {
                  s += ' ' + xValue(d[i]) + ' ' + yValue(d[i]);
              }
              // Draw with region // TODO: Fix for horizotal charts
              else {
                  xp = $$.getScale(d[i - 1].x + xOffset, d[i].x + xOffset, $$.isTimeSeries());
                  yp = $$.getScale(d[i - 1].value, d[i].value);
                  dx = x(d[i].x) - x(d[i - 1].x);
                  dy = y(d[i].value) - y(d[i - 1].value);
                  dd = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
                  diff = 2 / dd;
                  diffx2 = diff * 2;
                  for (j = diff; j <= 1; j += diffx2) {
                      s += sWithRegion(d[i - 1], d[i], j, diff);
                  }
              }
              d[i].x;
          }
          return s;
      };
      ChartInternal.prototype.updateArea = function (durationForExit) {
          var $$ = this, d3 = $$.d3;
          var mainArea = $$.main
              .selectAll('.' + CLASS.areas)
              .selectAll('.' + CLASS.area)
              .data($$.lineData.bind($$));
          var mainAreaEnter = mainArea
              .enter()
              .append('path')
              .attr('class', $$.classArea.bind($$))
              .style('fill', $$.color)
              .style('opacity', function () {
              $$.orgAreaOpacity = +d3.select(this).style('opacity');
              return 0;
          });
          $$.mainArea = mainAreaEnter
              .merge(mainArea)
              .style('opacity', $$.orgAreaOpacity);
          mainArea
              .exit()
              .transition()
              .duration(durationForExit)
              .style('opacity', 0);
      };
      ChartInternal.prototype.redrawArea = function (drawArea, withTransition, transition) {
          return [
              (withTransition ? this.mainArea.transition(transition) : this.mainArea)
                  .attr('d', drawArea)
                  .style('fill', this.color)
                  .style('opacity', this.orgAreaOpacity)
          ];
      };
      ChartInternal.prototype.generateDrawArea = function (areaIndices, isSub) {
          var $$ = this, config = $$.config, area = $$.d3.area(), getPoints = $$.generateGetAreaPoints(areaIndices, isSub), yScaleGetter = isSub ? $$.getSubYScale : $$.getYScale, xValue = function (d) {
              return (isSub ? $$.subxx : $$.xx).call($$, d);
          }, value0 = function (d, i) {
              return config.data_groups.length > 0
                  ? getPoints(d, i)[0][1]
                  : yScaleGetter.call($$, d.id)($$.getAreaBaseValue(d.id));
          }, value1 = function (d, i) {
              return config.data_groups.length > 0
                  ? getPoints(d, i)[1][1]
                  : yScaleGetter.call($$, d.id)(d.value);
          };
          area = config.axis_rotated
              ? area
                  .x0(value0)
                  .x1(value1)
                  .y(xValue)
              : area
                  .x(xValue)
                  .y0(config.area_above ? 0 : value0)
                  .y1(value1);
          if (!config.line_connectNull) {
              area = area.defined(function (d) {
                  return d.value !== null;
              });
          }
          return function (d) {
              var values = config.line_connectNull
                  ? $$.filterRemoveNull(d.values)
                  : d.values, x0 = 0, y0 = 0, path;
              if ($$.isAreaType(d)) {
                  if ($$.isStepType(d)) {
                      values = $$.convertValuesToStep(values);
                  }
                  path = area.curve($$.getInterpolate(d))(values);
              }
              else {
                  if (values[0]) {
                      x0 = $$.x(values[0].x);
                      y0 = $$.getYScale(d.id)(values[0].value);
                  }
                  path = config.axis_rotated ? 'M ' + y0 + ' ' + x0 : 'M ' + x0 + ' ' + y0;
              }
              return path ? path : 'M 0 0';
          };
      };
      ChartInternal.prototype.getAreaBaseValue = function () {
          return 0;
      };
      ChartInternal.prototype.generateGetAreaPoints = function (areaIndices, isSub) {
          // partial duplication of generateGetBarPoints
          var $$ = this, config = $$.config, areaTargetsNum = areaIndices.__max__ + 1, x = $$.getShapeX(0, areaTargetsNum, areaIndices, !!isSub), y = $$.getShapeY(!!isSub), areaOffset = $$.getShapeOffset($$.isAreaType, areaIndices, !!isSub), yScale = isSub ? $$.getSubYScale : $$.getYScale;
          return function (d, i) {
              var y0 = yScale.call($$, d.id)(0), offset = areaOffset(d, i) || y0, // offset is for stacked area chart
              posX = x(d), posY = y(d);
              // fix posY not to overflow opposite quadrant
              if (config.axis_rotated) {
                  if ((0 < d.value && posY < y0) || (d.value < 0 && y0 < posY)) {
                      posY = y0;
                  }
              }
              // 1 point that marks the area position
              return [
                  [posX, offset],
                  [posX, posY - (y0 - offset)],
                  [posX, posY - (y0 - offset)],
                  [posX, offset] // needed for compatibility
              ];
          };
      };
      ChartInternal.prototype.updateCircle = function (cx, cy) {
          var $$ = this;
          var mainCircle = $$.main
              .selectAll('.' + CLASS.circles)
              .selectAll('.' + CLASS.circle)
              .data($$.lineOrScatterOrStanfordData.bind($$));
          var mainCircleEnter = mainCircle
              .enter()
              .append('circle')
              .attr('shape-rendering', $$.isStanfordGraphType() ? 'crispEdges' : '')
              .attr('class', $$.classCircle.bind($$))
              .attr('cx', cx)
              .attr('cy', cy)
              .attr('r', $$.pointR.bind($$))
              .style('color', $$.isStanfordGraphType() ? $$.getStanfordPointColor.bind($$) : $$.color);
          $$.mainCircle = mainCircleEnter
              .merge(mainCircle)
              .style('opacity', $$.isStanfordGraphType() ? 1 : $$.initialOpacityForCircle.bind($$));
          mainCircle.exit().style('opacity', 0);
      };
      ChartInternal.prototype.redrawCircle = function (cx, cy, withTransition, transition) {
          var $$ = this, selectedCircles = $$.main.selectAll('.' + CLASS.selectedCircle);
          return [
              (withTransition ? $$.mainCircle.transition(transition) : $$.mainCircle)
                  .style('opacity', this.opacityForCircle.bind($$))
                  .style('color', $$.isStanfordGraphType() ? $$.getStanfordPointColor.bind($$) : $$.color)
                  .attr('cx', cx)
                  .attr('cy', cy),
              (withTransition ? selectedCircles.transition(transition) : selectedCircles)
                  .attr('cx', cx)
                  .attr('cy', cy)
          ];
      };
      ChartInternal.prototype.circleX = function (d) {
          return d.x || d.x === 0 ? this.x(d.x) : null;
      };
      ChartInternal.prototype.updateCircleY = function () {
          var $$ = this, lineIndices, getPoints;
          if ($$.config.data_groups.length > 0) {
              (lineIndices = $$.getShapeIndices($$.isLineType)),
                  (getPoints = $$.generateGetLinePoints(lineIndices));
              $$.circleY = function (d, i) {
                  return getPoints(d, i)[0][1];
              };
          }
          else {
              $$.circleY = function (d) {
                  return $$.getYScale(d.id)(d.value);
              };
          }
      };
      ChartInternal.prototype.getCircles = function (i, id) {
          var $$ = this;
          return (id
              ? $$.main.selectAll('.' + CLASS.circles + $$.getTargetSelectorSuffix(id))
              : $$.main).selectAll('.' + CLASS.circle + (isValue(i) ? '-' + i : ''));
      };
      ChartInternal.prototype.expandCircles = function (i, id, reset) {
          var $$ = this, r = $$.pointExpandedR.bind($$);
          if (reset) {
              $$.unexpandCircles();
          }
          $$.getCircles(i, id)
              .classed(CLASS.EXPANDED, true)
              .attr('r', r);
      };
      ChartInternal.prototype.unexpandCircles = function (i) {
          var $$ = this, r = $$.pointR.bind($$);
          $$.getCircles(i)
              .filter(function () {
              return $$.d3.select(this).classed(CLASS.EXPANDED);
          })
              .classed(CLASS.EXPANDED, false)
              .attr('r', r);
      };
      ChartInternal.prototype.pointR = function (d) {
          var $$ = this, config = $$.config;
          return $$.isStepType(d)
              ? 0
              : isFunction(config.point_r)
                  ? config.point_r(d)
                  : config.point_r;
      };
      ChartInternal.prototype.pointExpandedR = function (d) {
          var $$ = this, config = $$.config;
          if (config.point_focus_expand_enabled) {
              return isFunction(config.point_focus_expand_r)
                  ? config.point_focus_expand_r(d)
                  : config.point_focus_expand_r
                      ? config.point_focus_expand_r
                      : $$.pointR(d) * 1.75;
          }
          else {
              return $$.pointR(d);
          }
      };
      ChartInternal.prototype.pointSelectR = function (d) {
          var $$ = this, config = $$.config;
          return isFunction(config.point_select_r)
              ? config.point_select_r(d)
              : config.point_select_r
                  ? config.point_select_r
                  : $$.pointR(d) * 4;
      };
      ChartInternal.prototype.isWithinCircle = function (that, r) {
          var d3 = this.d3, mouse = d3.mouse(that), d3_this = d3.select(that), cx = +d3_this.attr('cx'), cy = +d3_this.attr('cy');
          return Math.sqrt(Math.pow(cx - mouse[0], 2) + Math.pow(cy - mouse[1], 2)) < r;
      };
      ChartInternal.prototype.isWithinStep = function (that, y) {
          return Math.abs(y - this.d3.mouse(that)[1]) < 30;
      };

      ChartInternal.prototype.getCurrentWidth = function () {
          var $$ = this, config = $$.config;
          return config.size_width ? config.size_width : $$.getParentWidth();
      };
      ChartInternal.prototype.getCurrentHeight = function () {
          var $$ = this, config = $$.config, h = config.size_height ? config.size_height : $$.getParentHeight();
          return h > 0
              ? h
              : 320 / ($$.hasType('gauge') && !config.gauge_fullCircle ? 2 : 1);
      };
      ChartInternal.prototype.getCurrentPaddingTop = function () {
          var $$ = this, config = $$.config, padding = isValue(config.padding_top) ? config.padding_top : 0;
          if ($$.title && $$.title.node()) {
              padding += $$.getTitlePadding();
          }
          return padding;
      };
      ChartInternal.prototype.getCurrentPaddingBottom = function () {
          var config = this.config;
          return isValue(config.padding_bottom) ? config.padding_bottom : 0;
      };
      ChartInternal.prototype.getCurrentPaddingLeft = function (withoutRecompute) {
          var $$ = this, config = $$.config;
          if (isValue(config.padding_left)) {
              return config.padding_left;
          }
          else if (config.axis_rotated) {
              return !config.axis_x_show || config.axis_x_inner
                  ? 1
                  : Math.max(ceil10($$.getAxisWidthByAxisId('x', withoutRecompute)), 40);
          }
          else if (!config.axis_y_show || config.axis_y_inner) {
              // && !config.axis_rotated
              return $$.axis.getYAxisLabelPosition().isOuter ? 30 : 1;
          }
          else {
              return ceil10($$.getAxisWidthByAxisId('y', withoutRecompute));
          }
      };
      ChartInternal.prototype.getCurrentPaddingRight = function () {
          var $$ = this, config = $$.config, padding = 0, defaultPadding = 10, legendWidthOnRight = $$.isLegendRight ? $$.getLegendWidth() + 20 : 0;
          if (isValue(config.padding_right)) {
              padding = config.padding_right + 1; // 1 is needed not to hide tick line
          }
          else if (config.axis_rotated) {
              padding = defaultPadding + legendWidthOnRight;
          }
          else if (!config.axis_y2_show || config.axis_y2_inner) {
              // && !config.axis_rotated
              padding =
                  2 +
                      legendWidthOnRight +
                      ($$.axis.getY2AxisLabelPosition().isOuter ? 20 : 0);
          }
          else {
              padding = ceil10($$.getAxisWidthByAxisId('y2')) + legendWidthOnRight;
          }
          if ($$.colorScale && $$.colorScale.node()) {
              padding += $$.getColorScalePadding();
          }
          return padding;
      };
      ChartInternal.prototype.getParentRectValue = function (key) {
          var parent = this.selectChart.node(), v;
          while (parent && parent.tagName !== 'BODY') {
              try {
                  v = parent.getBoundingClientRect()[key];
              }
              catch (e) {
                  if (key === 'width') {
                      // In IE in certain cases getBoundingClientRect
                      // will cause an "unspecified error"
                      v = parent.offsetWidth;
                  }
              }
              if (v) {
                  break;
              }
              parent = parent.parentNode;
          }
          return v;
      };
      ChartInternal.prototype.getParentWidth = function () {
          return this.getParentRectValue('width');
      };
      ChartInternal.prototype.getParentHeight = function () {
          var h = this.selectChart.style('height');
          return h.indexOf('px') > 0 ? +h.replace('px', '') : 0;
      };
      ChartInternal.prototype.getSvgLeft = function (withoutRecompute) {
          var $$ = this, config = $$.config, hasLeftAxisRect = config.axis_rotated || (!config.axis_rotated && !config.axis_y_inner), leftAxisClass = config.axis_rotated ? CLASS.axisX : CLASS.axisY, leftAxis = $$.main.select('.' + leftAxisClass).node(), svgRect = leftAxis && hasLeftAxisRect
              ? leftAxis.getBoundingClientRect()
              : { right: 0 }, chartRect = $$.selectChart.node().getBoundingClientRect(), hasArc = $$.hasArcType(), svgLeft = svgRect.right -
              chartRect.left -
              (hasArc ? 0 : $$.getCurrentPaddingLeft(withoutRecompute));
          return svgLeft > 0 ? svgLeft : 0;
      };
      ChartInternal.prototype.getAxisWidthByAxisId = function (id, withoutRecompute) {
          var $$ = this, position = $$.axis.getLabelPositionById(id);
          return ($$.axis.getMaxTickWidth(id, withoutRecompute) + (position.isInner ? 20 : 40));
      };
      ChartInternal.prototype.getHorizontalAxisHeight = function (axisId, isSubchart) {
          var $$ = this, config = $$.config, h = 30;
          if (axisId === 'x' && !(isDefined(isSubchart) && isSubchart ? config.subchart_axis_x_show : config.axis_x_show)) {
              return 8;
          }
          if (axisId === 'x' && config.axis_x_height) {
              return config.axis_x_height;
          }
          if (axisId === 'y' && !config.axis_y_show) {
              return config.legend_show && !$$.isLegendRight && !$$.isLegendInset ? 10 : 1;
          }
          if (axisId === 'y2' && !config.axis_y2_show) {
              return $$.rotated_padding_top;
          }
          // Calculate x axis height when tick rotated
          if (axisId === 'x' && !config.axis_rotated && config.axis_x_tick_rotate) {
              h =
                  30 +
                      $$.axis.getMaxTickWidth(axisId) *
                          Math.cos((Math.PI * (90 - Math.abs(config.axis_x_tick_rotate))) / 180);
          }
          // Calculate y axis height when tick rotated
          if (axisId === 'y' && config.axis_rotated && config.axis_y_tick_rotate) {
              h =
                  30 +
                      $$.axis.getMaxTickWidth(axisId) *
                          Math.cos((Math.PI * (90 - Math.abs(config.axis_y_tick_rotate))) / 180);
          }
          return (h +
              ($$.axis.getLabelPositionById(axisId).isInner ? 0 : 10) +
              (axisId === 'y2' ? -10 : 0));
      };

      ChartInternal.prototype.initBrush = function (scale) {
          var $$ = this, d3 = $$.d3;
          // TODO: dynamically change brushY/brushX according to axis_rotated.
          $$.brush = ($$.config.axis_rotated ? d3.brushY() : d3.brushX())
              .on('brush', function () {
              var event = d3.event.sourceEvent;
              if (event && event.type === 'zoom') {
                  return;
              }
              $$.redrawForBrush();
          })
              .on('end', function () {
              var event = d3.event.sourceEvent;
              if (event && event.type === 'zoom') {
                  return;
              }
              if ($$.brush.empty() && event && event.type !== 'end') {
                  $$.brush.clear();
              }
          });
          $$.brush.updateExtent = function () {
              var range = this.scale.range(), extent;
              if ($$.config.axis_rotated) {
                  extent = [
                      [0, range[0]],
                      [$$.width2, range[1]]
                  ];
              }
              else {
                  extent = [
                      [range[0], 0],
                      [range[1], $$.height2]
                  ];
              }
              this.extent(extent);
              return this;
          };
          $$.brush.updateScale = function (scale) {
              this.scale = scale;
              return this;
          };
          $$.brush.update = function (scale) {
              this.updateScale(scale || $$.subX).updateExtent();
              $$.context.select('.' + CLASS.brush).call(this);
          };
          $$.brush.clear = function () {
              $$.context.select('.' + CLASS.brush).call($$.brush.move, null);
          };
          $$.brush.selection = function () {
              return d3.brushSelection($$.context.select('.' + CLASS.brush).node());
          };
          $$.brush.selectionAsValue = function (selectionAsValue, withTransition) {
              var selection, brush;
              if (selectionAsValue) {
                  if ($$.context) {
                      selection = [
                          this.scale(selectionAsValue[0]),
                          this.scale(selectionAsValue[1])
                      ];
                      brush = $$.context.select('.' + CLASS.brush);
                      if (withTransition) {
                          brush = brush.transition();
                      }
                      $$.brush.move(brush, selection);
                  }
                  return [];
              }
              selection = $$.brush.selection() || [0, 0];
              return [this.scale.invert(selection[0]), this.scale.invert(selection[1])];
          };
          $$.brush.empty = function () {
              var selection = $$.brush.selection();
              return !selection || selection[0] === selection[1];
          };
          return $$.brush.updateScale(scale);
      };
      ChartInternal.prototype.initSubchart = function () {
          var $$ = this, config = $$.config, context = ($$.context = $$.svg
              .append('g')
              .attr('transform', $$.getTranslate('context')));
          // set style
          context.style('visibility', 'visible');
          // Define g for chart area
          context
              .append('g')
              .attr('clip-path', $$.clipPathForSubchart)
              .attr('class', CLASS.chart);
          // Define g for bar chart area
          context
              .select('.' + CLASS.chart)
              .append('g')
              .attr('class', CLASS.chartBars);
          // Define g for line chart area
          context
              .select('.' + CLASS.chart)
              .append('g')
              .attr('class', CLASS.chartLines);
          // Add extent rect for Brush
          context
              .append('g')
              .attr('clip-path', $$.clipPath)
              .attr('class', CLASS.brush);
          // ATTENTION: This must be called AFTER chart added
          // Add Axis
          $$.axes.subx = context
              .append('g')
              .attr('class', CLASS.axisX)
              .attr('transform', $$.getTranslate('subx'))
              .attr('clip-path', config.axis_rotated ? '' : $$.clipPathForXAxis)
              .style('visibility', config.subchart_axis_x_show ? 'visible' : 'hidden');
      };
      ChartInternal.prototype.initSubchartBrush = function () {
          var $$ = this;
          // Add extent rect for Brush
          $$.initBrush($$.subX).updateExtent();
          $$.context.select('.' + CLASS.brush).call($$.brush);
      };
      ChartInternal.prototype.updateTargetsForSubchart = function (targets) {
          var $$ = this, context = $$.context, config = $$.config, contextLineEnter, contextLine, contextBarEnter, contextBar, classChartBar = $$.classChartBar.bind($$), classBars = $$.classBars.bind($$), classChartLine = $$.classChartLine.bind($$), classLines = $$.classLines.bind($$), classAreas = $$.classAreas.bind($$);
          //-- Bar --//
          contextBar = context
              .select('.' + CLASS.chartBars)
              .selectAll('.' + CLASS.chartBar)
              .data(targets);
          contextBarEnter = contextBar
              .enter()
              .append('g')
              .style('opacity', 0);
          contextBarEnter.merge(contextBar).attr('class', classChartBar);
          // Bars for each data
          contextBarEnter.append('g').attr('class', classBars);
          //-- Line --//
          contextLine = context
              .select('.' + CLASS.chartLines)
              .selectAll('.' + CLASS.chartLine)
              .data(targets);
          contextLineEnter = contextLine
              .enter()
              .append('g')
              .style('opacity', 0);
          contextLineEnter.merge(contextLine).attr('class', classChartLine);
          // Lines for each data
          contextLineEnter.append('g').attr('class', classLines);
          // Area
          contextLineEnter.append('g').attr('class', classAreas);
          //-- Brush --//
          context
              .selectAll('.' + CLASS.brush + ' rect')
              .attr(config.axis_rotated ? 'width' : 'height', config.axis_rotated ? $$.width2 : $$.height2);
      };
      ChartInternal.prototype.updateBarForSubchart = function (durationForExit) {
          var $$ = this;
          var contextBar = $$.context
              .selectAll('.' + CLASS.bars)
              .selectAll('.' + CLASS.bar)
              .data($$.barData.bind($$));
          var contextBarEnter = contextBar
              .enter()
              .append('path')
              .attr('class', $$.classBar.bind($$))
              .style('stroke', 'none')
              .style('fill', $$.color);
          contextBar
              .exit()
              .transition()
              .duration(durationForExit)
              .style('opacity', 0)
              .remove();
          $$.contextBar = contextBarEnter
              .merge(contextBar)
              .style('opacity', $$.initialOpacity.bind($$));
      };
      ChartInternal.prototype.redrawBarForSubchart = function (drawBarOnSub, withTransition, duration) {
          (withTransition
              ? this.contextBar.transition(Math.random().toString()).duration(duration)
              : this.contextBar)
              .attr('d', drawBarOnSub)
              .style('opacity', 1);
      };
      ChartInternal.prototype.updateLineForSubchart = function (durationForExit) {
          var $$ = this;
          var contextLine = $$.context
              .selectAll('.' + CLASS.lines)
              .selectAll('.' + CLASS.line)
              .data($$.lineData.bind($$));
          var contextLineEnter = contextLine
              .enter()
              .append('path')
              .attr('class', $$.classLine.bind($$))
              .style('stroke', $$.color);
          contextLine
              .exit()
              .transition()
              .duration(durationForExit)
              .style('opacity', 0)
              .remove();
          $$.contextLine = contextLineEnter
              .merge(contextLine)
              .style('opacity', $$.initialOpacity.bind($$));
      };
      ChartInternal.prototype.redrawLineForSubchart = function (drawLineOnSub, withTransition, duration) {
          (withTransition
              ? this.contextLine.transition(Math.random().toString()).duration(duration)
              : this.contextLine)
              .attr('d', drawLineOnSub)
              .style('opacity', 1);
      };
      ChartInternal.prototype.updateAreaForSubchart = function (durationForExit) {
          var $$ = this, d3 = $$.d3;
          var contextArea = $$.context
              .selectAll('.' + CLASS.areas)
              .selectAll('.' + CLASS.area)
              .data($$.lineData.bind($$));
          var contextAreaEnter = contextArea
              .enter()
              .append('path')
              .attr('class', $$.classArea.bind($$))
              .style('fill', $$.color)
              .style('opacity', function () {
              $$.orgAreaOpacity = +d3.select(this).style('opacity');
              return 0;
          });
          contextArea
              .exit()
              .transition()
              .duration(durationForExit)
              .style('opacity', 0)
              .remove();
          $$.contextArea = contextAreaEnter.merge(contextArea).style('opacity', 0);
      };
      ChartInternal.prototype.redrawAreaForSubchart = function (drawAreaOnSub, withTransition, duration) {
          (withTransition
              ? this.contextArea.transition(Math.random().toString()).duration(duration)
              : this.contextArea)
              .attr('d', drawAreaOnSub)
              .style('fill', this.color)
              .style('opacity', this.orgAreaOpacity);
      };
      ChartInternal.prototype.redrawSubchart = function (withSubchart, transitions, duration, durationForExit, areaIndices, barIndices, lineIndices) {
          var $$ = this, d3 = $$.d3, drawAreaOnSub, drawBarOnSub, drawLineOnSub;
          // reflect main chart to extent on subchart if zoomed
          if (d3.event && d3.event.type === 'zoom') {
              $$.brush.selectionAsValue($$.x.orgDomain());
          }
          // update subchart elements if needed
          if (withSubchart) {
              // extent rect
              if (!$$.brush.empty()) {
                  $$.brush.selectionAsValue($$.x.orgDomain());
              }
              // setup drawer - MEMO: this must be called after axis updated
              drawAreaOnSub = $$.generateDrawArea(areaIndices, true);
              drawBarOnSub = $$.generateDrawBar(barIndices, true);
              drawLineOnSub = $$.generateDrawLine(lineIndices, true);
              $$.updateBarForSubchart(duration);
              $$.updateLineForSubchart(duration);
              $$.updateAreaForSubchart(duration);
              $$.redrawBarForSubchart(drawBarOnSub, duration, duration);
              $$.redrawLineForSubchart(drawLineOnSub, duration, duration);
              $$.redrawAreaForSubchart(drawAreaOnSub, duration, duration);
          }
      };
      ChartInternal.prototype.redrawForBrush = function () {
          var $$ = this, x = $$.x, d3 = $$.d3, s;
          $$.redraw({
              withTransition: false,
              withY: $$.config.zoom_rescale,
              withSubchart: false,
              withUpdateXDomain: true,
              withEventRect: false,
              withDimension: false
          });
          // update zoom transation binded to event rect
          s = d3.event.selection || $$.brush.scale.range();
          $$.main
              .select('.' + CLASS.eventRect)
              .call($$.zoom.transform, d3.zoomIdentity.scale($$.width / (s[1] - s[0])).translate(-s[0], 0));
          $$.config.subchart_onbrush.call($$.api, x.orgDomain());
      };
      ChartInternal.prototype.transformContext = function (withTransition, transitions) {
          var $$ = this, subXAxis;
          if (transitions && transitions.axisSubX) {
              subXAxis = transitions.axisSubX;
          }
          else {
              subXAxis = $$.context.select('.' + CLASS.axisX);
              if (withTransition) {
                  subXAxis = subXAxis.transition();
              }
          }
          $$.context.attr('transform', $$.getTranslate('context'));
          subXAxis.attr('transform', $$.getTranslate('subx'));
      };
      ChartInternal.prototype.getDefaultSelection = function () {
          var $$ = this, config = $$.config, selection = isFunction(config.axis_x_selection)
              ? config.axis_x_selection($$.getXDomain($$.data.targets))
              : config.axis_x_selection;
          if ($$.isTimeSeries()) {
              selection = [$$.parseDate(selection[0]), $$.parseDate(selection[1])];
          }
          return selection;
      };
      ChartInternal.prototype.removeSubchart = function () {
          var $$ = this;
          $$.brush = null;
          $$.context.remove();
          $$.context = null;
      };

      ChartInternal.prototype.initText = function () {
          var $$ = this;
          $$.main
              .select('.' + CLASS.chart)
              .append('g')
              .attr('class', CLASS.chartTexts);
          $$.mainText = $$.d3.selectAll([]);
      };
      ChartInternal.prototype.updateTargetsForText = function (targets) {
          var $$ = this, classChartText = $$.classChartText.bind($$), classTexts = $$.classTexts.bind($$), classFocus = $$.classFocus.bind($$);
          var mainText = $$.main
              .select('.' + CLASS.chartTexts)
              .selectAll('.' + CLASS.chartText)
              .data(targets);
          var mainTextEnter = mainText
              .enter()
              .append('g')
              .attr('class', classChartText)
              .style('opacity', 0)
              .style('pointer-events', 'none');
          mainTextEnter.append('g').attr('class', classTexts);
          mainTextEnter.merge(mainText).attr('class', function (d) {
              return classChartText(d) + classFocus(d);
          });
      };
      ChartInternal.prototype.updateText = function (xForText, yForText, durationForExit) {
          var $$ = this, config = $$.config, barOrLineData = $$.barOrLineData.bind($$), classText = $$.classText.bind($$);
          var mainText = $$.main
              .selectAll('.' + CLASS.texts)
              .selectAll('.' + CLASS.text)
              .data(barOrLineData);
          var mainTextEnter = mainText
              .enter()
              .append('text')
              .attr('class', classText)
              .attr('text-anchor', function (d) {
              return config.axis_rotated ? (d.value < 0 ? 'end' : 'start') : 'middle';
          })
              .style('stroke', 'none')
              .attr('x', xForText)
              .attr('y', yForText)
              .style('fill', function (d) {
              return $$.color(d);
          })
              .style('fill-opacity', 0);
          $$.mainText = mainTextEnter.merge(mainText).text(function (d, i, j) {
              return $$.dataLabelFormat(d.id)(d.value, d.id, i, j);
          });
          mainText
              .exit()
              .transition()
              .duration(durationForExit)
              .style('fill-opacity', 0)
              .remove();
      };
      ChartInternal.prototype.redrawText = function (xForText, yForText, forFlow, withTransition, transition) {
          return [
              (withTransition ? this.mainText.transition(transition) : this.mainText)
                  .attr('x', xForText)
                  .attr('y', yForText)
                  .style('fill', this.color)
                  .style('fill-opacity', forFlow ? 0 : this.opacityForText.bind(this))
          ];
      };
      ChartInternal.prototype.getTextRect = function (text, cls, element) {
          var dummy = this.d3
              .select('body')
              .append('div')
              .classed('c3', true), svg = dummy
              .append('svg')
              .style('visibility', 'hidden')
              .style('position', 'fixed')
              .style('top', 0)
              .style('left', 0), font = this.d3.select(element).style('font'), rect;
          svg
              .selectAll('.dummy')
              .data([text])
              .enter()
              .append('text')
              .classed(cls ? cls : '', true)
              .style('font', font)
              .text(text)
              .each(function () {
              rect = getBBox(this);
          });
          dummy.remove();
          return rect;
      };
      ChartInternal.prototype.generateXYForText = function (areaIndices, barIndices, lineIndices, forX) {
          var $$ = this, getAreaPoints = $$.generateGetAreaPoints(areaIndices, false), getBarPoints = $$.generateGetBarPoints(barIndices, false), getLinePoints = $$.generateGetLinePoints(lineIndices, false), getter = forX ? $$.getXForText : $$.getYForText;
          return function (d, i) {
              var getPoints = $$.isAreaType(d)
                  ? getAreaPoints
                  : $$.isBarType(d)
                      ? getBarPoints
                      : getLinePoints;
              return getter.call($$, getPoints(d, i), d, this);
          };
      };
      ChartInternal.prototype.getXForText = function (points, d, textElement) {
          var $$ = this, box = getBBox(textElement), xPos, padding;
          if ($$.config.axis_rotated) {
              padding = $$.isBarType(d) ? 4 : 6;
              xPos = points[2][1] + padding * (d.value < 0 ? -1 : 1);
          }
          else {
              xPos = $$.hasType('bar') ? (points[2][0] + points[0][0]) / 2 : points[0][0];
          }
          // show labels regardless of the domain if value is null
          if (d.value === null) {
              if (xPos > $$.width) {
                  xPos = $$.width - box.width;
              }
              else if (xPos < 0) {
                  xPos = 4;
              }
          }
          return xPos;
      };
      ChartInternal.prototype.getYForText = function (points, d, textElement) {
          var $$ = this, box = getBBox(textElement), yPos;
          if ($$.config.axis_rotated) {
              yPos = (points[0][0] + points[2][0] + box.height * 0.6) / 2;
          }
          else {
              yPos = points[2][1];
              if (d.value < 0 || (d.value === 0 && !$$.hasPositiveValue)) {
                  yPos += box.height;
                  if ($$.isBarType(d) && $$.isSafari()) {
                      yPos -= 3;
                  }
                  else if (!$$.isBarType(d) && $$.isChrome()) {
                      yPos += 3;
                  }
              }
              else {
                  yPos += $$.isBarType(d) ? -3 : -6;
              }
          }
          // show labels regardless of the domain if value is null
          if (d.value === null && !$$.config.axis_rotated) {
              if (yPos < box.height) {
                  yPos = box.height;
              }
              else if (yPos > this.height) {
                  yPos = this.height - 4;
              }
          }
          return yPos;
      };

      ChartInternal.prototype.initTitle = function () {
          var $$ = this;
          $$.title = $$.svg
              .append('text')
              .text($$.config.title_text)
              .attr('class', $$.CLASS.title);
      };
      ChartInternal.prototype.redrawTitle = function () {
          var $$ = this;
          $$.title.attr('x', $$.xForTitle.bind($$)).attr('y', $$.yForTitle.bind($$));
      };
      ChartInternal.prototype.xForTitle = function () {
          var $$ = this, config = $$.config, position = config.title_position || 'left', x;
          if (position.indexOf('right') >= 0) {
              x =
                  $$.currentWidth -
                      $$.getTextRect($$.title.node().textContent, $$.CLASS.title, $$.title.node()).width -
                      config.title_padding.right;
          }
          else if (position.indexOf('center') >= 0) {
              x = Math.max(($$.currentWidth -
                  $$.getTextRect($$.title.node().textContent, $$.CLASS.title, $$.title.node()).width) /
                  2, 0);
          }
          else {
              // left
              x = config.title_padding.left;
          }
          return x;
      };
      ChartInternal.prototype.yForTitle = function () {
          var $$ = this;
          return ($$.config.title_padding.top +
              $$.getTextRect($$.title.node().textContent, $$.CLASS.title, $$.title.node())
                  .height);
      };
      ChartInternal.prototype.getTitlePadding = function () {
          var $$ = this;
          return $$.yForTitle() + $$.config.title_padding.bottom;
      };

      function powerOfTen(d) {
          return d / Math.pow(10, Math.ceil(Math.log(d) / Math.LN10 - 1e-12)) === 1;
      }
      ChartInternal.prototype.drawColorScale = function () {
          var $$ = this, d3 = $$.d3, config = $$.config, target = $$.data.targets[0], barWidth, barHeight, axis, points, legendAxis, axisScale, inverseScale, height;
          barWidth = !isNaN(config.stanford_scaleWidth)
              ? config.stanford_scaleWidth
              : 20;
          barHeight = 5;
          if (barHeight < 0 || barWidth < 0) {
              throw Error("Colorscale's barheight and barwidth must be greater than 0.");
          }
          height =
              $$.height - config.stanford_padding.bottom - config.stanford_padding.top;
          points = d3.range(config.stanford_padding.bottom, height, barHeight);
          inverseScale = d3
              .scaleSequential(target.colors)
              .domain([points[points.length - 1], points[0]]);
          if ($$.colorScale) {
              $$.colorScale.remove();
          }
          $$.colorScale = $$.svg
              .append('g')
              .attr('width', 50)
              .attr('height', height)
              .attr('class', CLASS.colorScale);
          $$.colorScale
              .append('g')
              .attr('transform', "translate(0, " + config.stanford_padding.top + ")")
              .selectAll('bars')
              .data(points)
              .enter()
              .append('rect')
              .attr('y', function (d, i) { return i * barHeight; })
              .attr('x', 0)
              .attr('width', barWidth)
              .attr('height', barHeight)
              .attr('fill', function (d) {
              return inverseScale(d);
          });
          // Legend Axis
          axisScale = d3
              .scaleLog()
              .domain([target.minEpochs, target.maxEpochs])
              .range([
              points[0] +
                  config.stanford_padding.top +
                  points[points.length - 1] +
                  barHeight -
                  1,
              points[0] + config.stanford_padding.top
          ]);
          legendAxis = d3.axisRight(axisScale);
          if (config.stanford_scaleFormat === 'pow10') {
              legendAxis.tickValues([1, 10, 100, 1000, 10000, 100000, 1000000, 10000000]);
          }
          else if (isFunction(config.stanford_scaleFormat)) {
              legendAxis.tickFormat(config.stanford_scaleFormat);
          }
          else {
              legendAxis.tickFormat(d3.format('d'));
          }
          if (isFunction(config.stanford_scaleValues)) {
              legendAxis.tickValues(config.stanford_scaleValues(target.minEpochs, target.maxEpochs));
          }
          // Draw Axis
          axis = $$.colorScale
              .append('g')
              .attr('class', 'legend axis')
              .attr('transform', "translate(" + barWidth + ",0)")
              .call(legendAxis);
          if (config.stanford_scaleFormat === 'pow10') {
              axis
                  .selectAll('.tick text')
                  .text(null)
                  .filter(powerOfTen)
                  .text(10)
                  .append('tspan')
                  .attr('dy', '-.7em') // https://bl.ocks.org/mbostock/6738229
                  .text(function (d) {
                  return Math.round(Math.log(d) / Math.LN10);
              });
          }
          $$.colorScale.attr('transform', "translate(" + ($$.currentWidth - $$.xForColorScale()) + ", 0)");
      };
      ChartInternal.prototype.xForColorScale = function () {
          var $$ = this;
          return $$.config.stanford_padding.right + getBBox($$.colorScale.node()).width;
      };
      ChartInternal.prototype.getColorScalePadding = function () {
          var $$ = this;
          return $$.xForColorScale() + $$.config.stanford_padding.left + 20;
      };

      ChartInternal.prototype.isStanfordGraphType = function () {
          var $$ = this;
          return $$.config.data_type === 'stanford';
      };
      ChartInternal.prototype.initStanfordData = function () {
          var $$ = this, d3 = $$.d3, config = $$.config, target = $$.data.targets[0], epochs, maxEpochs, minEpochs;
          // Make larger values appear on top
          target.values.sort(compareEpochs);
          // Get array of epochs
          epochs = target.values.map(function (a) { return a.epochs; });
          minEpochs = !isNaN(config.stanford_scaleMin)
              ? config.stanford_scaleMin
              : d3.min(epochs);
          maxEpochs = !isNaN(config.stanford_scaleMax)
              ? config.stanford_scaleMax
              : d3.max(epochs);
          if (minEpochs > maxEpochs) {
              throw Error('Number of minEpochs has to be smaller than maxEpochs');
          }
          target.colors = isFunction(config.stanford_colors)
              ? config.stanford_colors
              : d3.interpolateHslLong(d3.hsl(250, 1, 0.5), d3.hsl(0, 1, 0.5));
          target.colorscale = d3
              .scaleSequentialLog(target.colors)
              .domain([minEpochs, maxEpochs]);
          target.minEpochs = minEpochs;
          target.maxEpochs = maxEpochs;
      };
      ChartInternal.prototype.getStanfordPointColor = function (d) {
          var $$ = this, target = $$.data.targets[0];
          return target.colorscale(d.epochs);
      };
      // http://jsfiddle.net/Xotic750/KtzLq/
      ChartInternal.prototype.getCentroid = function (points) {
          var area = getRegionArea(points);
          var x = 0, y = 0, i, j, f, point1, point2;
          for (i = 0, j = points.length - 1; i < points.length; j = i, i += 1) {
              point1 = points[i];
              point2 = points[j];
              f = point1.x * point2.y - point2.x * point1.y;
              x += (point1.x + point2.x) * f;
              y += (point1.y + point2.y) * f;
          }
          f = area * 6;
          return {
              x: x / f,
              y: y / f
          };
      };
      ChartInternal.prototype.getStanfordTooltipTitle = function (d) {
          var $$ = this, labelX = $$.axis.getLabelText('x'), labelY = $$.axis.getLabelText('y');
          return "\n      <tr><th>" + (labelX ? sanitise(labelX) : 'x') + "</th><th class='value'>" + d.x + "</th></tr>\n      <tr><th>" + (labelY ? sanitise(labelY) : 'y') + "</th><th class='value'>" + d.value + "</th></tr>\n    ";
      };
      ChartInternal.prototype.countEpochsInRegion = function (region) {
          var $$ = this, target = $$.data.targets[0], total, count;
          total = target.values.reduce(function (accumulator, currentValue) { return accumulator + Number(currentValue.epochs); }, 0);
          count = target.values.reduce(function (accumulator, currentValue) {
              if (pointInRegion(currentValue, region)) {
                  return accumulator + Number(currentValue.epochs);
              }
              return accumulator;
          }, 0);
          return {
              value: count,
              percentage: count !== 0 ? ((count / total) * 100).toFixed(1) : 0
          };
      };
      var getRegionArea = function (points) {
          // thanks to: https://stackoverflow.com/questions/16282330/find-centerpoint-of-polygon-in-javascript
          var area = 0, i, j, point1, point2;
          for (i = 0, j = points.length - 1; i < points.length; j = i, i += 1) {
              point1 = points[i];
              point2 = points[j];
              area += point1.x * point2.y;
              area -= point1.y * point2.x;
          }
          area /= 2;
          return area;
      };
      var pointInRegion = function (point, region) {
          // thanks to: http://bl.ocks.org/bycoffe/5575904
          // ray-casting algorithm based on
          // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
          var xi, yi, yj, xj, intersect, x = point.x, y = point.value, inside = false;
          for (var i = 0, j = region.length - 1; i < region.length; j = i++) {
              xi = region[i].x;
              yi = region[i].y;
              xj = region[j].x;
              yj = region[j].y;
              intersect = yi > y !== yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;
              if (intersect) {
                  inside = !inside;
              }
          }
          return inside;
      };
      var compareEpochs = function (a, b) {
          if (a.epochs < b.epochs) {
              return -1;
          }
          if (a.epochs > b.epochs) {
              return 1;
          }
          return 0;
      };

      ChartInternal.prototype.initStanfordElements = function () {
          var $$ = this;
          // Avoid blocking eventRect
          $$.stanfordElements = $$.main
              .select('.' + CLASS.chart)
              .append('g')
              .attr('class', CLASS.stanfordElements);
          $$.stanfordElements.append('g').attr('class', CLASS.stanfordLines);
          $$.stanfordElements.append('g').attr('class', CLASS.stanfordTexts);
          $$.stanfordElements.append('g').attr('class', CLASS.stanfordRegions);
      };
      ChartInternal.prototype.updateStanfordElements = function (duration) {
          var $$ = this, main = $$.main, config = $$.config, stanfordLine, stanfordLineEnter, stanfordRegion, stanfordRegionEnter, stanfordText, stanfordTextEnter, xvCustom = $$.xvCustom.bind($$), yvCustom = $$.yvCustom.bind($$), countPointsInRegion = $$.countEpochsInRegion.bind($$);
          // Stanford-Lines
          stanfordLine = main
              .select('.' + CLASS.stanfordLines)
              .style('shape-rendering', 'geometricprecision')
              .selectAll('.' + CLASS.stanfordLine)
              .data(config.stanford_lines);
          // enter
          stanfordLineEnter = stanfordLine
              .enter()
              .append('g')
              .attr('class', function (d) {
              return CLASS.stanfordLine + (d['class'] ? ' ' + d['class'] : '');
          });
          stanfordLineEnter
              .append('line')
              .attr('x1', function (d) {
              return config.axis_rotated ? yvCustom(d, 'value_y1') : xvCustom(d, 'value_x1');
          })
              .attr('x2', function (d) {
              return config.axis_rotated ? yvCustom(d, 'value_y2') : xvCustom(d, 'value_x2');
          })
              .attr('y1', function (d) {
              return config.axis_rotated ? xvCustom(d, 'value_x1') : yvCustom(d, 'value_y1');
          })
              .attr('y2', function (d) {
              return config.axis_rotated ? xvCustom(d, 'value_x2') : yvCustom(d, 'value_y2');
          })
              .style('opacity', 0);
          // update
          $$.stanfordLines = stanfordLineEnter.merge(stanfordLine);
          $$.stanfordLines
              .select('line')
              .transition()
              .duration(duration)
              .attr('x1', function (d) {
              return config.axis_rotated ? yvCustom(d, 'value_y1') : xvCustom(d, 'value_x1');
          })
              .attr('x2', function (d) {
              return config.axis_rotated ? yvCustom(d, 'value_y2') : xvCustom(d, 'value_x2');
          })
              .attr('y1', function (d) {
              return config.axis_rotated ? xvCustom(d, 'value_x1') : yvCustom(d, 'value_y1');
          })
              .attr('y2', function (d) {
              return config.axis_rotated ? xvCustom(d, 'value_x2') : yvCustom(d, 'value_y2');
          })
              .style('opacity', 1);
          // exit
          stanfordLine
              .exit()
              .transition()
              .duration(duration)
              .style('opacity', 0)
              .remove();
          // Stanford-Text
          stanfordText = main
              .select('.' + CLASS.stanfordTexts)
              .selectAll('.' + CLASS.stanfordText)
              .data(config.stanford_texts);
          // enter
          stanfordTextEnter = stanfordText
              .enter()
              .append('g')
              .attr('class', function (d) {
              return CLASS.stanfordText + (d['class'] ? ' ' + d['class'] : '');
          });
          stanfordTextEnter
              .append('text')
              .attr('x', function (d) { return (config.axis_rotated ? yvCustom(d, 'y') : xvCustom(d, 'x')); })
              .attr('y', function (d) { return (config.axis_rotated ? xvCustom(d, 'x') : yvCustom(d, 'y')); })
              .style('opacity', 0);
          // update
          $$.stanfordTexts = stanfordTextEnter.merge(stanfordText);
          $$.stanfordTexts
              .select('text')
              .transition()
              .duration(duration)
              .attr('x', function (d) { return (config.axis_rotated ? yvCustom(d, 'y') : xvCustom(d, 'x')); })
              .attr('y', function (d) { return (config.axis_rotated ? xvCustom(d, 'x') : yvCustom(d, 'y')); })
              .text(function (d) {
              return d.content;
          })
              .style('opacity', 1);
          // exit
          stanfordText
              .exit()
              .transition()
              .duration(duration)
              .style('opacity', 0)
              .remove();
          // Stanford-Regions
          stanfordRegion = main
              .select('.' + CLASS.stanfordRegions)
              .selectAll('.' + CLASS.stanfordRegion)
              .data(config.stanford_regions);
          // enter
          stanfordRegionEnter = stanfordRegion
              .enter()
              .append('g')
              .attr('class', function (d) {
              return CLASS.stanfordRegion + (d['class'] ? ' ' + d['class'] : '');
          });
          stanfordRegionEnter
              .append('polygon')
              .attr('points', function (d) {
              return d.points
                  .map(function (value) {
                  return [
                      config.axis_rotated ? yvCustom(value, 'y') : xvCustom(value, 'x'),
                      config.axis_rotated ? xvCustom(value, 'x') : yvCustom(value, 'y')
                  ].join(',');
              })
                  .join(' ');
          })
              .style('opacity', 0);
          stanfordRegionEnter
              .append('text')
              .attr('x', function (d) { return $$.getCentroid(d.points).x; })
              .attr('y', function (d) { return $$.getCentroid(d.points).y; })
              .style('opacity', 0);
          // update
          $$.stanfordRegions = stanfordRegionEnter.merge(stanfordRegion);
          $$.stanfordRegions
              .select('polygon')
              .transition()
              .duration(duration)
              .attr('points', function (d) {
              return d.points
                  .map(function (value) {
                  return [
                      config.axis_rotated ? yvCustom(value, 'y') : xvCustom(value, 'x'),
                      config.axis_rotated ? xvCustom(value, 'x') : yvCustom(value, 'y')
                  ].join(',');
              })
                  .join(' ');
          })
              .style('opacity', function (d) {
              return d.opacity ? d.opacity : 0.2;
          });
          $$.stanfordRegions
              .select('text')
              .transition()
              .duration(duration)
              .attr('x', function (d) {
              return config.axis_rotated
                  ? yvCustom($$.getCentroid(d.points), 'y')
                  : xvCustom($$.getCentroid(d.points), 'x');
          })
              .attr('y', function (d) {
              return config.axis_rotated
                  ? xvCustom($$.getCentroid(d.points), 'x')
                  : yvCustom($$.getCentroid(d.points), 'y');
          })
              .text(function (d) {
              if (d.text) {
                  var value, percentage, temp;
                  if ($$.isStanfordGraphType()) {
                      temp = countPointsInRegion(d.points);
                      value = temp.value;
                      percentage = temp.percentage;
                  }
                  return d.text(value, percentage);
              }
              return '';
          })
              .attr('text-anchor', 'middle')
              .attr('dominant-baseline', 'middle')
              .style('opacity', 1);
          // exit
          stanfordRegion
              .exit()
              .transition()
              .duration(duration)
              .style('opacity', 0)
              .remove();
      };

      ChartInternal.prototype.initTooltip = function () {
          var $$ = this, config = $$.config, i;
          $$.tooltip = $$.selectChart
              .style('position', 'relative')
              .append('div')
              .attr('class', CLASS.tooltipContainer)
              .style('position', 'absolute')
              .style('pointer-events', 'none')
              .style('display', 'none');
          // Show tooltip if needed
          if (config.tooltip_init_show) {
              if ($$.isTimeSeries() && isString(config.tooltip_init_x)) {
                  config.tooltip_init_x = $$.parseDate(config.tooltip_init_x);
                  for (i = 0; i < $$.data.targets[0].values.length; i++) {
                      if ($$.data.targets[0].values[i].x - config.tooltip_init_x === 0) {
                          break;
                      }
                  }
                  config.tooltip_init_x = i;
              }
              $$.tooltip.html(config.tooltip_contents.call($$, $$.data.targets.map(function (d) {
                  return $$.addName(d.values[config.tooltip_init_x]);
              }), $$.axis.getXAxisTickFormat(), $$.getYFormat($$.hasArcType()), $$.color));
              $$.tooltip
                  .style('top', config.tooltip_init_position.top)
                  .style('left', config.tooltip_init_position.left)
                  .style('display', 'block');
          }
      };
      ChartInternal.prototype.getTooltipSortFunction = function () {
          var $$ = this, config = $$.config;
          if (config.data_groups.length === 0 || config.tooltip_order !== undefined) {
              // if data are not grouped or if an order is specified
              // for the tooltip values we sort them by their values
              var order = config.tooltip_order;
              if (order === undefined) {
                  order = config.data_order;
              }
              var valueOf = function (obj) {
                  return obj ? obj.value : null;
              };
              // if data are not grouped, we sort them by their value
              if (isString(order) && order.toLowerCase() === 'asc') {
                  return function (a, b) {
                      return valueOf(a) - valueOf(b);
                  };
              }
              else if (isString(order) && order.toLowerCase() === 'desc') {
                  return function (a, b) {
                      return valueOf(b) - valueOf(a);
                  };
              }
              else if (isFunction(order)) {
                  // if the function is from data_order we need
                  // to wrap the returned function in order to format
                  // the sorted value to the expected format
                  var sortFunction = order;
                  if (config.tooltip_order === undefined) {
                      sortFunction = function (a, b) {
                          return order(a
                              ? {
                                  id: a.id,
                                  values: [a]
                              }
                              : null, b
                              ? {
                                  id: b.id,
                                  values: [b]
                              }
                              : null);
                      };
                  }
                  return sortFunction;
              }
              else if (isArray(order)) {
                  return function (a, b) {
                      return order.indexOf(a.id) - order.indexOf(b.id);
                  };
              }
          }
          else {
              // if data are grouped, we follow the order of grouped targets
              var ids = $$.orderTargets($$.data.targets).map(function (i) {
                  return i.id;
              });
              // if it was either asc or desc we need to invert the order
              // returned by orderTargets
              if ($$.isOrderAsc() || $$.isOrderDesc()) {
                  ids = ids.reverse();
              }
              return function (a, b) {
                  return ids.indexOf(a.id) - ids.indexOf(b.id);
              };
          }
      };
      ChartInternal.prototype.getTooltipContent = function (d, defaultTitleFormat, defaultValueFormat, color) {
          var $$ = this, config = $$.config, titleFormat = config.tooltip_format_title || defaultTitleFormat, nameFormat = config.tooltip_format_name ||
              function (name) {
                  return name;
              }, text, i, title, value, name, bgcolor;
          var valueFormat = config.tooltip_format_value;
          if (!valueFormat) {
              valueFormat = $$.isTargetNormalized(d.id)
                  ? function (v, ratio) { return (ratio * 100).toFixed(2) + "%"; }
                  : defaultValueFormat;
          }
          var tooltipSortFunction = this.getTooltipSortFunction();
          if (tooltipSortFunction) {
              d.sort(tooltipSortFunction);
          }
          for (i = 0; i < d.length; i++) {
              if (!(d[i] && (d[i].value || d[i].value === 0))) {
                  continue;
              }
              if ($$.isStanfordGraphType()) {
                  // Custom tooltip for stanford plots
                  if (!text) {
                      title = $$.getStanfordTooltipTitle(d[i]);
                      text = "<table class='" + $$.CLASS.tooltip + "'>" + title;
                  }
                  bgcolor = $$.getStanfordPointColor(d[i]);
                  name = sanitise(config.data_epochs); // Epochs key name
                  value = d[i].epochs;
              }
              else {
                  // Regular tooltip
                  if (!text) {
                      title = sanitise(titleFormat ? titleFormat(d[i].x, d[i].index) : d[i].x);
                      text =
                          "<table class='" +
                              $$.CLASS.tooltip +
                              "'>" +
                              (title || title === 0
                                  ? "<tr><th colspan='2'>" + title + '</th></tr>'
                                  : '');
                  }
                  value = sanitise(valueFormat(d[i].value, d[i].ratio, d[i].id, d[i].index, d));
                  if (value !== undefined) {
                      // Skip elements when their name is set to null
                      if (d[i].name === null) {
                          continue;
                      }
                      name = sanitise(nameFormat(d[i].name, d[i].ratio, d[i].id, d[i].index));
                      bgcolor = $$.levelColor ? $$.levelColor(d[i].value) : color(d[i].id);
                  }
              }
              if (value !== undefined) {
                  text +=
                      "<tr class='" +
                          $$.CLASS.tooltipName +
                          '-' +
                          $$.getTargetSelectorSuffix(d[i].id) +
                          "'>";
                  text +=
                      "<td class='name'><span style='background-color:" +
                          bgcolor +
                          "'></span>" +
                          name +
                          '</td>';
                  text += "<td class='value'>" + value + '</td>';
                  text += '</tr>';
              }
          }
          return text + '</table>';
      };
      ChartInternal.prototype.tooltipPosition = function (dataToShow, tWidth, tHeight, element) {
          var $$ = this, config = $$.config, d3 = $$.d3;
          var svgLeft, tooltipLeft, tooltipRight, tooltipTop, chartRight;
          var forArc = $$.hasArcType(), mouse = d3.mouse(element);
          // Determin tooltip position
          if (forArc) {
              tooltipLeft =
                  ($$.width - ($$.isLegendRight ? $$.getLegendWidth() : 0)) / 2 + mouse[0];
              tooltipTop =
                  ($$.hasType('gauge') ? $$.height : $$.height / 2) + mouse[1] + 20;
          }
          else {
              svgLeft = $$.getSvgLeft(true);
              if (config.axis_rotated) {
                  tooltipLeft = svgLeft + mouse[0] + 100;
                  tooltipRight = tooltipLeft + tWidth;
                  chartRight = $$.currentWidth - $$.getCurrentPaddingRight();
                  tooltipTop = $$.x(dataToShow[0].x) + 20;
              }
              else {
                  tooltipLeft =
                      svgLeft + $$.getCurrentPaddingLeft(true) + $$.x(dataToShow[0].x) + 20;
                  tooltipRight = tooltipLeft + tWidth;
                  chartRight = svgLeft + $$.currentWidth - $$.getCurrentPaddingRight();
                  tooltipTop = mouse[1] + 15;
              }
              if (tooltipRight > chartRight) {
                  // 20 is needed for Firefox to keep tooltip width
                  tooltipLeft -= tooltipRight - chartRight + 20;
              }
              if (tooltipTop + tHeight > $$.currentHeight) {
                  tooltipTop -= tHeight + 30;
              }
          }
          if (tooltipTop < 0) {
              tooltipTop = 0;
          }
          return {
              top: tooltipTop,
              left: tooltipLeft
          };
      };
      ChartInternal.prototype.showTooltip = function (selectedData, element) {
          var $$ = this, config = $$.config;
          var tWidth, tHeight, position;
          var forArc = $$.hasArcType(), dataToShow = selectedData.filter(function (d) {
              return d && isValue(d.value);
          }), positionFunction = config.tooltip_position || ChartInternal.prototype.tooltipPosition;
          if (dataToShow.length === 0 || !config.tooltip_show) {
              $$.hideTooltip();
              return;
          }
          $$.tooltip
              .html(config.tooltip_contents.call($$, selectedData, $$.axis.getXAxisTickFormat(), $$.getYFormat(forArc), $$.color))
              .style('display', 'block');
          // Get tooltip dimensions
          tWidth = $$.tooltip.property('offsetWidth');
          tHeight = $$.tooltip.property('offsetHeight');
          position = positionFunction.call(this, dataToShow, tWidth, tHeight, element);
          // Set tooltip
          $$.tooltip
              .style('top', position.top + 'px')
              .style('left', position.left + 'px');
      };
      ChartInternal.prototype.hideTooltip = function () {
          this.tooltip.style('display', 'none');
      };

      ChartInternal.prototype.setTargetType = function (targetIds, type) {
          var $$ = this, config = $$.config;
          $$.mapToTargetIds(targetIds).forEach(function (id) {
              $$.withoutFadeIn[id] = type === config.data_types[id];
              config.data_types[id] = type;
          });
          if (!targetIds) {
              config.data_type = type;
          }
      };
      ChartInternal.prototype.hasType = function (type, targets) {
          var $$ = this, types = $$.config.data_types, has = false;
          targets = targets || $$.data.targets;
          if (targets && targets.length) {
              targets.forEach(function (target) {
                  var t = types[target.id];
                  if ((t && t.indexOf(type) >= 0) || (!t && type === 'line')) {
                      has = true;
                  }
              });
          }
          else if (Object.keys(types).length) {
              Object.keys(types).forEach(function (id) {
                  if (types[id] === type) {
                      has = true;
                  }
              });
          }
          else {
              has = $$.config.data_type === type;
          }
          return has;
      };
      ChartInternal.prototype.hasArcType = function (targets) {
          return (this.hasType('pie', targets) ||
              this.hasType('donut', targets) ||
              this.hasType('gauge', targets));
      };
      ChartInternal.prototype.isLineType = function (d) {
          var config = this.config, id = isString(d) ? d : d.id;
          return (!config.data_types[id] ||
              ['line', 'spline', 'area', 'area-spline', 'step', 'area-step'].indexOf(config.data_types[id]) >= 0);
      };
      ChartInternal.prototype.isStepType = function (d) {
          var id = isString(d) ? d : d.id;
          return ['step', 'area-step'].indexOf(this.config.data_types[id]) >= 0;
      };
      ChartInternal.prototype.isSplineType = function (d) {
          var id = isString(d) ? d : d.id;
          return ['spline', 'area-spline'].indexOf(this.config.data_types[id]) >= 0;
      };
      ChartInternal.prototype.isAreaType = function (d) {
          var id = isString(d) ? d : d.id;
          return (['area', 'area-spline', 'area-step'].indexOf(this.config.data_types[id]) >=
              0);
      };
      ChartInternal.prototype.isBarType = function (d) {
          var id = isString(d) ? d : d.id;
          return this.config.data_types[id] === 'bar';
      };
      ChartInternal.prototype.isScatterType = function (d) {
          var id = isString(d) ? d : d.id;
          return this.config.data_types[id] === 'scatter';
      };
      ChartInternal.prototype.isStanfordType = function (d) {
          var id = isString(d) ? d : d.id;
          return this.config.data_types[id] === 'stanford';
      };
      ChartInternal.prototype.isPieType = function (d) {
          var id = isString(d) ? d : d.id;
          return this.config.data_types[id] === 'pie';
      };
      ChartInternal.prototype.isGaugeType = function (d) {
          var id = isString(d) ? d : d.id;
          return this.config.data_types[id] === 'gauge';
      };
      ChartInternal.prototype.isDonutType = function (d) {
          var id = isString(d) ? d : d.id;
          return this.config.data_types[id] === 'donut';
      };
      ChartInternal.prototype.isArcType = function (d) {
          return this.isPieType(d) || this.isDonutType(d) || this.isGaugeType(d);
      };
      ChartInternal.prototype.lineData = function (d) {
          return this.isLineType(d) ? [d] : [];
      };
      ChartInternal.prototype.arcData = function (d) {
          return this.isArcType(d.data) ? [d] : [];
      };
      /* not used
       function scatterData(d) {
       return isScatterType(d) ? d.values : [];
       }
       */
      ChartInternal.prototype.barData = function (d) {
          return this.isBarType(d) ? d.values : [];
      };
      ChartInternal.prototype.lineOrScatterOrStanfordData = function (d) {
          return this.isLineType(d) || this.isScatterType(d) || this.isStanfordType(d)
              ? d.values
              : [];
      };
      ChartInternal.prototype.barOrLineData = function (d) {
          return this.isBarType(d) || this.isLineType(d) ? d.values : [];
      };

      ChartInternal.prototype.isSafari = function () {
          var ua = window.navigator.userAgent;
          return ua.indexOf('Safari') >= 0 && ua.indexOf('Chrome') < 0;
      };
      ChartInternal.prototype.isChrome = function () {
          var ua = window.navigator.userAgent;
          return ua.indexOf('Chrome') >= 0;
      };

      ChartInternal.prototype.initZoom = function () {
          var $$ = this, d3 = $$.d3, config = $$.config, startEvent;
          $$.zoom = d3
              .zoom()
              .on('start', function () {
              if (config.zoom_type !== 'scroll') {
                  return;
              }
              var e = d3.event.sourceEvent;
              if (e && e.type === 'brush') {
                  return;
              }
              startEvent = e;
              config.zoom_onzoomstart.call($$.api, e);
          })
              .on('zoom', function () {
              if (config.zoom_type !== 'scroll') {
                  return;
              }
              var e = d3.event.sourceEvent;
              if (e && e.type === 'brush') {
                  return;
              }
              $$.redrawForZoom();
              config.zoom_onzoom.call($$.api, $$.x.orgDomain());
          })
              .on('end', function () {
              if (config.zoom_type !== 'scroll') {
                  return;
              }
              var e = d3.event.sourceEvent;
              if (e && e.type === 'brush') {
                  return;
              }
              // if click, do nothing. otherwise, click interaction will be canceled.
              if (e &&
                  startEvent.clientX === e.clientX &&
                  startEvent.clientY === e.clientY) {
                  return;
              }
              config.zoom_onzoomend.call($$.api, $$.x.orgDomain());
          });
          $$.zoom.updateDomain = function () {
              if (d3.event && d3.event.transform) {
                  if (config.axis_rotated && config.zoom_type === 'scroll' && d3.event.sourceEvent.type === 'mousemove') {
                      // we're moving the mouse in a rotated chart with zoom = "scroll", so we need rescaleY (i.e. vertical)
                      $$.x.domain(d3.event.transform.rescaleY($$.subX).domain());
                  }
                  else {
                      $$.x.domain(d3.event.transform.rescaleX($$.subX).domain());
                  }
              }
              return this;
          };
          $$.zoom.updateExtent = function () {
              this.scaleExtent([1, Infinity])
                  .translateExtent([
                  [0, 0],
                  [$$.width, $$.height]
              ])
                  .extent([
                  [0, 0],
                  [$$.width, $$.height]
              ]);
              return this;
          };
          $$.zoom.update = function () {
              return this.updateExtent().updateDomain();
          };
          return $$.zoom.updateExtent();
      };
      ChartInternal.prototype.zoomTransform = function (range) {
          var $$ = this, s = [$$.x(range[0]), $$.x(range[1])];
          return $$.d3.zoomIdentity.scale($$.width / (s[1] - s[0])).translate(-s[0], 0);
      };
      ChartInternal.prototype.initDragZoom = function () {
          var $$ = this;
          var d3 = $$.d3;
          var config = $$.config;
          var context = ($$.context = $$.svg);
          var brushXPos = $$.margin.left + 20.5;
          var brushYPos = $$.margin.top + 0.5;
          if (!(config.zoom_type === 'drag' && config.zoom_enabled)) {
              return;
          }
          var getZoomedDomain = function (selection) {
              return selection && selection.map(function (x) { return $$.x.invert(x); });
          };
          var brush = ($$.dragZoomBrush = d3
              .brushX()
              .on('start', function () {
              $$.api.unzoom();
              $$.svg.select('.' + CLASS.dragZoom).classed('disabled', false);
              config.zoom_onzoomstart.call($$.api, d3.event.sourceEvent);
          })
              .on('brush', function () {
              config.zoom_onzoom.call($$.api, getZoomedDomain(d3.event.selection));
          })
              .on('end', function () {
              if (d3.event.selection == null) {
                  return;
              }
              var zoomedDomain = getZoomedDomain(d3.event.selection);
              if (!config.zoom_disableDefaultBehavior) {
                  $$.api.zoom(zoomedDomain);
              }
              $$.svg.select('.' + CLASS.dragZoom).classed('disabled', true);
              config.zoom_onzoomend.call($$.api, zoomedDomain);
          }));
          context
              .append('g')
              .classed(CLASS.dragZoom, true)
              .attr('clip-path', $$.clipPath)
              .attr('transform', 'translate(' + brushXPos + ',' + brushYPos + ')')
              .call(brush);
      };
      ChartInternal.prototype.getZoomDomain = function () {
          var $$ = this, config = $$.config, d3 = $$.d3, min = d3.min([$$.orgXDomain[0], config.zoom_x_min]), max = d3.max([$$.orgXDomain[1], config.zoom_x_max]);
          return [min, max];
      };
      ChartInternal.prototype.redrawForZoom = function () {
          var $$ = this, d3 = $$.d3, config = $$.config, zoom = $$.zoom, x = $$.x;
          if (!config.zoom_enabled) {
              return;
          }
          if ($$.filterTargetsToShow($$.data.targets).length === 0) {
              return;
          }
          zoom.update();
          if (config.zoom_disableDefaultBehavior) {
              return;
          }
          if ($$.isCategorized() && x.orgDomain()[0] === $$.orgXDomain[0]) {
              x.domain([$$.orgXDomain[0] - 1e-10, x.orgDomain()[1]]);
          }
          $$.redraw({
              withTransition: false,
              withY: config.zoom_rescale,
              withSubchart: false,
              withEventRect: false,
              withDimension: false
          });
          if (d3.event.sourceEvent && d3.event.sourceEvent.type === 'mousemove') {
              $$.cancelClick = true;
          }
      };

      return c3;

    })));
    });

    var c3$1 = /*#__PURE__*/_mergeNamespaces({
        __proto__: null,
        'default': c3
    }, [c3]);

    /* src\front\esco-stats\integration1.svelte generated by Svelte v3.47.0 */

    const { console: console_1$7 } = globals;
    const file$8 = "src\\front\\esco-stats\\integration1.svelte";

    // (100:12) <NavbarBrand href="#/info">
    function create_default_slot_23$7(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("INICIO");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_23$7.name,
    		type: "slot",
    		source: "(100:12) <NavbarBrand href=\\\"#/info\\\">",
    		ctx
    	});

    	return block;
    }

    // (103:20) <DropdownToggle nav caret>
    function create_default_slot_22$7(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("API");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_22$7.name,
    		type: "slot",
    		source: "(103:20) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (105:20) <DropdownItem href="./api/v2/economies">
    function create_default_slot_21$7(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_21$7.name,
    		type: "slot",
    		source: "(105:20) <DropdownItem href=\\\"./api/v2/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (107:20) <DropdownItem href="./api/v1/esco-stats">
    function create_default_slot_20$7(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_20$7.name,
    		type: "slot",
    		source: "(107:20) <DropdownItem href=\\\"./api/v1/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (109:20) <DropdownItem href="./api/v1/expo-stats">
    function create_default_slot_19$7(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_19$7.name,
    		type: "slot",
    		source: "(109:20) <DropdownItem href=\\\"./api/v1/expo-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (104:20) <DropdownMenu end>
    function create_default_slot_18$7(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./api/v2/economies",
    				$$slots: { default: [create_default_slot_21$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "./api/v1/esco-stats",
    				$$slots: { default: [create_default_slot_20$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "./api/v1/expo-stats",
    				$$slots: { default: [create_default_slot_19$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_18$7.name,
    		type: "slot",
    		source: "(104:20) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (102:16) <Dropdown >
    function create_default_slot_17$7(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_22$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_18$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17$7.name,
    		type: "slot",
    		source: "(102:16) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (114:20) <DropdownToggle nav caret>
    function create_default_slot_16$7(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16$7.name,
    		type: "slot",
    		source: "(114:20) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (116:20) <DropdownItem href="./#/economies">
    function create_default_slot_15$7(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15$7.name,
    		type: "slot",
    		source: "(116:20) <DropdownItem href=\\\"./#/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (117:20) <DropdownItem href="#/esco-stats">
    function create_default_slot_14$7(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14$7.name,
    		type: "slot",
    		source: "(117:20) <DropdownItem href=\\\"#/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (118:20) <DropdownItem href="#/expo">
    function create_default_slot_13$7(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo-Stats FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13$7.name,
    		type: "slot",
    		source: "(118:20) <DropdownItem href=\\\"#/expo\\\">",
    		ctx
    	});

    	return block;
    }

    // (120:20) <DropdownItem href="#/graph">
    function create_default_slot_12$7(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Conjunto");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12$7.name,
    		type: "slot",
    		source: "(120:20) <DropdownItem href=\\\"#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (115:20) <DropdownMenu end>
    function create_default_slot_11$7(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies",
    				$$slots: { default: [create_default_slot_15$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({
    			props: {
    				href: "#/esco-stats",
    				$$slots: { default: [create_default_slot_14$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "#/expo",
    				$$slots: { default: [create_default_slot_13$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/graph",
    				$$slots: { default: [create_default_slot_12$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem1_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem1_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem1.$set(dropdownitem1_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$7.name,
    		type: "slot",
    		source: "(115:20) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (113:16) <Dropdown>
    function create_default_slot_10$7(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_16$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_11$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$7.name,
    		type: "slot",
    		source: "(113:16) <Dropdown>",
    		ctx
    	});

    	return block;
    }

    // (125:20) <DropdownToggle nav caret>
    function create_default_slot_9$7(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Gráficas");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$7.name,
    		type: "slot",
    		source: "(125:20) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (127:20) <DropdownItem href="./#/economies-graph">
    function create_default_slot_8$7(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$7.name,
    		type: "slot",
    		source: "(127:20) <DropdownItem href=\\\"./#/economies-graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (128:20) <DropdownItem href="#/graphesco">
    function create_default_slot_7$7(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$7.name,
    		type: "slot",
    		source: "(128:20) <DropdownItem href=\\\"#/graphesco\\\">",
    		ctx
    	});

    	return block;
    }

    // (129:20) <DropdownItem href="#/graphexpo">
    function create_default_slot_6$7(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$7.name,
    		type: "slot",
    		source: "(129:20) <DropdownItem href=\\\"#/graphexpo\\\">",
    		ctx
    	});

    	return block;
    }

    // (131:20) <DropdownItem href="#/graph">
    function create_default_slot_5$7(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Conjunto");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$7.name,
    		type: "slot",
    		source: "(131:20) <DropdownItem href=\\\"#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (126:20) <DropdownMenu end>
    function create_default_slot_4$7(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies-graph",
    				$$slots: { default: [create_default_slot_8$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({
    			props: {
    				href: "#/graphesco",
    				$$slots: { default: [create_default_slot_7$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "#/graphexpo",
    				$$slots: { default: [create_default_slot_6$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/graph",
    				$$slots: { default: [create_default_slot_5$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem1_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem1_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem1.$set(dropdownitem1_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$7.name,
    		type: "slot",
    		source: "(126:20) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (124:16) <Dropdown >
    function create_default_slot_3$7(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_9$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_4$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$7.name,
    		type: "slot",
    		source: "(124:16) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (101:12) <Nav navbar>
    function create_default_slot_2$7(ctx) {
    	let dropdown0;
    	let t0;
    	let dropdown1;
    	let t1;
    	let dropdown2;
    	let current;

    	dropdown0 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_17$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown1 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_10$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown2 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_3$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdown0.$$.fragment);
    			t0 = space();
    			create_component(dropdown1.$$.fragment);
    			t1 = space();
    			create_component(dropdown2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdown0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdown1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdown2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdown0_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdown0_changes.$$scope = { dirty, ctx };
    			}

    			dropdown0.$set(dropdown0_changes);
    			const dropdown1_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdown1_changes.$$scope = { dirty, ctx };
    			}

    			dropdown1.$set(dropdown1_changes);
    			const dropdown2_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdown2_changes.$$scope = { dirty, ctx };
    			}

    			dropdown2.$set(dropdown2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdown0.$$.fragment, local);
    			transition_in(dropdown1.$$.fragment, local);
    			transition_in(dropdown2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdown0.$$.fragment, local);
    			transition_out(dropdown1.$$.fragment, local);
    			transition_out(dropdown2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdown0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdown1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdown2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$7.name,
    		type: "slot",
    		source: "(101:12) <Nav navbar>",
    		ctx
    	});

    	return block;
    }

    // (99:8) <Navbar style="background-color: lightgreen; color:white;" light expand="lg" >
    function create_default_slot_1$7(ctx) {
    	let navbarbrand;
    	let t;
    	let nav;
    	let current;

    	navbarbrand = new NavbarBrand({
    			props: {
    				href: "#/info",
    				$$slots: { default: [create_default_slot_23$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	nav = new Nav({
    			props: {
    				navbar: true,
    				$$slots: { default: [create_default_slot_2$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navbarbrand.$$.fragment);
    			t = space();
    			create_component(nav.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbarbrand, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(nav, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navbarbrand_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				navbarbrand_changes.$$scope = { dirty, ctx };
    			}

    			navbarbrand.$set(navbarbrand_changes);
    			const nav_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				nav_changes.$$scope = { dirty, ctx };
    			}

    			nav.$set(nav_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbarbrand.$$.fragment, local);
    			transition_in(nav.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbarbrand.$$.fragment, local);
    			transition_out(nav.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbarbrand, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(nav, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$7.name,
    		type: "slot",
    		source: "(99:8) <Navbar style=\\\"background-color: lightgreen; color:white;\\\" light expand=\\\"lg\\\" >",
    		ctx
    	});

    	return block;
    }

    // (143:8) <Button on:click="{pop}">
    function create_default_slot$7(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Volver");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$7.name,
    		type: "slot",
    		source: "(143:8) <Button on:click=\\\"{pop}\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$8(ctx) {
    	let link;
    	let t0;
    	let main;
    	let navbar;
    	let t1;
    	let div;
    	let t2;
    	let button;
    	let current;

    	navbar = new Navbar({
    			props: {
    				style: "background-color: lightgreen; color:white;",
    				light: true,
    				expand: "lg",
    				$$slots: { default: [create_default_slot_1$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button = new Button({
    			props: {
    				$$slots: { default: [create_default_slot$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", pop);

    	const block = {
    		c: function create() {
    			link = element$1("link");
    			t0 = space();
    			main = element$1("main");
    			create_component(navbar.$$.fragment);
    			t1 = space();
    			div = element$1("div");
    			t2 = space();
    			create_component(button.$$.fragment);
    			attr_dev(link, "rel", "stylesheet");
    			attr_dev(link, "href", "./c3/c3.css");
    			add_location(link, file$8, 91, 8, 2882);
    			attr_dev(div, "id", "chart");
    			add_location(div, file$8, 139, 12, 5138);
    			add_location(main, file$8, 97, 4, 2976);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			append_dev(document.head, link);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			mount_component(navbar, main, null);
    			append_dev(main, t1);
    			append_dev(main, div);
    			append_dev(main, t2);
    			mount_component(button, main, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const navbar_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				navbar_changes.$$scope = { dirty, ctx };
    			}

    			navbar.$set(navbar_changes);
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			detach_dev(link);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			destroy_component(navbar);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Integration1', slots, []);
    	let apiData = {};
    	const delay = ms => new Promise(res => setTimeout(res, ms));
    	let stats = [];
    	let stats1 = [];
    	let country = [];
    	let year = [];
    	let tot_wom = ["tot_wom"];
    	let tot_man = ["tot_man"];
    	let tot_esco = ["tot_esco"];
    	let ages_seventy = ["ages_seventy"];
    	let ages_fifty_seventy = ["ages_fifty_seventy"];
    	let ages_zero_fifty = ["ages_zero_fifty"];

    	async function getData() {
    		console.log("Fetching stats....");
    		const res = await fetch("/api/v1/esco-stats");
    		const res1 = await fetch("/remoteAPI1-esco");

    		if (res.ok && res1.ok) {
    			const data = await res.json();
    			const data1 = await res1.json();
    			stats = data;
    			console.log("Estadísticas recibidas: " + stats.length);

    			//inicializamos los arrays para mostrar los datos
    			stats.forEach(stat => {
    				country.push(stat.country + "-" + stat.year);
    				tot_wom.push(stat.tot_wom);
    				tot_man.push(stat.tot_man);
    				tot_esco.push(stat.tot_esco);
    			});

    			stats1 = data1;
    			console.log("Estadísticas recibidas: " + stats1.length);

    			//inicializamos los arrays para mostrar los datos
    			stats1.forEach(stat => {
    				country.push(stat.country + "-" + stat.year);
    				ages_seventy.push(stat.ages_seventy);
    				ages_fifty_seventy.push(stat.ages_fifty_seventy);
    				ages_zero_fifty.push(stat.ages_zero_fifty);
    			});
    		} else {
    			console.log("Error cargando los datos");
    		}

    		loadGraph();
    		console.log("Comprobando");
    	}

    	async function loadGraph() {
    		c3.generate({
    			bindto: '#chart',
    			data: {
    				columns: [
    					tot_wom,
    					tot_man,
    					tot_esco,
    					ages_seventy,
    					ages_fifty_seventy,
    					ages_zero_fifty
    				],
    				type: 'spline'
    			},
    			axis: {
    				x: { type: 'category', categories: country }
    			}
    		});
    	}

    	onMount(getData);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$7.warn(`<Integration1> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		c3: c3$1,
    		Navbar,
    		Nav,
    		NavItem,
    		NavLink,
    		NavbarBrand,
    		Dropdown,
    		DropdownToggle,
    		DropdownMenu,
    		DropdownItem,
    		Table,
    		Button,
    		pop,
    		apiData,
    		delay,
    		stats,
    		stats1,
    		country,
    		year,
    		tot_wom,
    		tot_man,
    		tot_esco,
    		ages_seventy,
    		ages_fifty_seventy,
    		ages_zero_fifty,
    		getData,
    		loadGraph
    	});

    	$$self.$inject_state = $$props => {
    		if ('apiData' in $$props) apiData = $$props.apiData;
    		if ('stats' in $$props) stats = $$props.stats;
    		if ('stats1' in $$props) stats1 = $$props.stats1;
    		if ('country' in $$props) country = $$props.country;
    		if ('year' in $$props) year = $$props.year;
    		if ('tot_wom' in $$props) tot_wom = $$props.tot_wom;
    		if ('tot_man' in $$props) tot_man = $$props.tot_man;
    		if ('tot_esco' in $$props) tot_esco = $$props.tot_esco;
    		if ('ages_seventy' in $$props) ages_seventy = $$props.ages_seventy;
    		if ('ages_fifty_seventy' in $$props) ages_fifty_seventy = $$props.ages_fifty_seventy;
    		if ('ages_zero_fifty' in $$props) ages_zero_fifty = $$props.ages_zero_fifty;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [];
    }

    class Integration1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$8, create_fragment$8, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Integration1",
    			options,
    			id: create_fragment$8.name
    		});
    	}
    }

    /* src\front\esco-stats\integration2.svelte generated by Svelte v3.47.0 */

    const { console: console_1$6 } = globals;
    const file$7 = "src\\front\\esco-stats\\integration2.svelte";

    // (98:12) <NavbarBrand href="#/info">
    function create_default_slot_23$6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("INICIO");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_23$6.name,
    		type: "slot",
    		source: "(98:12) <NavbarBrand href=\\\"#/info\\\">",
    		ctx
    	});

    	return block;
    }

    // (101:20) <DropdownToggle nav caret>
    function create_default_slot_22$6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("API");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_22$6.name,
    		type: "slot",
    		source: "(101:20) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (103:20) <DropdownItem href="./api/v2/economies">
    function create_default_slot_21$6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_21$6.name,
    		type: "slot",
    		source: "(103:20) <DropdownItem href=\\\"./api/v2/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (105:20) <DropdownItem href="./api/v1/esco-stats">
    function create_default_slot_20$6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_20$6.name,
    		type: "slot",
    		source: "(105:20) <DropdownItem href=\\\"./api/v1/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (107:20) <DropdownItem href="./api/v1/expo-stats">
    function create_default_slot_19$6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_19$6.name,
    		type: "slot",
    		source: "(107:20) <DropdownItem href=\\\"./api/v1/expo-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (102:20) <DropdownMenu end>
    function create_default_slot_18$6(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./api/v2/economies",
    				$$slots: { default: [create_default_slot_21$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "./api/v1/esco-stats",
    				$$slots: { default: [create_default_slot_20$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "./api/v1/expo-stats",
    				$$slots: { default: [create_default_slot_19$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_18$6.name,
    		type: "slot",
    		source: "(102:20) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (100:16) <Dropdown >
    function create_default_slot_17$6(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_22$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_18$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17$6.name,
    		type: "slot",
    		source: "(100:16) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (112:20) <DropdownToggle nav caret>
    function create_default_slot_16$6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16$6.name,
    		type: "slot",
    		source: "(112:20) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (114:20) <DropdownItem href="./#/economies">
    function create_default_slot_15$6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15$6.name,
    		type: "slot",
    		source: "(114:20) <DropdownItem href=\\\"./#/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (115:20) <DropdownItem href="#/esco-stats">
    function create_default_slot_14$6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14$6.name,
    		type: "slot",
    		source: "(115:20) <DropdownItem href=\\\"#/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (116:20) <DropdownItem href="#/expo">
    function create_default_slot_13$6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo-Stats FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13$6.name,
    		type: "slot",
    		source: "(116:20) <DropdownItem href=\\\"#/expo\\\">",
    		ctx
    	});

    	return block;
    }

    // (118:20) <DropdownItem href="#/graph">
    function create_default_slot_12$6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Conjunto");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12$6.name,
    		type: "slot",
    		source: "(118:20) <DropdownItem href=\\\"#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (113:20) <DropdownMenu end>
    function create_default_slot_11$6(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies",
    				$$slots: { default: [create_default_slot_15$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({
    			props: {
    				href: "#/esco-stats",
    				$$slots: { default: [create_default_slot_14$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "#/expo",
    				$$slots: { default: [create_default_slot_13$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/graph",
    				$$slots: { default: [create_default_slot_12$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem1_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem1_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem1.$set(dropdownitem1_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$6.name,
    		type: "slot",
    		source: "(113:20) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (111:16) <Dropdown>
    function create_default_slot_10$6(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_16$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_11$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$6.name,
    		type: "slot",
    		source: "(111:16) <Dropdown>",
    		ctx
    	});

    	return block;
    }

    // (123:20) <DropdownToggle nav caret>
    function create_default_slot_9$6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Gráficas");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$6.name,
    		type: "slot",
    		source: "(123:20) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (125:20) <DropdownItem href="./#/economies-graph">
    function create_default_slot_8$6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$6.name,
    		type: "slot",
    		source: "(125:20) <DropdownItem href=\\\"./#/economies-graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (126:20) <DropdownItem href="#/graphesco">
    function create_default_slot_7$6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$6.name,
    		type: "slot",
    		source: "(126:20) <DropdownItem href=\\\"#/graphesco\\\">",
    		ctx
    	});

    	return block;
    }

    // (127:20) <DropdownItem href="#/graphexpo">
    function create_default_slot_6$6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$6.name,
    		type: "slot",
    		source: "(127:20) <DropdownItem href=\\\"#/graphexpo\\\">",
    		ctx
    	});

    	return block;
    }

    // (129:20) <DropdownItem href="#/graph">
    function create_default_slot_5$6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Conjunto");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$6.name,
    		type: "slot",
    		source: "(129:20) <DropdownItem href=\\\"#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (124:20) <DropdownMenu end>
    function create_default_slot_4$6(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies-graph",
    				$$slots: { default: [create_default_slot_8$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({
    			props: {
    				href: "#/graphesco",
    				$$slots: { default: [create_default_slot_7$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "#/graphexpo",
    				$$slots: { default: [create_default_slot_6$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/graph",
    				$$slots: { default: [create_default_slot_5$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem1_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem1_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem1.$set(dropdownitem1_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$6.name,
    		type: "slot",
    		source: "(124:20) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (122:16) <Dropdown >
    function create_default_slot_3$6(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_9$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_4$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$6.name,
    		type: "slot",
    		source: "(122:16) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (99:12) <Nav navbar>
    function create_default_slot_2$6(ctx) {
    	let dropdown0;
    	let t0;
    	let dropdown1;
    	let t1;
    	let dropdown2;
    	let current;

    	dropdown0 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_17$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown1 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_10$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown2 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_3$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdown0.$$.fragment);
    			t0 = space();
    			create_component(dropdown1.$$.fragment);
    			t1 = space();
    			create_component(dropdown2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdown0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdown1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdown2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdown0_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdown0_changes.$$scope = { dirty, ctx };
    			}

    			dropdown0.$set(dropdown0_changes);
    			const dropdown1_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdown1_changes.$$scope = { dirty, ctx };
    			}

    			dropdown1.$set(dropdown1_changes);
    			const dropdown2_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdown2_changes.$$scope = { dirty, ctx };
    			}

    			dropdown2.$set(dropdown2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdown0.$$.fragment, local);
    			transition_in(dropdown1.$$.fragment, local);
    			transition_in(dropdown2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdown0.$$.fragment, local);
    			transition_out(dropdown1.$$.fragment, local);
    			transition_out(dropdown2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdown0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdown1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdown2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$6.name,
    		type: "slot",
    		source: "(99:12) <Nav navbar>",
    		ctx
    	});

    	return block;
    }

    // (97:8) <Navbar style="background-color: lightgreen; color:white;" light expand="lg" >
    function create_default_slot_1$6(ctx) {
    	let navbarbrand;
    	let t;
    	let nav;
    	let current;

    	navbarbrand = new NavbarBrand({
    			props: {
    				href: "#/info",
    				$$slots: { default: [create_default_slot_23$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	nav = new Nav({
    			props: {
    				navbar: true,
    				$$slots: { default: [create_default_slot_2$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navbarbrand.$$.fragment);
    			t = space();
    			create_component(nav.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbarbrand, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(nav, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navbarbrand_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				navbarbrand_changes.$$scope = { dirty, ctx };
    			}

    			navbarbrand.$set(navbarbrand_changes);
    			const nav_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				nav_changes.$$scope = { dirty, ctx };
    			}

    			nav.$set(nav_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbarbrand.$$.fragment, local);
    			transition_in(nav.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbarbrand.$$.fragment, local);
    			transition_out(nav.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbarbrand, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(nav, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$6.name,
    		type: "slot",
    		source: "(97:8) <Navbar style=\\\"background-color: lightgreen; color:white;\\\" light expand=\\\"lg\\\" >",
    		ctx
    	});

    	return block;
    }

    // (140:8) <Button on:click="{pop}">
    function create_default_slot$6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Volver");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$6.name,
    		type: "slot",
    		source: "(140:8) <Button on:click=\\\"{pop}\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$7(ctx) {
    	let link;
    	let t0;
    	let main;
    	let navbar;
    	let t1;
    	let div;
    	let t2;
    	let button;
    	let current;

    	navbar = new Navbar({
    			props: {
    				style: "background-color: lightgreen; color:white;",
    				light: true,
    				expand: "lg",
    				$$slots: { default: [create_default_slot_1$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button = new Button({
    			props: {
    				$$slots: { default: [create_default_slot$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", pop);

    	const block = {
    		c: function create() {
    			link = element$1("link");
    			t0 = space();
    			main = element$1("main");
    			create_component(navbar.$$.fragment);
    			t1 = space();
    			div = element$1("div");
    			t2 = space();
    			create_component(button.$$.fragment);
    			attr_dev(link, "rel", "stylesheet");
    			attr_dev(link, "href", "./c3/c3.css");
    			add_location(link, file$7, 89, 8, 2843);
    			attr_dev(div, "id", "chart");
    			add_location(div, file$7, 136, 12, 5097);
    			add_location(main, file$7, 95, 4, 2937);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			append_dev(document.head, link);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			mount_component(navbar, main, null);
    			append_dev(main, t1);
    			append_dev(main, div);
    			append_dev(main, t2);
    			mount_component(button, main, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const navbar_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				navbar_changes.$$scope = { dirty, ctx };
    			}

    			navbar.$set(navbar_changes);
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			detach_dev(link);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			destroy_component(navbar);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Integration2', slots, []);
    	let apiData = {};
    	const delay = ms => new Promise(res => setTimeout(res, ms));
    	let stats = [];
    	let stats1 = [];
    	let country = [];
    	let year = [];
    	let tot_wom = ["tot_wom"];
    	let tot_man = ["tot_man"];
    	let tot_esco = ["tot_esco"];
    	let production = ["production"];
    	let absolute_change = ["absolute_change"];
    	let relative_change = ["relative_change"];

    	async function getData() {
    		console.log("Fetching stats....");
    		const res = await fetch("/api/v1/esco-stats");
    		const res1 = await fetch("/remoteAPI2-esco");

    		if (res.ok && res1.ok) {
    			const data = await res.json();
    			const data1 = await res1.json();
    			stats = data;
    			console.log("Estadísticas recibidas: " + stats.length);

    			//inicializamos los arrays para mostrar los datos
    			stats.forEach(stat => {
    				country.push(stat.country + "-" + stat.year);
    				tot_wom.push(stat.tot_wom);
    				tot_man.push(stat.tot_man);
    				tot_esco.push(stat.tot_esco);
    			});

    			stats1 = data1;
    			console.log("Estadísticas recibidas: " + stats1.length);

    			//inicializamos los arrays para mostrar los datos
    			stats1.forEach(stat => {
    				country.push(stat.country + "-" + stat.year);
    				production.push(stat.production);
    				absolute_change.push(stat.absolute_change);
    				relative_change.push(stat.relative_change);
    			});
    		} else {
    			console.log("Error cargando los datos");
    		}

    		loadGraph();
    		console.log("Comprobando");
    	}

    	async function loadGraph() {
    		c3.generate({
    			bindto: '#chart',
    			data: {
    				columns: [tot_wom, tot_man, tot_esco, production, absolute_change, relative_change],
    				type: 'spline'
    			},
    			axis: {
    				x: { type: 'category', categories: country }
    			}
    		});
    	}

    	onMount(getData);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$6.warn(`<Integration2> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		c3: c3$1,
    		Navbar,
    		Nav,
    		NavItem,
    		NavLink,
    		NavbarBrand,
    		Dropdown,
    		DropdownToggle,
    		DropdownMenu,
    		DropdownItem,
    		Table,
    		Button,
    		pop,
    		apiData,
    		delay,
    		stats,
    		stats1,
    		country,
    		year,
    		tot_wom,
    		tot_man,
    		tot_esco,
    		production,
    		absolute_change,
    		relative_change,
    		getData,
    		loadGraph
    	});

    	$$self.$inject_state = $$props => {
    		if ('apiData' in $$props) apiData = $$props.apiData;
    		if ('stats' in $$props) stats = $$props.stats;
    		if ('stats1' in $$props) stats1 = $$props.stats1;
    		if ('country' in $$props) country = $$props.country;
    		if ('year' in $$props) year = $$props.year;
    		if ('tot_wom' in $$props) tot_wom = $$props.tot_wom;
    		if ('tot_man' in $$props) tot_man = $$props.tot_man;
    		if ('tot_esco' in $$props) tot_esco = $$props.tot_esco;
    		if ('production' in $$props) production = $$props.production;
    		if ('absolute_change' in $$props) absolute_change = $$props.absolute_change;
    		if ('relative_change' in $$props) relative_change = $$props.relative_change;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [];
    }

    class Integration2 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$7, create_fragment$7, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Integration2",
    			options,
    			id: create_fragment$7.name
    		});
    	}
    }

    /* src\front\esco-stats\integration3.svelte generated by Svelte v3.47.0 */

    const { console: console_1$5 } = globals;
    const file$6 = "src\\front\\esco-stats\\integration3.svelte";

    // (98:12) <NavbarBrand href="#/info">
    function create_default_slot_23$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("INICIO");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_23$5.name,
    		type: "slot",
    		source: "(98:12) <NavbarBrand href=\\\"#/info\\\">",
    		ctx
    	});

    	return block;
    }

    // (101:20) <DropdownToggle nav caret>
    function create_default_slot_22$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("API");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_22$5.name,
    		type: "slot",
    		source: "(101:20) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (103:20) <DropdownItem href="./api/v2/economies">
    function create_default_slot_21$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_21$5.name,
    		type: "slot",
    		source: "(103:20) <DropdownItem href=\\\"./api/v2/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (105:20) <DropdownItem href="./api/v1/esco-stats">
    function create_default_slot_20$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_20$5.name,
    		type: "slot",
    		source: "(105:20) <DropdownItem href=\\\"./api/v1/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (107:20) <DropdownItem href="./api/v1/expo-stats">
    function create_default_slot_19$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_19$5.name,
    		type: "slot",
    		source: "(107:20) <DropdownItem href=\\\"./api/v1/expo-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (102:20) <DropdownMenu end>
    function create_default_slot_18$5(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./api/v2/economies",
    				$$slots: { default: [create_default_slot_21$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "./api/v1/esco-stats",
    				$$slots: { default: [create_default_slot_20$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "./api/v1/expo-stats",
    				$$slots: { default: [create_default_slot_19$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_18$5.name,
    		type: "slot",
    		source: "(102:20) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (100:16) <Dropdown >
    function create_default_slot_17$5(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_22$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_18$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17$5.name,
    		type: "slot",
    		source: "(100:16) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (112:20) <DropdownToggle nav caret>
    function create_default_slot_16$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16$5.name,
    		type: "slot",
    		source: "(112:20) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (114:20) <DropdownItem href="./#/economies">
    function create_default_slot_15$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15$5.name,
    		type: "slot",
    		source: "(114:20) <DropdownItem href=\\\"./#/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (115:20) <DropdownItem href="#/esco-stats">
    function create_default_slot_14$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14$5.name,
    		type: "slot",
    		source: "(115:20) <DropdownItem href=\\\"#/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (116:20) <DropdownItem href="#/expo">
    function create_default_slot_13$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo-Stats FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13$5.name,
    		type: "slot",
    		source: "(116:20) <DropdownItem href=\\\"#/expo\\\">",
    		ctx
    	});

    	return block;
    }

    // (118:20) <DropdownItem href="#/graph">
    function create_default_slot_12$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Conjunto");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12$5.name,
    		type: "slot",
    		source: "(118:20) <DropdownItem href=\\\"#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (113:20) <DropdownMenu end>
    function create_default_slot_11$5(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies",
    				$$slots: { default: [create_default_slot_15$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({
    			props: {
    				href: "#/esco-stats",
    				$$slots: { default: [create_default_slot_14$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "#/expo",
    				$$slots: { default: [create_default_slot_13$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/graph",
    				$$slots: { default: [create_default_slot_12$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem1_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem1_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem1.$set(dropdownitem1_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$5.name,
    		type: "slot",
    		source: "(113:20) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (111:16) <Dropdown>
    function create_default_slot_10$5(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_16$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_11$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$5.name,
    		type: "slot",
    		source: "(111:16) <Dropdown>",
    		ctx
    	});

    	return block;
    }

    // (123:20) <DropdownToggle nav caret>
    function create_default_slot_9$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Gráficas");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$5.name,
    		type: "slot",
    		source: "(123:20) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (125:20) <DropdownItem href="./#/economies-graph">
    function create_default_slot_8$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$5.name,
    		type: "slot",
    		source: "(125:20) <DropdownItem href=\\\"./#/economies-graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (126:20) <DropdownItem href="#/graphesco">
    function create_default_slot_7$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$5.name,
    		type: "slot",
    		source: "(126:20) <DropdownItem href=\\\"#/graphesco\\\">",
    		ctx
    	});

    	return block;
    }

    // (127:20) <DropdownItem href="#/graphexpo">
    function create_default_slot_6$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$5.name,
    		type: "slot",
    		source: "(127:20) <DropdownItem href=\\\"#/graphexpo\\\">",
    		ctx
    	});

    	return block;
    }

    // (129:20) <DropdownItem href="#/graph">
    function create_default_slot_5$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Conjunto");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$5.name,
    		type: "slot",
    		source: "(129:20) <DropdownItem href=\\\"#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (124:20) <DropdownMenu end>
    function create_default_slot_4$5(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies-graph",
    				$$slots: { default: [create_default_slot_8$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({
    			props: {
    				href: "#/graphesco",
    				$$slots: { default: [create_default_slot_7$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "#/graphexpo",
    				$$slots: { default: [create_default_slot_6$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/graph",
    				$$slots: { default: [create_default_slot_5$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem1_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem1_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem1.$set(dropdownitem1_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$5.name,
    		type: "slot",
    		source: "(124:20) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (122:16) <Dropdown >
    function create_default_slot_3$5(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_9$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_4$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$5.name,
    		type: "slot",
    		source: "(122:16) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (99:12) <Nav navbar>
    function create_default_slot_2$5(ctx) {
    	let dropdown0;
    	let t0;
    	let dropdown1;
    	let t1;
    	let dropdown2;
    	let current;

    	dropdown0 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_17$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown1 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_10$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown2 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_3$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdown0.$$.fragment);
    			t0 = space();
    			create_component(dropdown1.$$.fragment);
    			t1 = space();
    			create_component(dropdown2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdown0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdown1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdown2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdown0_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdown0_changes.$$scope = { dirty, ctx };
    			}

    			dropdown0.$set(dropdown0_changes);
    			const dropdown1_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdown1_changes.$$scope = { dirty, ctx };
    			}

    			dropdown1.$set(dropdown1_changes);
    			const dropdown2_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdown2_changes.$$scope = { dirty, ctx };
    			}

    			dropdown2.$set(dropdown2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdown0.$$.fragment, local);
    			transition_in(dropdown1.$$.fragment, local);
    			transition_in(dropdown2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdown0.$$.fragment, local);
    			transition_out(dropdown1.$$.fragment, local);
    			transition_out(dropdown2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdown0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdown1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdown2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$5.name,
    		type: "slot",
    		source: "(99:12) <Nav navbar>",
    		ctx
    	});

    	return block;
    }

    // (97:8) <Navbar style="background-color: lightgreen; color:white;" light expand="lg" >
    function create_default_slot_1$5(ctx) {
    	let navbarbrand;
    	let t;
    	let nav;
    	let current;

    	navbarbrand = new NavbarBrand({
    			props: {
    				href: "#/info",
    				$$slots: { default: [create_default_slot_23$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	nav = new Nav({
    			props: {
    				navbar: true,
    				$$slots: { default: [create_default_slot_2$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navbarbrand.$$.fragment);
    			t = space();
    			create_component(nav.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbarbrand, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(nav, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navbarbrand_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				navbarbrand_changes.$$scope = { dirty, ctx };
    			}

    			navbarbrand.$set(navbarbrand_changes);
    			const nav_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				nav_changes.$$scope = { dirty, ctx };
    			}

    			nav.$set(nav_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbarbrand.$$.fragment, local);
    			transition_in(nav.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbarbrand.$$.fragment, local);
    			transition_out(nav.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbarbrand, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(nav, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$5.name,
    		type: "slot",
    		source: "(97:8) <Navbar style=\\\"background-color: lightgreen; color:white;\\\" light expand=\\\"lg\\\" >",
    		ctx
    	});

    	return block;
    }

    // (140:8) <Button on:click="{pop}">
    function create_default_slot$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Volver");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$5.name,
    		type: "slot",
    		source: "(140:8) <Button on:click=\\\"{pop}\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$6(ctx) {
    	let link;
    	let t0;
    	let main;
    	let navbar;
    	let t1;
    	let div;
    	let t2;
    	let button;
    	let current;

    	navbar = new Navbar({
    			props: {
    				style: "background-color: lightgreen; color:white;",
    				light: true,
    				expand: "lg",
    				$$slots: { default: [create_default_slot_1$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button = new Button({
    			props: {
    				$$slots: { default: [create_default_slot$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", pop);

    	const block = {
    		c: function create() {
    			link = element$1("link");
    			t0 = space();
    			main = element$1("main");
    			create_component(navbar.$$.fragment);
    			t1 = space();
    			div = element$1("div");
    			t2 = space();
    			create_component(button.$$.fragment);
    			attr_dev(link, "rel", "stylesheet");
    			attr_dev(link, "href", "./c3/c3.css");
    			add_location(link, file$6, 89, 8, 2743);
    			attr_dev(div, "id", "chart");
    			add_location(div, file$6, 136, 12, 4997);
    			add_location(main, file$6, 95, 4, 2837);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			append_dev(document.head, link);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			mount_component(navbar, main, null);
    			append_dev(main, t1);
    			append_dev(main, div);
    			append_dev(main, t2);
    			mount_component(button, main, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const navbar_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				navbar_changes.$$scope = { dirty, ctx };
    			}

    			navbar.$set(navbar_changes);
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			detach_dev(link);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			destroy_component(navbar);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Integration3', slots, []);
    	let apiData = {};
    	const delay = ms => new Promise(res => setTimeout(res, ms));
    	let stats = [];
    	let stats1 = [];
    	let country = [];
    	let year = [];
    	let tot_wom = ["tot_wom"];
    	let tot_man = ["tot_man"];
    	let tot_esco = ["tot_esco"];
    	let co2_tot = ["co2_tot"];
    	let co2_kg = ["co2_kg"];
    	let co2_tpc = ["co2_tpc"];

    	async function getData() {
    		console.log("Fetching stats....");
    		const res = await fetch("/api/v1/esco-stats");
    		const res1 = await fetch("/remoteAPI3-esco");

    		if (res.ok && res1.ok) {
    			const data = await res.json();
    			const data1 = await res1.json();
    			stats = data;
    			console.log("Estadísticas recibidas: " + stats.length);

    			//inicializamos los arrays para mostrar los datos
    			stats.forEach(stat => {
    				country.push(stat.country + "-" + stat.year);
    				tot_wom.push(stat.tot_wom);
    				tot_man.push(stat.tot_man);
    				tot_esco.push(stat.tot_esco);
    			});

    			stats1 = data1;
    			console.log("Estadísticas recibidas: " + stats1.length);

    			//inicializamos los arrays para mostrar los datos
    			stats1.forEach(stat => {
    				country.push(stat.country + "-" + stat.year);
    				co2_tot.push(stat.co2_tot);
    				co2_kg.push(stat.co2_kg);
    				co2_tpc.push(stat.co2_tpc);
    			});
    		} else {
    			console.log("Error cargando los datos");
    		}

    		loadGraph();
    		console.log("Comprobando");
    	}

    	async function loadGraph() {
    		c3.generate({
    			bindto: '#chart',
    			data: {
    				columns: [tot_wom, tot_man, tot_esco, co2_tot, co2_kg, co2_tpc],
    				type: 'spline'
    			},
    			axis: {
    				x: { type: 'category', categories: country }
    			}
    		});
    	}

    	onMount(getData);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$5.warn(`<Integration3> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		c3: c3$1,
    		Navbar,
    		Nav,
    		NavItem,
    		NavLink,
    		NavbarBrand,
    		Dropdown,
    		DropdownToggle,
    		DropdownMenu,
    		DropdownItem,
    		Table,
    		Button,
    		pop,
    		apiData,
    		delay,
    		stats,
    		stats1,
    		country,
    		year,
    		tot_wom,
    		tot_man,
    		tot_esco,
    		co2_tot,
    		co2_kg,
    		co2_tpc,
    		getData,
    		loadGraph
    	});

    	$$self.$inject_state = $$props => {
    		if ('apiData' in $$props) apiData = $$props.apiData;
    		if ('stats' in $$props) stats = $$props.stats;
    		if ('stats1' in $$props) stats1 = $$props.stats1;
    		if ('country' in $$props) country = $$props.country;
    		if ('year' in $$props) year = $$props.year;
    		if ('tot_wom' in $$props) tot_wom = $$props.tot_wom;
    		if ('tot_man' in $$props) tot_man = $$props.tot_man;
    		if ('tot_esco' in $$props) tot_esco = $$props.tot_esco;
    		if ('co2_tot' in $$props) co2_tot = $$props.co2_tot;
    		if ('co2_kg' in $$props) co2_kg = $$props.co2_kg;
    		if ('co2_tpc' in $$props) co2_tpc = $$props.co2_tpc;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [];
    }

    class Integration3 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$6, create_fragment$6, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Integration3",
    			options,
    			id: create_fragment$6.name
    		});
    	}
    }

    /* src\front\esco-stats\integration4.svelte generated by Svelte v3.47.0 */

    const { console: console_1$4 } = globals;
    const file$5 = "src\\front\\esco-stats\\integration4.svelte";

    // (98:12) <NavbarBrand href="#/info">
    function create_default_slot_23$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("INICIO");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_23$4.name,
    		type: "slot",
    		source: "(98:12) <NavbarBrand href=\\\"#/info\\\">",
    		ctx
    	});

    	return block;
    }

    // (101:20) <DropdownToggle nav caret>
    function create_default_slot_22$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("API");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_22$4.name,
    		type: "slot",
    		source: "(101:20) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (103:20) <DropdownItem href="./api/v2/economies">
    function create_default_slot_21$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_21$4.name,
    		type: "slot",
    		source: "(103:20) <DropdownItem href=\\\"./api/v2/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (105:20) <DropdownItem href="./api/v1/esco-stats">
    function create_default_slot_20$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_20$4.name,
    		type: "slot",
    		source: "(105:20) <DropdownItem href=\\\"./api/v1/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (107:20) <DropdownItem href="./api/v1/expo-stats">
    function create_default_slot_19$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_19$4.name,
    		type: "slot",
    		source: "(107:20) <DropdownItem href=\\\"./api/v1/expo-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (102:20) <DropdownMenu end>
    function create_default_slot_18$4(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./api/v2/economies",
    				$$slots: { default: [create_default_slot_21$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "./api/v1/esco-stats",
    				$$slots: { default: [create_default_slot_20$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "./api/v1/expo-stats",
    				$$slots: { default: [create_default_slot_19$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_18$4.name,
    		type: "slot",
    		source: "(102:20) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (100:16) <Dropdown >
    function create_default_slot_17$4(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_22$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_18$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17$4.name,
    		type: "slot",
    		source: "(100:16) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (112:20) <DropdownToggle nav caret>
    function create_default_slot_16$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16$4.name,
    		type: "slot",
    		source: "(112:20) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (114:20) <DropdownItem href="./#/economies">
    function create_default_slot_15$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15$4.name,
    		type: "slot",
    		source: "(114:20) <DropdownItem href=\\\"./#/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (115:20) <DropdownItem href="#/esco-stats">
    function create_default_slot_14$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14$4.name,
    		type: "slot",
    		source: "(115:20) <DropdownItem href=\\\"#/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (116:20) <DropdownItem href="#/expo">
    function create_default_slot_13$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo-Stats FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13$4.name,
    		type: "slot",
    		source: "(116:20) <DropdownItem href=\\\"#/expo\\\">",
    		ctx
    	});

    	return block;
    }

    // (118:20) <DropdownItem href="#/graph">
    function create_default_slot_12$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Conjunto");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12$4.name,
    		type: "slot",
    		source: "(118:20) <DropdownItem href=\\\"#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (113:20) <DropdownMenu end>
    function create_default_slot_11$4(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies",
    				$$slots: { default: [create_default_slot_15$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({
    			props: {
    				href: "#/esco-stats",
    				$$slots: { default: [create_default_slot_14$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "#/expo",
    				$$slots: { default: [create_default_slot_13$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/graph",
    				$$slots: { default: [create_default_slot_12$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem1_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem1_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem1.$set(dropdownitem1_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$4.name,
    		type: "slot",
    		source: "(113:20) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (111:16) <Dropdown>
    function create_default_slot_10$4(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_16$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_11$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$4.name,
    		type: "slot",
    		source: "(111:16) <Dropdown>",
    		ctx
    	});

    	return block;
    }

    // (123:20) <DropdownToggle nav caret>
    function create_default_slot_9$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Gráficas");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$4.name,
    		type: "slot",
    		source: "(123:20) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (125:20) <DropdownItem href="./#/economies-graph">
    function create_default_slot_8$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$4.name,
    		type: "slot",
    		source: "(125:20) <DropdownItem href=\\\"./#/economies-graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (126:20) <DropdownItem href="#/graphesco">
    function create_default_slot_7$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$4.name,
    		type: "slot",
    		source: "(126:20) <DropdownItem href=\\\"#/graphesco\\\">",
    		ctx
    	});

    	return block;
    }

    // (127:20) <DropdownItem href="#/graphexpo">
    function create_default_slot_6$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$4.name,
    		type: "slot",
    		source: "(127:20) <DropdownItem href=\\\"#/graphexpo\\\">",
    		ctx
    	});

    	return block;
    }

    // (129:20) <DropdownItem href="#/graph">
    function create_default_slot_5$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Conjunto");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$4.name,
    		type: "slot",
    		source: "(129:20) <DropdownItem href=\\\"#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (124:20) <DropdownMenu end>
    function create_default_slot_4$4(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies-graph",
    				$$slots: { default: [create_default_slot_8$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({
    			props: {
    				href: "#/graphesco",
    				$$slots: { default: [create_default_slot_7$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "#/graphexpo",
    				$$slots: { default: [create_default_slot_6$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/graph",
    				$$slots: { default: [create_default_slot_5$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem1_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem1_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem1.$set(dropdownitem1_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$4.name,
    		type: "slot",
    		source: "(124:20) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (122:16) <Dropdown >
    function create_default_slot_3$4(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_9$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_4$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$4.name,
    		type: "slot",
    		source: "(122:16) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (99:12) <Nav navbar>
    function create_default_slot_2$4(ctx) {
    	let dropdown0;
    	let t0;
    	let dropdown1;
    	let t1;
    	let dropdown2;
    	let current;

    	dropdown0 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_17$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown1 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_10$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown2 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_3$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdown0.$$.fragment);
    			t0 = space();
    			create_component(dropdown1.$$.fragment);
    			t1 = space();
    			create_component(dropdown2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdown0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdown1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdown2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdown0_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdown0_changes.$$scope = { dirty, ctx };
    			}

    			dropdown0.$set(dropdown0_changes);
    			const dropdown1_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdown1_changes.$$scope = { dirty, ctx };
    			}

    			dropdown1.$set(dropdown1_changes);
    			const dropdown2_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdown2_changes.$$scope = { dirty, ctx };
    			}

    			dropdown2.$set(dropdown2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdown0.$$.fragment, local);
    			transition_in(dropdown1.$$.fragment, local);
    			transition_in(dropdown2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdown0.$$.fragment, local);
    			transition_out(dropdown1.$$.fragment, local);
    			transition_out(dropdown2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdown0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdown1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdown2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$4.name,
    		type: "slot",
    		source: "(99:12) <Nav navbar>",
    		ctx
    	});

    	return block;
    }

    // (97:8) <Navbar style="background-color: lightgreen; color:white;" light expand="lg" >
    function create_default_slot_1$4(ctx) {
    	let navbarbrand;
    	let t;
    	let nav;
    	let current;

    	navbarbrand = new NavbarBrand({
    			props: {
    				href: "#/info",
    				$$slots: { default: [create_default_slot_23$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	nav = new Nav({
    			props: {
    				navbar: true,
    				$$slots: { default: [create_default_slot_2$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navbarbrand.$$.fragment);
    			t = space();
    			create_component(nav.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbarbrand, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(nav, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navbarbrand_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				navbarbrand_changes.$$scope = { dirty, ctx };
    			}

    			navbarbrand.$set(navbarbrand_changes);
    			const nav_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				nav_changes.$$scope = { dirty, ctx };
    			}

    			nav.$set(nav_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbarbrand.$$.fragment, local);
    			transition_in(nav.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbarbrand.$$.fragment, local);
    			transition_out(nav.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbarbrand, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(nav, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$4.name,
    		type: "slot",
    		source: "(97:8) <Navbar style=\\\"background-color: lightgreen; color:white;\\\" light expand=\\\"lg\\\" >",
    		ctx
    	});

    	return block;
    }

    // (140:8) <Button on:click="{pop}">
    function create_default_slot$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Volver");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$4.name,
    		type: "slot",
    		source: "(140:8) <Button on:click=\\\"{pop}\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$5(ctx) {
    	let link;
    	let t0;
    	let main;
    	let navbar;
    	let t1;
    	let div;
    	let t2;
    	let button;
    	let current;

    	navbar = new Navbar({
    			props: {
    				style: "background-color: lightgreen; color:white;",
    				light: true,
    				expand: "lg",
    				$$slots: { default: [create_default_slot_1$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button = new Button({
    			props: {
    				$$slots: { default: [create_default_slot$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", pop);

    	const block = {
    		c: function create() {
    			link = element$1("link");
    			t0 = space();
    			main = element$1("main");
    			create_component(navbar.$$.fragment);
    			t1 = space();
    			div = element$1("div");
    			t2 = space();
    			create_component(button.$$.fragment);
    			attr_dev(link, "rel", "stylesheet");
    			attr_dev(link, "href", "./c3/c3.css");
    			add_location(link, file$5, 89, 8, 2843);
    			attr_dev(div, "id", "chart");
    			add_location(div, file$5, 136, 12, 5097);
    			add_location(main, file$5, 95, 4, 2937);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			append_dev(document.head, link);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			mount_component(navbar, main, null);
    			append_dev(main, t1);
    			append_dev(main, div);
    			append_dev(main, t2);
    			mount_component(button, main, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const navbar_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				navbar_changes.$$scope = { dirty, ctx };
    			}

    			navbar.$set(navbar_changes);
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			detach_dev(link);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			destroy_component(navbar);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Integration4', slots, []);
    	let apiData = {};
    	const delay = ms => new Promise(res => setTimeout(res, ms));
    	let stats = [];
    	let stats1 = [];
    	let country = [];
    	let year = [];
    	let tot_wom = ["tot_wom"];
    	let tot_man = ["tot_man"];
    	let tot_esco = ["tot_esco"];
    	let public_expenditure = ["public_expenditure"];
    	let pe_to_gdp = ["pe_to_gdp"];
    	let pe_on_defence = ["pe_on_defence"];

    	async function getData() {
    		console.log("Fetching stats....");
    		const res = await fetch("/api/v1/esco-stats");
    		const res1 = await fetch("/remoteAPI4-esco");

    		if (res.ok && res1.ok) {
    			const data = await res.json();
    			const data1 = await res1.json();
    			stats = data;
    			console.log("Estadísticas recibidas: " + stats.length);

    			//inicializamos los arrays para mostrar los datos
    			stats.forEach(stat => {
    				country.push(stat.country + "-" + stat.year);
    				tot_wom.push(stat.tot_wom);
    				tot_man.push(stat.tot_man);
    				tot_esco.push(stat.tot_esco);
    			});

    			stats1 = data1;
    			console.log("Estadísticas recibidas: " + stats1.length);

    			//inicializamos los arrays para mostrar los datos
    			stats1.forEach(stat => {
    				country.push(stat.country + "-" + stat.year);
    				public_expenditure.push(stat.public_expenditure);
    				pe_to_gdp.push(stat.pe_to_gdp);
    				pe_on_defence.push(stat.pe_on_defence);
    			});
    		} else {
    			console.log("Error cargando los datos");
    		}

    		loadGraph();
    		console.log("Comprobando");
    	}

    	async function loadGraph() {
    		c3.generate({
    			bindto: '#chart',
    			data: {
    				columns: [tot_wom, tot_man, tot_esco, public_expenditure, pe_to_gdp, pe_on_defence],
    				type: 'spline'
    			},
    			axis: {
    				x: { type: 'category', categories: country }
    			}
    		});
    	}

    	onMount(getData);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$4.warn(`<Integration4> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		c3: c3$1,
    		Navbar,
    		Nav,
    		NavItem,
    		NavLink,
    		NavbarBrand,
    		Dropdown,
    		DropdownToggle,
    		DropdownMenu,
    		DropdownItem,
    		Table,
    		Button,
    		pop,
    		apiData,
    		delay,
    		stats,
    		stats1,
    		country,
    		year,
    		tot_wom,
    		tot_man,
    		tot_esco,
    		public_expenditure,
    		pe_to_gdp,
    		pe_on_defence,
    		getData,
    		loadGraph
    	});

    	$$self.$inject_state = $$props => {
    		if ('apiData' in $$props) apiData = $$props.apiData;
    		if ('stats' in $$props) stats = $$props.stats;
    		if ('stats1' in $$props) stats1 = $$props.stats1;
    		if ('country' in $$props) country = $$props.country;
    		if ('year' in $$props) year = $$props.year;
    		if ('tot_wom' in $$props) tot_wom = $$props.tot_wom;
    		if ('tot_man' in $$props) tot_man = $$props.tot_man;
    		if ('tot_esco' in $$props) tot_esco = $$props.tot_esco;
    		if ('public_expenditure' in $$props) public_expenditure = $$props.public_expenditure;
    		if ('pe_to_gdp' in $$props) pe_to_gdp = $$props.pe_to_gdp;
    		if ('pe_on_defence' in $$props) pe_on_defence = $$props.pe_on_defence;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [];
    }

    class Integration4 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$5, create_fragment$5, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Integration4",
    			options,
    			id: create_fragment$5.name
    		});
    	}
    }

    /* src\front\esco-stats\integration5.svelte generated by Svelte v3.47.0 */

    const { console: console_1$3 } = globals;
    const file$4 = "src\\front\\esco-stats\\integration5.svelte";

    // (98:12) <NavbarBrand href="#/info">
    function create_default_slot_23$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("INICIO");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_23$3.name,
    		type: "slot",
    		source: "(98:12) <NavbarBrand href=\\\"#/info\\\">",
    		ctx
    	});

    	return block;
    }

    // (101:20) <DropdownToggle nav caret>
    function create_default_slot_22$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("API");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_22$3.name,
    		type: "slot",
    		source: "(101:20) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (103:20) <DropdownItem href="./api/v2/economies">
    function create_default_slot_21$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_21$3.name,
    		type: "slot",
    		source: "(103:20) <DropdownItem href=\\\"./api/v2/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (105:20) <DropdownItem href="./api/v1/esco-stats">
    function create_default_slot_20$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_20$3.name,
    		type: "slot",
    		source: "(105:20) <DropdownItem href=\\\"./api/v1/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (107:20) <DropdownItem href="./api/v1/expo-stats">
    function create_default_slot_19$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_19$3.name,
    		type: "slot",
    		source: "(107:20) <DropdownItem href=\\\"./api/v1/expo-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (102:20) <DropdownMenu end>
    function create_default_slot_18$3(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./api/v2/economies",
    				$$slots: { default: [create_default_slot_21$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "./api/v1/esco-stats",
    				$$slots: { default: [create_default_slot_20$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "./api/v1/expo-stats",
    				$$slots: { default: [create_default_slot_19$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_18$3.name,
    		type: "slot",
    		source: "(102:20) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (100:16) <Dropdown >
    function create_default_slot_17$3(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_22$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_18$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17$3.name,
    		type: "slot",
    		source: "(100:16) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (112:20) <DropdownToggle nav caret>
    function create_default_slot_16$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16$3.name,
    		type: "slot",
    		source: "(112:20) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (114:20) <DropdownItem href="./#/economies">
    function create_default_slot_15$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15$3.name,
    		type: "slot",
    		source: "(114:20) <DropdownItem href=\\\"./#/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (115:20) <DropdownItem href="#/esco-stats">
    function create_default_slot_14$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14$3.name,
    		type: "slot",
    		source: "(115:20) <DropdownItem href=\\\"#/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (116:20) <DropdownItem href="#/expo">
    function create_default_slot_13$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo-Stats FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13$3.name,
    		type: "slot",
    		source: "(116:20) <DropdownItem href=\\\"#/expo\\\">",
    		ctx
    	});

    	return block;
    }

    // (118:20) <DropdownItem href="#/graph">
    function create_default_slot_12$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Conjunto");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12$3.name,
    		type: "slot",
    		source: "(118:20) <DropdownItem href=\\\"#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (113:20) <DropdownMenu end>
    function create_default_slot_11$3(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies",
    				$$slots: { default: [create_default_slot_15$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({
    			props: {
    				href: "#/esco-stats",
    				$$slots: { default: [create_default_slot_14$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "#/expo",
    				$$slots: { default: [create_default_slot_13$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/graph",
    				$$slots: { default: [create_default_slot_12$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem1_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem1_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem1.$set(dropdownitem1_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$3.name,
    		type: "slot",
    		source: "(113:20) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (111:16) <Dropdown>
    function create_default_slot_10$3(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_16$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_11$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$3.name,
    		type: "slot",
    		source: "(111:16) <Dropdown>",
    		ctx
    	});

    	return block;
    }

    // (123:20) <DropdownToggle nav caret>
    function create_default_slot_9$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Gráficas");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$3.name,
    		type: "slot",
    		source: "(123:20) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (125:20) <DropdownItem href="./#/economies-graph">
    function create_default_slot_8$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$3.name,
    		type: "slot",
    		source: "(125:20) <DropdownItem href=\\\"./#/economies-graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (126:20) <DropdownItem href="#/graphesco">
    function create_default_slot_7$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$3.name,
    		type: "slot",
    		source: "(126:20) <DropdownItem href=\\\"#/graphesco\\\">",
    		ctx
    	});

    	return block;
    }

    // (127:20) <DropdownItem href="#/graphexpo">
    function create_default_slot_6$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$3.name,
    		type: "slot",
    		source: "(127:20) <DropdownItem href=\\\"#/graphexpo\\\">",
    		ctx
    	});

    	return block;
    }

    // (129:20) <DropdownItem href="#/graph">
    function create_default_slot_5$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Conjunto");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$3.name,
    		type: "slot",
    		source: "(129:20) <DropdownItem href=\\\"#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (124:20) <DropdownMenu end>
    function create_default_slot_4$3(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies-graph",
    				$$slots: { default: [create_default_slot_8$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({
    			props: {
    				href: "#/graphesco",
    				$$slots: { default: [create_default_slot_7$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "#/graphexpo",
    				$$slots: { default: [create_default_slot_6$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/graph",
    				$$slots: { default: [create_default_slot_5$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem1_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem1_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem1.$set(dropdownitem1_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$3.name,
    		type: "slot",
    		source: "(124:20) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (122:16) <Dropdown >
    function create_default_slot_3$3(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_9$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_4$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$3.name,
    		type: "slot",
    		source: "(122:16) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (99:12) <Nav navbar>
    function create_default_slot_2$3(ctx) {
    	let dropdown0;
    	let t0;
    	let dropdown1;
    	let t1;
    	let dropdown2;
    	let current;

    	dropdown0 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_17$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown1 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_10$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown2 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_3$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdown0.$$.fragment);
    			t0 = space();
    			create_component(dropdown1.$$.fragment);
    			t1 = space();
    			create_component(dropdown2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdown0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdown1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdown2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdown0_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdown0_changes.$$scope = { dirty, ctx };
    			}

    			dropdown0.$set(dropdown0_changes);
    			const dropdown1_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdown1_changes.$$scope = { dirty, ctx };
    			}

    			dropdown1.$set(dropdown1_changes);
    			const dropdown2_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdown2_changes.$$scope = { dirty, ctx };
    			}

    			dropdown2.$set(dropdown2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdown0.$$.fragment, local);
    			transition_in(dropdown1.$$.fragment, local);
    			transition_in(dropdown2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdown0.$$.fragment, local);
    			transition_out(dropdown1.$$.fragment, local);
    			transition_out(dropdown2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdown0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdown1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdown2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$3.name,
    		type: "slot",
    		source: "(99:12) <Nav navbar>",
    		ctx
    	});

    	return block;
    }

    // (97:8) <Navbar style="background-color: lightgreen; color:white;" light expand="lg" >
    function create_default_slot_1$3(ctx) {
    	let navbarbrand;
    	let t;
    	let nav;
    	let current;

    	navbarbrand = new NavbarBrand({
    			props: {
    				href: "#/info",
    				$$slots: { default: [create_default_slot_23$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	nav = new Nav({
    			props: {
    				navbar: true,
    				$$slots: { default: [create_default_slot_2$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navbarbrand.$$.fragment);
    			t = space();
    			create_component(nav.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbarbrand, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(nav, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navbarbrand_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				navbarbrand_changes.$$scope = { dirty, ctx };
    			}

    			navbarbrand.$set(navbarbrand_changes);
    			const nav_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				nav_changes.$$scope = { dirty, ctx };
    			}

    			nav.$set(nav_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbarbrand.$$.fragment, local);
    			transition_in(nav.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbarbrand.$$.fragment, local);
    			transition_out(nav.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbarbrand, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(nav, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$3.name,
    		type: "slot",
    		source: "(97:8) <Navbar style=\\\"background-color: lightgreen; color:white;\\\" light expand=\\\"lg\\\" >",
    		ctx
    	});

    	return block;
    }

    // (140:8) <Button on:click="{pop}">
    function create_default_slot$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Volver");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$3.name,
    		type: "slot",
    		source: "(140:8) <Button on:click=\\\"{pop}\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$4(ctx) {
    	let link;
    	let t0;
    	let main;
    	let navbar;
    	let t1;
    	let div;
    	let t2;
    	let button;
    	let current;

    	navbar = new Navbar({
    			props: {
    				style: "background-color: lightgreen; color:white;",
    				light: true,
    				expand: "lg",
    				$$slots: { default: [create_default_slot_1$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button = new Button({
    			props: {
    				$$slots: { default: [create_default_slot$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", pop);

    	const block = {
    		c: function create() {
    			link = element$1("link");
    			t0 = space();
    			main = element$1("main");
    			create_component(navbar.$$.fragment);
    			t1 = space();
    			div = element$1("div");
    			t2 = space();
    			create_component(button.$$.fragment);
    			attr_dev(link, "rel", "stylesheet");
    			attr_dev(link, "href", "./c3/c3.css");
    			add_location(link, file$4, 89, 8, 2833);
    			attr_dev(div, "id", "chart");
    			add_location(div, file$4, 136, 12, 5087);
    			add_location(main, file$4, 95, 4, 2927);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			append_dev(document.head, link);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			mount_component(navbar, main, null);
    			append_dev(main, t1);
    			append_dev(main, div);
    			append_dev(main, t2);
    			mount_component(button, main, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const navbar_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				navbar_changes.$$scope = { dirty, ctx };
    			}

    			navbar.$set(navbar_changes);
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			detach_dev(link);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			destroy_component(navbar);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Integration5', slots, []);
    	let apiData = {};
    	const delay = ms => new Promise(res => setTimeout(res, ms));
    	let stats = [];
    	let stats1 = [];
    	let country = [];
    	let year = [];
    	let tot_wom = ["tot_wom"];
    	let tot_man = ["tot_man"];
    	let tot_esco = ["tot_esco"];
    	let spen_mill_eur = ["spen_mill_eur"];
    	let public_percent = ["public_percent"];
    	let pib_percent = ["pib_percent"];

    	async function getData() {
    		console.log("Fetching stats....");
    		const res = await fetch("/api/v1/esco-stats");
    		const res1 = await fetch("/remoteAPI5-esco");

    		if (res.ok && res1.ok) {
    			const data = await res.json();
    			const data1 = await res1.json();
    			stats = data;
    			console.log("Estadísticas recibidas: " + stats.length);

    			//inicializamos los arrays para mostrar los datos
    			stats.forEach(stat => {
    				country.push(stat.country + "-" + stat.year);
    				tot_wom.push(stat.tot_wom);
    				tot_man.push(stat.tot_man);
    				tot_esco.push(stat.tot_esco);
    			});

    			stats1 = data1;
    			console.log("Estadísticas recibidas: " + stats1.length);

    			//inicializamos los arrays para mostrar los datos
    			stats1.forEach(stat => {
    				country.push(stat.country + "-" + stat.year);
    				spen_mill_eur.push(stat.spen_mill_eur);
    				public_percent.push(stat.public_percent);
    				pib_percent.push(stat.pib_percent);
    			});
    		} else {
    			console.log("Error cargando los datos");
    		}

    		loadGraph();
    		console.log("Comprobando");
    	}

    	async function loadGraph() {
    		c3.generate({
    			bindto: '#chart',
    			data: {
    				columns: [tot_wom, tot_man, tot_esco, spen_mill_eur, public_percent, pib_percent],
    				type: 'spline'
    			},
    			axis: {
    				x: { type: 'category', categories: country }
    			}
    		});
    	}

    	onMount(getData);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$3.warn(`<Integration5> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		c3: c3$1,
    		Navbar,
    		Nav,
    		NavItem,
    		NavLink,
    		NavbarBrand,
    		Dropdown,
    		DropdownToggle,
    		DropdownMenu,
    		DropdownItem,
    		Table,
    		Button,
    		pop,
    		apiData,
    		delay,
    		stats,
    		stats1,
    		country,
    		year,
    		tot_wom,
    		tot_man,
    		tot_esco,
    		spen_mill_eur,
    		public_percent,
    		pib_percent,
    		getData,
    		loadGraph
    	});

    	$$self.$inject_state = $$props => {
    		if ('apiData' in $$props) apiData = $$props.apiData;
    		if ('stats' in $$props) stats = $$props.stats;
    		if ('stats1' in $$props) stats1 = $$props.stats1;
    		if ('country' in $$props) country = $$props.country;
    		if ('year' in $$props) year = $$props.year;
    		if ('tot_wom' in $$props) tot_wom = $$props.tot_wom;
    		if ('tot_man' in $$props) tot_man = $$props.tot_man;
    		if ('tot_esco' in $$props) tot_esco = $$props.tot_esco;
    		if ('spen_mill_eur' in $$props) spen_mill_eur = $$props.spen_mill_eur;
    		if ('public_percent' in $$props) public_percent = $$props.public_percent;
    		if ('pib_percent' in $$props) pib_percent = $$props.pib_percent;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [];
    }

    class Integration5 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$4, create_fragment$4, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Integration5",
    			options,
    			id: create_fragment$4.name
    		});
    	}
    }

    /* src\front\esco-stats\integration5b.svelte generated by Svelte v3.47.0 */

    const { console: console_1$2 } = globals;
    const file$3 = "src\\front\\esco-stats\\integration5b.svelte";

    // (98:12) <NavbarBrand href="#/info">
    function create_default_slot_23$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("INICIO");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_23$2.name,
    		type: "slot",
    		source: "(98:12) <NavbarBrand href=\\\"#/info\\\">",
    		ctx
    	});

    	return block;
    }

    // (101:20) <DropdownToggle nav caret>
    function create_default_slot_22$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("API");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_22$2.name,
    		type: "slot",
    		source: "(101:20) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (103:20) <DropdownItem href="./api/v2/economies">
    function create_default_slot_21$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_21$2.name,
    		type: "slot",
    		source: "(103:20) <DropdownItem href=\\\"./api/v2/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (105:20) <DropdownItem href="./api/v1/esco-stats">
    function create_default_slot_20$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_20$2.name,
    		type: "slot",
    		source: "(105:20) <DropdownItem href=\\\"./api/v1/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (107:20) <DropdownItem href="./api/v1/expo-stats">
    function create_default_slot_19$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_19$2.name,
    		type: "slot",
    		source: "(107:20) <DropdownItem href=\\\"./api/v1/expo-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (102:20) <DropdownMenu end>
    function create_default_slot_18$2(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./api/v2/economies",
    				$$slots: { default: [create_default_slot_21$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "./api/v1/esco-stats",
    				$$slots: { default: [create_default_slot_20$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "./api/v1/expo-stats",
    				$$slots: { default: [create_default_slot_19$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_18$2.name,
    		type: "slot",
    		source: "(102:20) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (100:16) <Dropdown >
    function create_default_slot_17$2(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_22$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_18$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17$2.name,
    		type: "slot",
    		source: "(100:16) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (112:20) <DropdownToggle nav caret>
    function create_default_slot_16$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16$2.name,
    		type: "slot",
    		source: "(112:20) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (114:20) <DropdownItem href="./#/economies">
    function create_default_slot_15$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15$2.name,
    		type: "slot",
    		source: "(114:20) <DropdownItem href=\\\"./#/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (115:20) <DropdownItem href="#/esco-stats">
    function create_default_slot_14$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14$2.name,
    		type: "slot",
    		source: "(115:20) <DropdownItem href=\\\"#/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (116:20) <DropdownItem href="#/expo">
    function create_default_slot_13$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo-Stats FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13$2.name,
    		type: "slot",
    		source: "(116:20) <DropdownItem href=\\\"#/expo\\\">",
    		ctx
    	});

    	return block;
    }

    // (118:20) <DropdownItem href="#/graph">
    function create_default_slot_12$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Conjunto");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12$2.name,
    		type: "slot",
    		source: "(118:20) <DropdownItem href=\\\"#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (113:20) <DropdownMenu end>
    function create_default_slot_11$2(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies",
    				$$slots: { default: [create_default_slot_15$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({
    			props: {
    				href: "#/esco-stats",
    				$$slots: { default: [create_default_slot_14$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "#/expo",
    				$$slots: { default: [create_default_slot_13$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/graph",
    				$$slots: { default: [create_default_slot_12$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem1_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem1_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem1.$set(dropdownitem1_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$2.name,
    		type: "slot",
    		source: "(113:20) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (111:16) <Dropdown>
    function create_default_slot_10$2(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_16$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_11$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$2.name,
    		type: "slot",
    		source: "(111:16) <Dropdown>",
    		ctx
    	});

    	return block;
    }

    // (123:20) <DropdownToggle nav caret>
    function create_default_slot_9$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Gráficas");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$2.name,
    		type: "slot",
    		source: "(123:20) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (125:20) <DropdownItem href="./#/economies-graph">
    function create_default_slot_8$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$2.name,
    		type: "slot",
    		source: "(125:20) <DropdownItem href=\\\"./#/economies-graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (126:20) <DropdownItem href="#/graphesco">
    function create_default_slot_7$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$2.name,
    		type: "slot",
    		source: "(126:20) <DropdownItem href=\\\"#/graphesco\\\">",
    		ctx
    	});

    	return block;
    }

    // (127:20) <DropdownItem href="#/graphexpo">
    function create_default_slot_6$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$2.name,
    		type: "slot",
    		source: "(127:20) <DropdownItem href=\\\"#/graphexpo\\\">",
    		ctx
    	});

    	return block;
    }

    // (129:20) <DropdownItem href="#/graph">
    function create_default_slot_5$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Conjunto");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$2.name,
    		type: "slot",
    		source: "(129:20) <DropdownItem href=\\\"#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (124:20) <DropdownMenu end>
    function create_default_slot_4$2(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies-graph",
    				$$slots: { default: [create_default_slot_8$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({
    			props: {
    				href: "#/graphesco",
    				$$slots: { default: [create_default_slot_7$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "#/graphexpo",
    				$$slots: { default: [create_default_slot_6$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/graph",
    				$$slots: { default: [create_default_slot_5$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem1_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem1_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem1.$set(dropdownitem1_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$2.name,
    		type: "slot",
    		source: "(124:20) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (122:16) <Dropdown >
    function create_default_slot_3$2(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_9$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_4$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$2.name,
    		type: "slot",
    		source: "(122:16) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (99:12) <Nav navbar>
    function create_default_slot_2$2(ctx) {
    	let dropdown0;
    	let t0;
    	let dropdown1;
    	let t1;
    	let dropdown2;
    	let current;

    	dropdown0 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_17$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown1 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_10$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown2 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_3$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdown0.$$.fragment);
    			t0 = space();
    			create_component(dropdown1.$$.fragment);
    			t1 = space();
    			create_component(dropdown2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdown0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdown1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdown2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdown0_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdown0_changes.$$scope = { dirty, ctx };
    			}

    			dropdown0.$set(dropdown0_changes);
    			const dropdown1_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdown1_changes.$$scope = { dirty, ctx };
    			}

    			dropdown1.$set(dropdown1_changes);
    			const dropdown2_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				dropdown2_changes.$$scope = { dirty, ctx };
    			}

    			dropdown2.$set(dropdown2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdown0.$$.fragment, local);
    			transition_in(dropdown1.$$.fragment, local);
    			transition_in(dropdown2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdown0.$$.fragment, local);
    			transition_out(dropdown1.$$.fragment, local);
    			transition_out(dropdown2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdown0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdown1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdown2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$2.name,
    		type: "slot",
    		source: "(99:12) <Nav navbar>",
    		ctx
    	});

    	return block;
    }

    // (97:8) <Navbar style="background-color: lightgreen; color:white;" light expand="lg" >
    function create_default_slot_1$2(ctx) {
    	let navbarbrand;
    	let t;
    	let nav;
    	let current;

    	navbarbrand = new NavbarBrand({
    			props: {
    				href: "#/info",
    				$$slots: { default: [create_default_slot_23$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	nav = new Nav({
    			props: {
    				navbar: true,
    				$$slots: { default: [create_default_slot_2$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navbarbrand.$$.fragment);
    			t = space();
    			create_component(nav.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbarbrand, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(nav, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navbarbrand_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				navbarbrand_changes.$$scope = { dirty, ctx };
    			}

    			navbarbrand.$set(navbarbrand_changes);
    			const nav_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				nav_changes.$$scope = { dirty, ctx };
    			}

    			nav.$set(nav_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbarbrand.$$.fragment, local);
    			transition_in(nav.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbarbrand.$$.fragment, local);
    			transition_out(nav.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbarbrand, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(nav, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$2.name,
    		type: "slot",
    		source: "(97:8) <Navbar style=\\\"background-color: lightgreen; color:white;\\\" light expand=\\\"lg\\\" >",
    		ctx
    	});

    	return block;
    }

    // (140:8) <Button on:click="{pop}">
    function create_default_slot$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Volver");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$2.name,
    		type: "slot",
    		source: "(140:8) <Button on:click=\\\"{pop}\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3(ctx) {
    	let link;
    	let t0;
    	let main;
    	let navbar;
    	let t1;
    	let div;
    	let t2;
    	let button;
    	let current;

    	navbar = new Navbar({
    			props: {
    				style: "background-color: lightgreen; color:white;",
    				light: true,
    				expand: "lg",
    				$$slots: { default: [create_default_slot_1$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button = new Button({
    			props: {
    				$$slots: { default: [create_default_slot$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", pop);

    	const block = {
    		c: function create() {
    			link = element$1("link");
    			t0 = space();
    			main = element$1("main");
    			create_component(navbar.$$.fragment);
    			t1 = space();
    			div = element$1("div");
    			t2 = space();
    			create_component(button.$$.fragment);
    			attr_dev(link, "rel", "stylesheet");
    			attr_dev(link, "href", "./c3/c3.css");
    			add_location(link, file$3, 89, 8, 2809);
    			attr_dev(div, "id", "chart");
    			add_location(div, file$3, 136, 12, 5063);
    			add_location(main, file$3, 95, 4, 2903);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			append_dev(document.head, link);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			mount_component(navbar, main, null);
    			append_dev(main, t1);
    			append_dev(main, div);
    			append_dev(main, t2);
    			mount_component(button, main, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const navbar_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				navbar_changes.$$scope = { dirty, ctx };
    			}

    			navbar.$set(navbar_changes);
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			detach_dev(link);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			destroy_component(navbar);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Integration5b', slots, []);
    	let apiData = {};
    	const delay = ms => new Promise(res => setTimeout(res, ms));
    	let stats = [];
    	let stats1 = [];
    	let country = [];
    	let year = [];
    	let tot_wom = ["tot_wom"];
    	let tot_man = ["tot_man"];
    	let tot_esco = ["tot_esco"];
    	let total_debt = ["total_debt"];
    	let debt_gdp = ["debt_gdp"];
    	let per_capita_debt = ["per_capita_debt"];

    	async function getData() {
    		console.log("Fetching stats....");
    		const res = await fetch("/api/v1/esco-stats");
    		const res1 = await fetch("/remoteAPI5b-esco");

    		if (res.ok && res1.ok) {
    			const data = await res.json();
    			const data1 = await res1.json();
    			stats = data;
    			console.log("Estadísticas recibidas: " + stats.length);

    			//inicializamos los arrays para mostrar los datos
    			stats.forEach(stat => {
    				country.push(stat.country + "-" + stat.year);
    				tot_wom.push(stat.tot_wom);
    				tot_man.push(stat.tot_man);
    				tot_esco.push(stat.tot_esco);
    			});

    			stats1 = data1;
    			console.log("Estadísticas recibidas: " + stats1.length);

    			//inicializamos los arrays para mostrar los datos
    			stats1.forEach(stat => {
    				country.push(stat.country + "-" + stat.year);
    				total_debt.push(stat.total_debt);
    				debt_gdp.push(stat.debt_gdp);
    				per_capita_debt.push(stat.per_capita_debt);
    			});
    		} else {
    			console.log("Error cargando los datos");
    		}

    		loadGraph();
    		console.log("Comprobando");
    	}

    	async function loadGraph() {
    		c3.generate({
    			bindto: '#chart',
    			data: {
    				columns: [tot_wom, tot_man, tot_esco, total_debt, debt_gdp, per_capita_debt],
    				type: 'spline'
    			},
    			axis: {
    				x: { type: 'category', categories: country }
    			}
    		});
    	}

    	onMount(getData);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$2.warn(`<Integration5b> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		c3: c3$1,
    		Navbar,
    		Nav,
    		NavItem,
    		NavLink,
    		NavbarBrand,
    		Dropdown,
    		DropdownToggle,
    		DropdownMenu,
    		DropdownItem,
    		Table,
    		Button,
    		pop,
    		apiData,
    		delay,
    		stats,
    		stats1,
    		country,
    		year,
    		tot_wom,
    		tot_man,
    		tot_esco,
    		total_debt,
    		debt_gdp,
    		per_capita_debt,
    		getData,
    		loadGraph
    	});

    	$$self.$inject_state = $$props => {
    		if ('apiData' in $$props) apiData = $$props.apiData;
    		if ('stats' in $$props) stats = $$props.stats;
    		if ('stats1' in $$props) stats1 = $$props.stats1;
    		if ('country' in $$props) country = $$props.country;
    		if ('year' in $$props) year = $$props.year;
    		if ('tot_wom' in $$props) tot_wom = $$props.tot_wom;
    		if ('tot_man' in $$props) tot_man = $$props.tot_man;
    		if ('tot_esco' in $$props) tot_esco = $$props.tot_esco;
    		if ('total_debt' in $$props) total_debt = $$props.total_debt;
    		if ('debt_gdp' in $$props) debt_gdp = $$props.debt_gdp;
    		if ('per_capita_debt' in $$props) per_capita_debt = $$props.per_capita_debt;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [];
    }

    class Integration5b extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$3, create_fragment$3, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Integration5b",
    			options,
    			id: create_fragment$3.name
    		});
    	}
    }

    /* src\front\esco-stats\integration6.svelte generated by Svelte v3.47.0 */

    const { console: console_1$1 } = globals;
    const file$2 = "src\\front\\esco-stats\\integration6.svelte";

    // (107:12) <NavbarBrand href="#/info">
    function create_default_slot_25$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("INICIO");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_25$1.name,
    		type: "slot",
    		source: "(107:12) <NavbarBrand href=\\\"#/info\\\">",
    		ctx
    	});

    	return block;
    }

    // (110:20) <DropdownToggle nav caret>
    function create_default_slot_24$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("API");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_24$1.name,
    		type: "slot",
    		source: "(110:20) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (112:20) <DropdownItem href="./api/v2/economies">
    function create_default_slot_23$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_23$1.name,
    		type: "slot",
    		source: "(112:20) <DropdownItem href=\\\"./api/v2/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (114:20) <DropdownItem href="./api/v1/esco-stats">
    function create_default_slot_22$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_22$1.name,
    		type: "slot",
    		source: "(114:20) <DropdownItem href=\\\"./api/v1/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (116:20) <DropdownItem href="./api/v1/expo-stats">
    function create_default_slot_21$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_21$1.name,
    		type: "slot",
    		source: "(116:20) <DropdownItem href=\\\"./api/v1/expo-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (111:20) <DropdownMenu end>
    function create_default_slot_20$1(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./api/v2/economies",
    				$$slots: { default: [create_default_slot_23$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "./api/v1/esco-stats",
    				$$slots: { default: [create_default_slot_22$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "./api/v1/expo-stats",
    				$$slots: { default: [create_default_slot_21$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_20$1.name,
    		type: "slot",
    		source: "(111:20) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (109:16) <Dropdown >
    function create_default_slot_19$1(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_24$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_20$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_19$1.name,
    		type: "slot",
    		source: "(109:16) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (121:20) <DropdownToggle nav caret>
    function create_default_slot_18$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_18$1.name,
    		type: "slot",
    		source: "(121:20) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (123:20) <DropdownItem href="./#/economies">
    function create_default_slot_17$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17$1.name,
    		type: "slot",
    		source: "(123:20) <DropdownItem href=\\\"./#/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (124:20) <DropdownItem href="#/esco-stats">
    function create_default_slot_16$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16$1.name,
    		type: "slot",
    		source: "(124:20) <DropdownItem href=\\\"#/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (125:20) <DropdownItem href="#/expo">
    function create_default_slot_15$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo-Stats FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15$1.name,
    		type: "slot",
    		source: "(125:20) <DropdownItem href=\\\"#/expo\\\">",
    		ctx
    	});

    	return block;
    }

    // (127:20) <DropdownItem href="#/graph">
    function create_default_slot_14$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Conjunto");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14$1.name,
    		type: "slot",
    		source: "(127:20) <DropdownItem href=\\\"#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (122:20) <DropdownMenu end>
    function create_default_slot_13$1(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies",
    				$$slots: { default: [create_default_slot_17$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({
    			props: {
    				href: "#/esco-stats",
    				$$slots: { default: [create_default_slot_16$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "#/expo",
    				$$slots: { default: [create_default_slot_15$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/graph",
    				$$slots: { default: [create_default_slot_14$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem1_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				dropdownitem1_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem1.$set(dropdownitem1_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13$1.name,
    		type: "slot",
    		source: "(122:20) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (120:16) <Dropdown>
    function create_default_slot_12$1(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_18$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_13$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12$1.name,
    		type: "slot",
    		source: "(120:16) <Dropdown>",
    		ctx
    	});

    	return block;
    }

    // (132:20) <DropdownToggle nav caret>
    function create_default_slot_11$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Gráficas");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$1.name,
    		type: "slot",
    		source: "(132:20) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (134:20) <DropdownItem href="./#/economies-graph">
    function create_default_slot_10$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$1.name,
    		type: "slot",
    		source: "(134:20) <DropdownItem href=\\\"./#/economies-graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (135:20) <DropdownItem href="#/graphesco">
    function create_default_slot_9$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$1.name,
    		type: "slot",
    		source: "(135:20) <DropdownItem href=\\\"#/graphesco\\\">",
    		ctx
    	});

    	return block;
    }

    // (136:20) <DropdownItem href="#/graphexpo">
    function create_default_slot_8$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$1.name,
    		type: "slot",
    		source: "(136:20) <DropdownItem href=\\\"#/graphexpo\\\">",
    		ctx
    	});

    	return block;
    }

    // (138:20) <DropdownItem href="#/graph">
    function create_default_slot_7$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Conjunto");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$1.name,
    		type: "slot",
    		source: "(138:20) <DropdownItem href=\\\"#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (133:20) <DropdownMenu end>
    function create_default_slot_6$1(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies-graph",
    				$$slots: { default: [create_default_slot_10$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({
    			props: {
    				href: "#/graphesco",
    				$$slots: { default: [create_default_slot_9$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "#/graphexpo",
    				$$slots: { default: [create_default_slot_8$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/graph",
    				$$slots: { default: [create_default_slot_7$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem1_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				dropdownitem1_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem1.$set(dropdownitem1_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$1.name,
    		type: "slot",
    		source: "(133:20) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (131:16) <Dropdown >
    function create_default_slot_5$1(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_11$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_6$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$1.name,
    		type: "slot",
    		source: "(131:16) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (108:12) <Nav navbar>
    function create_default_slot_4$1(ctx) {
    	let dropdown0;
    	let t0;
    	let dropdown1;
    	let t1;
    	let dropdown2;
    	let current;

    	dropdown0 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_19$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown1 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_12$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown2 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_5$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdown0.$$.fragment);
    			t0 = space();
    			create_component(dropdown1.$$.fragment);
    			t1 = space();
    			create_component(dropdown2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdown0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdown1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdown2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdown0_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				dropdown0_changes.$$scope = { dirty, ctx };
    			}

    			dropdown0.$set(dropdown0_changes);
    			const dropdown1_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				dropdown1_changes.$$scope = { dirty, ctx };
    			}

    			dropdown1.$set(dropdown1_changes);
    			const dropdown2_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				dropdown2_changes.$$scope = { dirty, ctx };
    			}

    			dropdown2.$set(dropdown2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdown0.$$.fragment, local);
    			transition_in(dropdown1.$$.fragment, local);
    			transition_in(dropdown2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdown0.$$.fragment, local);
    			transition_out(dropdown1.$$.fragment, local);
    			transition_out(dropdown2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdown0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdown1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdown2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$1.name,
    		type: "slot",
    		source: "(108:12) <Nav navbar>",
    		ctx
    	});

    	return block;
    }

    // (106:8) <Navbar style="background-color: lightgreen; color:white;" light expand="lg" >
    function create_default_slot_3$1(ctx) {
    	let navbarbrand;
    	let t;
    	let nav;
    	let current;

    	navbarbrand = new NavbarBrand({
    			props: {
    				href: "#/info",
    				$$slots: { default: [create_default_slot_25$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	nav = new Nav({
    			props: {
    				navbar: true,
    				$$slots: { default: [create_default_slot_4$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navbarbrand.$$.fragment);
    			t = space();
    			create_component(nav.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbarbrand, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(nav, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navbarbrand_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				navbarbrand_changes.$$scope = { dirty, ctx };
    			}

    			navbarbrand.$set(navbarbrand_changes);
    			const nav_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				nav_changes.$$scope = { dirty, ctx };
    			}

    			nav.$set(nav_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbarbrand.$$.fragment, local);
    			transition_in(nav.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbarbrand.$$.fragment, local);
    			transition_out(nav.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbarbrand, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(nav, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$1.name,
    		type: "slot",
    		source: "(106:8) <Navbar style=\\\"background-color: lightgreen; color:white;\\\" light expand=\\\"lg\\\" >",
    		ctx
    	});

    	return block;
    }

    // (150:8) <Button outline color="success" on:click={Loadinfo}>
    function create_default_slot_2$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Datos del Admin");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$1.name,
    		type: "slot",
    		source: "(150:8) <Button outline color=\\\"success\\\" on:click={Loadinfo}>",
    		ctx
    	});

    	return block;
    }

    // (154:8) <Button on:click="{pop}">
    function create_default_slot_1$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Volver");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$1.name,
    		type: "slot",
    		source: "(154:8) <Button on:click=\\\"{pop}\\\">",
    		ctx
    	});

    	return block;
    }

    // (158:12) {#if checkMSG}
    function create_if_block$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1(/*checkMSG*/ ctx[0]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*checkMSG*/ 1) set_data_dev(t, /*checkMSG*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(158:12) {#if checkMSG}",
    		ctx
    	});

    	return block;
    }

    // (157:8) <Alert color={color} isOpen={visible} toggle={() => (visible = false)}>
    function create_default_slot$1(ctx) {
    	let if_block_anchor;
    	let if_block = /*checkMSG*/ ctx[0] && create_if_block$1(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*checkMSG*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$1(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$1.name,
    		type: "slot",
    		source: "(157:8) <Alert color={color} isOpen={visible} toggle={() => (visible = false)}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2(ctx) {
    	let link;
    	let t0;
    	let main;
    	let navbar;
    	let t1;
    	let div;
    	let t2;
    	let button0;
    	let t3;
    	let button1;
    	let t4;
    	let alert;
    	let current;

    	navbar = new Navbar({
    			props: {
    				style: "background-color: lightgreen; color:white;",
    				light: true,
    				expand: "lg",
    				$$slots: { default: [create_default_slot_3$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button0 = new Button({
    			props: {
    				outline: true,
    				color: "success",
    				$$slots: { default: [create_default_slot_2$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button0.$on("click", /*Loadinfo*/ ctx[3]);

    	button1 = new Button({
    			props: {
    				$$slots: { default: [create_default_slot_1$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1.$on("click", pop);

    	alert = new Alert({
    			props: {
    				color: /*color*/ ctx[2],
    				isOpen: /*visible*/ ctx[1],
    				toggle: /*func*/ ctx[4],
    				$$slots: { default: [create_default_slot$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			link = element$1("link");
    			t0 = space();
    			main = element$1("main");
    			create_component(navbar.$$.fragment);
    			t1 = space();
    			div = element$1("div");
    			t2 = space();
    			create_component(button0.$$.fragment);
    			t3 = space();
    			create_component(button1.$$.fragment);
    			t4 = space();
    			create_component(alert.$$.fragment);
    			attr_dev(link, "rel", "stylesheet");
    			attr_dev(link, "href", "./c3/c3.css");
    			add_location(link, file$2, 98, 8, 3142);
    			attr_dev(div, "id", "chart");
    			add_location(div, file$2, 147, 12, 5408);
    			add_location(main, file$2, 104, 4, 3236);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			append_dev(document.head, link);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			mount_component(navbar, main, null);
    			append_dev(main, t1);
    			append_dev(main, div);
    			append_dev(main, t2);
    			mount_component(button0, main, null);
    			append_dev(main, t3);
    			mount_component(button1, main, null);
    			append_dev(main, t4);
    			mount_component(alert, main, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const navbar_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				navbar_changes.$$scope = { dirty, ctx };
    			}

    			navbar.$set(navbar_changes);
    			const button0_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    			const alert_changes = {};
    			if (dirty & /*color*/ 4) alert_changes.color = /*color*/ ctx[2];
    			if (dirty & /*visible*/ 2) alert_changes.isOpen = /*visible*/ ctx[1];
    			if (dirty & /*visible*/ 2) alert_changes.toggle = /*func*/ ctx[4];

    			if (dirty & /*$$scope, checkMSG*/ 524289) {
    				alert_changes.$$scope = { dirty, ctx };
    			}

    			alert.$set(alert_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			transition_in(alert.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			transition_out(alert.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			detach_dev(link);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			destroy_component(navbar);
    			destroy_component(button0);
    			destroy_component(button1);
    			destroy_component(alert);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Integration6', slots, []);
    	let apiData = {};
    	const delay = ms => new Promise(res => setTimeout(res, ms));
    	let checkMSG = "";
    	let visible = false;
    	let color = "danger";
    	let stats = [];
    	let stats1 = [];
    	let country = [];
    	let year = [];
    	let tot_wom = ["tot_wom"];
    	let tot_man = ["tot_man"];
    	let tot_esco = ["tot_esco"];
    	let ages_seventy = ["ages_seventy"];
    	let ages_fifty_seventy = ["ages_fifty_seventy"];
    	let ages_zero_fifty = ["ages_zero_fifty"];

    	async function getData() {
    		console.log("Fetching stats....");
    		const res = await fetch("/api/v1/esco-stats");
    		const res1 = await fetch("https://reqres.in/api/users/2");

    		if (res.ok && res1.ok) {
    			const data = await res.json();
    			const data1 = await res1.json();
    			stats = data;
    			console.log("Estadísticas recibidas: " + stats.length);

    			//inicializamos los arrays para mostrar los datos
    			stats.forEach(stat => {
    				country.push(stat.country + "-" + stat.year);
    				tot_wom.push(stat.tot_wom);
    				tot_man.push(stat.tot_man);
    				tot_esco.push(stat.tot_esco);
    			});

    			stats1 = data1;
    			console.log(stats1.data);
    			console.log("Estadísticas recibidas: " + stats1.length);
    		} else {
    			console.log("Error cargando los datos"); //inicializamos los arrays para mostrar los datos
    		}

    		loadGraph();
    		console.log("Comprobando");
    	}

    	async function loadGraph() {
    		c3.generate({
    			bindto: '#chart',
    			data: {
    				columns: [tot_wom, tot_man, tot_esco],
    				type: 'spline'
    			},
    			axis: {
    				x: { type: 'category', categories: country }
    			}
    		});
    	}

    	async function Loadinfo() {
    		console.log("Loading info....");

    		await fetch("https://reqres.in/api/users/2").then(function (res) {
    			$$invalidate(2, color = "");
    			$$invalidate(0, checkMSG = "Nombre: " + JSON.stringify(stats1.data.first_name) + " " + JSON.stringify(stats1.data.last_name) + "        email: " + JSON.stringify(stats1.data.email));
    			$$invalidate(1, visible = "true");
    		}); //window.alert("Entradas cargadas con éxito");
    	}

    	onMount(getData);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$1.warn(`<Integration6> was created with unknown prop '${key}'`);
    	});

    	const func = () => $$invalidate(1, visible = false);

    	$$self.$capture_state = () => ({
    		onMount,
    		c3: c3$1,
    		Alert,
    		Navbar,
    		Nav,
    		NavItem,
    		NavLink,
    		NavbarBrand,
    		Dropdown,
    		DropdownToggle,
    		DropdownMenu,
    		DropdownItem,
    		Table,
    		Button,
    		pop,
    		apiData,
    		delay,
    		checkMSG,
    		visible,
    		color,
    		stats,
    		stats1,
    		country,
    		year,
    		tot_wom,
    		tot_man,
    		tot_esco,
    		ages_seventy,
    		ages_fifty_seventy,
    		ages_zero_fifty,
    		getData,
    		loadGraph,
    		Loadinfo
    	});

    	$$self.$inject_state = $$props => {
    		if ('apiData' in $$props) apiData = $$props.apiData;
    		if ('checkMSG' in $$props) $$invalidate(0, checkMSG = $$props.checkMSG);
    		if ('visible' in $$props) $$invalidate(1, visible = $$props.visible);
    		if ('color' in $$props) $$invalidate(2, color = $$props.color);
    		if ('stats' in $$props) stats = $$props.stats;
    		if ('stats1' in $$props) stats1 = $$props.stats1;
    		if ('country' in $$props) country = $$props.country;
    		if ('year' in $$props) year = $$props.year;
    		if ('tot_wom' in $$props) tot_wom = $$props.tot_wom;
    		if ('tot_man' in $$props) tot_man = $$props.tot_man;
    		if ('tot_esco' in $$props) tot_esco = $$props.tot_esco;
    		if ('ages_seventy' in $$props) ages_seventy = $$props.ages_seventy;
    		if ('ages_fifty_seventy' in $$props) ages_fifty_seventy = $$props.ages_fifty_seventy;
    		if ('ages_zero_fifty' in $$props) ages_zero_fifty = $$props.ages_zero_fifty;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [checkMSG, visible, color, Loadinfo, func];
    }

    class Integration6 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$2, create_fragment$2, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Integration6",
    			options,
    			id: create_fragment$2.name
    		});
    	}
    }

    /* src\front\esco-stats\integration7.svelte generated by Svelte v3.47.0 */

    const { console: console_1 } = globals;
    const file$1 = "src\\front\\esco-stats\\integration7.svelte";

    // (107:12) <NavbarBrand href="#/info">
    function create_default_slot_25(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("INICIO");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_25.name,
    		type: "slot",
    		source: "(107:12) <NavbarBrand href=\\\"#/info\\\">",
    		ctx
    	});

    	return block;
    }

    // (110:20) <DropdownToggle nav caret>
    function create_default_slot_24(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("API");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_24.name,
    		type: "slot",
    		source: "(110:20) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (112:20) <DropdownItem href="./api/v2/economies">
    function create_default_slot_23(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_23.name,
    		type: "slot",
    		source: "(112:20) <DropdownItem href=\\\"./api/v2/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (114:20) <DropdownItem href="./api/v1/esco-stats">
    function create_default_slot_22(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_22.name,
    		type: "slot",
    		source: "(114:20) <DropdownItem href=\\\"./api/v1/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (116:20) <DropdownItem href="./api/v1/expo-stats">
    function create_default_slot_21(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_21.name,
    		type: "slot",
    		source: "(116:20) <DropdownItem href=\\\"./api/v1/expo-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (111:20) <DropdownMenu end>
    function create_default_slot_20(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./api/v2/economies",
    				$$slots: { default: [create_default_slot_23] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "./api/v1/esco-stats",
    				$$slots: { default: [create_default_slot_22] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "./api/v1/expo-stats",
    				$$slots: { default: [create_default_slot_21] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_20.name,
    		type: "slot",
    		source: "(111:20) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (109:16) <Dropdown >
    function create_default_slot_19(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_24] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_20] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_19.name,
    		type: "slot",
    		source: "(109:16) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (121:20) <DropdownToggle nav caret>
    function create_default_slot_18(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_18.name,
    		type: "slot",
    		source: "(121:20) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (123:20) <DropdownItem href="./#/economies">
    function create_default_slot_17(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17.name,
    		type: "slot",
    		source: "(123:20) <DropdownItem href=\\\"./#/economies\\\">",
    		ctx
    	});

    	return block;
    }

    // (124:20) <DropdownItem href="#/esco-stats">
    function create_default_slot_16(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16.name,
    		type: "slot",
    		source: "(124:20) <DropdownItem href=\\\"#/esco-stats\\\">",
    		ctx
    	});

    	return block;
    }

    // (125:20) <DropdownItem href="#/expo">
    function create_default_slot_15(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("expo-Stats FRONT-END");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15.name,
    		type: "slot",
    		source: "(125:20) <DropdownItem href=\\\"#/expo\\\">",
    		ctx
    	});

    	return block;
    }

    // (127:20) <DropdownItem href="#/graph">
    function create_default_slot_14(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Conjunto");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14.name,
    		type: "slot",
    		source: "(127:20) <DropdownItem href=\\\"#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (122:20) <DropdownMenu end>
    function create_default_slot_13(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies",
    				$$slots: { default: [create_default_slot_17] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({
    			props: {
    				href: "#/esco-stats",
    				$$slots: { default: [create_default_slot_16] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "#/expo",
    				$$slots: { default: [create_default_slot_15] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/graph",
    				$$slots: { default: [create_default_slot_14] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem1_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				dropdownitem1_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem1.$set(dropdownitem1_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13.name,
    		type: "slot",
    		source: "(122:20) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (120:16) <Dropdown>
    function create_default_slot_12(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_18] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_13] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12.name,
    		type: "slot",
    		source: "(120:16) <Dropdown>",
    		ctx
    	});

    	return block;
    }

    // (132:20) <DropdownToggle nav caret>
    function create_default_slot_11(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Gráficas");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11.name,
    		type: "slot",
    		source: "(132:20) <DropdownToggle nav caret>",
    		ctx
    	});

    	return block;
    }

    // (134:20) <DropdownItem href="./#/economies-graph">
    function create_default_slot_10(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("economies-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10.name,
    		type: "slot",
    		source: "(134:20) <DropdownItem href=\\\"./#/economies-graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (135:20) <DropdownItem href="#/graphesco">
    function create_default_slot_9(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("esco-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9.name,
    		type: "slot",
    		source: "(135:20) <DropdownItem href=\\\"#/graphesco\\\">",
    		ctx
    	});

    	return block;
    }

    // (136:20) <DropdownItem href="#/graphexpo">
    function create_default_slot_8(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Expo-Stats");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8.name,
    		type: "slot",
    		source: "(136:20) <DropdownItem href=\\\"#/graphexpo\\\">",
    		ctx
    	});

    	return block;
    }

    // (138:20) <DropdownItem href="#/graph">
    function create_default_slot_7(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Conjunto");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7.name,
    		type: "slot",
    		source: "(138:20) <DropdownItem href=\\\"#/graph\\\">",
    		ctx
    	});

    	return block;
    }

    // (133:20) <DropdownMenu end>
    function create_default_slot_6(ctx) {
    	let dropdownitem0;
    	let t0;
    	let dropdownitem1;
    	let t1;
    	let dropdownitem2;
    	let t2;
    	let dropdownitem3;
    	let t3;
    	let dropdownitem4;
    	let current;

    	dropdownitem0 = new DropdownItem({
    			props: {
    				href: "./#/economies-graph",
    				$$slots: { default: [create_default_slot_10] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem1 = new DropdownItem({
    			props: {
    				href: "#/graphesco",
    				$$slots: { default: [create_default_slot_9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem2 = new DropdownItem({
    			props: {
    				href: "#/graphexpo",
    				$$slots: { default: [create_default_slot_8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownitem3 = new DropdownItem({ props: { divider: true }, $$inline: true });

    	dropdownitem4 = new DropdownItem({
    			props: {
    				href: "#/graph",
    				$$slots: { default: [create_default_slot_7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdownitem0.$$.fragment);
    			t0 = space();
    			create_component(dropdownitem1.$$.fragment);
    			t1 = space();
    			create_component(dropdownitem2.$$.fragment);
    			t2 = space();
    			create_component(dropdownitem3.$$.fragment);
    			t3 = space();
    			create_component(dropdownitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdownitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdownitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdownitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dropdownitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dropdownitem4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdownitem0_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				dropdownitem0_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem0.$set(dropdownitem0_changes);
    			const dropdownitem1_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				dropdownitem1_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem1.$set(dropdownitem1_changes);
    			const dropdownitem2_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				dropdownitem2_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem2.$set(dropdownitem2_changes);
    			const dropdownitem4_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				dropdownitem4_changes.$$scope = { dirty, ctx };
    			}

    			dropdownitem4.$set(dropdownitem4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownitem0.$$.fragment, local);
    			transition_in(dropdownitem1.$$.fragment, local);
    			transition_in(dropdownitem2.$$.fragment, local);
    			transition_in(dropdownitem3.$$.fragment, local);
    			transition_in(dropdownitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdownitem0.$$.fragment, local);
    			transition_out(dropdownitem1.$$.fragment, local);
    			transition_out(dropdownitem2.$$.fragment, local);
    			transition_out(dropdownitem3.$$.fragment, local);
    			transition_out(dropdownitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdownitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdownitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdownitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dropdownitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dropdownitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6.name,
    		type: "slot",
    		source: "(133:20) <DropdownMenu end>",
    		ctx
    	});

    	return block;
    }

    // (131:16) <Dropdown >
    function create_default_slot_5(ctx) {
    	let dropdowntoggle;
    	let t;
    	let dropdownmenu;
    	let current;

    	dropdowntoggle = new DropdownToggle({
    			props: {
    				nav: true,
    				caret: true,
    				$$slots: { default: [create_default_slot_11] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdownmenu = new DropdownMenu({
    			props: {
    				end: true,
    				$$slots: { default: [create_default_slot_6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdowntoggle.$$.fragment);
    			t = space();
    			create_component(dropdownmenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdowntoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dropdownmenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdowntoggle_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				dropdowntoggle_changes.$$scope = { dirty, ctx };
    			}

    			dropdowntoggle.$set(dropdowntoggle_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				dropdownmenu_changes.$$scope = { dirty, ctx };
    			}

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdowntoggle.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdowntoggle.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdowntoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dropdownmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5.name,
    		type: "slot",
    		source: "(131:16) <Dropdown >",
    		ctx
    	});

    	return block;
    }

    // (108:12) <Nav navbar>
    function create_default_slot_4(ctx) {
    	let dropdown0;
    	let t0;
    	let dropdown1;
    	let t1;
    	let dropdown2;
    	let current;

    	dropdown0 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_19] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown1 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_12] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown2 = new Dropdown({
    			props: {
    				$$slots: { default: [create_default_slot_5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dropdown0.$$.fragment);
    			t0 = space();
    			create_component(dropdown1.$$.fragment);
    			t1 = space();
    			create_component(dropdown2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdown0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dropdown1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdown2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dropdown0_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				dropdown0_changes.$$scope = { dirty, ctx };
    			}

    			dropdown0.$set(dropdown0_changes);
    			const dropdown1_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				dropdown1_changes.$$scope = { dirty, ctx };
    			}

    			dropdown1.$set(dropdown1_changes);
    			const dropdown2_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				dropdown2_changes.$$scope = { dirty, ctx };
    			}

    			dropdown2.$set(dropdown2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdown0.$$.fragment, local);
    			transition_in(dropdown1.$$.fragment, local);
    			transition_in(dropdown2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdown0.$$.fragment, local);
    			transition_out(dropdown1.$$.fragment, local);
    			transition_out(dropdown2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdown0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dropdown1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdown2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4.name,
    		type: "slot",
    		source: "(108:12) <Nav navbar>",
    		ctx
    	});

    	return block;
    }

    // (106:8) <Navbar style="background-color: lightgreen; color:white;" light expand="lg" >
    function create_default_slot_3(ctx) {
    	let navbarbrand;
    	let t;
    	let nav;
    	let current;

    	navbarbrand = new NavbarBrand({
    			props: {
    				href: "#/info",
    				$$slots: { default: [create_default_slot_25] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	nav = new Nav({
    			props: {
    				navbar: true,
    				$$slots: { default: [create_default_slot_4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navbarbrand.$$.fragment);
    			t = space();
    			create_component(nav.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbarbrand, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(nav, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navbarbrand_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				navbarbrand_changes.$$scope = { dirty, ctx };
    			}

    			navbarbrand.$set(navbarbrand_changes);
    			const nav_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				nav_changes.$$scope = { dirty, ctx };
    			}

    			nav.$set(nav_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbarbrand.$$.fragment, local);
    			transition_in(nav.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbarbrand.$$.fragment, local);
    			transition_out(nav.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbarbrand, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(nav, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3.name,
    		type: "slot",
    		source: "(106:8) <Navbar style=\\\"background-color: lightgreen; color:white;\\\" light expand=\\\"lg\\\" >",
    		ctx
    	});

    	return block;
    }

    // (150:8) <Button outline color="success" on:click={Loadinfo}>
    function create_default_slot_2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Información de los datos");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2.name,
    		type: "slot",
    		source: "(150:8) <Button outline color=\\\"success\\\" on:click={Loadinfo}>",
    		ctx
    	});

    	return block;
    }

    // (154:8) <Button on:click="{pop}">
    function create_default_slot_1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Volver");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1.name,
    		type: "slot",
    		source: "(154:8) <Button on:click=\\\"{pop}\\\">",
    		ctx
    	});

    	return block;
    }

    // (158:12) {#if checkMSG}
    function create_if_block(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1(/*checkMSG*/ ctx[0]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*checkMSG*/ 1) set_data_dev(t, /*checkMSG*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(158:12) {#if checkMSG}",
    		ctx
    	});

    	return block;
    }

    // (157:8) <Alert color={color} isOpen={visible} toggle={() => (visible = false)}>
    function create_default_slot(ctx) {
    	let if_block_anchor;
    	let if_block = /*checkMSG*/ ctx[0] && create_if_block(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$2();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*checkMSG*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot.name,
    		type: "slot",
    		source: "(157:8) <Alert color={color} isOpen={visible} toggle={() => (visible = false)}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1(ctx) {
    	let link;
    	let t0;
    	let main;
    	let navbar;
    	let t1;
    	let div;
    	let t2;
    	let button0;
    	let t3;
    	let button1;
    	let t4;
    	let alert;
    	let current;

    	navbar = new Navbar({
    			props: {
    				style: "background-color: lightgreen; color:white;",
    				light: true,
    				expand: "lg",
    				$$slots: { default: [create_default_slot_3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button0 = new Button({
    			props: {
    				outline: true,
    				color: "success",
    				$$slots: { default: [create_default_slot_2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button0.$on("click", /*Loadinfo*/ ctx[3]);

    	button1 = new Button({
    			props: {
    				$$slots: { default: [create_default_slot_1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1.$on("click", pop);

    	alert = new Alert({
    			props: {
    				color: /*color*/ ctx[2],
    				isOpen: /*visible*/ ctx[1],
    				toggle: /*func*/ ctx[4],
    				$$slots: { default: [create_default_slot] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			link = element$1("link");
    			t0 = space();
    			main = element$1("main");
    			create_component(navbar.$$.fragment);
    			t1 = space();
    			div = element$1("div");
    			t2 = space();
    			create_component(button0.$$.fragment);
    			t3 = space();
    			create_component(button1.$$.fragment);
    			t4 = space();
    			create_component(alert.$$.fragment);
    			attr_dev(link, "rel", "stylesheet");
    			attr_dev(link, "href", "./c3/c3.css");
    			add_location(link, file$1, 98, 8, 3107);
    			attr_dev(div, "id", "chart");
    			add_location(div, file$1, 147, 12, 5373);
    			add_location(main, file$1, 104, 4, 3201);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			append_dev(document.head, link);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			mount_component(navbar, main, null);
    			append_dev(main, t1);
    			append_dev(main, div);
    			append_dev(main, t2);
    			mount_component(button0, main, null);
    			append_dev(main, t3);
    			mount_component(button1, main, null);
    			append_dev(main, t4);
    			mount_component(alert, main, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const navbar_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				navbar_changes.$$scope = { dirty, ctx };
    			}

    			navbar.$set(navbar_changes);
    			const button0_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    			const alert_changes = {};
    			if (dirty & /*color*/ 4) alert_changes.color = /*color*/ ctx[2];
    			if (dirty & /*visible*/ 2) alert_changes.isOpen = /*visible*/ ctx[1];
    			if (dirty & /*visible*/ 2) alert_changes.toggle = /*func*/ ctx[4];

    			if (dirty & /*$$scope, checkMSG*/ 524289) {
    				alert_changes.$$scope = { dirty, ctx };
    			}

    			alert.$set(alert_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			transition_in(alert.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			transition_out(alert.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			detach_dev(link);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			destroy_component(navbar);
    			destroy_component(button0);
    			destroy_component(button1);
    			destroy_component(alert);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Integration7', slots, []);
    	let apiData = {};
    	const delay = ms => new Promise(res => setTimeout(res, ms));
    	let checkMSG = "";
    	let visible = false;
    	let color = "danger";
    	let stats = [];
    	let stats1 = [];
    	let country = [];
    	let year = [];
    	let tot_wom = ["tot_wom"];
    	let tot_man = ["tot_man"];
    	let tot_esco = ["tot_esco"];
    	let ages_seventy = ["ages_seventy"];
    	let ages_fifty_seventy = ["ages_fifty_seventy"];
    	let ages_zero_fifty = ["ages_zero_fifty"];

    	async function getData() {
    		console.log("Fetching stats....");
    		const res = await fetch("/api/v1/esco-stats");
    		const res1 = await fetch("https://reqres.in/api/unknown/2");

    		if (res.ok && res1.ok) {
    			const data = await res.json();
    			const data1 = await res1.json();
    			stats = data;
    			console.log("Estadísticas recibidas: " + stats.length);

    			//inicializamos los arrays para mostrar los datos
    			stats.forEach(stat => {
    				country.push(stat.country + "-" + stat.year);
    				tot_wom.push(stat.tot_wom);
    				tot_man.push(stat.tot_man);
    				tot_esco.push(stat.tot_esco);
    			});

    			stats1 = data1;
    			console.log(stats1.data);
    			console.log("Estadísticas recibidas: " + stats1.length);
    		} else {
    			console.log("Error cargando los datos"); //inicializamos los arrays para mostrar los datos
    		}

    		loadGraph();
    		console.log("Comprobando");
    	}

    	async function loadGraph() {
    		c3.generate({
    			bindto: '#chart',
    			data: {
    				columns: [tot_wom, tot_man, tot_esco],
    				type: 'spline'
    			},
    			axis: {
    				x: { type: 'category', categories: country }
    			}
    		});
    	}

    	async function Loadinfo() {
    		console.log("Loading info....");

    		await fetch("https://reqres.in/api/unknown/2").then(function (res) {
    			$$invalidate(2, color = "");
    			$$invalidate(0, checkMSG = "Nombre: " + JSON.stringify(stats1.data.name) + "        año de creación: " + JSON.stringify(stats1.data.year));
    			$$invalidate(1, visible = "true");
    		}); //window.alert("Entradas cargadas con éxito");
    	}

    	onMount(getData);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<Integration7> was created with unknown prop '${key}'`);
    	});

    	const func = () => $$invalidate(1, visible = false);

    	$$self.$capture_state = () => ({
    		onMount,
    		c3: c3$1,
    		Alert,
    		Navbar,
    		Nav,
    		NavItem,
    		NavLink,
    		NavbarBrand,
    		Dropdown,
    		DropdownToggle,
    		DropdownMenu,
    		DropdownItem,
    		Table,
    		Button,
    		pop,
    		apiData,
    		delay,
    		checkMSG,
    		visible,
    		color,
    		stats,
    		stats1,
    		country,
    		year,
    		tot_wom,
    		tot_man,
    		tot_esco,
    		ages_seventy,
    		ages_fifty_seventy,
    		ages_zero_fifty,
    		getData,
    		loadGraph,
    		Loadinfo
    	});

    	$$self.$inject_state = $$props => {
    		if ('apiData' in $$props) apiData = $$props.apiData;
    		if ('checkMSG' in $$props) $$invalidate(0, checkMSG = $$props.checkMSG);
    		if ('visible' in $$props) $$invalidate(1, visible = $$props.visible);
    		if ('color' in $$props) $$invalidate(2, color = $$props.color);
    		if ('stats' in $$props) stats = $$props.stats;
    		if ('stats1' in $$props) stats1 = $$props.stats1;
    		if ('country' in $$props) country = $$props.country;
    		if ('year' in $$props) year = $$props.year;
    		if ('tot_wom' in $$props) tot_wom = $$props.tot_wom;
    		if ('tot_man' in $$props) tot_man = $$props.tot_man;
    		if ('tot_esco' in $$props) tot_esco = $$props.tot_esco;
    		if ('ages_seventy' in $$props) ages_seventy = $$props.ages_seventy;
    		if ('ages_fifty_seventy' in $$props) ages_fifty_seventy = $$props.ages_fifty_seventy;
    		if ('ages_zero_fifty' in $$props) ages_zero_fifty = $$props.ages_zero_fifty;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [checkMSG, visible, color, Loadinfo, func];
    }

    class Integration7 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$1, create_fragment$1, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Integration7",
    			options,
    			id: create_fragment$1.name
    		});
    	}
    }

    /* src\front\App.svelte generated by Svelte v3.47.0 */
    const file = "src\\front\\App.svelte";

    function create_fragment(ctx) {
    	let main;
    	let router;
    	let current;

    	router = new Router({
    			props: { routes: /*routes*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			main = element$1("main");
    			create_component(router.$$.fragment);
    			add_location(main, file, 85, 0, 3263);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			mount_component(router, main, null);
    			current = true;
    		},
    		p: noop$4,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(router.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(router.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(router);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('App', slots, []);

    	const routes = {
    		'/': Home,
    		"/info": Info,
    		"/about": About,
    		"/integration": Integration,
    		"/esco-stats": Esco,
    		"/esco/:country/:year": Editesco_1,
    		"/graphesco": MyGraphesco,
    		"/economies": Economies,
    		"/economies/:country/:year": EditEconomies_1,
    		"/economies-graph": MyGraphEconomies,
    		"/expo": Expo,
    		"/expo/:country/:year": EditExpo_1,
    		"/graphexpo": ExpoGraph,
    		"/graph": MyGraph,
    		"/expo/integrationExpo1": IntegrationAPIpneumonia,
    		"/expo/integrationExpo2": IntegrationAPIagricultural,
    		"/economies/integracion1": IntegrationApi1,
    		"/economies/integracion2": IntegrationApi2,
    		"/economies/integracion3": IntegrationApi3,
    		"/economies/integracion4": IntegrationApi4,
    		"/economies/integracion5": IntegrationApi5,
    		"/economies/integracion6": IntegrationApi6,
    		"/economies/integracion7": IntegrationApi7,
    		"/economies/integracion8": IntegrationApi8,
    		"/integration1": Integration1,
    		"/integration2": Integration2,
    		"/integration3": Integration3,
    		"/integration4": Integration4,
    		"/integration5": Integration5,
    		"/integration5b": Integration5b,
    		"/integration6": Integration6,
    		"/integration7": Integration7
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Router,
    		Home,
    		Info,
    		esco: Esco,
    		Editesco: Editesco_1,
    		MyGraphesco,
    		economies: Economies,
    		EditEconomies: EditEconomies_1,
    		MyGraphEconomies,
    		Expo,
    		EditExpo: EditExpo_1,
    		ExpoGraph,
    		MyGraph,
    		about: About,
    		analytics: Integration,
    		IntegrationEco1: IntegrationApi1,
    		IntegrationEco2: IntegrationApi2,
    		IntegrationEco3: IntegrationApi3,
    		IntegrationEco4: IntegrationApi4,
    		IntegrationEco5: IntegrationApi5,
    		IntegrationEco6: IntegrationApi6,
    		IntegrationEco7: IntegrationApi7,
    		IntegrationEco8: IntegrationApi8,
    		IntegrationExpo1: IntegrationAPIpneumonia,
    		IntegrationExpo2: IntegrationAPIagricultural,
    		Integration1,
    		Integration2,
    		Integration3,
    		Integration4,
    		Integration5,
    		Integration5b,
    		Integration6,
    		Integration7,
    		routes
    	});

    	return [routes];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance, create_fragment, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment.name
    		});
    	}
    }

    const app = new App({
    	target: document.body,
    	props: {
    		name: 'SOS2122-25'
    	}
    });

    return app;

})();
//# sourceMappingURL=bundle.js.map
